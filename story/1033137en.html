<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>干净代码-备注</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">干净代码-备注</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-04 15:31:23</div><div class="page_narrow text-break page_content"><p>The following is a list of notes taken on writing clean code, i.e. code that is maintainable and extensible.</p><p>以下是编写干净代码的注意事项列表，即可维护和可扩展的代码。</p><p>  Naming is the  hardest and the most important part of writing clean code. Names should clearly express intent and the assumption here is that everyone involved in the codebase has the same cultural background which is not always the case in practice. Some general tips:</p><p>命名是编写干净代码最困难也是最重要的部分。名字应该清楚地表达意图，这里的假设是，代码库中涉及的每个人都有相同的文化背景，但在实践中并不总是这样。一些一般提示：</p><p>    Functions or methods are the fundamental building blocks of programming. In fact, the internal operation of programs normally consists mostly of functions pushing data onto and popping data off the stack as they call each other. Sometimes memory needs to be allocated on the heap for data that must survive across function calls.</p><p>函数或方法是编程的基本构件。事实上，程序的内部操作通常主要由函数在相互调用时将数据推送到堆栈和从堆栈中弹出数据组成。有时，需要在堆上为必须在函数调用中存活的数据分配内存。</p><p> When a function is called, a  stack frame is created to support the function&#39;s execution. The stack frame contains the function&#39;s local variables and the arguments passed to the function by its caller. The frame also contains housekeeping information that allows the called function (the callee) to return to the caller safely. The exact contents and layout of the stack vary by processor architecture and function call convention.</p><p>调用函数时，会创建一个堆栈帧来支持函数的执行。堆栈帧包含函数的局部变量和由其调用者传递给函数的参数。该框架还包含允许被调用函数(被调用者)安全返回调用者的内务信息。堆栈的确切内容和布局因处理器体系结构和函数调用约定而异。</p><p> An example of a call stack for the  DrawLine function which is called by  DrawSquare.</p><p>DrawSquare调用的DrawLine函数的调用堆栈示例。</p><p>  Functions should be small and they should do 1 thing only:  Only have 1 level of indentation - highly nested functions should be refactored into sub-routines</p><p>函数应该很小，它们应该只做一件事：只有1级缩进-高度嵌套的函数应该重构为子例程。</p><p>  No side-effects!  public int sum(int a, int b) { int result = a + b; resetGui(); // this is untestable and introduces a hidden dependency! return result;}</p><p>没有副作用！Public int sum(int a，int b){int result=a+b；setGui()；//这是不可测试的，并且引入了隐藏的依赖关系！返回结果；}。</p><p>  Do not return  null - caller will need to always check cluttering p code, consider using  special case return values</p><p>不返回NULL-调用者将需要始终检查混乱的p代码，请考虑使用特殊情况的返回值</p><p>    Prefer exceptions for error conditions except in cases were a  Nullable or  Optional type is available</p><p>除可为Null或可选类型的情况外，错误条件的首选异常可用。</p><p>    Fewer arguments are better - the more the arguments, the more the complexity and test cases that need to be written</p><p>参数越少越好-参数越多，需要编写的复杂性和测试用例就越多。</p><p>   An important but suble point to note in OOP is that objects hide their data behind abstractions and expose functions that operate on that data whereas data structures expose their data and have no meaningful functions. Good OOP requires knowing when to use objects and when to use data structures. Consider the following example:</p><p>在OOP中需要注意的一个重要但很有说服力的地方是，对象将其数据隐藏在抽象后面，并公开对该数据进行操作的函数，而数据结构则公开它们的数据，并且没有有意义的函数。好的OOP需要知道何时使用对象和何时使用数据结构。考虑以下示例：</p><p>  public class Point { public double x; public double y;}public interface Point { double getX(); double getY(); void setCartesian(double x, double y); double getR(); double getTheta(); void setPolar(double r, double theta);}</p><p>公共类点{public Double x；public Double y；}公共接口点{Double getX()；Double Gty()；void setCartesian(Double x，Double y)；Double getR()；Double getTheta()；void setPolar(Double r，Double theta)；}。</p><p>  In the second  Point definition the co-ordinate system being used by the implementation is not known and need not necessarily be cartesian nor polar!</p><p>在第二点定义中，实现所使用的坐标系是未知的，并且不一定是笛卡尔坐标系或极坐标！</p><p>   Avoid using boundary interfaces, e.g. instead of returning a  Map, wrap it in a class ( Sensors) to encapsulate the implementation</p><p>避免使用边界接口，例如，不返回Map，而是将其包装在一个类(传感器)中以封装实现。</p><p>  Comments should only be used for clarification or amplification - avoid in general and let the code do the talking!</p><p>注释应该只用于澄清或放大--一般避免使用，让代码来说话！</p><p>  Prefer exceptions to error codes - error codes have the habit of spilling out into the entire system</p><p>更喜欢异常而不是错误代码-错误代码有溢出到整个系统的习惯</p><p>    Finally, procedural code makes it hard to add new data structures because all the functions must change. OO code makes it hard to add new functions because all the classes must change. Again, writing clean code requires insight as to when to use which style of programming.</p><p>最后，过程性代码使添加新数据结构变得困难，因为所有函数都必须更改。OO代码使添加新函数变得困难，因为所有类都必须更改。同样，编写干净的代码需要洞察何时使用哪种风格的编程。</p><p>    Unit Tests should follow the F.I.R.S.T principle, i.e. they should be Fast, Independent of any external dependencies or manual setup, Repeatable, Self-validating (no manual checking verification) and Timely (run just before writing production code). Some general tips on writing clean tests:</p><p>单元测试应遵循F.I.R.S.T原则，即它们应快速、独立于任何外部依赖项或手动设置、可重复、自我确认(无手动检查验证)和及时(在编写生产代码之前运行)。编写干净测试的一些一般提示：</p><p> Tests should be readable above all else and this might mean relaxing certain production code restrictions on performance</p><p>测试应该是可读的，这可能意味着放松某些产品代码对性能的限制。</p><p>     You may not write more of a test than is sufficient to fail, and not compiling is failing.</p><p>您编写的测试可能不会超过失败的程度，不编译就是失败。</p><p>    You may not write more production code than is sufficient to pass the currently failing test.</p><p>您编写的产品代码不能超过通过当前失败测试所需的数量。</p><p>         Classes should follow the open-closed principle - open for extension but closed for modification. Consider the following example where we write an  AreaCalculator which calculates the total area of a collection of rectangles.  public class Rectangle { public double width; public double height;}public class AreaCalculator { public double calculateArea(Collection  rectangles) { double result = 0; for (Rectangle r : rectangles) { result += r.width * r.height; } return result; }}</p><p>类应该遵循开放-关闭原则--对扩展开放，对修改关闭。考虑以下示例，其中我们编写了一个计算矩形集合总面积的AreaCalculator。Public class Rectangle{public Double Width；public Double Height；}public class AreaCalculator{public Double culateArea(集合矩形){Double Result=0；for(Rectangle r：Rectles){Result+=r.width*r.Height；}返回结果；}}。</p><p> We would now like to extend this function to calculate the area of circles as well. Our new function now looks as follows:  public abstract class Shape { }public class Rectangle extends Shape { public double width; public double height;}public class Circle extends Shape { public double radius;}public class AreaCalculator { public double calculateArea(Collection  shapes) { double result = 0; for (Shape s : shapes) { if (s instanceof Rectangle) { Rectangle r = (Rectangle) s; result += r.width * r.height; } else { Circle c = (Circle) s; result += c.radius * c.radius * Math.PI; } } return result; }}</p><p>现在我们想扩展这个函数来计算圆的面积。我们的新函数现在看起来如下：public抽象类Shape{}public class Rectangle Extended Shape{public Double Width；public Double Height；}Public类Circle扩展Shape{public Double Radius；}Public Class AreaCalculator{public Double culateArea(Collection Shares){Double Result=0；for(Shape s：Shares){if(S Instanceof Rectangle){Rectangle r=(Rectangle)s；Result+=r.width*r.Height；}Else{Circle c=(Circle)s；Result+=c.Radius*c.Radius*Math.PI；}}返回结果；}}。</p><p> Extending this further to calculate the area of triangles now requires another modification to the  calculateArea method, i.e. it is not  open for extension. We can change this by introducing an  area method on the  Shape data structure. Our code now looks like the following:  public abstract class Shape { abstract double area();}public class Rectangle extends Shape { public double width; public double height; @Override public double area() { return width * height; }}public class Circle extends Shape { public double radius; @Override public double area() { return radius * radius * Math.PI; }}public class AreaCalculator { public double calculateArea(Collection  shapes) { double result = 0; for (Shape s : shapes) { result += s.area(); // note the simplicity } return result; }}</p><p>将其进一步扩展以计算三角形的面积现在需要对culateArea方法进行另一次修改，即它不能进行扩展。我们可以通过在形状数据结构上引入面积方法来改变这一点。我们的代码如下所示：public抽象类shape{抽象Double Area()；}public class Rectangle扩展Shape{public Double Width；public Double Height；@Override public Double Area(){return width*Height；}}public class Circle扩展Shape{public Double Radius；@Override public Double Area(){return Radius*RADIUS*Math.PI；}}public class AreaCalculator{public Double culateArea(Collection Shares){Double Result=0；for(Shape s：Shares){result+=s.area()；//注意简单}返回结果；}}</p><p>    When building large software systems, try to avoid doing a big design up front - use a dependency injection container to separate cross-cutting concers like transactions, logging, etc. from business logic</p><p>在构建大型软件系统时，尽量避免预先进行大型设计-使用依赖项注入容器将事务、日志等横切容器与业务逻辑分开</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://smalldata.tech/blog/2018/09/16/clean-code-notes">https://smalldata.tech/blog/2018/09/16/clean-code-notes</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/code/">#code</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/函数/">#函数</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033055.html"><img src="http://img2.diglog.com/img/2020/11/thumb_8c74279672206b919a652f0020abd350.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033055.html">只需点击“记录”即可记录您的代码。</a></div><span class="my_story_list_date">2020-11-4 5:51</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032920.html"><img src="http://img2.diglog.com/img/2020/11/thumb_a43233b95ced0cf51878a1f2af7b4ac9.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032920.html">在降价中创建Git差异</a></div><span class="my_story_list_date">2020-11-3 13:56</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032893.html"><img src="http://img2.diglog.com/img/2020/11/thumb_64d2ec6863c7815afccdaaa0cf416c51.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032893.html">使用VizTracer可视化Python代码执行</a></div><span class="my_story_list_date">2020-11-3 10:14</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032572.html"><img src="http://img2.diglog.com/img/2020/11/thumb_9b2a7fcceee51585feb5628a787bccaa.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032572.html">打算停止在我的(JavaScript)代码中使用NULL</a></div><span class="my_story_list_date">2020-11-1 10:50</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>