<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>配置PostgreSQL的可观察性 Configuring PostgreSQL for Observability</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Configuring PostgreSQL for Observability<br/>配置PostgreSQL的可观察性 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-31 02:09:55</div><div class="page_narrow text-break page_content"><p>PostgreSQL comes with a plethora of configuration options, but changing thedefault settings of some of these options drastically improves the observabilityof your PostgreSQL server. You’ll want to set and configure these options beforeissues crop up in production, as they can provide information essential tounderstanding and resolving those issues.</p><p>PostgreSQL带有很多配置选项，但是更改其中一些选项的默认设置可以大大提高PostgreSQL服务器的可观察性。您需要在批量生产之前设置和配置这些选项，因为它们可以提供理解和解决这些问题所必需的信息。</p><p> Read on to learn more about the settings and extensions that expose metrics andinformation about the inner workings of your PostgreSQL server.</p><p> 继续阅读以了解有关设置和扩展的更多信息，这些设置和扩展公开了有关PostgreSQL服务器内部工作情况的指标和信息。</p><p>  The  log_line_prefix configuration option determines what PostgreSQL writes atthe beginning of each log line. The default depends on the specific Linuxdistribution or managed solution that you’re using, but more often than not itdoes not include a few items that can prove very useful in tracking downmisbehaving clients. Try this  log_line_prefix:</p><p>  log_line_prefix配置选项确定PostgreSQL在每条日志行的开头写入什么内容。默认值取决于您使用的特定Linux发行版或托管解决方案，但通常不包含一些对跟踪行为异常的客户端非常有用的项目。试试这个log_line_prefix：</p><p>  It includes the timestamp ( %m), the PID of the backend process ( %p), theapplication name ( %a) of the client, the username which the client has connectedwith ( %u), the database which the client has connected to ( %d) and thehostname or IP where the connection is coming from ( %h). This results in loglines like this:</p><p>  它包括时间戳记（％m），后端进程的PID（％p），客户端的应用程序名称（％a），客户端已连接的用户名（％u），客户端已连接的数据库（％d）以及连接来自（％h）的主机名或IP。结果是这样的日志行：</p><p> 2021-01-30 05:06:03.675 UTC [73] psql postgres bench 172.17.0.1 ERROR: relation &#34;pgbench_akkounts&#34; does not exist at character 152021-01-30 05:06:03.675 UTC [73] psql postgres bench 172.17.0.1 STATEMENT: select * from pgbench_akkounts;</p><p> 2021-01-30 05：06：03.675 UTC [73] psql postgres长凳172.17.0.1错误：关系＆＃34; pgbench_akkounts＆＃34;在字符152021-01-30 05：06：03.675 UTC不存在[73] psql postgres bench 172.17.0.1语句：从pgbench_akkounts中选择*；</p><p> which are much more useful than the default. You can see that a client connectedfrom  172.17.0.1 as user  postgres to database  bench, and the applicationwas  psql. Definitely an improvement over the default option, which showsonly this:</p><p> 比默认值有用得多。您可以看到一个客户端以用户postgres的身份从172.17.0.1连接到数据库基准，并且该应用程序是psql。绝对是对默认选项的改进，默认选项仅显示以下内容：</p><p> 2021-01-30 05:13:22.630 UTC [63] ERROR: relation &#34;pgbench_akkounts&#34; does not exist at character 152021-01-30 05:13:22.630 UTC [63] STATEMENT: select * from pgbench_akkounts;</p><p> 2021-01-30 05：13：22.630 UTC [63]错误：关系＆＃34; pgbench_akkounts＆＃34;在字符152021-01-30 05：13：22.630 UTC [63]声明中不存在：从pgbench_akkounts中选择*； </p><p>  PostgreSQL can be configured to log queries that take more than a set amountof time to execute. These go into the same log file; there is no separateslow query log file as in MySQL.</p><p>可以将PostgreSQL配置为记录执行查询所需的时间。它们进入相同的日志文件；没有像MySQL中那样的单独的低速查询日志文件。</p><p> To log statements that take more than 1 second to execute, use the log_min_duration_statement option like this:</p><p> 要记录执行时间超过1秒的语句，请使用log_min_duration_statement选项，如下所示：</p><p>  Note that  log_min_duration_statement will consider all statements (includingfor example, long-running admin statements like  REINDEX TABLE) and not justqueries ( SELECT). Here are some log entries produced by this option:</p><p>  请注意，log_min_duration_statement将考虑所有语句（包括长时间运行的admin语句，例如REINDEX TABLE），而不考虑公正查询（SELECT）。这是此选项产生的一些日志条目：</p><p> 2021-01-30 08:42:57.473 UTC [62] psql postgres postgres 172.17.0.1 LOG: duration: 1016.283 ms statement: select pg_sleep(1);2021-01-30 08:52:00.541 UTC [62] psql postgres postgres 172.17.0.1 LOG: duration: 1118.277 ms statement: select pg_sleep(1.1);</p><p> 2021-01-30 08：42：57.473 UTC [62] psql postgres postgres 172.17.0.1 LOG：持续时间：1016.283 ms语句：select pg_sleep（1）; 2021-01-30 08：52：00.541 UTC [62] psql postgres postgres 172.17.0.1 LOG：持续时间：1118.277 ms语句：select pg_sleep（1.1）;</p><p> If this results in too many logs of similar statements, you can tell Postgres tolog only a percentage of it, using:</p><p> 如果这导致太多类似语句的日志，您可以使用以下方法告诉Postgres仅记录其中的一部分：</p><p>  This logs only 25% of the statements that become eligible for logging (the onesthat took more than 1 second to execute). The log output is the same as before.There is no way to know how many eligible statements were not logged.</p><p>  这仅记录符合记录条件的语句的25％（执行时间超过1秒的语句）。日志输出与以前相同。无法知道没有记录多少合格的语句。</p><p> To log all statements, along with the time taken to execute them, use the log_statement option instead:</p><p> 要记录所有语句以及执行它们所花费的时间，请改用log_statement选项： </p><p>  The ‘mod’ option tells Postgres to log DDLs and data-modifying statements. Thisresults in logs like these:</p><p>“ mod”选项告诉Postgres记录DDL和修改数据的语句。结果是这样的日志：</p><p> 2021-01-30 08:35:08.985 UTC [64] pgbench postgres bench 172.17.0.1 LOG: statement: insert into pgbench_tellers(tid,bid,tbalance) values (10,1,0)2021-01-30 08:35:08.985 UTC [64] pgbench postgres bench 172.17.0.1 LOG: duration: 0.241 ms</p><p> 2021-01-30 08：35：08.985 UTC [64] pgbench postgres bench 172.17.0.1 LOG：语句：插入pgbench_tellers（tid，bid，tbalance）值（10,1,0）2021-01-30 08:35 ：08.985 UTC [64] pgbench postgres bench 172.17.0.1 LOG：持续时间：0.241 ms</p><p> Be warned that it is  not possible to sample statement logging enabled this way,all statements will be logged, and you’ll end up with tons of log entries.</p><p> 请注意，无法通过这种方式启用示例日志记录示例，所有语句都将被记录，最终您将获得大量日志条目。</p><p>  Queries can wait too long to acquire a lock. Typically, an upper limit on howlong to wait is set using the option  lock_timeout, usually at the client side.If a query has been waiting this long to acquire a lock, Postgres will cancelthe execution of this query and log an error:</p><p>  查询可能等待太久才能获取锁。通常情况下，使用选项lock_timeout设置等待时间的上限（通常在客户端）。如果查询已经等待了这么长时间以获取锁，则Postgres将取消此查询的执行并记录错误：</p><p> 2021-01-30 09:35:52.415 UTC [67] psql postgres testdb 172.17.0.1 ERROR: canceling statement due to lock timeout2021-01-30 09:35:52.415 UTC [67] psql postgres testdb 172.17.0.1 STATEMENT: cluster t;</p><p> 2021-01-30 09：35：52.415 UTC [67] psql postgres testdb 172.17.0.1错误：由于锁定超时而取消语句2021-01-30 09：35：52.415 UTC [67] psql postgres testdb 172.17.0.1陈述：群集;</p><p> Let’s say you want to set a lock timeout of 1 minute, but log queries thatwait for locks for more than, say 30 seconds. You can do this using:</p><p> 假设您想将锁定超时时间设置为1分钟，但是将等待锁定的日志记录记录在30秒以上。您可以使用以下方法执行此操作：</p><p>   2021-01-30 09:49:22.331 UTC [70] psql postgres testdb 172.17.0.1 LOG: process 70 still waiting for ShareLock on transaction 493 after 30009.004 ms2021-01-30 09:49:22.331 UTC [70] psql postgres testdb 172.17.0.1 DETAIL: Process holding the lock: 68. Wait queue: 70.2021-01-30 09:49:22.331 UTC [70] psql postgres testdb 172.17.0.1 CONTEXT: while locking tuple (0,3) in relation &#34;t&#34;2021-01-30 09:49:22.331 UTC [70] psql postgres testdb 172.17.0.1 STATEMENT: select * from t for update;</p><p>   2021-01-30 09：49：22.331 UTC [70] psql postgres testdb 172.17.0.1日志：进程70在30009.004 ms之后仍在等待事务493上的ShareLock 2021-01-30 09：49：22.331 UTC [70] psql postgres testdb 172.17.0.1详细信息：持有锁的进程：68。等待队列：70.2021-01-30 09：49：22.331 UTC [70] psql postgres testdb 172.17.0.1背景：在关系＆＃34中锁定元组（0,3）时; t＆＃34; 2021-01-30 09：49：22.331 UTC [70] psql postgres testdb 172.17.0.1语句：从*中选择*进行更新； </p><p> The use of  deadlock_timeout is not a typo: it is the value that the lock waitlogging mechanism uses. Ideally, there should have been something like  log_min_duration_lock_wait,but unfortunately, that is not the case.</p><p>使用deadlock_timeout并不是一个错字：它是锁waitlogging机制使用的值。理想情况下，应该有类似log_min_duration_lock_wait之类的东西，但不幸的是，事实并非如此。</p><p> In case of actual deadlocks, Postgres will abort the deadlocked transactionsafter  deadlock_timeout duration, and will log the offending statements. Noexplicit configuration is necessary.</p><p> 如果出现实际的死锁，Postgres将在Deadlock_timeout持续时间之后中止死锁的事务，并将记录有问题的语句。没有明确的配置是必要的。</p><p> 2021-01-30 09:55:37.724 UTC [68] psql postgres testdb 172.17.0.1 LOG: process 68 detected deadlock while waiting for ShareLock on transaction 496 after 30007.633 ms2021-01-30 09:55:37.724 UTC [68] psql postgres testdb 172.17.0.1 DETAIL: Process holding the lock: 70. Wait queue: .2021-01-30 09:55:37.724 UTC [68] psql postgres testdb 172.17.0.1 CONTEXT: while locking tuple (0,3) in relation &#34;t&#34;2021-01-30 09:55:37.724 UTC [68] psql postgres testdb 172.17.0.1 STATEMENT: select * from t where a=4 for update;2021-01-30 09:55:37.725 UTC [68] psql postgres testdb 172.17.0.1 ERROR: deadlock detected2021-01-30 09:55:37.725 UTC [68] psql postgres testdb 172.17.0.1 DETAIL: Process 68 waits for ShareLock on transaction 496; blocked by process 70. Process 70 waits for ShareLock on transaction 495; blocked by process 68. Process 68: select * from t where a=4 for update; Process 70: select * from t where a=0 for update;2021-01-30 09:55:37.725 UTC [68] psql postgres testdb 172.17.0.1 HINT: See server log for query details.2021-01-30 09:55:37.725 UTC [68] psql postgres testdb 172.17.0.1 CONTEXT: while locking tuple (0,3) in relation &#34;t&#34;2021-01-30 09:55:37.725 UTC [68] psql postgres testdb 172.17.0.1 STATEMENT: select * from t where a=4 for update;</p><p> 2021-01-30 09：55：37.724 UTC [68] psql postgres testdb 172.17.0.1日志：进程68在30007.633 ms之后等待事务496上的ShareLock时检测到死锁2021-01-30 09：55：37.724 UTC [68] psql postgres testdb 172.17.0.1详细信息：持有锁的进程：70。等待队列：.2021-01-30 09：55：37.724 UTC [68] psql postgres testdb 172.17.0.1背景：在锁定相关的元组（0,3）时＆＃34; t＆＃34; 2021-01-30 09：55：37.724 UTC [68] psql postgres testdb 172.17.0.1语句：从*中选择*，其中a = 4进行更新； 2021-01-30 09:55： 37.725 UTC [68] psql postgres testdb 172.17.0.1错误：检测到死锁2021-01-30 09：55：37.725 UTC [68] psql postgres testdb 172.17.0.1详细信息：进程68等待事务496上的ShareLock。进程70阻塞。进程70等待事务495的ShareLock；过程68阻止。过程68：从t中选择*，其中a ＝ 4以进行更新；流程70：从*中选择*，其中a = 0进行更新; 2021-01-30 09：55：37.725 UTC [68] psql postgres testdb 172.17.0.1提示：请参阅服务器日志以获取查询详细信息.2021-01-30 09： 55：37.725 UTC [68] psql postgres testdb 172.17.0.1上下文：同时在与＆＃34; t＆＃34; 2021-01-30 09：55：37.725 UTC [68] psql postgres testdb关系中锁定元组（0,3） 172.17.0.1语句：从t中选择*，其中a = 4进行更新；</p><p>  The autovacuum process kicks in when Postgres determines the data in a tablehas changed sufficiently to warrant a vacuum and analyze. To keep an eye onthis process, enable the logging of autovacuum runs:</p><p>  当Postgres确定表中的数据已充分更改以保证可以进行抽真空和分析时，将启动自动真空处理。要密切注意此过程，请启用自动真空运行记录：</p><p>   2021-01-30 10:23:33.201 UTC [63] LOG: automatic vacuum of table &#34;postgres.public.t&#34;: index scans: 0 pages: 0 removed, 95 remain, 0 skipped due to pins, 0 skipped frozen tuples: 8991 removed, 10000 remain, 0 are dead but not yet removable, oldest xmin: 492 buffer usage: 215 hits, 4 misses, 4 dirtied avg read rate: 1.885 MB/s, avg write rate: 1.885 MB/s system usage: CPU: user: 0.01 s, system: 0.00 s, elapsed: 0.01 s WAL usage: 244 records, 1 full page images, 67984 bytes2021-01-30 10:23:33.222 UTC [63] LOG: automatic analyze of table &#34;postgres.public.t&#34; system usage: CPU: user: 0.01 s, system: 0.00 s, elapsed: 0.01 s</p><p>   2021-01-30 10：23：33.201 UTC [63]日志：表＆＃34; postgres.public.t＆＃34;的自动清理：索引扫描：0页：删除了0个，保留了95个，由于针脚而跳过了0个，0个跳过的冻结元组：删除了8991，剩余10000个，0个已死但尚未移除，最旧的xmin：492缓冲区使用率：215次命中，4次未中，4个弄脏的平均读取速率：1.885 MB / s，平均写入速率：1.885 MB / s系统使用率：CPU：用户：0.01 s，系统：0.00 s，经过：0.01 s WAL使用：244条记录，1张全页图像，67984字节2021-01-30 10：23：33.222 UTC [63]日志：自动分析表＆＃34; postgres.public.t＆＃34;系统使用率：CPU：用户：0.01 s，系统：0.00 s，经过时间：0.01 s</p><p> Note that autovacuum will typically trigger an analyze after the vacuum, andthis will also be logged.</p><p> 请注意，自动真空通常会在真空后触发分析，并且也会记录下来。</p><p> These logs will help you figure out how best to tune the autovacuum parameters,and will help in investigating if and when autovacuum is not being as effectiveas you thought it would be.</p><p> 这些日志将帮助您确定如何最有效地调整自动真空参数，并有助于调查自动真空是否以及何时不如您预期的那样有效。 </p><p>  Checkpointing is the process of pushing WAL-logged changes into the actual filesthat back tables. Ideally checkpoints should occur at regular-and-not-too-frequentintervals, as it is a CPU and disk intensive process. For various reasons,checkpoints are also forced to happen before the next scheduled time, and thisresults in reduced query performance.</p><p>检查点是将WAL记录的更改推送到支​​持表的实际文件中的过程。理想情况下，检查点应该以规则的间隔而不是太频繁的间隔发生，因为它是CPU和磁盘密集型进程。由于各种原因，检查点也被迫在下一个预定时间之前发生，这导致查询性能降低。</p><p>    2021-01-30 10:05:57.085 UTC [56] LOG: checkpoint starting: immediate force wait2021-01-30 10:05:57.159 UTC [56] LOG: checkpoint complete: wrote 0 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.000 s, sync=0.000 s, total=0.074 s; sync files=0, longest=0.000 s, average=0.000 s; distance=0 kB, estimate=0 kB</p><p>    2021-01-30 10：05：57.085 UTC [56]日志：检查点开始：立即强制等待2021-01-30 10：05：57.159 UTC [56] LOG：检查点完成：写了0个缓冲区（0.0％）;添加了0个WAL文件，删除了0个文件，回收了0个文件；写入= 0.000 s，同步= 0.000 s，总计= 0.074 s;同步文件= 0，最长= 0.000 s，平均= 0.000 s；距离= 0 kB，估计= 0 kB</p><p> The first line contains the flags that backend passed to the checkpointer. Youcan see that the “force” caused a checkpoint even though there were no pendingchanges to checkpoint. If “immediate” had not been specified, the checkpointerwould have checkpointed up to  checkpoint_completion_target.</p><p> 第一行包含后端传递给检查指针的标志。您可以看到，即使没有对检查点的更改，“强制”也会导致检查点。如果未指定“立即”，则检查点将检查点向上到checkpoint_completion_target。</p><p>  There are a couple of other settings that you can turn on in your PostgreSQLconfiguration that will help with diagnosing issues:</p><p>  您可以在PostgreSQL配置中打开其他几个设置，这些设置将有助于诊断问题：</p><p> track_io_timing - setting this to  on lets you see the time spent indisk I/O for each query (combined with pg_stat_statements extensiondescribed below). See  the docsabout a caveat to turning this on, but should be safe on nearly any modernLinux. Seeing a query’s disk I/O cost is impossible without turning this on.</p><p> track_io_timing-将此设置为on可让您查看每个查询在磁盘I / O上花费的时间（与下面描述的pg_stat_statements扩展组合）。请参阅有关启用此警告的文档，但是在几乎所有现代Linux上都应该是安全的。如果不启用查询功能，就不可能看到查询的磁盘I / O成本。</p><p>  track_commit_timestamp - setting this to  on can be useful in debuggingreplication lags and other replication-related issues.</p><p>  track_commit_timestamp-将其设置为on在调试复制延迟和其他与复制相关的问题时很有用。</p><p>  The extension  pg_stat_statements is an essential accessory for any PostgreSQLdeployment. It collects and records statistics for each query executed, andpresents them as a view called “pg_stat_statements”. This is an extension,which means you have to install it explicitly in each database that youwant data for, using the command:</p><p>  扩展pg_stat_statements是任何PostgreSQL部署的基本附件。它收集并记录执行的每个查询的统计信息，并将其显示为称为“ pg_stat_statements”的视图。这是一个扩展，这意味着您必须使用以下命令在需要数据的每个数据库中显式安装它： </p><p>  Since the extension relies on a  .so, you’ll need to load that using shared_preload_libraries:</p><p>由于扩展名依赖于.so，因此您需要使用shared_preload_libraries加载该扩展名：</p><p>  This unfortunately requires a restart of the PostgreSQL server; so make sure youdo this before going live.</p><p>  不幸的是，这需要重新启动PostgreSQL服务器。因此，请确保在上线之前进行此操作。</p><p> If you have upgraded from a previous version of PostgreSQL, be sure to upgradeyour pg_stat_statement extension also, using:</p><p> 如果您是从PostgreSQL的早期版本升级的，请确保也使用以下命令升级pg_stat_statement扩展：</p><p>  The pg_stat_statements extension does not log anything, it is used via queryingthe view of the same name. For more details, see the  official documentation.</p><p>  pg_stat_statements扩展不记录任何内容，它是通过查询同名视图来使用的。有关更多详细信息，请参见官方文档。</p><p>  auto_explain is another extension present in core PostgreSQL. It can log theexecution plans of slow queries. It only needs to be added to shared_preload_libraries, and does not need to be installed as an extension.It also has a couple of other options that typically need to be set to non-defaultvalues:</p><p>  auto_explain是核心PostgreSQL中的另一个扩展。它可以记录慢查询的执行计划。它仅需要添加到shared_preload_libraries中，并且不需要作为扩展安装。它还具有两个其他选项，通常需要将其设置为非默认值：</p><p> shared_preload_libraries  =  &#39;pg_stat_statements,auto_explain&#39; auto_explain . log_min_duration  =  1 s auto_explain . log_analyze  =  on auto_explain . log_buffers  =  on auto_explain . log_triggers  =  on auto_explain . log_timing  =  on auto_explain . log_verbose  =  on auto_explain . log_format  =  json</p><p> shared_preload_libraries =＆＃39; pg_stat_statements，auto_explain＆＃39; auto_explain。 log_min_duration = 1秒auto_explain。 log_analyze =在auto_explain上。 log_buffers =在auto_explain上。 log_triggers =在auto_explain上。 log_timing =在auto_explain上。 log_verbose = on auto_explain。 log_format = JSON</p><p> The above logs the execution plan for any query that takes more than 1 secondto complete. Here is a sample output:</p><p> 上面记录了所有花费1秒以上才能完成的查询的执行计划。这是一个示例输出： </p><p> 2021-01-30 11:28:25.977 UTC [64] psql postgres postgres 172.17.0.1 LOG: duration: 1.305 ms plan: { &#34;Query Text&#34;: &#34;SELECT n.nspname as \&#34;Schema\&#34;,\n c.relname as \&#34;Name\&#34;,\n CASE c.relkind WHEN &#39;r&#39; THEN &#39;table&#39; WHEN &#39;v&#39; THEN &#39;view&#39; WHEN &#39;m&#39; THEN &#39;materialized view&#39; WHEN &#39;i&#39; THEN &#39;index&#39; WHEN &#39;S&#39; THEN &#39;sequence&#39; WHEN &#39;s&#39; THEN &#39;special&#39; WHEN &#39;f&#39; THEN &#39;foreign table&#39; WHEN &#39;p&#39; THEN &#39;table&#39; WHEN &#39;I&#39; THEN &#39;index&#39; END as \&#34;Type\&#34;,\n pg_catalog.pg_get_userbyid(c.relowner) as \&#34;Owner\&#34;\nFROM pg_catalog.pg_class c\n LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\nWHERE c.relkind IN (&#39;r&#39;,&#39;p&#39;,&#39;v&#39;,&#39;m&#39;,&#39;S&#39;,&#39;f&#39;,&#39;&#39;)\n AND n.nspname &lt;&gt; &#39;pg_catalog&#39;\n AND n.nspname &lt;&gt; &#39;information_schema&#39;\n ANDn.nspname !~ &#39;^pg_toast&#39;\n AND pg_catalog.pg_table_is_visible(c.oid)\nORDER BY 1,2;&#34;, &#34;Plan&#34;: { &#34;Node Type&#34;: &#34;Sort&#34;, &#34;Parallel Aware&#34;: false, &#34;Startup Cost&#34;: 32.93, &#34;Total Cost&#34;: 33.01, &#34;Plan Rows&#34;: 32, &#34;Plan Width&#34;: 224, &#34;Actual Startup Time&#34;: 1.292, &#34;Actual Total Time&#34;: 1.298, &#34;Actual Rows&#34;: 0,[... lots of text snipped ...]</p><p>2021-01-30 11：28：25.977 UTC [64] psql postgres postgres 172.17.0.1 LOG：持续时间：1.305 ms计划：{＆＃34; Query Text＆＃34 ;:＆＃34; SELECT n.nspname as \＆ ＃34; Schema \＆＃34; \ n c.relname为\＆＃34; Name \＆＃34; \ n CASE relkind当＆＃39; r＆＃39; THEN＆＃39;表＆＃39; v＆＃39;然后查看何时然后实体化视图当我THEN＆＃39;索引＆＃39;当＆＃39;然后序列何时然后特殊的当＆＃39;然后＆nbsp;外表＆＃39;何时THEN＆＃39;表＆＃39;当我THEN＆＃39;索引＆＃39; END作为\＆＃34; Type \＆＃34;，\ n pg_catalog.pg_get_userbyid（c.relowner）作为\＆＃34; Owner \＆＃34; \ nFROM pg_catalog.pg_class c \ n LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace \ n在哪里c.relkind IN（＆＃39; r＆＃39;，＆＃39; p＆＃39;，＆＃39; v＆＃39;，＆＃39; m＆＃39; ，＆＃39;＆＃39; f＆＃39;，＃39;）\ n AND n.nspname＆lt;＆gt; ＆＃39; pg_catalog＆＃39;和n.nspname＆lt;＆gt; ＆＃39; information_schema＆＃39; \ n ANDn.nspname！〜＆＃39; ^ pg_toast＆＃39; \ n AND pg_catalog.pg_table_is_visible（c.oid）\ nORDER BY 1,2;＆＃34 ;,＆＃34 ; Plan＆＃34 ;: {＆＃34; Node Type＆＃34 ;:＆＃34; Sort＆＃34 ;,＆＃34; Parallel Aware＆＃34 ;: false，＆＃34; Startup Cost＆＃34 ;: 32.93， ＆＃34;总成本＆＃34 ;： 33.01，＆＃34;计划行＆＃34 ;： 32，＆＃34;计划宽度＆＃34 ;： 224，＆＃34;实际启动时间＆＃34 ;： 1.292，＆ ＃34; Actual Total Time＆＃34 ;: 1.298，＆＃34; Actual Rows＆＃34 ;: 0，[...大量文本被截断...]</p><p>  The extensions  pg_stat_statements and  auto_explain are the only twowidely-supported options that PostgreSQL has for query performance managementand query plan management. It pays to get to know these two features, and toplan ahead on using them in production.</p><p>  扩展pg_stat_statements和auto_explain是PostgreSQL在查询性能管理和查询计划管理中仅有的两个受广泛支持的选项。了解这两个功能并提前计划在生产中使用它们是值得的。</p><p>  The application name is a client-side parameter, and can usually be set inDSNs or libpq-style connection strings that your application uses forconnection information. Many tools and utilities in the PostgreSQL eco systemunderstand application name, and it helps to set this to a meaningful value,for example:</p><p>  应用程序名称是一个客户端参数，通常可以在应用程序用于连接信息的DSN或libpq样式的连接字符串中设置。 PostgreSQL生态系统中的许多工具和实用程序都可以理解应用程序名称，这有助于将其设置为有意义的值，例如：</p><p>    pgDash is a modern, in-depth monitoring solution designedspecifically for PostgreSQL deployments. pgDash shows you information andmetrics about every aspect of your PostgreSQL database server, collected usingthe open-source tool  pgmetrics.</p><p>    pgDash是专门针对PostgreSQL部署而设计的现代深度监控解决方案。 pgDash向您显示使用开源工具pgmetrics收集的有关PostgreSQL数据库服务器各个方面的信息和度量标准。</p><p>  pgDash provides core reporting and visualization functionality, includingcollecting and displaying PostgreSQL information and providing time-seriesgraphs, detailed reports, diagnostics, alerting, teams and more. Checkout the features here or  signup todayfor a free trial.</p><p>  pgDash提供了核心的报告和可视化功能，包括收集和显示PostgreSQL信息以及提供时序图，详细的报告，诊断，警报，团队等等。在此处查看功能或立即注册以免费试用。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://pgdash.io/blog/postgres-observability.html?h">https://pgdash.io/blog/postgres-observability.html?h</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/查询/">#查询</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>