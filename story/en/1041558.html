<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Docker多阶段和多平台编译Qt Compiling Qt with Docker multi-stage and multi-platform</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Compiling Qt with Docker multi-stage and multi-platform<br/>使用Docker多阶段和多平台编译Qt </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-24 21:29:06</div><div class="page_narrow text-break page_content"><p>This is a guest post from Viktor Petersson, CEO of Screenly.io. Screenly is the most popular digital signage product for the Raspberry Pi. Find Viktor on Twitter @vpetersson.</p><p>这是Screenly.io首席执行官Viktor Petersson的特邀帖子。 Screenly是Raspberry Pi最受欢迎的数字标牌产品。在Twitter @vpetersson上找到Viktor。</p><p> For those not familiar with Qt, it is a cross-platform development framework that is used in a wide range of products, including cars ( Tesla), digital signs ( Screenly), and airplanes ( Lufthansa). Needless to say, Qt is very powerful. One thing you cannot say about the Qt framework, however, is that it is easy to compile — at least for embedded devices. The countless blog posts, forum threads, and Stack Overflow posts on the topic reveal that compiling Qt is a common headache.</p><p> 对于不熟悉Qt的人来说，它是一个跨平台开发框架，可用于多种产品，包括汽车（Tesla），数字标牌（Screenly）和飞机（Lufthansa）。不用说，Qt非常强大。关于Qt框架，您不能说的一件事是，它易于编译-至少对于嵌入式设备而言。关于该主题的无数博客文章，论坛主题和Stack Overflow文章表明，编译Qt是一个常见的麻烦。</p><p> As long-term Qt users, we have had our fair share of battles with it at Screenly. We migrated to Qt for our commercial  digital signage software a number of years ago, and since then, we have been very happy with both its performance and flexibility. Recently, we decided to migrate our open source digital signage software ( Screenly OSE) to Qt as well. Since these projects share no code base, this was a greenfield opportunity that allowed us to start afresh and explore exciting new technologies for the build process.</p><p> 作为Qt的长期用户，我们在Screenly上与我们有许多应战。几年前，我们迁移到了Qt以获得商业数字标牌软件，从那时起，我们一直对它的性能和灵活性感到非常满意。最近，我们决定将我们的开源数字标牌软件（Screenly OSE）也迁移到Qt。由于这些项目没有共享代码库，因此这是一个全新的机会，使我们可以重新开始并探索构建过程中令人兴奋的新技术。</p><p> Because compiling Qt (and QtWebEngine) is a  very heavy operation, we would need to pre-compile and distribute Qt so that the Dockerfile could simply download and include it in the build process (rather than compiling as part of the installation process).</p><p> 由于编译Qt（和QtWebEngine）是一项非常繁重的操作，因此我们需要预编译和分发Qt，以便Dockerfile可以简单地下载并将其包含在构建过​​程中（而不是作为安装过程的一部分进行编译）。</p><p>  We need to be able to build Qt/QtWebEngine for  all supported Raspberry Pi boards (with the appropriate Qt  device profile).</p><p>  我们需要能够为所有受支持的Raspberry Pi板构建Qt / QtWebEngine（具有适当的Qt设备配置文件）。</p><p> We should use cross compilation on x86 to speed up the process where it makes sense.</p><p> 我们应该在x86上使用交叉编译，以加快有意义的处理速度。</p><p> We need to be able to run the full process on CI, and thus cannot rely on a Raspberry Pi.</p><p> 我们需要能够在CI上运行完整的过程，因此不能依赖Raspberry Pi。 </p><p> We should confine everything to run inside Docker containers so we do not clutter the host with build packages.</p><p>我们应该将所有内容限制在Docker容器中运行，以免主机被构建包所困扰。</p><p> With the above goals in mind, we had a great opportunity to try out the new  multi-platform support in Docker. Used in conjunction with  multi-stage builds, we were able to get the best of both worlds:</p><p> 考虑到上述目标，我们有很大的机会尝试在Docker中提供新的多平台支持。与多阶段构建结合使用，我们能够获得两全其美的优势：</p><p>   The easiest way to use multi-platform functionality in Docker is to invoke it from the command line. Using the  docker buildx, we can tap into new beta functionalities. By running  docker buildx build --platform linux/arm/v7 -t arm-build . This command builds the docker image as per the `Dockerfile` in the current directory using ARMv7 emulation. Behind the scenes, Docker runs the whole Docker build process in a QEMU virtualized environment ( qemu-user-static to be precise). By doing this, the complexity of setting up a custom VM is removed. Once built, we can even use  docker run to launch containers in ARMv7 mode automagically.</p><p>   在Docker中使用多平台功能的最简单方法是从命令行调用它。使用docker buildx，我们可以利用新的Beta功能。通过运行docker buildx build --platform linux / arm / v7 -t arm-build。该命令使用ARMv7仿真在当前目录中根据Dockerfile生成docker映像。在幕后，Docker在QEMU虚拟化环境（准确地说是qemu-user-static）中运行了整个Docker构建过程。通过这样做，消除了设置自定义VM的复杂性。构建完成后，我们甚至可以使用docker run来自动以ARMv7模式启动容器。</p><p>  While multi-platform functionality is a great stand-alone feature, it gets even more powerful when combined with multi-stage builds. Within a single Dockerfile, we’re able to mix and match platforms and copy between the steps. This functionality is exactly what we ended up doing with the Qt build process for Screenly OSE.</p><p>  尽管多平台功能是一项出色的独立功能，但与多阶段构建结合使用时，功能甚至更加强大。在单个Dockerfile中，我们可以混合和匹配平台并在步骤之间进行复制。该功能正是我们最终用Screenly OSE的Qt构建过程完成的。</p><p>  Thanks to the fine folks over at  Balena, we are able to use a Raspbian base image in the first stage. We can invoke this step using:</p><p>  感谢Balena的优秀人才，我们能够在第一阶段使用Raspbian基本图像。我们可以使用以下步骤调用此步骤：</p><p>  After the above step, we can use Docker as we normally do and execute various  RUN commands, such as installing packages etc.. Do note that this container is running emulated using QEMU if the build is not run on ARMv7 hardware. In our case, we use the command to install the Qt build dependencies. The above step also allows us to fully eliminate the need for copying files from either a disk image (which is what the  Qt Wiki suggests) or  rsync files from a physical Raspberry Pi.</p><p>  完成上述步骤后，我们可以像平常一样使用Docker并执行各种RUN命令，例如安装软件包等。请注意，如果构建未在ARMv7硬件上运行，则此容器正在使用QEMU进行仿真。在我们的例子中，我们使用命令来安装Qt构建依赖关系。上面的步骤还使我们能够完全消除从磁盘映像（这是Qt Wiki建议的）或物理Raspberry Pi的rsync文件复制文件的需要。</p><p>  Once we have installed our dependencies in our ARM step, we can switch over to the builder’s native x86 architecture to avoid emulation and do the cross compile with the following line:</p><p>  在ARM步骤中安装依赖项后，我们可以切换到构建器的本机x86架构以避免仿真，并使用以下代码进行交叉编译： </p><p>  Now, we are onto the interesting part. After we have switched over to x86, we can copy files from the previous step. We do this in order to create a sysroot that we can use for Qt. We complete this step by running the following commands:</p><p>现在，我们进入有趣的部分。切换到x86后，我们可以复制上一步中的文件。我们这样做是为了创建可用于Qt的sysroot。我们通过运行以下命令来完成此步骤：</p><p> RUN mkdir -p /sysroot/usr /sysroot/opt /sysroot/libCOPY --from=builder /lib/ /sysroot/lib/COPY --from=builder /usr/include/ /sysroot/usr/include/COPY --from=builder /usr/lib/ /sysroot/usr/lib/COPY --from=builder /opt/vc/ sysroot/opt/vc/</p><p> 运行mkdir -p / sysroot / usr / sysroot / opt / sysroot / libCOPY --from = builder / lib / / sysroot / lib / COPY --from = builder / usr / include / / sysroot / usr / include / COPY- from = builder / usr / lib / / sysroot / usr / lib / COPY --from = builder / opt / vc / sysroot / opt / vc /</p><p> We now have the best of both worlds. By taking advantage of both multi-step and multi-platform functionality, we generate a sysroot that we can use to build Qt. Since we used a fully functional Raspbian image in our previous step, we are even able to get Qt to pick up all existing libraries.</p><p> 我们现在两全其美。通过利用多步骤和多平台功能，我们生成了可用于构建Qt的sysroot。由于我们在上一步中使用了功能齐全的Raspbian映像，因此我们甚至可以让Qt选择所有现有的库。</p><p>    As we mentioned in the introduction, compiling Qt is far from straightforward. There are a lot of steps required to compile it successfully. To learn more about the exact steps, you can see the full  Dockerfile and script  build_qt5.sh.</p><p>    正如我们在引言中提到的，编译Qt远非简单易行。成功编译它需要很多步骤。要了解有关确切步骤的更多信息，可以查看完整的Dockerfile和脚本build_qt5.sh。</p><p>  Being able to emulate a platform like ARM is amazing and provides a lot of flexibility. However, it does come at a cost. There is a big performance penalty. This issue is the reason why we do not actually compile Qt using emulation. Instead, we use cross-compilation. If you have the ability to cross-compile rather than emulate, know that cross-compilation will give you much better performance.</p><p>  能够模拟ARM之类的平台非常出色，并提供了很多灵活性。但是，确实要付出一定的代价。有很大的性能损失。这个问题是为什么我们实际上不使用仿真来编译Qt的原因。相反，我们使用交叉编译。如果您具有交叉编译而不是模拟的能力，请知道交叉编译将为您提供更好的性能。</p><p>  Screenly is the most popular digital signage product for the Raspberry Pi. If you want to turn a physical screen into a secure, remotely-controllable device (over UI or  digital signage API) that can display dashboards, images, videos, and webpages, Screenly makes setup a breeze. Screenly is available in two flavors: an  open source version and a  commercial version.</p><p>  Screenly是Raspberry Pi最受欢迎的数字标牌产品。如果要将物理屏幕变成可以显示仪表板，图像，视频和网页的安全的，可远程控制的设备（通过UI或数字标牌API），Screenly使设置变得轻而易举。 Screenly有两种版本：开源版本和商业版本。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.docker.com/blog/compiling-qt-with-docker-multi-stage-and-multi-platform/">https://www.docker.com/blog/compiling-qt-with-docker-multi-stage-and-multi-platform/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/docker/">#docker</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/multi/">#multi</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/qt/">#qt</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>