<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Genode OS框架20.11Genode OS Framework 20.11</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Genode OS Framework 20.11<br/>Genode OS框架20.11</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-29 15:07:58</div><div class="page_narrow text-break page_content"><p>With Genode 20.11, we focused on the scalability of real-world application workloads, and nurtured Genode&#39;s support for 64-bit ARM hardware. We thereby follow the overarching goal to run highly sophisticated Genode-based systems on devices of various form factors.</p><p>在Genode 20.11中，我们专注于实际应用程序工作负载的可伸缩性，并培养了Genode对64位ARM硬件的支持。因此，我们遵循的首要目标是在各种外形尺寸的设备上运行高度复杂的基于Genode的系统。</p><p>  When speaking of real-world workloads, we acknowledge that we cannot always know the exact behavior of applications. The system must deal gracefully with many unknowns: The roles and CPU intensity of threads, the interplay of application code with I/O, memory-pressure situations, or the sudden fragility of otherwise very useful code. The worst case must always be anticipated. In traditional operating systems, this implies that the OS kernel needs to be aware of certain behavioral patterns of the applications, and has to take decisions based on heuristics. Think of CPU scheduling, load balancing among CPU cores, driving power-saving features of the hardware, memory swapping, caching, and responding to near-fatal situations like OOM.</p><p>  当谈到实际工作负载时，我们承认我们不能总是知道应用程序的确切行为。系统必须妥善处理许多未知因素：线程的角色和CPU强度，应用程序代码与I / O的相互作用，内存压力情况或本来非常有用的代码的突然脆弱性。必须始终预见最坏的情况。在传统的操作系统中，这意味着OS内核需要了解应用程序的某些行为模式，并且必须基于启发式决策。考虑一下CPU调度，CPU内核之间的负载平衡，驱动硬件的节能功能，内存交换，缓存以及对诸如OOM之类的致命故障做出响应。</p><p>  Genode allows us to move such complex heuristics outside the kernel into dedicated components. Our new CPU balancer described in Section  CPU-load balancing is a living poster child of our approach. With this optional component, a part of a Genode system can be subjected to a CPU-load balancing policy of arbitrary complexity without affecting the quality of service of unrelated components, and without polluting the OS kernel with complexity.</p><p>  Genode允许我们将内核之外的复杂启发式方法转移到专用组件中。 “ CPU负载平衡”一节中介绍的新CPU平衡器是我们这种方法的生动体现。使用此可选组件，Genode系统的一部分可以经受任意复杂度的CPU负载平衡策略，而不会影响无关组件的服务质量，也不会污染操作系统内核。</p><p>  A second aspect of real-world workloads is that they are usually  not designed for Genode. To accommodate the wealth of time tested applications, we need to bridge the massive gap between APIs of olde (think of POSIX) and Genode&#39;s clean-slate interfaces. Section  Streamlined ioctl handling in the C runtime / VFS shows how the current release leverages our novel VFS concept for the emulation of traditional ioctl-based interfaces. So useful existing applications come to live without compromising the architectural benefits of Genode.</p><p>  实际工作负载的第二个方面是它们通常不是为Genode设计的。为了适应经过时间考验的大量应用程序，我们需要弥合过时的API（认为是POSIX）与Genode的clean-slate接口之间的巨大差距。 C运行时/ VFS中简化的ioctl处理部分将展示当前版本如何利用我们新颖的VFS概念模拟传统的基于ioctl的接口。因此，在不影响Genode的体系结构优势的情况下，有用的现有应用程序开始使用。</p><p>  Platform-wise, the new release continues our mission to host Genode-based systems such as  Sculpt OS on 64-bit ARM hardware. This work entails intensive development of device drivers and the overall driver architecture. Section  Sculpt OS on 64-bit ARM hardware (i.MX8 EVK) reports on the achievement of bringing Sculpt to 64-bit i.MX8 hardware. This line of work goes almost hand in hand with the improvements of our custom virtual machine monitor for ARM as outlined in Section  Multicore virtualization on ARM.</p><p>  在平台方面，新版本继续执行我们的使命，即在64位ARM硬件上托管基于Genode的系统，例如Sculpt OS。这项工作需要对设备驱动程序和整个驱动程序体系结构进行大量开发。在64位ARM硬件（i.MX8 EVK）上的Sculpt OS部分中报告了将Sculpt引入64位i.MX8硬件的成就。正如我们在ARM的多核虚拟化部分中概述的那样，此工作线几乎与我们针对ARM的自定义虚拟机监视器的改进并驾齐驱。</p><p>        Migrating load over CPUs may be desirable in dynamic scenarios, where the workload is not known in advance or too complex. For example, in case of POSIX software ported to Genode, amount and roles of threads and processes can generally not planned for. With the current release, we add an optional CPU service designated for such dynamic scenarios. The new component called  CPU balancer is able to monitor threads and their utilization behaviour. Depending on configured policies, the balancer can instruct Genode&#39;s core via the CPU session interface to migrate threads between CPUs.</p><p>        在工作负载未知或过于复杂的动态场景中，可能希望通过CPU迁移负载。例如，如果将POSIX软件移植到Genode，通常不会计划线程和进程的数量和角色。在当前版本中，我们添加了为此类动态方案指定的可选CPU服务。称为CPU平衡器的新组件能够监视线程及其利用率行为。根据配置的策略，平衡器可以通过CPU会话接口指示Genode的核心在CPU之间迁移线程。</p><p>      This feature requires a kernel that supports thread migration, which are Fiasco.OC, seL4, and to some degree the NOVA kernel. For the NOVA kernel, solely threads with an attached scheduling context can be migrated, which are  Genode::Thread and POSIX pthread instances. Genode&#39;s entrypoint and virtual CPU instances are not supported.</p><p>      此功能需要一个支持线程迁移的内核，包括Fiasco.OC，seL4和某种程度上的NOVA内核。对于NOVA内核，只能迁移具有附加调度上下文的线程，它们是Genode :: Thread和POSIX pthread实例。不支持Genode的入口点和虚拟CPU实例。</p><p>  The feature can be tested by the scenario located at  repos/os/run/cpu_balancer.run. Further information regarding policy configuration, a demo integration into Sculpt 20.08, and a screencast video are available as a dedicated  CPU balancer article.</p><p>可以通过位于repos / os / run / cpu_balancer.run中的方案测试该功能。有关策略配置，Sculpt 20.08中的演示集成以及截屏视频的更多信息，可作为专用的CPU平衡器文章。</p><p>      Within the last year, a lot of effort was put into Genode&#39;s support for ARM 64-bit hardware. A consequent next step was to port Sculpt OS to the i.MX8 EVK board, which we have used so far as reference platform. With the current release, we proudly present the first incarnation of Sculpt OS for this board.</p><p>      在过去的一年中，Genode对ARM 64位硬件的支持投入了大量精力。随后的下一步是将Sculpt OS移植到i.MX8 EVK板上，到目前为止，我们已将其用作参考平台。在当前版本中，我们自豪地展示了此板的Sculpt OS的第一个版本。</p><p>  In contrast to the original x86 PC variant, this first ARM version ships with a static set of devices inside the drivers subsystem. No device manager component probes for the used hardware and starts drivers on demand. Instead, the set of drivers defined in the  drivers_managed-imx8q_evk package enables USB HID devices to make use of mouse and keyboard peripherals connected to the board. It drives the SD-card, which can be used as storage back end for Genode&#39;s depot package management. Finally, it contains drivers to manage the display engine and the platform&#39;s device resources.</p><p>  与原始的x86 PC变体相比，该第一个ARM版本在驱动程序子系统内部附带了一组静态设备。没有设备管理器组件会探测所使用的硬件并按需启动驱动程序。相反，使用drivers_managed-imx8q_evk软件包中定义的一组驱动程序，USB HID设备可以使用连接到该板上的鼠标和键盘外围设备。它可以驱动SD卡，该卡可以用作Genode仓库包装管理的存储后端。最后，它包含用于管理显示引擎和平台设备资源的驱动程序。</p><p>  With Sculpt OS for ARM 64-bit, we not only aim for classical desktop/notebook systems - like on x86 - but also for embedded consumer hardware like phones and tablets. In order to leverage this goal, we enabled support for  NXP&#39;s MX8_DSI_OLED1 display on the i.MX8 platform on Genode. The panel features an OLED display as well as a Synaptics RMI4 compliant touch screen.</p><p>  借助适用于ARM 64位的Sculpt OS，我们不仅针对经典的台式机/笔记本电脑系统（如x86），还针对嵌入式消费类硬件（如手机和平板电脑）。为了利用此目标，我们在Genode的i.MX8平台上启用了对恩智浦MX8_DSI_OLED1显示器的支持。该面板具有OLED显示屏以及符合Synaptics RMI4的触摸屏。</p><p>  Genode&#39;s i.MX8 display driver that we released with version  20.02 supported HDMI devices only, whereas the OLED display is connected via  MIPI DSI to the SoC. Therefore, we extended the display driver by the MIPI DSI infrastructure as well as the actual driver for the OLED display. This endeavor turned out to be a very rocky one, which we have documented in detail on our  Genodians website.</p><p>  我们与20.02版一起发布的Genode的i.MX8显示驱动器仅支持HDMI设备，而OLED显示器则通过MIPI DSI连接到SoC。因此，我们通过MIPI DSI基础架构以及OLED显示器的实际驱动器扩展了显示驱动器。事实证明，这项工作非常艰难，我们已在Genodians网站上详细记录了该工作。</p><p>      In order to enable the touch screen device, we implemented a new Genode component from scratch. The touch screen is connected via an I2C bus to the SoC where data can be sent to and received from. At the moment, the I2C implementation is hidden within the driver but as more devices require I2C access, it will eventually become a standalone component. Interrupts are delivered via GPIO pins from the touch screen to the SoC, which made it necessary to enable i.MX8 support within Genode&#39;s generic i.MX GPIO driver. We took this as an opportunity to streamline, cleanup, and make the driver more robust. Additionally, all driver components now take advantage of the new platform driver API for ARM that has been introduced with release  20.05.</p><p>      为了启用触摸屏设备，我们从头开始实现了一个新的Genode组件。触摸屏通过I2C总线连接到SoC，可以在该SoC上发送和接收数据。目前，I2C实现隐藏在驱动程序中，但是随着更多设备需要I2C访问，它最终将成为独立组件。中断是通过GPIO引脚从触摸屏传递到SoC的，因此有必要在Genode的通用i.MX GPIO驱动程序中启用i.MX8支持。我们以此为契机，简化，清理并使驱动程序更强大。此外，所有驱动程序组件现在都利用20.05版中引入的用于ARM的新平台驱动程序API。</p><p>  In its current incarnation, the driver for the display management is not able to switch in between HDMI or MIPI-DSI connected displays dynamically. Therefore, the display to be used in Sculpt has to be configured in the framebuffer configuration manually. By default the HDMI connector is used.</p><p>  以目前的形式，用于显示管理的驱动程序无法在HDMI或MIPI-DSI连接的显示器之间动态切换。因此，必须在帧缓冲区配置中手动配置要在Sculpt中使用的显示。默认情况下，使用HDMI连接器。</p><p>  Beyond the driver subsystem, there are few components dependent on the actual hardware, which is why the look &amp; feel of the Sculpt desktop does not actually differ from the x86 PC version, with the following exceptions:</p><p>除了驱动程序子系统之外，几乎没有任何组件依赖于实际的硬件，这就是为什么Sculpt桌面的外观与x86 PC版本实际上没有区别的原因，但以下情况除外：</p><p>  When you select the network configuration dialog, you&#39;ll have no &#34;Wifi&#34; option because of the missing hardware. However, the &#34;Wired&#34; option allows you to start the corresponding driver for the i.MX FEC Ethernet device. The second difference to the Sculpt OS x86 PC variant is the absence of a virtual machine solution at the moment. Although Genode comprises a mature virtual-machine-monitor solution for ARM - see Section  Multicore virtualization on ARM - it still lacks a reasonable storage back end. Therefore, we left virtualization out of the picture for now. Lastly, there is no possibility to use USB block devices, because the required management component - a driver manager for i.MX8 - does not exist yet. We plan to bridge these remaining few gaps compared to the x86 version with the upcoming Genode releases.</p><p>  选择网络配置对话框时，由于缺少硬件，因此将没有“ Wifi”选项。但是，“有线”选项允许您启动i.MX FEC以太网设备的相应驱动程序。与Sculpt OS x86 PC变体的第二个区别是，目前没有虚拟机解决方案。尽管Genode包括针对ARM的成熟的虚拟机监控器解决方案-请参阅“ ARM上的多核虚拟化”部分-它仍然缺少合理的存储后端。因此，我们暂时不在虚拟化范围之内。最后，由于无法使用所需的管理组件（i.MX8的驱动程序管理器），因此无法使用USB块设备。与即将推出的Genode发行版相比，我们计划弥合与x86版本相比尚余的空白。</p><p>  To give Sculpt a try on the i.MX8 EVK board, you have to start the well-known Sculpt run-script as usual, but for the base-hw kernel. For example:</p><p>  要尝试Sculpt在i.MX8 EVK板上尝试，您必须像往常一样启动著名的Sculpt运行脚本，但要使用base-hw内核。例如：</p><p>   Under the hood, the run script requests a sculpt-&lt;board&gt; specific package from the depot package system. Currently,  sculpt-pc and  sculpt-imx8q_evk are available.</p><p>   在后台，运行脚本从仓库软件包系统请求特定于Sculpt- 的软件包。当前，sculpt-pc和sculpt-imx8q_evk可用。</p><p>      The written-from-scratch virtualization solution for Genode on ARMv8 entered the picture exactly one year ago with  release 19.11. Since then, a couple of improvements and validations have been incorporated into it. Support for VirtIO network and console models had been added. Moreover, it got streamlined with our prior existing ARMv7 hypervisor and virtual-machine monitor (VMM). But although the architecture of the VMM was designed from the very beginning with more than one virtual-CPU (VCPU) in mind, running a VM on multiple cores had not been addressed nor tested.</p><p>      从头开始编写的针对ARMv8上的Genode的虚拟化解决方案正好在一年前发布了19.11版。从那时起，其中进行了一些改进和验证。添加了对VirtIO网络和控制台模型的支持。此外，它与我们先前的现有ARMv7虚拟机管理程序和虚拟机监视器（VMM）相简化。但是，尽管VMM的体系结构从一开始就考虑了多个虚拟CPU（VCPU），但尚未解决或测试在多个内核上运行VM的问题。</p><p>  With this release, we enhance the virtualization support of the base-hw kernel, acting as the ARM hypervisor, to support multicore virtual machines. The VMM implementation got extended to start an entrypoint for each VCPU owned by a VM. The affinities of those entrypoints are configured to distribute over all physical CPUs available to the VMM. The affinity of an entrypoint that handles events of a VCPU is automatically used as the affinity of the VCPU itself. Whenever a VCPU exit needs to be handled, this is delegated to the VMM entrypoint running on the same CPU. Once the VMM&#39;s entrypoint successfully handled the exit reason, it resumes the VCPU.</p><p>  在此版本中，我们增强了作为ARM虚拟机管理程序的base-hw内核的虚拟化支持，以支持多核虚拟机。 VMM实施得到扩展，可以为VM拥有的每个VCPU启动一个入口点。这些入口点的关联性配置为分布在VMM可用的所有物理CPU上。处理VCPU事件的入口点的关联会自动用作VCPU本身的关联。每当需要处理VCPU出口时，都将其委派给在同一CPU上运行的VMM入口点。一旦VMM的入口点成功处理了退出原因，它将恢复VCPU。</p><p>  Formerly, the control to start or stop a VCPU was implemented by core&#39;s VM service that runs on the first CPU. But that implied that all different VMM entrypoints running on distinct CPUs would have needed to frequently call core&#39;s service entrypoint on the first CPU, inducing costly cross-CPU communication. This is amplified by the fact that core&#39;s entrypoint uses a system call to instruct the kernel&#39;s internal scheduler of the corresponding target CPU, which again would potentially target a remote CPU. For simplifying the implementation and for improving performance, we slightly extended the VM-session interface to return a kernel-specific capability addressing a VCPU directly. With this capability, a VMM&#39;s entrypoint is able to directly call the kernel to start or stop a VCPU instead of using the indirection over core. However, the detail whether the kernel is called directly or not is hidden behind the VM session client API and transparent to the user.</p><p>  以前，启动或停止VCPU的控制由运行在第一个CPU上的内核的VM服务实现。但这意味着运行在不同CPU上的所有不同VMM入口点都需要频繁调用第一个CPU上的核心服务入口点，从而导致昂贵的跨CPU通信。内核的入口点使用系统调用来指示相应目标CPU的内核内部调度程序这一事实进一步放大了这一点，这又可能会以远程CPU为目标。为了简化实现并提高性能，我们稍微扩展了VM会话接口，以返回特定于内核的功能，直接处理VCPU。借助此功能，VMM的入口点能够直接调用内核以启动或停止VCPU，而无需使用内核间接访问。但是，是否直接调用内核的详细信息隐藏在VM会话客户端API的后面，并且对用户透明。</p><p>        We improved the support for aligned memory allocations to fix sporadic memory leaks, which occurred with our port of the Falkon web browser. One relevant change is the implementation of the  posix_memalign() function, another change is that the address alignment of anonymous  mmap() allocations is now configurable like follows:</p><p>我们改进了对对齐内存分配的支持，以修复偶发的内存泄漏，这种情况是在我们的Falkon Web浏览器端口发生的。一个相关的更改是posix_memalign（）函数的实现，另一个更改是，匿名mmap（）分配的地址对齐现在可以如下配置：</p><p>     Even though Genode uses C++ as its primary programming language, we do not rely on or make use of any C++ standard library within the Genode OS framework. However, since a C++ STL is a vital part of application programming with C++, we provide one for applications built on top of the base framework; in particular the GNU C++ STL library ( libstdc++). It is treated as a regular 3rd party library and its functionality is extended on demand. This approach worked well enough to even enable larger C++-based software like Qt5 and Chromium&#39;s Blink engine (as part of QtWebEngine) to run on Genode. That being said, for developers using  libstdc++ on Genode, it is not immediately clear, which features are supported and which are not.</p><p>     即使Genode使用C ++作为其主要编程语言，我们也不依赖或使用Genode OS框架内的任何C ++标准库。但是，由于C ++ STL是使用C ++进行应用程序编程的重要组成部分，因此我们为在基础框架之上构建的应用程序提供了一个。特别是GNU C ++ STL库（libstdc ++）。它被视为常规的第三方库，其功能可以按需扩展。这种方法效果很好，甚至可以使更大的基于C ++的软件（例如Qt5和Chromium的Blink引擎（作为QtWebEngine的一部分））在Genode上运行。话虽这么说，对于在Genode上使用libstdc ++的开发人员来说，尚不清楚，哪些功能受支持，哪些功能不受支持。</p><p>  Fortunately,  libstdc++ includes a testsuite that - as the name suggests - allows for testing the range of functionality of the library on a given platform. So we turned to it to establish a base line of supported features. We were particularly interested in how our port behaves when C++17 is requested. It goes without saying that this only includes the aspects, which are specifically probed by the testsuite. Rather than adding thorough Genode support to the testsuite, we opted for providing an  environment that mimics the common  unix target and allows us to execute the testsuite on the Linux version of Genode via a regular Linux host OS. It uses the Genode tool chain to compile the tests and spawns a Genode base-linux system to execute them.</p><p>  幸运的是，libstdc ++包含一个测试套件，顾名思义，该套件可在给定平台上测试该库的功能范围。因此，我们转向它来建立支持功能的基线。我们对请求C ++ 17时端口的行为特别感兴趣。不言而喻，这仅包括测试套件专门探究的方面。我们没有向测试套件添加全面的Genode支持，而是选择提供一种模仿通用unix目标的环境，并允许我们通过常规Linux主机OS在Linux版本的Genode上执行测试套件。它使用Genode工具链来编译测试，并生成Genode基本Linux系统来执行它们。</p><p>  Executing the testsuite was an iterative process because in the beginning, we encountered many falsely failed tests. On one hand, most of them were due to the way C++ is applied in Genode or rather how our build system works internally. For one,  libsupc++ on Genode is part of the  cxx library. This library in turn is part of  ldso.lib.so, the dynamic linker that provides the base API. As the build system uses stub libraries generated from  symbol files containing the ABI of a given shared object, each missing symbol must be made available. Otherwise the linking step is going to fail complaining about undefined references because components use these stub libraries during compilation. On the other hand, we had to get cozy with the testsuite&#39;s underlying test framework in order to get our test environment straight.</p><p>  执行测试套件是一个反复的过程，因为在开始时，我们遇到了许多错误地失败的测试。一方面，大多数是由于C ++在Genode中的应用方式，或者是我们的构建系统在内部工作的方式。首先，Genode上的libsupc ++是cxx库的一部分。该库又是ldso.lib.so（提供基本API的动态链接器）的一部分。由于构建系统使用从包含给定共享库的ABI的符号文件生成的存根库，因此每个丢失的符号都必须可用。否则，链接步骤将因抱怨未定义的引用而失败，因为组件在编译期间使用了这些存根库。另一方面，我们必须对测试套件的基础测试框架感到满意，才能使测试环境变得更加整洁。</p><p>  In case of the testsuite, there were a lot of symbols missing because we did not encounter them so far in our workloads, and thus, were not part of the symbols file. After all, templates will always generate specific symbols that are difficult to foresee. Besides that, we lacked support for aligned  new and  delete operators. With these adaptions in place, we were able to successfully execute the testsuite.</p><p>  对于测试套件，遗漏了很多符号，因为到目前为止我们在工作负载中还没有遇到过这些符号，因此这些符号也不属于符号文件。毕竟，模板将始终生成难以预见的特定符号。除此之外，我们缺乏对对齐的new和delete运算符的支持。有了这些适应措施，我们就能够成功执行测试套件。</p><p>  In the end, the results paint a good picture. The current short-comings boil down to</p><p>  最后，结果描绘了一个好画面。当前的缺点归结为</p><p>  Support for the  stdc++fs library is not available as the library is not ported yet.</p><p>  由于尚未移植stdc ++ fs库，因此不支持该库。</p><p>      Various subsystems ( std::thread,  std::random_device, numerics library) need further attention for proper functionality. This is most prominent for the failing execution tests where sometimes the threads appear to get stuck.</p><p>为了正确的功能，各种子系统（std :: thread，std :: random_device，数字库）需要进一步关注。这对于失败的执行测试最为突出，在执行测试中，有时线程似乎卡住了。</p><p>      The CBE is a library for the management of encrypted block-devices that is entirely written in SPARK. It was first announced and integrated with  Genode 19.11, reached feature-completeness with  Genode 20.05, and has received a highly modular back-end system with version  20.08. For this release, we thoroughly streamlined the CBE repository, added enhanced automated quality assurance, and switched to another default encryption back end.</p><p>      CBE是一个用于管理加密块设备的库，该库完全用SPARK编写。它首次发布并与Genode 19.11集成，并通过Genode 20.05达到了功能完善性，并且已收到版本为20.08的高度模块化的后端系统。对于此版本，我们彻底简化了CBE存储库，增加了增强的自动化质量保证，并切换到另一个默认的加密后端。</p><p>    Generally speaking, the  CBE repository has been freed from everything that is not either part of the SPARK-based core logic (cbe, cbe_common, and the hashing algorithm), the essential SPARK-based tooling (initialization, checking), or the Ada-based C++ bindings (*_cxx libraries). The whole Genode-specific integration, testing, and packaging moved to Genode&#39;s  gems repository and the former Genode sub-repository  cbe was replaced by the new CBE port  gems/ports/cbe.port. We also took the opportunity to remove many unused remnants of earlier development stages and to drastically simplify the ecosystem of CBE-related packages.</p><p>    一般而言，CBE储存库中的所有内容都不属于基于SPARK的核心逻辑（cbe，cbe_common和哈希算法），基于SPARK的基本工具（初始化，检查）或Ada-基于C ++的绑定（* _cxx库）。整个特定于Ge​​node的集成，测试和包装已移至Genode的gems存储库，而以前的Genode子存储库cbe被新的CBE port gems / ports / cbe.port取代。我们还借此机会删除了早期开发阶段的许多未使用的残余物，并大大简化了与CBE相关的软件包的生态系统。</p><p>  We hope that this allows for certain characteristics of the CBE project, like its strong OS-independence or a completely &#34;flow-mode&#34;-provable core logic to become more clear, while at the same time, the Genode-specific accessories can benefit from being part of Genode&#39;s mainline development.</p><p>  我们希望这可以使CBE项目的某些特征（例如其强大的OS独立性或完全“流模式”可证明的核心逻辑）变得更加清晰，与此同时，特定于Ge​​node的附件可以从中受益是Genode主线开发的一部分。</p><p>    The CBE tester is a scriptable environment meant for testing all aspects of the CBE library and its basic tooling. Through its XML command interface, one can not only access and validate data of CBE devices but also initialize them, check their consistency, analyze their meta data, execute performance benchmarks, manage device snapshots, perform online re-keying or online re-dimensioning of devices, and, last but not least, manage the required Trust Anchors.</p><p>    CBE测试器是一个可编写脚本的环境，旨在测试CBE库及其基本工具的所有方面。通过其XML命令界面，不仅可以访问和验证CBE设备的数据，还可以对其进行初始化，检查其一致性，分析其元数据，执行性能基准测试，管理设备快照，对CBE设备进行在线重新键入或在线重新设置尺寸设备，最后但并非最不重要的是，管理所需的信任锚。</p><p>  Before this release, the CBE tester was a mere patchwork solution and many of the above mentioned features were limited or even missing. For instance block access was issued only in a synchronous fashion, the Trust-Anchor was managed implicitly, and validating read data wasn&#39;t possible. Besides adding the missing features, we also reworked the component entirely to follow a clean and comprehensible implementation concept. The new CBE tester comes together with the run script  gems/run/cbe_tester.run that shall serve as both a demonstration how to use the tester and an extensive automated test and benchmark for the CBE.</p><p>  在此版本之前，CBE测试仪仅是一个拼凑的解决方案，并且上述许多功能都受到限制甚至缺失。例如，块访问仅以同步方式发布，对Trust-Anchor进行隐式管理，并且无法验证读取的数据。除了添加缺少的功能之外，我们还对组件进行了完全的重新设计，以遵循简洁易懂的实现概念。新的CBE测试器与运行脚本gems / run / cbe_tester.run一起提供，该脚本将既演示如何使用该测试器，又作为CBE的广泛自动化测试和基准。</p><p>  Furthermore, we created the CBE-specific autopilot tool  tool/cbe_autopilot that is meant to establish a common reference for the quality of CBE releases as well as for their integration in Genode. Running the tool without arguments will give instructions how to use it. In a nutshell, when running  tool/cbe_autopilot basics, the tool will GNAT-prove what is expected to be provable, run all CBE-related run scripts expected to work, and build all CBE-related packages (existing build and depot directories are not touched in this process). The idea is to make the successful execution of the test mandatory before advancing the master branch of the CBE repository or releasing a new version of the integration in Genode. A handy side-feature of the tool is that one can run  tool/cbe_autopilot prove to do only the GNAT-proving part. With  tool/cbe_autopilot clean finally, the tool cleans up all of its artifacts.</p><p>  此外，我们创建了特定于CBE的自动驾驶仪工具tool / cbe_autopilot，旨在为CBE版本的质量以及它们在Genode中的集成建立通用参考。在不带参数的情况下运行该工具将说明如何使用它。简而言之，当运行tool / cbe_autopilot基础时，该工具将通过GNAT验证预期可证明的内容，运行所有预期有效的与CBE相关的运行脚本，并构建所有与CBE相关的软件包（现有的build和depot目录不存在）在这个过程中感动）。这个想法是在推进CBE存储库的master分支或在Genode中发布集成的新版本之前，使测试的成功执行成为强制性的。该工具的一个便利功能是可以运行tool / cbe_autopilot证明仅执行GNAT证明部分。最后使用tool / cbe_autopilot清理，该工具清理其所有工件。</p><p>    The introduction of VFS plugins for CBE back ends in the previous Genode release made it much easier to interchange concrete implementations. This motivated us to play around a bit in our endeavour of optimizing execution time. It turned out that especially the choice of the block-encryption back end has a significant impact on the overall performance of CBE block operations. It furthermore seemed that especially the  libsparkcrypto library, our former default for block encryption, prioritizes other qualities over performance.</p><p>在以前的Genode版本中，为CBE后端引入了VFS插件，这使得互换具体实现变得容易得多。这促使我们在优化执行时间方面进行了一些尝试。事实证明，特别是块加密后端的选择对CBE块操作的整体性能有重大影响。此外，似乎尤其是libsparkcrypto库（我们以前的块加密默认库）将其他质量放在性能之上。</p><p>  That said, in general, we want to enable an informed user to decide for him- or herself which qualities one prefers in such an algorithm. The VFS plugin mechanism pays tribute to this. And it also seems very natural to us to combine a SPARK-based block-device management with a SPARK-based encryption back-end like  libsparkcrypto. But for our default use case, we came to the conclusion that the  libcrypto library might be a better choice.</p><p>  就是说，总的来说，我们希望使知情的用户能够为他或她自己决定在这种算法中谁更喜欢哪些质量。 VFS插件机制对此表示敬意。对于我们来说，将基于SPARK的块设备管理与基于SPARK的加密后端（如libsparkcrypto）相结合似乎也很自然。但是对于我们的默认用例，我们得出的结论是libcrypto库可能是一个更好的选择。</p><p>    The Genode release  19.11 introduced the emulation of ioctl operations via pseudo files. This feature was first used by the Terminal. With the current release, we further employ this mechanism for additional ioctl operations, like the block-device related I/O controls, as the long-term plan is to remove the notion of ioctl&#39;s from the  Vfs::File_io_services API all-together.</p><p>    Genode版本19.11引入了通过伪文件对ioctl操作进行仿真的功能。此功能最初由终端使用。在当前版本中，我们进一步将这种机制用于其他ioctl操作，例如与块设备相关的I / O控件，因为长期计划是从Vfs :: File_io_services API中完全删除ioctl的概念。</p><p>  We therefore equipped the block VFS-plugin with a compound directory hosting the pseudo files for triggering device operations:</p><p>  因此，我们为块VFS-plugin配备了一个复合目录，该目录托管用于触发设备操作的伪文件：</p><p>  This file contains the device information structured as  block XML node having  size and  count attributes providing the used block size as well as the total number of blocks.</p><p>  该文件包含构造为块XML节点的设备信息，该XML节点具有提供使用的块大小以及块总数的大小和计数属性。</p><p>  Furthermore, we split the existing  ioctl handling method in the libc into specific ones for dealing with terminals and block devices because at some point more different groups of I/O controls are to follow.</p><p>  此外，我们将libc中现有的ioctl处理方法拆分为用于处理终端和块设备的特定方法，因为在某些时候将遵循更多不同的I / O控件组。</p><p>  The first one to follow is the  SNDCTL group. This group deals with audio devices and corresponds to the standard set by the OpenSoundSystem (OSS) specification years ago. In the same vein as the terminal and block I/O controls, the sound controls are implemented via property files.</p><p>  跟随的第一个是SNDCTL组。该组处理音频设备，并对应于几年前OpenSoundSystem（OSS）规范设定的标准。与终端和块I / O控件一样，声音控件是通过属性文件实现的。</p><p>  The controls currently implemented are the ones used by the OSS-output plugin of  cmus, the driving factor behind the implementation, which uses the (obsolete) version 3 API.</p><p>当前实现的控件是cmus的OSS输出插件所使用的控件，cmus是该实现背后的驱动因素，它使用（过时）版本3 API。</p><p>  At the moment, it is not possible to set or rather change any parameters. In case the requested setting differs from the parameters of the underlying audio-out session - in contrast to the suggestion in the OSS manual - we do not silently adjust the parameters returned to the callee but let the I/O control operation fail.</p><p>  目前，无法设置或更改任何参数。如果请求的设置与基础音频输出会话的参数不同-与OSS手册中的建议相反-我们不会默默地调整返回给被调用方的参数，而是让I / O控制操作失败。</p><p>    sets the number of channels. We return the available channels here and return ENOTSUP if it differs from the requested number of channels.</p><p>    设置通道数。我们在此处返回可用频道，如果与请求的频道数不同，则返回ENOTSUP。</p><p>    returns the amount of playback data that can be written without blocking. For now it amounts the space left in the stream buffer of the audio-out session.</p><p>    返回可以写入而不会阻塞的播放数据量。现在，它等于音频输出会话的流缓冲区中剩余的空间。</p><p>        is supposed to reset the devi</p><p>        应该重置设备</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://genode.org/documentation/release-notes/20.11">https://genode.org/documentation/release-notes/20.11</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/os/">#os</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/genode/">#genode</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>