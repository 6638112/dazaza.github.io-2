<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>设计模式、Smalltalk和失落的代码阅读艺术</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">设计模式、Smalltalk和失落的代码阅读艺术</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-21 06:41:25</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/a2886c7db03f7e5e98ddf60a8289f491.png"><img src="http://img2.diglog.com/img/2020/10/a2886c7db03f7e5e98ddf60a8289f491.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The last year has not been kind to a book that I believe to be one of the classic, and most important works of computer science — the book  Design Patterns: Elements of Reusable Object Oriented Design. This is unfortunate, because the preceding year had been the 25th anniversary of the book’s publication and it’s odd that a book that old can generate such vitriol. The twitterverse in particular has been pretty savage to the book — using words like “impenetrable” and in one memorable put-down “the  Atlas Shrugged of Computer Science”.</p><p>我认为这本书是计算机科学中最经典、最重要的著作之一--“设计模式：面向重用对象设计的元素”(Design Patterns：Elements of Reuse Object Oriented Design)。这是不幸的，因为前一年是这本书出版25周年，一本如此古老的书能产生如此尖酸刻薄的言辞是很奇怪的。尤其是推特上的人对这本书相当粗暴-使用了像“无法穿透”这样的词，并在一个令人难忘的降级中使用了“计算机科学的地图集耸耸肩”(The Atlas Shimed Of Computer Science)。</p><p> In a sense, I’m not surprised by this. Even when the book came out, it seemed it had as many detractors as it had supporters. What’s more, even when it was being written, there was a small but impassioned contingent of reviewers at the time that argued that the book needed to be completely rewritten before it was ever published. But every book has issues — and  Design Patterns is not immune to the fact that any work is at best an imperfect reflection of the ideas of the authors.</p><p>从某种意义上说，我对此并不感到惊讶。即使当这本书出版时，它似乎也有和支持者一样多的批评者。更重要的是，即使是在写这本书的时候，当时也有一小群热情的评论家认为，在出版之前，这本书需要完全重写。但每本书都有问题-设计模式也不能幸免于这样一个事实，即任何作品充其量只能不完美地反映作者的想法。</p><p> However, what to my mind is the most difficult part to understand is that regardless of comments on the format, style, or even font choice of the work, I’ve never quite understood is how anyone could reject the  ideas contained within it as being either trivial, useless, or banal. But then again, that’s where my experience as a programmer, and an author, differs from what I have found over the last twenty-five years to be the most common case.</p><p>然而，在我看来，最难理解的是，不管对作品的格式、风格甚至字体选择有何评论，我一直不太明白的是，为什么有人会以琐碎、无用或平庸为由拒绝其中包含的想法。但话又说回来，这就是我作为一名程序员和一名作家的经历与我在过去25年中发现的最常见的情况不同的地方。</p><p> So let’s start with the beginning. I first learned how to program in the same way many people of my generation did — we learned BASIC programming on a home computer. For me, it was a succession of them that I encountered at school, at friends houses, and eventually that I owned. During my high school years I learned to program on the Apple II in Integer and Applesoft BASIC, on the VIC-20, on the TI-99/4A, and on the Sinclair TX1000. Programming on the Sinclair, with only 4K and it’s bizarre shift-key combinations to create BASIC keywords was very different experience from programming on the relatively spacious 48K that the Apple II possessed and it’s wonderfully tactile keyboard that required you to fully type out all of your commands. As a result, I did a lot more low-level development with PEEK and POKE on the Sinclair than I did on the Apple, where the wonderful floating-point capabilities of Applesoft BASIC gave me free reign for my imagination. So nearly from the beginning, I learned that your available environment and language formed the way you thought about a problem.</p><p>那么让我们从头开始吧。我首先学会了如何编程，就像我们这一代的许多人一样--我们在家用电脑上学习基本编程。对我来说，这是我在学校、在朋友家遇到的一连串的东西，最终我拥有了它们。在高中期间，我学会了用Integer和Applesoft Basic在Apple II上编程，在VIC-20上编程，在TI-99/4A上编程，在Sclair TX1000上编程。在Sclair上编程，只有4K，奇怪的Shift-键组合来创建基本的关键字，这与在Apple II相对宽敞的48K上编程的体验截然不同，苹果II的键盘触感极佳，需要你完整地键入所有命令。因此，我在Sclair上进行的低级开发比在Apple上做的要多得多，在Apple上，Applesoft Basic出色的浮点功能让我可以自由发挥自己的想象力。几乎从一开始，我就了解到你可用的环境和语言形成了你思考问题的方式。</p><p> Besides that, the way I learned to program was pretty typical for the time — I learned by writing programs. Now, there would be some programs that you could read — particularly those published in magazines where you had to type them in to run them (no internet!) and in the few that were available freely and circulated on BBS, disk and tape (long before “open source” became a thing), but in general, you learned how to solve problems by solving problems.</p><p>除此之外，我学习编程的方式在当时是相当典型的-我是通过编写程序来学习的。现在，会有一些你可以阅读的程序-特别是那些在杂志上发表的程序，你必须键入它们才能运行它们(没有互联网！)。在少数几个可以免费获得并在BBS、磁盘和磁带上流传的(早在“开源”成为一件事之前很久)，但总的来说，你学会了如何通过解决问题来解决问题。</p><p> When I went to University for my degree, I found that this was still the predominant paradigm for learning the trickier bits of programming and of computer science. For example, when I took a class on operating systems, we would read about a concept, like a semaphore, or a file system, and then be expected to be able to implement the concept. There might be a few simple examples in the text to help get you over the hump as to how the implementation would work, but more often than not these were in a type of pseudocode that you would have to mentally translate into C or C++.</p><p>当我去大学攻读学位时，我发现这仍然是学习编程和计算机科学中比较棘手的部分的主要范例。例如，当我上一堂关于操作系统的课程时，我们会读到一个概念，比如信号量或文件系统，然后被期望能够实现这个概念。文本中可能有几个简单的示例来帮助您了解实现如何工作，但通常这些示例是伪代码类型，您必须在头脑中将其转换为C或C++。</p><p> When I graduated from University and went to work as a C++ and C programmer, nothing much changed from the way I had learned things in college. Every programming problem began with searching out the documentation of the relevant libraries, then sitting down and plotting out how to write the solution from scratch. That was just the way I thought development should be, and always would be.</p><p>当我从大学毕业，开始从事C++和C程序员的工作时，与我在大学里学习东西的方式相比，没有什么太大的改变。每个编程问题都是从搜索相关库的文档开始的，然后坐下来规划如何从头开始编写解决方案。这正是我认为发展应该是这样的，而且永远都会是这样。</p><p> But then, in the winter of 1989, I had an unusual opportunity come my way that changed the way I thought about programming by changing the way I thought about how to solve problems. That opportunity was when I was introduced to Smalltalk (particularly the Smalltalk/V PM version from Digitalk). Writing programs in Smalltalk is such a departure from traditional ways of developing that it took me a long time to fully wrap my head around it. I’ve found that people that try to learn it end up in one of two extremes — either it becomes their all-time favorite development language and environment, or they hate it with a passion bordering on mania.</p><p>但是，在1989年冬天，我有了一个不同寻常的机会，改变了我思考如何解决问题的方式，从而改变了我对编程的思考方式。那个机会是在我被介绍给Smalltalk的时候(特别是Digitalk的Smalltalk/V PM版本)。用Smalltalk编写程序与传统的开发方式背道而驰，我花了很长时间才完全理解它。我发现，试图学习它的人最终会陷入两个极端之一-要么它成为他们一直以来最喜欢的开发语言和环境，要么他们以近乎狂热的热情讨厌它。</p><p> In order to understand why this is true, you need to understand some things that were, at the time completely radical about Smalltalk, and that even to this day, have not fully been replicated in any other development language or environment.</p><p>为了理解为什么这是真的，您需要了解一些事情，这些事情在当时对于Smalltalk来说是完全激进的，即使到了今天，也没有在任何其他开发语言或环境中完全复制。</p><p> 1. Smalltalk does not have files where you put your source code. Now, in a sense that’s a lie, because there IS a single file that contains your source code, but it’s not organized the way you think it might be. Instead of a single file for each module or class, all of the early Smalltalk implementations feature a single large, rolling log file, called the change log, that contains the new source code that you’ve added to the system. As you add a new method, or modify a method, it gets added on the end of the change file. 2. Smalltalk doesn’t have a file-based compilation system — instead, every change you make to any method or class definition in that changes file is instantly compiled by an incremental compiler and added into a single, large, in-memory image of the entire Smalltalk system.  3. Smalltalk was (and is) completely and totally Object-oriented. It was object-oriented in a way that Java, Python or C++ (or newer languages) cannot even match — in that even Integers are objects — and what’s more, you can extend the behavior of an Integer by adding new methods to it! 4. Smalltalk had this great concept called Workspaces that allowed you to highlight and run little snippets of code of any length — it would just compile and run them instantly. People would also mix and match documentation and code snippets within a Workspace — this is the basic idea behind Jupyter notebooks today. This was awesome for just trying something out to see what it did — part of a process of learning by exploration.</p><p>1.Smalltalk没有您放置源代码的文件。现在，从某种意义上说，这是一个谎言，因为只有一个文件包含你的源代码，但它并不是按照你想象的方式组织起来的。与每个模块或类的单个文件不同，所有早期的Smalltalk实现都有一个称为更改日志的大型滚动日志文件，其中包含您添加到系统中的新源代码。当您添加新方法或修改方法时，它会添加到更改文件的末尾。2.Smalltalk没有基于文件的编译系统-相反，您对更改文件中的任何方法或类定义所做的每一次更改都会由增量编译器立即编译，并添加到整个Smalltalk系统的单个大型内存映像中。3.SmallTalk过去(现在也是)完全是面向对象的。它是面向对象的，Java、Python或C++(或更新的语言)甚至无法与之匹敌-因为即使是整数也是对象-而且，您可以通过向其添加新方法来扩展Integer的行为！4.Smalltalk有一个很棒的概念，称为工作区，它允许您突出显示和运行任何长度的小代码片段-它只需立即编译和运行它们。人们还会在一个工作区内混合搭配文档和代码片段--这是当今Jupyter笔记本背后的基本理念。这对于仅仅尝试一些东西看看它做了什么来说是很棒的--这是在探索中学习的过程的一部分。</p><p> But that last observation is merely the tip of the iceberg on what I think was one of the most revolutionary things about Smalltalk that changed the way I develop — and influenced the way that everyone who was exposed to Smalltalk in those days thinks about development. The remainder of that iceberg is this —  the entire system, from the code implementing the editors you developed in, to the basic system libraries like the Integer and Collection classes, up through the Smalltalk compiler classes themselves were available in that Image (from a single base, unchanging “sources” file) for you to read!</p><p>但最后这一点只是冰山一角，我认为这是Smalltalk最具革命性的事情之一，它改变了我的发展方式，并影响了当时每个接触Smalltalk的人对发展的看法。冰山的其余部分是这样的-整个系统，从实现您在中开发的编辑器的代码，到像Integer和Collection类这样的基本系统库，再到Smalltalk编译器类本身，都可以在Image中(从单个基础的、不变的“源”文件)供您阅读！</p><p>  It was this feature that changed the way I thought about developing — and that change only came about by how I was taught to use Smalltalk. I had the wonderful experience of being taught by two of the true masters of the language — Sam Adams and Ken Auer, who at the time were both with Knowledge Systems Corporation, one of the first Smalltalk consulting companies. The simple lesson they taught me was this:</p><p>正是这个功能改变了我对开发的想法--而这种改变只是通过教我如何使用Smalltalk来实现的。我得到了两位真正的语言大师-萨姆·亚当斯(Sam Adams)和肯·奥尔(Ken Auer)的授课，这是一次美妙的经历，他们当时都在知识系统公司(Knowledge Systems Corporation)工作，这是最早的Smalltalk咨询公司之一。他们给我上的简单一课是这样的：</p><p> Don’t start any new programming task from scratch — always look in the Smalltalk image first to see what’s available and what has been already done before you start building anything new.</p><p>不要从头开始任何新的编程任务-在开始构建任何新任务之前，请始终先查看Smalltalk映像，看看有哪些可用内容以及已经完成了哪些操作。</p><p> To me, this was a revelation. It upended everything I had ever learned to this point about programming. But as I’ve thought back over my career and my life, I realized that this really isn’t that unusual. Think back to how you first learned to read (in whatever language that was). Your elementary school teachers didn’t expect you to write a novel as soon as you mastered the alphabet. No, what they probably did (I know mine did) was to first give you the opportunity to read at length before you were expected to be able to write something comparable. As I look back to my elementary school days, I remember writing a lot of book reports — which are really just shorter summaries of larger works — but the point is, we ended up reading probably 10 times more than we actually wrote.</p><p>对我来说，这是一个启示。它颠覆了我到目前为止所学到的关于编程的一切。但是，当我回想起我的职业生涯和生活时，我意识到这并不是什么不寻常的事情。回想一下你最初是如何学会阅读的(不管是哪种语言)。你的小学老师没想到你一掌握字母就会写小说。不，他们可能做的(我知道我做的)是先给你机会详细阅读，然后你才能写出类似的东西。当我回顾我的小学时代时，我记得我写了很多读书报告-它们实际上只是较大作品的较短摘要-但重点是，我们最终阅读的内容可能是实际写作的10倍。</p><p> As I moved into high school and college, the lengths of the essays, reports and other things I was expected to write grew, but that same rough 10–1 ratio of reading to writing remained approximately the same, or even increased as I moved on to university and especially graduate school (where the ratio may have been 50–1).</p><p>随着我进入高中和大学，我预计要写的文章、报告和其他东西的长度增加了，但同样粗略的10：1读写比大致保持不变，甚至随着我进入大学，特别是研究生(在那里，这一比例可能是50：1)，我的读写比例也在增加。</p><p> At this point, some of my Gen Z and Millenial friends will be losing interest as they start muttering about Boomers because of the following thought</p><p>在这一点上，我的一些Z世代和千禧一代的朋友将失去兴趣，因为他们开始喃喃地谈论婴儿潮一代，原因如下</p><p> That’s just Boomertalk. We have this thing called the “Internet” now, and especially this thing called “Stack Overflow”</p><p>那只是自吹自擂。我们现在有一个叫做“互联网”的东西，特别是这个叫做“堆栈溢出”的东西。</p><p> (I’m Gen X, thank you — and as such my natural Gen X cynicism informs me that you forgot we exist, didn’t you!) But the argument I want to make is that using Stack Overflow is not the same as what I’m referring to — and that the experience was quite different. When you use Stack Overflow, or a search engine like Google, what you’re doing is narrowing in on a particular way of solving a problem in the specific way you describe it. That’s because you’re searching by keyword — what you’re missing is context — and the ability to see a solution in the context in which it was written. What you’re also missing is the serendipity of coming across a better way of thinking about a problem than you may have had in mind when you began the search. You’re also missing the sheer joy of just chasing rabbits through the source code as you sought to understand how a particular section of the code worked, which led you to another rabbit, and another.</p><p>(我是X世代，谢谢-因此，我天生的X世代愤世嫉俗告诉我，你忘记了我们的存在，不是吗？)。但我想提出的论点是，使用Stack Overflow与我所指的不同，体验也完全不同。当您使用Stack Overflow或像Google这样的搜索引擎时，您所做的就是以您所描述的特定方式缩小解决问题的特定方式。这是因为您是按关键字搜索的-您缺少的是上下文-以及在编写解决方案的上下文中查看解决方案的能力。你还错过了一个偶然发现的思考问题的更好的方法，这可能是你开始搜索时想不到的。您还错过了在源代码中追逐兔子的纯粹乐趣，因为您试图了解代码的某一特定部分是如何工作的，这导致您找到了另一只兔子，又是另一只兔子。</p><p> And that is where we work our way back to the original topic of this blog, which was the book  Design Patterns. I had been a Smalltalk programmer for about five years when the book first came out — in fact, I first encountered the patterns in a xeroxed pre-print of part of the book before the book was officially released. Outside of the context of the book as a whole, they didn’t make much of an impression on me. But then, once the book was released, I took a copy with me on a long car ride from Raleigh to Atlanta (about six hours) and read it on the way. This time, it clicked.</p><p>这就是我们回到这个博客的原始主题的地方，那就是“设计模式”一书。当这本书第一次出版时，我已经做了大约五年的Smalltalk程序员-事实上，在这本书正式发行之前，我第一次遇到这些模式是在这本书的一部分的复印预印本中。除了这本书的整体背景之外，它们并没有给我留下太多印象。但是，一旦这本书出版，我就带着一本书从罗利到亚特兰大的长途汽车旅行(大约6个小时)，并在路上阅读了它。这一次，它一拍即合。</p><p> So let’s think about how the way I had been developing for the last several years had molded my thinking — I would always browse through the Smalltalk source code for ideas and inspiration whenever I was solving a programming problem. That means I had read through most, if not all of the Smalltalk/V and Smalltalk-80 (VisualWorks) source code several times, and had been using things I picked up from that source code in the projects I was working on.</p><p>因此，让我们想想我过去几年的开发方式是如何塑造我的思维的-每当我解决编程问题时，我总是浏览Smalltalk源代码来寻找想法和灵感。这意味着我已经多次阅读了Smalltalk/V和Smalltalk-80(VisualWorks)的大部分(如果不是全部)源代码，并且在我正在工作的项目中一直在使用我从源代码中获得的东西。</p><p> What  Design Patterns did was to suddenly give me a vocabulary for many (not all, but a lot) of the things that I had already encountered in reading all of that source code. I remember coming across  Observer and thinking — “OK, I’ve not only seen this, but I’ve used this a couple of hundred times because you can’t write a GUI in VisualWorks Smalltalk without it.” Then I came across  Mediator — and realized I had seen that inside the GUI source code of both Smalltalk versions, and as I read more I kept experiencing the same sense of deja vu over, and over, and over again.</p><p>设计模式所做的就是突然为我提供了一个词汇表，涵盖了我在阅读所有源代码时已经遇到的许多(不是全部，但很多)东西。我记得在遇到观察者时想--“好吧，我不仅见过这个，而且我已经用了几百次了，因为没有它就不能在VisualWorks Smalltalk中编写GUI。”然后我遇到了Mediator-并意识到我已经在两个Smalltalk版本的GUI源代码中看到了这一点，随着我阅读的越来越多，我不断地体验到同样的似曾相识的感觉，一遍又一遍。</p><p> The best analogy I can think of was as if I had been reading and writing fiction, but I didn’t have the vocabulary to describe what I was doing — I didn’t know what to call a Character, or a Scene, or a Plot Device, but I had used all of them on my own work and had encountered them in fiction I had read.</p><p>我能想到的最好的比喻是，就好像我一直在读和写小说，但我没有描述我正在做的事情的词汇量-我不知道怎么称呼一个人物，一个场景，或者一个情节装置，但我在自己的作品中都使用了它们，并且在我读过的小说中遇到了它们。</p><p> But the thing that it really did was to open my mind to the possibility that those 23 patterns weren’t all of the recurring themes that I had seen. Today, in fiction (particularly the anime and sci-fi genres) we call these Tropes, and there are entire websites devoted to them, like  TVTropes, where you can learn about common themes like  The Mad Scientist’s Beautiful Daughter and  The Sorting Algorithm of Evil (read them both — you’ll recognize them). But the idea is much older — Joseph Campbell famously declared that there is a single “monomyth” called  The Hero’s Journey that can capture the essence of every epic story from  The Odyssey through  Star Wars.</p><p>但它真正起到的作用是打开了我的思维，让我认识到这23种模式并不是我见过的所有反复出现的主题。今天，在小说中(尤其是动漫和科幻类型)，我们把这些比喻称为比喻，有很多专门针对它们的网站，比如TVTropes，在那里你可以了解到共同的主题，比如疯狂科学家的美丽女儿和邪恶的分类算法(这两个都读了--你会认出它们来的)。但这个想法要古老得多-约瑟夫·坎贝尔(Joseph Campbell)著名地宣称，有一个名为英雄之旅的单一“单一神话”可以捕捉到从“奥德赛”到“星球大战”的每个史诗故事的精髓。</p><p> And that wraps me back around to the original thesis of this blog. People pick up  Design Patterns and expect to read it as literature, but you can’t do that — it’s not a story. You shouldn’t read it that way. It’s more like a textbook about comparative literature. At its best it teaches you something about the art of writing code, much like a comparative literature textbook would teach you something about the art of writing fiction. It will not teach you programming — that is the problem with the way many people started applying the patterns, which resulted in unbelievable overuse of the 23 patterns where they applied the “Everything looks like a nail when you have a hammer” antipattern.</p><p>这让我回到了这个博客的原始主题。人们拿起设计模式，希望把它当作文学来读，但你不能这样做--它不是一个故事。你不应该那样读。它更像是一本关于比较文学的教科书。它最好的情况是教你一些关于编写代码的艺术，就像一本比较文学教科书教你一些关于写小说的艺术一样。它不会教你编程-这就是许多人开始应用模式的方式的问题，这导致了令人难以置信的过度使用23个模式，他们在这些模式中应用了“当你有锤子的时候，一切看起来都像钉子”反模式。</p><p> Instead, you should just think of the patterns as 23 terms that can be useful for describing particular tropes that are most common in object-oriented programming. It can help you recognize those tropes, and even give you some indication as to when they might be helpful — but most importantly it gives you a vocabulary to talk to others about those tropes.</p><p>相反，您只应将模式视为23个术语，它们可用于描述面向对象编程中最常见的特定比喻。它可以帮助你识别这些比喻，甚至给你一些提示，告诉你什么时候它们可能会有帮助-但最重要的是，它给了你一个与他人谈论这些比喻的词汇表。</p><p> Now, there is one more thing I want to bring in about this — probably the most common thing I hear people dismiss the patterns as are “well, these are just things that are language features in X, Y or Z, so you don’t need them in that language”. Nothing could be farther from the truth.</p><p>现在，还有一件事我想提出--可能是我听到人们对这些模式不屑一顾的最常见的一件事，因为“嗯，这些只是X、Y或Z中的语言特征，所以在那种语言中你不需要它们。”没有什么比真相更离谱的了。</p><p> You see, the first language that this particular trope was applied to was Smalltalk! When the book came out, the Smalltalk message boards (remember — this was 1996!) were flooded with messages from Smalltalk developers saying that these patterns were only needed because C++ (which was the only other OO language widely used at the time) was so deficient. This was despite the fact that about half of the examples in  Design Patterns were originally written in Smalltalk.</p><p>你看，这个特殊的比喻应用到的第一种语言是Smalltalk！当这本书出版时，Smalltalk留言板(记住-这是1996年！)。充斥着来自Smalltalk开发人员的消息，他们说，之所以需要这些模式，只是因为C++(它是当时唯一广泛使用的另一种面向对象语言)非常不足。尽管设计模式中大约一半的示例最初是用Smalltalk编写的，但这仍然是事实。</p><p> But this is where I was able to help out. To make a long story short, Sherman Alpert, Bobby Woolf and I became co-authors of  The Design Patterns Smalltalk Companion — the very first official follow-on book to  Design Patterns. We showed that the ideas, the tropes, are universal. You can implement them more simply in some languages than others, but the fact that the ideas remain the same across the boundaries of language and environment is the important thing.</p><p>但这就是我能帮上忙的地方。长话短说，Sherman Alpert、Bobby Woolf和我成为了Design Patterns Smalltalk Companion的合著者--这是Design Pattern的第一本官方续集。我们证明了这些想法和比喻是普遍存在的。您可以用某些语言比其他语言更简单地实现它们，但重要的是，这些思想跨越语言和环境的界限保持不变。</p><p> Which brings me to the last point I want to make — if you don’t understand the patterns, and can’t make heads or tails of them, maybe one thing to do is — read more code. If you’ve primarily read your own code, and you’ve not read widely in the code of others, odds are good that you’ve not encountered any of the patterns, much like you’d never encounter  The Sorting Algorithm of Evil if you never watched or read any science fiction or played online MMORPGs. But the more you watch and read, the more likely you are to encounter that trope.</p><p>这就引出了我想要说明的最后一点--如果您不理解这些模式，并且不能理解它们，那么也许要做的一件事就是--多读一些代码。如果您主要阅读过自己的代码，而没有广泛阅读过其他人的代码，那么您很有可能没有遇到任何模式，就像您从未看过或读过任何科幻小说或在线玩过MMORPG游戏一样，永远不会遇到邪恶的排序算法。但是，你看的和读的越多，你就越有可能遇到这种比喻。</p><p> Another thing to do is to read particular types of code — let’s be honest — not all code is created equally. In my job I do a lot of code review of client code, mostly in Java, and some of it is particularly terrible. In fact, there’s one problem I see that is endemic. That’s where the code is “supposedly” object-oriented, but in fact, it doesn’t take advantage of any of the features of object orientation (no inheritance, no method overrides, and few if any uses of type substitution). In particular I see tons of code where there are these static “data” objects (a misunderstanding of another pattern from Martin Fowler, called the  Data Access Object) and these “processing” objects that are, for the most part, just bags of procedures that operate on the data objects. This is object-orientation in name only, and not in practice. If the only code you ever encounter looks like that, then I again understand why you may never have encountered any of the patterns from  Design Patterns. I also feel terrible for you, because reading code like that is painful and wearing. Unfortunately, I think that this style of development is encouraged by the very tools we use to develop them — editors that focus on the level of a file will, unfortunately, never encourage you think about what lies beyond the context of the file — yet another thing that’s been lost as file-oriented languages and development environments took over.</p><p>另一件要做的事情是阅读特定类型的代码-老实说-并不是所有的代码都是平等创建的。在我的工作中，我对客户端代码做了大量的代码审查，主要是用Java，其中一些特别糟糕。事实上，我发现有一个问题是地方性的。这就是代码“假定”面向对象的地方，但实际上，它没有利用面向对象的任何特性(没有继承、没有方法重写，并且很少使用类型替换(如果有的话)。特别是，我看到大量代码中存在这些静态“数据”对象(对Martin Fowler的另一种模式的误解，称为数据访问对象)和这些“处理”对象，它们在很大程度上只是对数据对象进行操作的过程。这只是名义上的面向对象，而不是实践中的面向对象。如果您遇到的唯一代码是这样的，那么我再次理解为什么您可能从未遇到过设计模式中的任何模式。我也为您感到难过，因为像这样阅读代码既痛苦又累人。不幸的是，我认为这种开发风格受到了我们用来开发它们的工具的鼓励-不幸的是，关注文件级别的编辑器永远不会鼓励您考虑文件上下文之外的内容-随着面向文件的语言和开发环境取而代之，另一个东西已经丢失了。</p><p> Despite that potential pain, in any case, reading more code can never be a bad thing. If you don’t have any good code to read in your work, then I encourage you to turn to open source projects — many of us simply consume open-source code and use the public API’s without ever diving down into understanding how the internals are written — doing that will give you an opportunity to see how many different people code, and to compare many different styles of development. Even if you don’t see the 23 patterns from  Design Patterns, you will learn to identify and pick up other tropes that will, I guarantee, improve your programming in whatever language you develop in. And, if you want to help others out with a vocabulary to describe those tropes, then you can do what the authors of  Design Patterns did — write the trope down so that others can identify it. That’s how everyone will benefit — you from learning from the experiences of others, and everyone else from being able to adopt your vocabulary when they re-encounter that particular concept.</p><p>尽管存在这种潜在的痛苦，但在任何情况下，阅读更多的代码都不会是一件坏事。如果您在工作中没有任何好的代码可读，那么我鼓励您转向开源项目-我们中的许多人只是使用开源代码和使用公共API，而没有深入了解内部是如何编写的-这样做将使您有机会看到有多少不同的人编写代码，并比较许多不同的开发风格。即使您没有看到设计模式中的23种模式，您也将学会识别和学习其他的用法，我保证，这些用法将改进您的编程，无论您使用哪种语言进行开发。而且，如果您想用词汇表来帮助其他人描述这些比喻，那么您可以像设计模式的作者那样做-写下比喻，以便其他人可以识别它。这就是每个人都会从中受益的方式--你从别人的经验中学习，其他人在再次遇到这个特定概念时能够采用你的词汇。</p><p> BTW, if you want to try Smalltalk yourself,   Squeak Smalltalk  provides a very faithful open-source implementation of Smalltalk and is available on most platforms.</p><p>顺便说一句，如果您想亲自尝试Smalltalk，Squeak Smalltalk提供了一个非常忠实的Smalltalk开源实现，并且可以在大多数平台上使用。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://medium.com/swlh/design-patterns-smalltalk-and-the-lost-art-of-reading-code-1727d93fd7fa">https://medium.com/swlh/design-patterns-smalltalk-and-the-lost-art-of-reading-code-1727d93fd7fa</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/smalltalk/">#smalltalk</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/patterns/">#patterns</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1030070.html"><img src="http://img2.diglog.com/img/2020/10/thumb_c40716e51603636341006e1e1df256f7.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030070.html">您将收获您所编写的代码</a></div><span class="my_story_list_date">2020-10-20 22:49</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030062.html"><img src="http://img2.diglog.com/img/2020/10/thumb_febd33768c5e817e34a81b0bd750e291.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030062.html">CPython提速实施方案</a></div><span class="my_story_list_date">2020-10-20 22:46</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029637.html"><img src="http://img2.diglog.com/img/2020/10/thumb_87000f9b51e962da1315667056ddec8e.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029637.html">在代码库中管理技术质量</a></div><span class="my_story_list_date">2020-10-19 1:40</span></div><div class="col-sm"><div><a target="_blank" href="/story/1029580.html"><img src="http://img2.diglog.com/img/2020/10/thumb_77603e98af8e217dccff4b9f4ff785c0.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1029580.html">代码审查而不是代码审批</a></div><span class="my_story_list_date">2020-10-18 16:58</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>