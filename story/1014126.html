<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Seccomp通告--弱势集装箱发展的新前沿</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Seccomp通告--弱势集装箱发展的新前沿</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-07-25 21:40:19</div><div class="story_img_container"><a href="http://img.diglog.com/img/2020/7/a08e0ffe35c7df426e5aeb1fe9948832.png"><img src="http://img.diglog.com/img/2020/7/a08e0ffe35c7df426e5aeb1fe9948832.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>正如大多数人所知道的那样，我们做了很多上游内核开发。这涉及多个领域，当然，我们还围绕容器做了大量内核工作。在这篇文章中，我想仔细看看我们在内核和用户空间中开发的新的seccomp Notify特性，它将会看到越来越多的用户。在过去的两年里，我在不同的会议上(最近又是在OSS NA上)多次讨论过这个特性，但是从来没有真正坐下来写一篇关于它的博客文章。这是我很长一段时间以来一直想做的事情。首先，因为从纯技术角度来看，它是一个非常令人兴奋的特性，而且从它为(非特权)容器和其他用例打开的新可能性来看，它也是一个非常令人兴奋的特性。</p><p>(Linux)容器是用户空间虚构的，这是当今众所周知的格言。它只是表示在Linux内核中没有容器内核对象这一事实。相反，用户空间可以相对自由地定义什么是容器。但在很大程度上，用户空间同意容器在某种程度上与将任务或任务树与主机系统隔离有关。这是通过组合多种Linux内核功能来实现的。用于构建容器的较知名的内核特性之一是名称空间。随着时间的推移，内核支持的名称空间数量不断增加，我们目前支持的名称空间数量为8个。在您查看它们的名称空间(7)之前，它们如下所示：</p><p>在这8个名称空间中，用户名称空间是唯一一个与隔离Linux上的核心特权概念(如用户和组ID以及功能)有关的名称空间。</p><p>我们经常看到用户空间中的任务检查它们是否以root身份运行，或者它们是否具有特定的功能(例如，创建设备节点需要CAP_MKNOD)，似乎当答案是“是”时，该任务实际上是一个特权任务。但和往常一样，事情并没有那么简单。任务认为它在检查什么和内核真正在检查什么可能是两件非常不同的事情。一个幼稚的任务，即不知道用户名称空间的任务，可能会认为它是在询问它是否拥有相对于整个系统(即主机)的特权，但内核真正检查的是该任务是否具有相对于它所在的用户名称空间的必要权限。</p><p>在大多数情况下，内核不会检查任务是否具有相对于整个系统的特权。相反，它几乎总是调用名为ns_capable()的函数，这是内核检查调用任务在其当前用户名称空间中是否具有特权的方式。</p><p>例如，当通过在unshare(2)或clone3(2)中设置CLONE_NEWUSER标志来创建新的用户名称空间时，内核将通过新用户名称空间中的clone3(2)向调用unshare(2)的任务或新创建的子任务授予一整套能力。例如，当该任务现在检查它是否具有CAP_MKNOD功能时，内核将报告它确实具有该功能。不过，关键的一点是，这个“是”不是全局的“是”，即“我是否有足够的特权来执行此操作？”仅适用于当前用户命名空间(从技术上讲，还适用于任何嵌套的用户命名空间)，而不适用于主机本身。</p><p>当试图理解为什么在新的用户命名空间中以root身份运行的具有所有引发的功能的任务仍然会看到EPERM时，例如，即使它似乎拥有所有必要的权限，尝试调用minkd(&#34；/dev/mem&#34；，make dev(1，1))时，这一区别也很重要。这种违反直觉的行为的原因是内核并不总是检查您是否拥有针对当前用户名称空间的特权。相反，对于它认为向非特权用户公开是危险的任何操作，它将检查该任务是否在初始用户命名空间(即主机的用户命名空间)中具有特权。</p><p>创建设备节点就是这样一个例子：如果在用户名称空间中运行的任务能够创建字符或块设备节点，则它可以例如创建/dev/kmem或任何其他关键设备，并使用该设备接管主机。因此，内核总是针对初始用户名称空间执行所需权限的检查，从而简单地阻止在用户名称空间中创建所有设备节点。当然，这在技术上是不一致的，因为功能是按用户名称空间计算的，正如我们在上面观察到的那样。</p><p>内核需要初始用户命名空间中的权限的其他示例是挂载块设备。因此，简单地使磁盘设备节点对非特权容器可用仍然不能使其可用，因为它不能挂载它。另一方面，一些文件系统(如cgroup、cgroup2、tmpfs、proc、sysfs和fuse)可以挂载在用户名称空间中(对proc和sys有一些警告，但我们现在忽略这些细节)，因为内核可以保证这是安全的。</p><p>但当然，这些限制令人恼火。不能挂载块设备或创建设备节点意味着相当多的工作负载不能在容器中运行，即使它们可以安全运行。通常，当容器试图执行的操作是安全的时，像LXD这样的容器管理器会比内核更清楚。</p><p>设备节点就是一个很好的例子。大多数容器将一组标准设备绑定到容器中，否则将无法正常工作：</p><p>允许容器创建这些设备将是安全的。当然，容器只是在容器启动时将这些设备绑定挂载到容器中，所以这并不是一个真正严重的问题。但是，在容器内运行的任何想要创建这些无害设备节点的程序都会失败。</p><p>前面提到的另一个示例是挂载基于块的文件系统。我们的用户经常指示LXD将某些磁盘设备提供给他们的容器，因为他们知道这是安全的。例如，他们可以为容器使用专用磁盘，或者希望在容器之间或容器之间共享数据。但是容器不能安装这些磁盘中的任何一个。</p><p>对于管理员知道容器中缺少设备节点或磁盘设备的任何用例，LXD提供将它们热插拔到一个或多个容器中的能力。例如，下面是如何将/dev/0热插拔到正在运行的容器中的方法：</p><p>Brauner@Wittgenstein|~&gt；lxc exec f5--ls-al/my/zerobrauner@Wittgenstein|~&gt；lxc配置设备add f5零设备unix-char source=/dev/零路径=/my/zeroDevice零设备已添加到f5brauner@Wittgenstein|~&gt；lxc exec f5--ls-al/my/zercrw。</p><p>但当然，当容器内的随机应用程序调用mnowd(2)本身时，这根本没有任何帮助。在这些情况下，LXD没有办法通过热插拔设备来帮助应用程序，因为它不知道已经执行了mculd syscall。</p><p>因此，问题的根源似乎在于：-容器内的任务执行将失败的系统调用。-系统调用将不需要失败，因为容器管理器知道它是安全的。-容器管理器无法知道何时执行这样的系统调用。-即使容器管理器将知道何时执行这样的系统调用，它也无法详细检查它。</p><p>因此，此问题的一个潜在解决方案似乎是，只要容器管理器或任何有足够特权的任务执行通常会失败的syscall，它就可以代表容器执行操作。因此，我们需要以某种方式与另一个任务的系统调用进行交互。</p><p>最值得关注的候选公司是seccomp。它是“安全计算”的缩写，它提供了一种限制任务的syscall的方法，要么只允许内核支持的syscall的子集，要么拒绝它认为对相关任务不安全的一组syscall。但是seccomp允许通过所谓的“过滤器”进行更高级的配置。过滤器是BPF程序(不能等同于eBPF。BPF是eBPF的前身。)。它可以在用户空间中编写并加载到内核中。例如，任务可以使用seccomp筛选器来只允许mount()syscall，并且只允许那些创建绑定装载的装载syscall。这种简单的syscall管理机制使seccomp成为许多用户空间程序的基本安全特性。如今，将任何关键程序限制在它绝对需要成功运行的系统调用上被认为是很好的做法。基于浏览器的沙箱和容器是主要示例，但即使是systemd服务也可能受到seccomp限制。</p><p>Seccomp的核心只不过是一种syscall拦截机制。无论如何，每个操作系统都有一些至少大致可以比较的东西。Seccomp的工作方式是在特定于体系结构的syscall入口路径中拦截syscall。因此，seccomp调用本身驻留在特定于体系结构的代码路径中，尽管它周围的大部分逻辑都是体系结构不可知的。</p><p>通常，当执行syscall并且没有对发出syscall的任务应用seccomp过滤器时，内核将简单地在特定于体系结构的syscall表中查找syscall号，如果它是已知的syscall号，则执行它，并将结果返回给用户空间。</p><p>但是，当为发出syscall的任务加载seccomp筛选器时，而不是直接在体系结构的syscall表中查找syscall号，内核将首先调用seccomp并运行加载的seccomp筛选器。</p><p>根据seccomp筛选器是使用拒绝还是允许方法，筛选器未专门处理的任何syscall要么被执行，要么被拒绝向调用任务报告指定的默认值。如果所请求的syscall被认为是由seccomp过滤器专门处理的，则例如可以使内核报告回特定的错误代码。这样，例如，可以通过创建seccomp筛选器来假装内核不知道mount(2)syscall，该筛选器在任务尝试调用mount(2)时报告ENOSYS。</p><p>但seccomp过去的工作方式并不是非常动态。具体地说，一旦加载了过滤器，就会根据过滤器表达的策略来确定系统调用是否成功。因此，没有办法逐个做出在某些情况下可能会派上用场的决定。</p><p>此外，seccomp本身并不能使syscall真正成功，除了将成功报告给调用者这种微不足道的方式。因此，seccomp只允许内核假装syscall成功。因此，虽然可以指示内核为挂载(2)syscall返回0，但实际上不能指示内核使挂载(2)syscall成功。因此，仅仅让seccomp筛选器返回0以将专用ext4磁盘设备挂载到/mnt仍然不会实际将其挂载到/mnt；它只是向调用者假装它已经挂载了。当然，对于许多用例来说，这本身就是一个有用的属性，但它并不能真正帮助解决上面概述的mnowd(2)或mount(2)问题。</p><p>因此，从上面的部分可以清楚地看出，seccomp提供了一些所需的属性，这些属性使其成为帮助解决mnowd(2)和mount(2)问题的自然候选者。因为seccomp在syscall路径的早期拦截syscall，所以它已经为我们提供了一个进入给定任务的syscall路径的钩子。但是，缺少一种将另一个任务(如LXD容器管理器)引入其中的方法。我们需要以某种方式修改seccomp，使容器管理器不仅可以在容器内的任务执行它想要通知的syscall时得到通知，而且还可以阻止该任务，直到容器管理器指示内核允许它继续进行。</p><p>这些问题的答案是seccomp通告程序。现在是引入一些历史背景的好时机。截取系统调用的更动态方式的想法的确切起源可能是无法恢复的，它在各种讨论中以不具体的形式被抛出，但没有任何严肃的事情成为现实。围绕seccomp通知器的第一个具体细节是在2017年初LXD团队中构思出来的。Stéphane Graber在洛杉矶举行的Container‘s MicroConference的2017年Linux水管工大会上发表了第一次关于这一功能的基本想法的公开演讲。这次演讲的细节仍然列在这里，我相信斯特凡仍然可以提供我们想出来的幻灯片。我没有找到录像带，尽管不知何故我以为我们确实有。如果有人真的很好奇，我可以尝试向Linux Plumbers委员会进行调查。在这次演讲之后，当天晚些时候的走廊会议上讨论了实现细节。在经历了漫长而艰辛的旅程之后，曾经在LXD团队工作的Tycho Andersen逆流而上。剩下的就是历史日志了。</p><p>本质上，seccomp通知机制只是特定seccomp筛选器的文件描述符(FD)。当容器启动时，它通常会加载seccomp过滤器来限制其攻击面。即使对于没有特权的容器也是这样做的，尽管这不是严格必要的。</p><p>通过添加seccomp通知器，希望由另一个进程处理syscall子集的容器可以在其seccomp过滤器上设置新的SECCOMP_RET_USER_NOTIF标志。此标志指示内核在加载其筛选器后向调用任务返回文件描述符。此文件描述符是seccomp NOTIFY文件描述符。</p><p>当然，seccomp通知FD对任务本身并不是很有用。首先，由于它除了非常奇怪的用例之外没有太多意义-任务侦听自己的系统调用的用例。其次，因为这项任务很可能会很快地无限期地阻止自己，而不会采取极端的谨慎措施。</p><p>但是任务可以使用seccomp通知器执行的操作是移交给另一个任务。通常，它将把seccomp通知FD交给的任务将比其自身具有更高的特权。对于容器，最明显的候选者当然是容器管理器。</p><p>由于seccomp通知FD是可轮询的，因此可以将其放入EPOLL(7)、POLL(2)或SELECT(2)等事件循环中，并等待文件描述符变为可读，即内核将EPOLLIN返回到用户空间。使seccomp通知FD变得可读意味着它所引用的seccomp过滤器已经检测到它所应用的任务之一已经执行了系统调用，该系统调用是它实现的策略的一部分。这是一种复杂的说法，即内核正在通知容器管理器容器中的一个任务已经执行了它关心的syscall，例如minkd(2)或mount(2)。</p><p>换句话说，这意味着容器管理器可以监听在容器中运行的任务的syscall事件。现在，内核将在seccomp上向容器管理器发送通知，通知fd，并阻塞执行syscall的任务，而不是简单地运行过滤器并立即报告回调用任务。</p><p>在seccomp通知FD指示它是可读的之后，容器管理器可以使用与seccomp通知FD相关联的新的SECCOMP_IOCTL_NOTIF_RECV ioctl()来读取Syscall的struct seccomp_NOTIFY消息。当前，要从seccomp Notify FD读取的数据包括以下片段。但请注意，我们正在讨论未来版本的潜在侵入性更改：</p><p>让我们更详细地看一下这一点。PID字段是执行syscall的任务的PID，如调用方的PID名称空间所示。为了保持在我们当前示例的范围内，这只是容器中任务的PID，例如，容器管理器的PID名称空间中可以看到名为mKnod(2)的任务。ID字段是执行的系统调用的唯一标识符。这可用于验证任务是否仍处于活动状态以及syscall请求是否仍然有效，以避免PID回收引起的任何争用情况。FLAGS参数当前未使用，并为将来的扩展保留。</p><p>Struct seccomp_data参数可能是最有趣的，因为它包含真正令人兴奋的内容：</p><p>Int字段是syscall号，只能相对于ARCH字段正确解释。ARCH字段是为其生成此系统调用的(审核)体系结构。此字段非常相关，因为兼容体系结构(对于x86体系结构，这至少包括x32、i386和x86_64)。ARM、MIPS和POWER体系结构也具有兼容的“子”体系结构。)。是可堆叠的，并且返回的syscall号可能与当前标头所暗示的不同(例如，您可以从64位内核上的32位用户空间进行syscall。如果截获的syscall在32位和64位上具有不同的syscall编号，例如，syscall foo()可能在32位上具有syscall编号1，在64位上具有2。因此，读取seccomp数据的任务不能简单地假设，因为它本身在32位环境中运行，所以syscall编号必须为1。相反，它必须检查审核搜索是什么，然后检查syscall的值在32位上是否为1，在64位上是否为2。否则，容器管理器可能最终会模拟mount()，而实际上它应该模拟minkd()。)。INSTRUCTION_POINTER设置为执行系统调用的指令的地址。当然，这也是特定于体系结构的。最后一个args成员是任务用来执行syscall的syscall参数。</p><p>根据系统调用布局及其类型的不同，需要对参数进行不同的解释和处理。如果它们是非指针参数(无符号整型等)。可以将它们复制到本地变量中并立即解释。但是，如果它们是指针参数，则它们是执行系统调用的任务的虚拟内存的偏移量。在后一种情况下，需要读取和复制内存，然后才能解释它。</p><p>让我们看一个具体的例子，来弄清楚为什么除了知道syscall参数的类型之外，了解syscall布局是非常重要的。假设执行的syscall是mount(2)。为了正确解释args字段，我们查看mount()的syscall布局。(请注意，我要强调的是，我们需要查看syscall的布局，唯一可靠的来源实际上是内核源代码。Linux手册页通常列出由系统libc提供的包装器，并且这些包装器不一定与syscall本身对齐(比较waitid()包装器和waitid()syscall或各种clone()syscall布局)。从mount(2)的布局中我们可以看到，args[0]是标识源路径的指针参数，args[1]是标识目标路径的另一个指针参数，args[2]是标识文件系统类型的指针参数，args[3]是标识选项的非指针参数，args[4]是标识其他挂载选项的另一个指针参数。</p><p>因此，如果我们对此mount(2)syscall的源路径感兴趣，我们需要打开执行此syscall的任务的/proc/&lt；pid&gt；/mem文件，例如，使用带有args[0]的prede(2)函数作为任务虚拟内存的偏移量，并将其至少读入标准路径长度的缓冲区。或者，我们可以使用单个系统调用(如process_vm_readv(2))一次性读取不同位置的多个远程指针。一旦我们做到了这一点，我们就可以解释它了。</p><p>一个友好的建议：通常情况下，容器管理器阅读所有。</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://people.kernel.org/brauner/the-seccomp-notifier-new-frontiers-in-unprivileged-container-development">https://people.kernel.org/brauner/the-seccomp-notifier-new-frontiers-in-unprivileged-container-development</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/通告/">#通告</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/notifier/">#notifier</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/syscall/">#syscall</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>