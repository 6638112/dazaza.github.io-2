<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>ZK-Snarks的缺失解释：第一部分</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">ZK-Snarks的缺失解释：第一部分</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-02 04:12:48</div><div class="page_narrow text-break page_content"><p>What are ZK-SNARKs and how do they work? This is a question I’ve had for years, and always felt like the resources I found gave no clear intuition as to how all of that stuff worked. So today, after a breakthrough in my own understanding, I thought it would be good to re-share what I’ve learned in a more understandable picture. Something that tells you what is the right way of thinking about these things, and what are the gaps that you can fill for yourself if you want to.</p><p>什么是ZK-Snarks？它们是如何工作的？这是我多年来一直存在的问题，我总是觉得我找到的资源对所有这些东西是如何工作的没有给出明确的直觉。所以今天，在我对自己的理解有了突破之后，我想用一张更容易理解的图片来重新分享我所学到的东西会很好。告诉你思考这些事情的正确方式是什么，如果你想的话，你可以为自己填补哪些空白。</p><p>  The first part of the question is pretty easy to answer. ZK-SNARKs, no matter what their funny name might imply, are simply  zero-knowledge proofs that are:</p><p>问题的第一部分很容易回答。ZK-Snarks，不管他们有趣的名字可能暗示着什么，都是简单的零知识证据，它们是：</p><p>   Well first,  zero-knowledge proofs are cryptographic proofs that you know something, without revealing the something (zero-knowledgeness). That “something” is usually called the  witness, but this detail doesn’t matter much. There are a lot of resources about zero-knowledge proofs so I won’t explain much about how they work, or what their exact cryptographic properties are (completeness, soundness, zero-knowledgeness).Zero-knowledge proofs are often seen used to prove that you know the discrete logarithm in some base of an element of some group (e.g. what is $x$ in $g^x mod p$), or similarly-limited statements.“ Limited yes, but still useful!” yells Schnorr, inventor of the Schnorr signature scheme which is fabricated by taking a zero-knowledge proof of the knowledge of a discrete logarithm, and making it  non-interactive. A zero-knowledge proof or  ZKP is an interactive protocol between a prover (who knows the  witness) and a verifier (who has to be convinced). An interactive protocol sucks in the real world, as it often limits the number of potential use-cases of the primitive, and slows down protocols depending on the number of round trips that need to happen between the prover and the verifier. Fortunately, some ZKPs can be constructed without interaction with a verifier. In other words, a prover can simply create a proof, and that proof can be verified by anyone at any point in time later without further help from the prover. When ZKPs are made non-interactive, we simply call them non-interactive zero-knowledge proofs or  NIZKs. I talk more about  the link between signatures and zero-knowledge proofs here.ZKPs and NIZKs can also be constructed on much more general statements like “I know an input to some function such that the execution gives some output”, or more specifically “I know $a$ in $f(a, b) = c$”. If this still doesn’t make sense think about the usual example given to illustrate general-purpose ZKPs: “I know the solution of the sudoku”. We’re almost there:  ZK-SNARKs are general-purpose non-interactive zero-knowledge proofs, and more! They are also  succinct, meaning that the proofs they produce are small in size and are fast to verify, which makes them so special they deserve to be called ZK-SNARKs. Not every modern proof systems deserve that special classification, for example STARKs don’t :(</p><p>首先，零知识证明是一种密码证明，证明你知道一些东西，而不会暴露某些东西(零知识)。这个“东西”通常被称为证人，但这个细节并不重要。关于零知识证明的资源很多，所以我不会太多地解释它们是如何工作的，或者它们的确切密码属性是什么(完备性、可靠性、零知识)。零知识证明经常被用来证明您知道某个群的元素的某一底的离散对数(例如，$g^x mod p$中的$x$是什么)，或者类似限制的语句。“有限的是的，但仍然有用！”Yells Schnorr，Schnorr签名方案的发明者，该方案是通过对离散对数的知识进行零知识证明并使其非交互来构建的。零知识证明或ZKP是证明者(认识证人)和验证者(必须被说服)之间的交互协议。交互式协议在现实世界中很糟糕，因为它经常限制原语的潜在用例的数量，并根据证明者和验证者之间需要发生的往返次数而降低协议的速度。幸运的是，一些ZKP可以在不与验证器交互的情况下构建。换句话说，证明者可以简单地创建证明，任何人都可以在以后的任何时间点验证该证明，而不需要证明者的进一步帮助。当ZKP变得非交互式时，我们简单地称它们为非交互式零知识证明(NIZK)。这里我更多地讨论签名和零知识证明之间的联系，ZKP和NIZK也可以构建在更一般的语句上，比如“我知道某个函数的输入，这样执行就会产生一些输出”，或者更具体地说，“我知道$a$in$f(a，b)=c$”。如果这仍然没有意义，请考虑一下用来说明通用ZKP的常见示例：“我知道数独的解决方案”。我们就快到了：ZK-snarks是通用的、非交互式的零知识证明，还有更多！它们也很简洁，这意味着它们制作的校样体积小，验证速度快，这使得它们如此特殊，以至于当之无愧地被称为ZK-snarks。并不是每一个现代的证明系统都配得上这个特殊的分类，例如斯塔克就不配：</p><p>  general purpose: a proof of a more general statement, like the knowledge of secret inputs or outputs of a program</p><p>一般用途：对更一般的陈述的证明，如程序的秘密输入或输出的知识。</p><p> But not only did you ask, what are ZK-SNARKs, but you also asked about how they work.</p><p>但你不仅问了ZK-Snarks是什么，还问了他们是如何工作的。</p><p>  And oh boy, this is a complex subject to answer. First and foremost, there are many many schemes, too many of them, and so I’m not sure exactly how to answer that question. But I have some idea of how some of them work, and so I imagine that most of them follow that pattern, or improve on it, so let me explain…</p><p>哦，天哪，这是一个复杂的问题需要回答。首先也是最重要的是，有很多计划，太多了，所以我不确定如何准确地回答这个问题。但是我对它们中的一些是如何工作的有一些了解，所以我想它们中的大多数都遵循这种模式，或者对其进行改进，所以让我来解释一下…。</p><p>  The encoding or compilation of a program to something the proving system can prove, which I&#39;ll explain in part 2 of this post (to be written).</p><p>将程序编码或编译成证明系统可以证明的东西，我将在这篇文章(待写)的第2部分中解释。</p><p> The first part is not too hard to understand, while the second sort of requires a graduate course into the subject…</p><p>第一部分并不太难理解，而第二部分则需要研究生课程才能进入主题…</p><p>  Here it is, remember that one: ZK-SNARKs are all about proving that you know some polynomial $f(x)$ that has some roots.By roots I mean that the verifier has some values in mind (e.g. $1$ and $2$) and the prover must prove that the secret polynomial they have in mind evaluates to $0$ for this values (e.g. $f(1) = f(2) = 0$).By the way, a polynomial that has 1 and 2 as roots (in our example) can be written as $f(x)=(x-1)(x-2)h(x)$ for some polynomial $h(x)$. (If you’re not convinced try to evaluate that at $x=1$ and $x=2$.So we say that the prover must prove that they know an $f(x)$ and $h(x)$ such that $f(x) = t(x)h(x)$ for some target polynomial $t(x) = (x-1)(x-2)$ (in the example that $1$ and $2$ are the roots that the verifier wants to check).</p><p>这里，记住这一点：ZK-snarks完全是关于证明你知道某些有根的多项式$f(X)$。根我的意思是验证者心里有一些值(例如$1$和$2$)，证明者必须证明他们头脑中的秘密多项式对于这个值的计算结果是$0$(例如$f(1)=f(2)=0$)。顺便说一句，我的意思是验证者心里有一些值(例如$1$和$2$)，并且证明者必须证明他们头脑中的秘密多项式对于这个值的计算结果是$0$(例如$f(1)=f(2)=0$)。以1和2为根的多项式(在我们的示例中)可以写为$f(X)=(x-1)(x-2)h(X)$，对于某个多项式$h(X)$。(如果您不信服，请尝试在$x=1$和$x=2$时求值。因此，我们说证明者必须证明他们知道$f(X)$和$h(X)$，使得$f(X)=t(X)h(X)$对于某个目标多项式$t(X)=(x-1)(x-2)$(在该示例中，$1$和$2$是验证者想要检查的根)。</p><p> But that’s it, that’s what ZK-SNARKs proving systems usually provide: something to prove that you know some polynomial. I’m repeating this because the first time I learned about that it made no sense to me: how can you prove that you know some secret input to a program, if all you can prove is that you know a polynomial. Well, that’s why part 2 of this explanation is so difficult: it’s about translating a program into a polynomial. But more on that later.</p><p>但仅此而已，这就是ZK-Snarks证明系统通常提供的：证明你知道某个多项式的东西。我之所以重复这一点，是因为我第一次了解到这一点对我来说毫无意义：如果你能证明的只是你知道一个多项式，你怎么能证明你知道某个程序的一些秘密输入呢？这就是为什么这个解释的第二部分如此困难：它是关于将程序转换成多项式的。但稍后会有更多关于这一点的报道。</p><p> Back to our proving system, how does one prove that they know such a function $f(x)$? Well they just have to prove that they know a $h(x)$ such that youc an write $f(x)$ as $f(x) = t(x)h(x)$. Ugh… Not so fast here. We’re talking about  zero-knowledge proofs right? How can we prove this without giving out $f(x)$? Well, by using three tricks!</p><p>回到我们的证明系统，如何证明他们知道这样一个函数$f(X)$？他们只需要证明他们知道一个$h(X)$，这样你就可以把$f(X)$写成$f(X)=t(X)h(X)$。UGH…。这里不要那么快。我们谈论的是零知识证明，对吗？在不给出$f(X)$的情况下，我们如何证明这一点呢？那就用三招吧！</p><p>   The first trick is to use  commitments to hide the values that we’re sending to the prover. But not only do we hide them, we also want to allow the  verifier to perform some operations on them so that they can verify the proof. Specifically verify that if the prover commits on their polynomial $f(x)$ as well as $h(x)$, then we have$$com(f(x)) = com(t(x)) com(h(x)) = com(t(x)h(x))$$</p><p>第一个技巧是使用承诺来隐藏我们发送给证明者的值。但我们不仅要隐藏它们，我们还希望允许验证者对它们执行一些操作，以便他们可以验证证据。具体地说，验证如果证明者提交他们的多项式$f(X)$和$h(X)$，则我们有$$com(f(X))=com(t(X))com(h(X))=com(t(X)h(X))$$。</p><p> where $com(t(x))$ is computed by the verifier as these are the known constraints on the polynomial.These operations are called  homomorphic operations and we can’t perform them if we use hash functions as commitment mechanisms. Instead, we can simply “hide the values in the exponent” (e.g. for a value $v$ then send the commitment $g^v \mod{p}$) as these are commitments that allow for these homomorphic operations. (To convince yourself, observe that if $a = bc$ then $g^a = g^b g^c = g^{b+c}$.</p><p>其中$com(t(X))$由验证器计算，因为这些是对多项式的已知约束。这些操作称为同态操作，如果我们使用哈希函数作为提交机制，则不能执行这些操作。相反，我们可以简单地“隐藏指数中的值”(例如，对于值$v$，然后发送承诺$g^v\mod{p}$)，因为这些承诺允许这些同态操作。(为了说服自己，观察如果$a=bc$，则$g^a=g^b g^c=g^{b+c}$。</p><p>   $g^a = (g^b)^c = g^{bc}$ gets us there, but only if $c$ is a known value and not a commitment (e.g. $g^c$). Unfortunately this is a limitation for our proving protocol, as there will be multiplication operations between commitments. This is where  bilinear pairings can be used to unblock us, and this is the  sole reason why we use bilinear pairings in a ZK-SNARK (really just to be able to multiply the values inside the commitments).I don’t want to go too deep into what bilinear pairings are, but just know that it is just another tool in our toolkit that:</p><p>$g^a=(g^b)^c=g^{bc}$可以实现目标，但前提是$c$是已知值，而不是承诺(例如，$g^c$)。不幸的是，这是我们的证明协议的一个限制，因为在承诺之间将有乘法运算。这就是我们可以使用双线性对来解除阻碍的地方，这也是我们在ZK-snark中使用双线性对的唯一原因(实际上只是为了能够将承诺中的值相乘)。我不想太深入地讨论什么是双线性对，但只知道它只是我们工具包中的另一个工具：</p><p> Takes two values of our group (the values generates by $g$ raised to different powers modulo $p$) and place them in another group.</p><p>取我们组的两个值(由$g$生成的值以$p$为模，取不同的幂)，并将它们放入另一个组。</p><p> By moving stuff from one group to the other,  we can multiply things that couldn&#39;t be multiplied previously.</p><p>通过把东西从一组搬到另一组，我们可以把以前不能乘的东西成倍增加。</p><p> So using $e$ as the typical way of writing a bilinear pairing, we have $e(g_1, g_2) = h_3$ and we can use it to perform multiplications hidden in the exponent via this one equation:</p><p>因此，使用$e$作为编写双线性对的典型方法，我们有$e(g_1，g_2)=h_3$，我们可以使用它通过以下公式执行隐藏在指数中的乘法：</p><p>  But no more about bilinear pairings! Again that’s the only reason why we use these in ZK-SNARKs. It’s just a trick to make our homomorphic commitments more homomorphic, to allow us to do:</p><p>但是不要再谈双线性配对了！这也是我们在ZK-snarks中使用这些的唯一原因。这只是一个让我们的同态承诺更同态的把戏，让我们可以做到：</p><p>   Finally, the  succinctness of ZK-SNARKs come from the fact that two functions that differ will evaluate to different points most of the time.What this means for us is that if my $f(x)$ is not really $t(x)h(x)$), meaning that I don’t have a polynomial $f(x)$ that really has the roots we’ve chosen with the verifier, then evaluating $f(x)$ and $t(x)h(x)$ at a random point $r$ will not give out the same result (most of the time). In other words for almost all $r$, $f(r) \neq t(r)h(r)$.</p><p>最后，ZK-snarks的简洁性来自于这样一个事实，即两个不同的函数在大多数情况下会计算到不同的点。这对我们意味着，如果我的$f(X)$不是真正的$t(X)h(X)$)，这意味着我没有真正具有我们用验证器选择的根的多项式$f(X)$，那么在任意点$r$计算$f(X)$和$t(X)h(X)$不会给出相同的结果(大多数情况下)。换句话说，对于几乎所有的$r$，$f(R)\neq t(R)h(R)$。</p><p>   Knowing this, it is enough to prove that $com(f(r)) = com(t(r)h(r))$ for some random point $r$. This is why ZK-SNARKs are so small; by comparing points in a group you end up comparing entire polynomials!</p><p>了解了这一点，证明某个随机点$r$的$com(f(R))=com(t(R)h(R))$就足够了。这就是ZK-snark如此小的原因；通过比较一组中的点，您最终可以比较整个多项式！</p><p> But this is also why there is a “trusted setup” needed before most ZK-SNARKs can work. If a prover learns the random point $r$, then they can forge bad polynomials that will verify. So a trusted setup is about:</p><p>但这也是为什么在大多数ZK-Snark可以工作之前，需要一个“可信的设置”。如果证明者学习了随机点$r$，那么他们就可以伪造将被验证的坏多项式。因此，受信任的设置与以下内容有关：</p><p> committing different exponentiation of it $g^r, g^{r^2}, g^{r^3}, \ldots$ so that they can be used by the prover to compute their polynomial without knowing the point $r$</p><p>对其进行不同的求幂$g^r、g^{r^2}、g^{r^3}、\ldots$，以便证明者可以在不知道点$r$的情况下使用它们来计算其多项式。</p><p> Does the second point makes sense? If my polynomial as the prover is $f(x) = x^2 + x$ then all I have to do is compute $g^{r^2} g^r$ to obtain a commitment of my polynomial evaluated at that random point $r$.</p><p>第二点说得通吗？如果我的多项式作为证明者是$f(X)=x^2+x$，那么我所要做的就是计算$g^{r^2}g^r$，以获得我的多项式在该随机点$r$处求值的承诺。</p><p> Next, I&#39;ll write the second part of this blogpost and you&#39;ll have to wait until I&#39;m done.</p><p>接下来，我要写这篇博文的第二部分，你得等我写完了。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.cryptologie.net/article/507/the-missing-explanation-of-zk-snarks/">https://www.cryptologie.net/article/507/the-missing-explanation-of-zk-snarks/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/snarks/">#snarks</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/证明/">#证明</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>