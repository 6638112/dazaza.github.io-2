<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用ANSI转义码构建自己的命令行（2016） Build your own Command Line with ANSI escape codes (2016)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Build your own Command Line with ANSI escape codes (2016)<br/>使用ANSI转义码构建自己的命令行（2016） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-06 20:03:57</div><div class="page_narrow text-break page_content"><p>Everyone is used to programs printing out output in a terminal that scrolls as new text appears, but that&#39;s not all your can do: your program can color your text, move the cursor up, down, left or right, or clear portions of the screen if you are going to re-print them later. This is what lets programs like  Git implement its dynamic progress indicators, and  Vim or  Bash implement their editors that let you modify already-displayed text without scrolling the terminal.</p><p>每个人都习惯于在终端上打印输出，该终端会随着新文本的出现而滚动，但这并不是您所能做的：您的程序可以为文本加上颜色，上下，左右或上下移动光标屏幕上的部分，如果您以后要重新打印它们。这就是让Git等程序实现其动态进度指示器，而Vim或Bash实现其编辑器的功能，这些编辑器使您可以修改已经显示的文本而无需滚动终端。</p><p> There are libraries like  Readline,  JLine, or the  Python Prompt Toolkit that help you do this in various programming languages, but you can also do it yourself. This post will explore the basics of how you can control the terminal from any command-line program, with examples in Python, and how your own code can directly make use of all the special features the terminal has to offer.</p><p> 有诸如Readline，JLine或Python Prompt Toolkit之类的库可以帮助您使用各种编程语言来完成此操作，但是您也可以自己执行。这篇文章将探讨如何从任何命令行程序控制终端的基础知识，并提供Python示例，以及您自己的代码如何直接利用终端必须提供的所有特殊功能。</p><p>    About the Author:  Haoyi is a software engineer, and the author of many open-source Scala tools such as the Ammonite REPL and the Mill Build Tool. If you enjoyed the contents on this blog, you may also enjoy Haoyi&#39;s book    Hands-on Scala Programming</p><p>    关于作者：Haoyi是一名软件工程师，并且是许多开源Scala工具（例如Ammonite REPL和Mill Build Tool）的作者。如果您喜欢此博客上的内容，那么您可能还会喜欢Haoyi的《动手Scala编程》一书</p><p>   The way that most programs interact with the Unix terminal is through  ANSI escape codes. These are special codes that your program can print in order to give the terminal instructions. Various terminals support different subsets of these codes, and it&#39;s difficult to find a &#34;authoritative&#34; list of what every code does. Wikipedia has a  reasonable listing of them, as do many other sites.</p><p>   大多数程序与Unix终端进行交互的方式是通过ANSI转义码。这些是您的程序可以打印的特殊代码，以提供终端说明。各种终端支持这些代码的不同子集，因此很难找到权威的代码。每个代码的功能列表。维基百科和其他许多网站一样，都列出了它们的合理列表。</p><p> Nevertheless, it&#39;s possible to write programs that make use of ANSI escape codes, and at least will work on common Unix systems like Ubuntu or OS-X (though not Windows, which I won&#39;t cover here and is its own adventure!). This post will explore the basics of what Ansi escape codes exist, and demonstrate how to use them to write your own interactive command-line from first principles:</p><p> 尽管如此，仍然可以编写使用ANSI转义码的程序，并且至少可以在常见的Unix系统（例如Ubuntu或OS-X）上运行（尽管Windows无法运行，在此我将不做介绍，自己的冒险！）。这篇文章将探讨Ansi逃逸代码的基础知识，并演示如何从第一原理中使用它们来编写自己的交互式命令行：</p><p>      The most basic Ansi escape codes are those involved in rendering text. These let you add decorations like  Colors,  Background Colors or other  Decorations to your printed text, but don&#39;t do anything fancy. The text you print will still end up at the bottom of the terminal, and still make your terminal scroll, just now it will be colored text instead of the default black/white color scheme your terminal has.</p><p>      最基本的Ansi逸出代码是呈现文本所涉及的代码。这些使您可以在打印的文本中添加颜色，背景色或其他装饰等装饰，但不要做任何花哨的事情。您打印的文本仍将最终显示在终端的底部，并仍使您的终端滚动，只是现在它将是彩色文本，而不是终端具有的默认黑白配色方案。</p><p>  The most basic thing you can do to your text is to color it. The Ansi colors all look like</p><p>  您可以对文本执行的最基本操作是为文本着色。 Ansi的颜色看起来都像 </p><p>  This  \u001b character is the special character that starts off most Ansi escapes; most languages allow this syntax for representing special characters, e.g. Java, Python and Javascript all allow the  \u001b syntax.</p><p>\ u001b字符是从大多数Ansi逃逸开始的特殊字符；大多数语言都允许使用此语法表示特殊字符，例如Java，Python和Javascript都允许使用\ u001b语法。</p><p>    Note how we need to prefix the string with  u i.e.  u&#34;...&#34; in order for this to work in Python 2.7.10. This is not necessary in Python 3 or in other languages.</p><p>    请注意，我们如何需要在字符串前面加上u，即u＆＃34; ...＆＃34;为了使其在Python 2.7.10中有效。在Python 3或其他语言中，这不是必需的。</p><p> See how the red color, starting from the printed  Hello World, ends up spilling into the  &gt;&gt;&gt; prompt. In fact, any code we type into this prompt will also be colored red, as will any subsequent output! That is how Ansi colors work: once you print out the special code enabling a color, the color persists forever until someone else prints out the code for a different color, or prints out the  Reset code to disable it.</p><p> 看看从打印的“ Hello World”开始，红色最终如何溢出到＆gt;＆gt;＆gt;中。提示。实际上，我们在此提示符下键入的任何代码也将被涂成红色，并且随后的输出也将被涂成红色！这就是Ansi颜色的工作方式：一旦您打印出启用颜色的特殊代码，该颜色就会永久存在，直到其他人打印出另一种颜色的代码或打印出“重置代码”以将其禁用为止。</p><p>    And we can see the prompt turns back white. In general, you should always remember to end any colored string you&#39;re printing with a  Reset, to make sure you don&#39;t accidentally</p><p>    我们可以看到提示变成白色。通常，您应该始终记得以“重置”结束要打印的所有彩色字符串，以确保您不会意外</p><p> To avoid this, we need to make sure we end our colored-string with the  Reset code:</p><p> 为了避免这种情况，我们需要确保我们用Reset代码结束彩色字符串：</p><p>   Which propertly resets the color after the string has been printed. You can also  Reset halfway through the string to make the second-half un-colored:</p><p>   在打印完字符串后，它将适当地重设颜色。您还可以在字符串的一半处进行重置，以使下半部分不着色：</p><p>    We have seen how  Red and  Reset work. The most basic terminals have a set of 8 different colors:</p><p>    我们已经看到了红色和重置的工作方式。最基本的终端有一组8种不同的颜色： </p><p>  Which we can demonstrate by printing one letter of each color, followed by a  Reset:</p><p>我们可以通过打印每种颜色的一个字母，然后重新设置来演示：</p><p> print u&#34;\u001b[30m A \u001b[31m B \u001b[32m C \u001b[33m D \u001b[0m&#34;print u&#34;\u001b[34m E \u001b[35m F \u001b[36m G \u001b[37m H \u001b[0m&#34;</p><p> 打印u＆＃34; \ u001b [30m A \ u001b [31m B \ u001b [32m C \ u001b [33m D \ u001b [0m＆＃34; print u＆＃34; \ u001b [34m E \ u001b [35m F \ u001b [ 36m G \ u001b [37m H \ u001b [0m＆＃34;</p><p>  Note how the black  A is totally invisible on the black terminal, while the white  H looks the same as normal text. If we chose a different color-scheme for our terminal, it would be the opposite:</p><p>  请注意，黑色A在黑色终端上是完全不可见的，而白色H看起来与普通文本相同。如果我们为终端选择了不同的颜色方案，那就相反了：</p><p> print u&#34;\u001b[30;1m A \u001b[31;1m B \u001b[32;1m C \u001b[33;1m D \u001b[0m&#34;print u&#34;\u001b[34;1m E \u001b[35;1m F \u001b[36;1m G \u001b[37;1m H \u001b[0m&#34;</p><p> 打印u＆＃34; \ u001b [30; 1m A \ u001b [31; 1m B \ u001b [32; 1m C \ u001b [33; 1m D \ u001b [0m＆＃34; print u＆＃34; \ u001b [34; 1m E \ u001b [35; 1m F \ u001b [36; 1m G \ u001b [37; 1m H \ u001b [0m＆＃34;</p><p>  With the black  A being obvious and the white  H being hard to make out.</p><p>  黑色A很明显，白色H很难辨认。</p><p>  Most terminals, apart from the basic set of 8 colors, also support the &#34;bright&#34; or &#34;bold&#34; colors. These have their own set of codes, mirroring the normal colors, but with an additional  ;1 in their codes:</p><p>  除了8种颜色的基本设置外，大多数终端还支持＆＃34; bright＆＃34;或＆＃34;粗体＆＃34;颜色。这些都有自己的一组代码，它们反映了正常的颜色，但是在代码中附加了; 1：</p><p>  Note that  Reset is the same: this is the reset code that resets  all colors and text effects.</p><p>  请注意，“重置”是相同的：这是重置代码，用于重置所有颜色和文本效果。 </p><p>   And see that they are, indeed, much brighter than the basic set of 8 colors. Even the black  A is now bright enough to be a visible gray on the black background, and the white  H is now even brighter than the default text color.</p><p>并看到它们确实比基本的8种颜色要亮得多。现在，即使黑色A足够亮，在黑色背景上也可以看到灰色，而白色H现在甚至比默认文本颜色还要亮。</p><p>     import sysfor i in range(0, 16): for j in range(0, 16): code = str(i * 16 + j) sys.stdout.write(u&#34;\u001b[38;5;&#34; + code + &#34;m &#34; + code.ljust(4)) print u&#34;\u001b[0m&#34;</p><p>     导入sysfor i在范围（0，16）中：对于j在范围（0，16）中：code = str（i * 16 + j）sys.stdout.write（u＆＃34; \ u001b [38; 5;＆＃ 34; +代码+＆＃34; m＆＃34; + code.ljust（4））打印u＆＃34; \ u001b [0m＆＃34;</p><p>  Here we use  sys.stdout.write instead of  print so we can print multiple items on the same line, but otherwise it&#39;s pretty self-explanatory. Each code from 0 to 255 corresponds to a particular color.</p><p>  在这里，我们使用sys.stdout.write而不是print，因此我们可以在同一行上打印多个项目，但是否则，这很容易解释。从0到255的每个代码对应一种特定的颜色。</p><p>  The Ansi escape codes let you set the color of the text-background the same way it lets you set the color of the foregrond. For example, the 8 background colors correspond to the codes:</p><p>  Ansi转义码使您可以设置文本背景的颜色，就像您设置前背的颜色一样。例如，这8种背景色与代码相对应：</p><p>       print u&#34;\u001b[40m A \u001b[41m B \u001b[42m C \u001b[43m D \u001b[0m&#34;print u&#34;\u001b[44m A \u001b[45m B \u001b[46m C \u001b[47m D \u001b[0m&#34;print u&#34;\u001b[40;1m A \u001b[41;1m B \u001b[42;1m C \u001b[43;1m D \u001b[0m&#34;print u&#34;\u001b[44;1m A \u001b[45;1m B \u001b[46;1m C \u001b[47;1m D \u001b[0m&#34;</p><p>       打印u＆＃34; \ u001b [40m A \ u001b [41m B \ u001b [42m C \ u001b [43m D \ u001b [0m＆＃34; print u＆＃34; \ u001b [44m A \ u001b [45m B \ u001b [ 46m C \ u001b [47m D \ u001b [0m＆＃34; print u＆＃34; \ u001b [40; 1m A \ u001b [41; 1m B \ u001b [42; 1m C \ u001b [43; 1m D \ u001b [ 0m＆＃34;打印u＆＃34; \ u001b [44; 1m A \ u001b [45; 1m B \ u001b [46; 1m C \ u001b [47; 1m D \ u001b [0m＆＃34;</p><p>  Note that the bright versions of the background colors do not change the background, but rather make the  foreground text brighter. This is unintuitive but that&#39;s just the way it works.</p><p>  请注意，背景颜色的亮色不会改变背景，而是使前景文本更亮。这是不直观的，但这只是它的工作方式。</p><p>  import sysfor i in range(0, 16): for j in range(0, 16): code = str(i * 16 + j) sys.stdout.write(u&#34;\u001b[48;5;&#34; + code + &#34;m &#34; + code.ljust(4)) print u&#34;\u001b[0m&#34;</p><p>  导入sysfor i在范围（0，16）中：对于j在范围（0，16）中：代码= str（i * 16 + j）sys.stdout.write（u＆＃34; \ u001b [48; 5;＆＃ 34; +代码+＆＃34; m＆＃34; + code.ljust（4））打印u＆＃34; \ u001b [0m＆＃34; </p><p>               The next set of Ansi escape codes are more complex: they allow you to move the cursor around the terminal window, or erase parts of it. These are the Ansi escape codes that programs like Bash use to let you move your cursor left and right across your input command in response to arrow-keys.</p><p>下一组Ansi转义码更为复杂：它们使您可以在终端窗口中移动光标或擦除其中的一部分。这些是Ansi转义码，Bash等程序使用它来使您响应输入键在输入命令中左右移动光标。</p><p>   To make use of these, first let&#39;s establish a baseline of what the &#34;normal&#34; Python prompt does.</p><p>   为了利用这些，首先让我们建立一个“正常”基线。 Python提示可以。</p><p> Here, we add a  time.sleep(10) just so we can see it in action. We can see that if we print something, first it prints the output and moves our cursor onto the next line:</p><p> 在这里，我们添加了一个time.sleep（10），以便可以看到它的实际作用。我们可以看到，如果我们打印出一些东西，那么首先打印出输出，然后将光标移至下一行：</p><p>   Then it prints the next prompt and moves our cursor to the right of it.</p><p>   然后它会打印下一个提示，并将光标移到它的右侧。</p><p>  So that&#39;s the baseline of where the cursor already goes. What can we do with this?</p><p>  因此，这就是游标已经到达的基线。我们该怎么办？</p><p>  The easiest thing we can do with our cursor-navigation Ansi escape codes is to make a loading prompt:</p><p>  使用光标导航Ansi转义码最简单的方法是发出加载提示：</p><p> import time, sysdef loading(): print &#34;Loading...&#34; for i in range(0, 100): time.sleep(0.1) sys.stdout.write(u&#34;\u001b[1000D&#34; + str(i + 1) + &#34;%&#34;) sys.stdout.flush() print loading()</p><p> 导入时间，sysdef loading（）：打印＆＃34; Loading ...＆＃34;对于范围（0，100）中的i：time.sleep（0.1）sys.stdout.write（u＆＃34; \ u001b [1000D＆＃34; + str（i +1）+＆＃34;％＆＃34; ）sys.stdout.flush（）打印loading（） </p><p> This prints the text from  1% to  100%, all on the same line since it uses  stdout.write rather than  print. However, before printing each percentage it first prints  \u001b[1000D, which means &#34;move cursor left by 1000 characters). This should move it all the way to the left of the screen, thus letting the new percentage that gets printed over-write the old one. Hence we see the loading percentage seamlessly changing from  1% to  100% before the function returns:</p><p>由于它使用stdout.write而不是print，因此可以在同一行上打印从1％到100％的文本。但是，在打印每个百分比之前，它首先打印\ u001b [1000D，这意味着将光标向左移动1000个字符）。这应该将其一直移到屏幕的左侧，这样就可以使新打印的百分比覆盖旧的百分比。因此，在函数返回之前，我们看到加载百分比从1％无缝变为100％：</p><p>  It might be a bit hard to visualize in your head where the cursor is moving, but we can easily slow it down and add more  sleeps to make the code show us:</p><p>  可能很难想象光标在哪里移动，但是我们可以轻松放慢速度并添加更多睡眠以使代码显示给我们：</p><p> import time, sysdef loading(): print &#34;Loading...&#34; for i in range(0, 100): time.sleep(1) sys.stdout.write(u&#34;\u001b[1000D&#34;) sys.stdout.flush() time.sleep(1) sys.stdout.write(str(i + 1) + &#34;%&#34;) sys.stdout.flush() print loading()</p><p> 导入时间，sysdef loading（）：打印＆＃34; Loading ...＆＃34;对于范围（0，100）中的i：time.sleep（1）sys.stdout.write（u＆＃34; \ u001b [1000D＆＃34;）sys.stdout.flush（）time.sleep（1）sys.stdout .write（str（i +1）+＆＃34;％＆＃34;）sys.stdout.flush（）打印loading（）</p><p> Here, we split up the  write that writes the &#34;move left&#34; escape code, from the write that writes the percentage progress indicator. We also added a 1 second sleep between them, to give us a chance to see the cursors &#34;in between&#34; states rather than just the end result:</p><p> 在这里，我们拆分了写入＆＃34;向左移动＆＃34;的写入转义代码，来自写入百分比进度指示器的写入。我们还在它们之间增加了1秒钟的睡眠时间，使我们有机会看到它们之间的光标。状态，而不仅仅是最终结果：</p><p>  Now, we can see the cursor moving left to the edge of the screen, before the new printed percentage over-writes the old one.</p><p>  现在，我们可以看到光标在新打印的百分比覆盖旧的百分比之前向左移动到屏幕边缘。</p><p>  Now that we know how to make a self-updating progress bar using Ansi escape codes to control the terminal, it becomes relatively easy to modify it to be fancier, e.g. having a ASCII bar that goes across the screen:</p><p>  既然我们知道了如何使用Ansi转义码制作一个自我更新的进度条来控制终端，那么将其修改为更高级的操作变得相对容易，例如屏幕上有一个ASCII栏：</p><p> import time, sysdef loading(): print &#34;Loading...&#34; for i in range(0, 100): time.sleep(0.1) width = (i + 1) / 4 bar = &#34;[&#34; + &#34;#&#34; * width + &#34; &#34; * (25 - width) + &#34;]&#34; sys.stdout.write(u&#34;\u001b[1000D&#34; + bar) sys.stdout.flush() print loading()</p><p> 导入时间，sysdef loading（）：打印＆＃34; Loading ...＆＃34;对于范围（0，100）中的i：time.sleep（0.1）width =（i + 1）/ 4 bar =＆＃34; [＆＃34; +＆＃34;＃＆＃34; *宽度+＆＃34; ＆＃34; *（25-width）+＆＃34;]＆＃34; sys.stdout.write（u＆＃34; \ u001b [1000D＆＃34; + bar）sys.stdout.flush（）打印loading（） </p><p>  This works as you would expect: every iteration of the loop, the entire row is erased and a new version of the ASCII bar is drawn.</p><p>这可以按您预期的那样工作：循环的每次迭代，将擦除整个行，并绘制新版本的ASCII条。</p><p> We could even use the  Up and  Down cursor movements to let us draw multiple progress bars at once:</p><p> 我们甚至可以使用向上和向下光标移动来一次绘制多个进度条：</p><p> import time, sys, randomdef loading(count): all_progress = [0] * count sys.stdout.write(&#34;\n&#34; * count) # Make sure we have space to draw the bars while any(x &lt; 100 for x in all_progress): time.sleep(0.01) # Randomly increment one of our progress values unfinished = [(i, v) for (i, v) in enumerate(all_progress) if v &lt; 100] index, _ = random.choice(unfinished) all_progress[index] += 1 # Draw the progress bars sys.stdout.write(u&#34;\u001b[1000D&#34;) # Move left sys.stdout.write(u&#34;\u001b[&#34; + str(count) + &#34;A&#34;) # Move up for progress in all_progress: width = progress / 4 print &#34;[&#34; + &#34;#&#34; * width + &#34; &#34; * (25 - width) + &#34;]&#34; loading()</p><p> 导入时间，sys，randomdef加载（计数）：all_progress = [0] *计数sys.stdout.write（＆＃34; \ n＆＃34; *计数）＃确保我们有空间在任何（x ＆lt;在all_progress中x等于100：time.sleep（0.01）＃随机增加未完成的进度值之一= [[i，v）for enumerate（all_progress）中的（i，v），如果v＆lt; 100]索引，_ = random.choice（未完成）all_progress [index] + = 1＃绘制进度条sys.stdout.write（u＆＃34; \ u001b [1000D＆＃34;）＃向左移动sys.stdout.write （u＆＃34; \ u001b [＆＃34; + str（count）+＆＃34; A＆＃34;）＃在all_progress中向上移动以取得进度：width = progress / 4 print＆＃34; [＆＃34; +＆＃34;＃＆＃34; *宽度+＆＃34; ＆＃34; *（25-width）+＆＃34;]＆＃34; loading（）</p><p>  Make sure we have enough space to draw the progress bars! This is done by writing  &#34;\n&#34; * count when the function starts. This creates a series of newlines that makes the terminal scroll, ensuring that there are exactly  count blank lines at the bottom of the terminal for the progress bars to be rendered on</p><p>  确保我们有足够的空间绘制进度条！这是通过编写＆＃34; \ n＆＃34;来完成的*计数功能启动的时间。这将创建一系列使终端滚动的换行符，从而确保在终端底部精确计数空白行，以便在其上显示进度条</p><p>  Simulated multiple things in progress with the  all_progress array, and having the various slots in that array fill up randomly</p><p>  用all_progress数组模拟正在进行的多件事，并使该数组中的各个插槽随机填充</p><p>  Used the  Up ansi code to move the cursor  count lines up each time, so we can then print the  count progress bars one per linee</p><p>  使用Up ansi代码每次将光标计数行向上移动，因此我们可以每行打印一次计数进度条</p><p>   Perhaps next time you are writing a command line application that&#39;s downloading lots of files in parallel, or doing some similar kind of parallel task, you could write a similar Ansi-escape-code-based progress bar so the user can see how their command is progressing.</p><p>   也许下次您编写并行下载大量文件的命令行应用程序，或执行类似的并行任务时，您可以编写类似的基于Ansi-escape-code的进度条，以便用户可以看到他们的命令进展如何。 </p><p> Of course, all these progress prompts so far are fake: they&#39;re not really monitoring the progress of any task. Nevertheless, they demonstrate how you can use Ansi escape codes to put a dynamic progress indicator in any command-line program you write, so when you  do have something whose progress you can monitor, you now have the ability to put fancy live-updating progress bars on it.</p><p>当然，到目前为止，所有这些进度提示都是虚假的：它们并没有真正监视任何任务的进度。但是，它们演示了如何使用Ansi转义代码将动态进度指示器放置在您编写的任何命令行程序中，因此，当您有可以监视其进度的内容时，现在就可以放置动态更新进度了吧。</p><p>  One of the more fancy things you might do with Ansi escape codes is to implement a command-line. Bash, Python, Ruby, all have their own in-built command line that lets you type out a command and edit its text before submitting it for execution. While it may seem special, in reality this command line is just another program that interacts with the terminal via Ansi escape codes! Since we know how to use Ansi escape codes, we can do it too and write our own command line.</p><p>  您可以使用Ansi转义码执行的更有趣的操作之一是实现命令行。 Bash，Python，Ruby都有自己的内置命令行，可让您键入命令并编辑其文本，然后再提交执行。尽管它看起来很特殊，但实际上该命令行只是通过Ansi转义码与终端交互的另一个程序！由于我们知道如何使用Ansi转义码，因此我们也可以这样做并编写我们自己的命令行。</p><p>  The first thing we have to do with a command-line, which we haven&#39;t done so far, is to take user input. This can be done with the following code:</p><p>  到目前为止，我们尚未完成的与命令行相关的第一件事就是接受用户输入。可以使用以下代码完成此操作：</p><p> import sys, ttydef command_line(): tty.setraw(sys.stdin) while True: char = sys.stdin.read(1) if ord(char) == 3: # CTRL-C break; print ord(char) sys.stdout.write(u&#34;\u001b[1000D&#34;) # Move all the way left</p><p> import sys，ttydef command_line（）：tty.setraw（sys.stdin）而True：char = sys.stdin.read（1）如果ord（char）== 3：＃CTRL-C break;打印ord（char）sys.stdout.write（u＆＃34; \ u001b [1000D＆＃34;）＃一直向左移动</p><p> In effect, we use  setraw to make sure our raw character input goes straight into our process (without echoing or buffering or anything), and then reading and echoing the character-codes we see until  3 appears (which is  CTRL-C, the common command for existing a REPL). Since we&#39;ve turned on  tty.setraw  print doesn&#39;t reset the cursor to the left anymore, so we need to manually move left with  \u001b[1000D after each  print.</p><p> 实际上，我们使用setraw来确保原始字符输入直接进入我们的过程（没有回显或缓冲或任何东西），然后读取并回显我们看到的字符代码，直到出现3（这是CTRL-C，常见的现有REPL的命令）。由于我们已打开tty.setraw打印，因此不再将光标重置到左侧，因此我们需要在每次打印后以\ u001b [1000D手动向左移动。</p><p> If you run this in the Python prompt ( CTRL-C to exit) and try hitting some characters, you will see that:</p><p> 如果您在Python提示符下运行此命令（CTRL-C退出）并尝试输入一些字符，您将看到：</p><p> (Left, Right, Up, Down) are ( 27 91 68,  27 91 67,  27 91 65,  27 91 66). This might vary based on your terminal and operating system.</p><p> （左，右，上，下）是（27 91 68，27 91 67，27 91 65，27 91 66）。这可能取决于您的终端和操作系统。 </p><p> Thus, we can try making our first primitive command line that simply echoes whatever the user typed:</p><p>因此，我们可以尝试制作我们的第一个原始命令行，该命令行简单地回显用户键入的内容：</p><p> When the user presses Enter, print out the user input at that point, a new line, and start a new empty input.</p><p> 当用户按下Enter键时，在该点打印用户输入，换行，然后开始新的空输入。</p><p>    When the user presses an arrow key, move the cursor  Left or  Right using the Ansi escape codes we saw above</p><p>    当用户按下箭头键时，使用我们在上面看到的Ansi转义码向左或向右移动光标</p><p> This is obviously greatly simplified; we haven&#39;t even covered all the different kinds of  ASCII characters that exist, nevermind all the  Unicode stuff! Nevertheless it will be sufficient for a simple proof-of-concept.</p><p> 显然，这大大简化了；我们甚至还没有介绍所有存在的所有不同类型的ASCII字符，请不要忘记所有Unicode东西！但是，对于简单的概念验证就足够了。</p><p>   When the user presses Enter, print out the user input at that point, a new line, and start a new empty input.</p><p>   当用户按下Enter键时，在该点打印用户输入，换行，然后开始新的空输入。</p><p>   import sys, tty def command_line(): tty.setraw(sys.stdin) while True: # loop for each line # Define data-model for an input-string with a cursor input = &#34;&#34; while True: # loop for each character char = ord(sys.stdin.read(1)) # read one char and get char code # Manage internal data-model if char == 3: # CTRL-C return elif 32 &lt;= char &lt;= 126: input = input + chr(char) elif char in {10, 13}: sys.stdout.write(u&#34;\u001b[1000D&#34;) print &#34;\nechoing... &#34;, input input = &#34;&#34; # Print current input-string sys.stdout.write(u&#34;\u001b[1000D&#34;) # Move all the way left sys.stdout.write(input) sys.stdout.flush()</p><p>   import sys，tty def command_line（）：tty.setraw（sys.stdin）而True：＃每行循环＃为带有光标输入的输入字符串定义数据模型=＆＃34;＆＃34;而True：＃每个字符循环char = ord（sys.stdin.read（1））＃读取一个char并获取char代码＃如果char == 3，则管理内部数据模型：＃CTRL-C返回elif 32＆lt; = char＆lt; = 126：输入=输入+ chr（char）elif char in {10，13}：sys.stdout.write（u＆＃34; \ u001b [1000D＆＃34;）print＆＃34; \ nechoing。 ..＆＃34 ;，输入input =＆＃34;＆＃34; ＃打印当前输入字符串sys.stdout.write（u＆＃34; \ u001b [1000D＆＃34;）＃一直向左移动sys.stdout.write（input）sys.stdout.flush（）</p><p>    As we&#39;d expect, arrow keys don&#39;t work and result in odd  [D [A [C [B characters being printed, which correspond to the arrow key codes we saw above. We will get that working next. Nevertheless, we can enter text and then submit it with Enter.</p><p>    正如我们期望的那样，箭头键不起作用，并导致打印出奇数[D [A [C [B]字符，这与我们在上面看到的箭头键代码相对应。接下来，我们将开始处理该工作。不过，我们可以输入文本，然后使用Enter提交。 </p><p>   The next step would be to let the user move the cursor around using arrow-keys. This is provided by default for Bash, Python, and other command-lines, but as we are implementing our own command line here we have to do it ourselves. We know that the arrow keys  Left and  Right correspond to the sequences of character-codes  27 91 68,  27 91 67, so we can put in code to check for those and appropiately move the cursor  index variable</p><p>下一步将是让用户使用箭头键来移动光标。默认情况下，Bash，Python和其他命令行提供了此功能，但是当我们在此处实现自己的命令行时，我们必须自己做。我们知道箭头键Left和Right对应于字符代码27 91 68、27 91 67的序列，因此我们可以在代码中进行检查以检查它们并适当地移动光标索引变量</p><p> import sys, tty def command_line(): tty.setraw(sys.stdin) while True: # loop for each line # Define data-model for an input-string with a cursor input = &#34;&#34; index = 0 while True: # loop for each character char = ord(sys.stdin.read(1)) # read one char and get char code # Manage internal data-model if char == 3: # CTRL-C return elif 32 &lt;= char &lt;= 126: input = input[:index] + chr(char) + input[index:] index += 1 elif char in {10, 13}: sys.stdout.write(u&#34;\u001b[1000D&#34;) print &#34;\nechoing... &#34;, input input = &#34;&#34; index = 0 elif char == 27: next1, next2 = ord(sys.stdin.read(1)), ord(sys.stdin.read(1)) if next1 == 91: if next2 == 68: # Left index = max(0, index - 1) elif next2 == 67: # Right index = min(len(input), index + 1) # Print current input-string sys.stdout.write(u&#34;\u001b[1000D&#34;) # Move all the way left sys.stdout.write(input) sys.stdout.write(u&#34;\u001b[1000D&#34;) # Move all the way left again if index &gt; 0: sys.stdout.write(u&#34;\u001b[&#34; + str(index) + &#34;C&#34;) # Move cursor too index sys.stdout.flush()</p><p> import sys，tty def command_line（）：tty.setraw（sys.stdin）而True：＃每行循环＃为带有光标输入的输入字符串定义数据模型=＆＃34;＆＃34; index = 0，但为True时：＃每个字符循环char = ord（sys.stdin.read（1））＃读取一个char并获取char代码＃如果char == 3，则管理内部数据模型：＃CTRL-C返回elif 32＆lt; =字符＆lt; = 126：输入=输入[：索引] + chr（字符）+输入[索引：]索引+ = 1 elif char in {10，13}：sys.stdout.write（u＆＃34 ; \ u001b [1000D＆＃34;）打印＆＃34; \ nechoing ...＆＃34 ;，输入input =＆＃34;＆＃34; index = 0 elif char == 27：next1，next2 = ord（sys.stdin.read（1）），ord（sys.stdin.read（1））if next1 == 91：if next2 == 68：＃左index = max（0，index-1）elif next2 == 67：＃右index = min（len（input），index + 1）＃打印当前输入字符串sys.stdout.write（u＆＃34; \ u001b [ 1000D＆＃34;）＃一直向左移动sys.stdout.write（input）sys.stdout.write（u＆＃34; \ u001b [1000D＆＃34;）＃如果索引＆gt;再次向左移动0：sys.stdout.write（u＆＃34; \ u001b [＆＃34; + str（index）+＆＃34; C＆＃34;）＃也将光标移到索引sys.stdout.flush（）</p><p>  We now maintain an  index variable. Previously, the cursor was always at the right-end of the  input, since you couldn&#39;t use arrow keys to move it left, and new input was always appended at the right-end. Now, we need to keep a separate  index which is not necessarily at the end of the  input, and when a user enters a character we splice it into the  input in the correct location.</p><p>  现在，我们维护一个索引变量。以前，光标始终位于输入的右端，因为您不能使用箭头键将其向左移动，而新输入始终会附加在右端。现在，我们需要保留一个单独的索引，该索引不一定在输入的结尾，并且当用户输入字符时，我们会将其拼接到正确位置的输入中。</p><p>  We check for  char == 27, and then also check for the next two characters to identify the  Left and **Right* arrow keys, and increment/decrement the  index of our cursor (making sure to keep it within the  input string.</p><p>  我们检查char == 27，然后再检查接下来的两个字符以标识向左和**向右箭头键，并递增/递减光标的索引（确保将其保留在输入字符串中）。</p><p>  After writing the  input, we now have to manually move the cursor all the way to the left and move it rightward the correct number of characters corresponding to our cursor  index. Previously the cursor was always at the right-most point of our  input because arrow keys didn&#39;t work, but now the cursor could be anywhere.</p><p>  写入输入后，我们现在必须手动将光标一直移到最左侧，然后将其向右正确移动与光标索引相对应的字符数。以前，光标始终位于我们输入的最右边，因为箭头键不起作用，但是现在光标可以在任何地方。</p><p>   It would take more effort to make  Home and  End (or  Fn-Left and  Fn-Right) work, as well as Bash-like shortcuts like  Esc-f and  Esc-B, but there&#39;s nothing in principle difficult about those: you just need to write down the code-sequences they produce the same way we did  at the start of this section, and make them change our cursor  index appropriately.</p><p>   要使Home和End（或Fn-Left和Fn-Right）以及类似Bash的快捷键（如Esc-f和Esc-B）正常工作，需要付出更多的努力，但是从原则上讲，这些都不困难：您只需要写下它们产生的代码序列与本节开始时相同的方式，并使它们适当地更改我们的光标索引。</p><p>  The last thing on our feature list to implement is deletion: using  Backspace should cause one character before the cursor to disappear, and move the cursor left by 1. This can be done naively by inserting an</p><p>  功能列表上要实现的最后一件事是删除：使用Backspace会导致光标消失之前先产生一个字符，然后将光标向左移动1。 </p><p>    As you can see, the deletion works, in that after I delete the characters, they are no longer echoed back at me when I press  Enter to submit. However, the characters are still sitting their  on screen even as I delete them! At least until they are over-written with  new characters, as can be seen in the third line in the above example.</p><p>如您所见，删除是有效的，因为删除字符后，当我按Enter提交时，它们不再回显我。但是，即使删除它们，角色仍然坐在屏幕上！至少直到它们被新字符覆盖为止，如上例中的第三行所示。</p><p> The problem is that so far, we have never actually cleared the entire line: we&#39;ve always just written the new characters over the old characters, assuming that the string of new characters would be longer and over-write them. This is no longer true once we can delete characters.</p><p> 问题在于，到目前为止，我们还没有真正清除整行内容：我们一直只是将新字符写在旧字符上，假设新字符的字符串会更长并且覆盖它们。一旦我们可以删除字符，这将不再成立。</p><p> A fix is to use the  Clear Line Ansi escape code  \u001b[0K, one of a set of Ansi escape codes which lets you clear various portions of the terminal:</p><p> 解决方法是使用Clear Line Ansi转义码\ u001b [0K，这是一组Ansi转义码中的一个，它使您可以清除终端的各个部分：</p><p>    Clears all characters from the cursor to the end of the line. That lets us make sure that when we delete and re-print a shorter input after that, any &#34;leftover&#34; text that we&#39;re not over-writing still gets properly cleared from the screen.</p><p>    清除从光标到行尾的所有字符。这样一来，我们可以确保在删除并重新打印较短的输入后，所有＆＃34; leftover＆＃34;我们不会覆盖的文本仍会从屏幕上正确清除。</p><p>  import sys, tty def command_line(): tty.setraw(sys.stdin) while True: # loop for each line # Define data-model for an input-string with a cursor input = &#34;&#34; index = 0 while True: # loop for each character char = ord(sys.stdin.read(1)) # read one char and get char code # Manage internal data-model if char == 3: # CTRL-C return elif 32 &lt;= char &lt;= 126: input = input[:index] + chr(char) + input[index:] index += 1 elif char in {10, 13}: sys.stdout.write(u&#34;\u001b[1000D&#34;) print &#34;\nechoing... &#34;, input input = &#34;&#34; index = 0 elif char == 27: next1, next2 = ord(sys.stdin.read(1)), ord(sys.stdin.read(1)) if next1 == 91: if next2 == 68: # Left index = max(0, index - 1) elif next2 == 67: # Right index = min(len(input), index + 1) elif char == 127: input = input[:index-1] + input[index:] index -= 1 # Print current input-string sys.stdout.write(u&#34;\u001b[1000D&#34;) # Move all the way left sys.stdout.write(u&#34;\u001b[0K&#34;) # Clear the line sys.stdout.write(input) sys.stdout.write(u&#34;\u001b[1000D&#34;) # Move all the way left again if index &gt; 0: sys.stdout.write(u&#34;\u001b[&#34; + str(index) + &#34;C&#34;) # Move cursor too index sys.stdout.flush()</p><p>  import sys，tty def command_line（）：tty.setraw（sys.stdin）而True：＃每行循环＃为带有光标输入的输入字符串定义数据模型=＆＃34;＆＃34; index = 0，但为True时：＃每个字符循环char = ord（sys.stdin.read（1））＃读取一个char并获取char代码＃如果char == 3，则管理内部数据模型：＃CTRL-C返回elif 32＆lt; =字符＆lt; = 126：输入=输入[：索引] + chr（字符）+输入[索引：]索引+ = 1 elif char in {10，13}：sys.stdout.write（u＆＃34 ; \ u001b [1000D＆＃34;）打印＆＃34; \ nechoing ...＆＃34 ;，输入input =＆＃34;＆＃34; index = 0 elif char == 27：next1，next2 = ord（sys.stdin.read（1）），ord（sys.stdin.read（1））if next1 == 91：if next2 == 68：＃左index = max（0，index-1）elif next2 == 67：＃右index = min（len（input），index + 1）elif char == 127：input = input [：index-1] + input [index ：] index-= 1＃打印当前输入字符串sys.stdout.write（u＆＃34; \ u001b [1000D＆＃34;）＃一直向左移动sys.stdout.write（u＆＃34; \ u001b [0K＆ ＃34;）＃清除sys.stdout.write（input）行sys.stdout.write（u＆＃34; \ u001b [1000D＆＃34;）＃如果索引＆gt;再次向左移动0：sys.stdout.write（u＆＃34; \ u001b [＆＃34; + str（index）+＆＃34; C＆＃34;）＃也将光标移到索引sys.stdout.flush（）</p><p>   At this point, it&#39;s worth putting some  sys.stdout.flush(); time.sleep(0.2);s into the code, after every  sys.stdout.write, just to see it working. If you do that, you will see something like this:</p><p>   此时，值得放置一些sys.stdout.flush（）;。在每次sys.stdout.write之后，将time.sleep（0.2）; s放入代码中，只是看它是否起作用。如果这样做，您将看到类似以下内容：</p><p>    Normally, when you are using this code, it all happens instantly </p><p>    通常，当您使用此代码时，所有这些都会立即发生 </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.lihaoyi.com/post/BuildyourownCommandLinewithANSIescapecodes.html">https://www.lihaoyi.com/post/BuildyourownCommandLinewithANSIescapecodes.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ansi/">#ansi</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/command/">#command</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>