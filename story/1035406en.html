<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>将OkCupid从REST迁移到GraphQL</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">将OkCupid从REST迁移到GraphQL</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-16 16:47:35</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/7bad9964559357b13344abb35156c3fc.png"><img src="http://img2.diglog.com/img/2020/11/7bad9964559357b13344abb35156c3fc.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>A lot has been written about the benefits of moving from a REST API to a GraphQL API  1. But let’s say that you’re already convinced. If you want to convert a site with millions of users, ensure that performance doesn’t suffer, and just  really don’t want to screw it up: how do you do it?</p><p>关于从REST API迁移到GraphQL API 1的好处，已经写了很多文章，但我们假设您已经确信了这一点。如果你想转换一个拥有数百万用户的网站，确保它的性能不会受到影响，而且真的不想搞砸：你是怎么做到的？</p><p> We embarked on this journey last year and made it out alive to tell the tale! Our GraphQL API is now the official API at OkCupid, with all clients adopting it: our iOS and Android apps, as well as our desktop and mobile web single-page React apps.</p><p>我们去年踏上了这段旅程，并活着讲述了这个故事！我们的GraphQL API现在是OkCupid的官方API，所有客户端都采用它：我们的iOS和Android应用程序，以及我们的桌面和移动网页单页反应应用程序。</p><p> So, here’s how we tackled this huge project. I’ll talk a little about what we built, the strategy we came up with to test the new code we were shipping, and a few things that could have gone better on the technology side. Disclaimer: this article is more about the process than the code itself; check back soon for another post about the performance issues we had to overcome to reach parity with our previous API.</p><p>所以，这就是我们如何解决这个庞大项目的。我将谈一谈我们构建的内容、我们用来测试我们发布的新代码的策略，以及在技术方面本可以做得更好的一些事情。免责声明：这篇文章更多的是关于过程，而不是代码本身；请稍后查看另一篇文章，内容是我们必须克服的性能问题，才能达到与以前的API相同的水平。</p><p>  Our GraphQL API has been in production for 1½ years, and we stopped adding new features to our REST API over a year ago. The graph handles up to 170k requests per minute, and it is made up of 227 entities.</p><p>我们的GraphQL API已经投入生产一年半了，而我们在一年多前就停止向REST API添加新功能了。该图每分钟处理多达170k个请求，它由227个实体组成。</p><p> We haven’t fully deprecated our REST API, but we’re more than halfway through converting our clients if you look at request volume (we’ve added the entities that support the most popular pages), and maybe a little less than halfway there by entity count.</p><p>我们还没有完全弃用我们的rest API，但是如果您看一下请求量(我们已经添加了支持最受欢迎页面的实体)，那么转换我们的客户端的过程已经过半，按实体数计算可能还不到一半。</p><p>  Since this was a whole new tech stack and repository for us (Node, Apollo Server, Docker  2), we needed to figure out a plan to verify its efficacy without disrupting production. Our process was:</p><p>由于这对我们来说是一个全新的技术堆栈和存储库(Node、Apollo Server、Docker 2)，我们需要制定一个计划，在不中断生产的情况下验证其有效性。我们的流程是：</p><p> Add a shadow request to call the new API while still fetching data via the REST API</p><p>添加影子请求以调用新API，同时仍通过REST API获取数据。</p><p> We started the project at the start of January 2019, released our shadow query on January 28th, started our A/B test on March 13th, and released it fully on April 30th. So in just 4 “easy” steps, you too can have a graph in production in “only” 4 months!</p><p>我们于2019年1月初启动项目，1月28日发布影子查询，3月13日开始A/B测试，4月30日全面发布。因此，只需4个“简单”步骤，您也可以在“仅”4个月内就有一个生产中的图表！</p><p>   We decided to make the OkCupid Conversations page our test bed. On this page, users can see the list of ongoing conversations they have, as well as a list of “mutual matches” (people with whom they can start a new conversation):</p><p>我们决定把OkCupid对话页作为我们的试验台。在这个页面上，用户可以看到他们正在进行的对话列表，以及“相互匹配”列表(可以与之开始新对话的人)：</p><p>  It’s important to choose a page that will let you model some core parts of your site; this will help you settle on conventions, flesh out important parts of your data model, create a better base for future work, and just be a better proof of concept. The more “real” the page is, the more it will help you learn if the new API is going to work.</p><p>选择一个允许您对站点的一些核心部分进行建模的页面非常重要；这将帮助您确定约定，充实数据模型的重要部分，为将来的工作创建更好的基础，并更好地验证概念。页面越“真实”，就越能帮助您了解新的API是否有效。</p><p>  Match: stateful information about how two users relate to each other (e.g., match percent, if one has liked the other, etc.)</p><p>Match：关于两个用户如何相互关联的有状态信息(例如，匹配百分比、一个用户是否喜欢另一个用户等)。</p><p> Conversation: basic conversation information (e.g., the sender, a snippet of the last message, the time sent)</p><p>对话：基本对话信息(例如，发送者、最后一条消息的片段、发送时间)。</p><p>   For a lot of teams doing schema design for the first time, this will likely be a challenging step — it was for me! Some tips:</p><p>对于许多第一次进行模式设计的团队来说，这可能是一个具有挑战性的步骤-对我来说就是如此！小贴士：</p><p> Do research. There is a lot of great writing about schemas, from the  basic examples in the GraphQL docs, to  GitHub and  Yelp’s public APIs, to  Relay’s docs. A big shout-out to the Apollo team here; we got great help from them at this stage.</p><p>做些调查。从GraphQL文档中的基本示例，到GitHub和Yelp的公共API，再到Relay的文档，关于模式的文章很多。在这里向阿波罗团队大喊一声；我们在这个阶段从他们那里得到了很大的帮助。</p><p> Don’t worry about how your REST API formatted its data. It’s better to design your schema to be more expressive and idiomatic than it is to feel constrained by what your previous API returned.</p><p>不用担心rest API如何格式化数据。最好将您的模式设计得更具表现力和习惯用法，而不是受到以前API返回的内容的约束。</p><p> Be consistent. Our previous API was mostly  snake_case, but had a few ugly combined words (e.g.,  userid and  displayname). This is your opportunity to make your field names more standard and readable, so take it!</p><p>保持一致。我们之前的API主要是Snake_case，但是有一些难看的组合词(例如，userid和displayName)。这是让你的域名更标准、更易读的机会，所以抓住它吧！</p><p> Be specific. The more accurately you name the fields in your graph, the easier it is to migrate to a new field if you need to make a breaking change. For example,  User.essaysWithDefaults is better than  User.essays.</p><p>具体点。图表中的字段命名越准确，如果需要进行突破性更改，则迁移到新字段就越容易。例如，User.essaysWithDefaults比User.essays更好。</p><p> Take your research and make something that works for your team. When investigating pagination standards, for example, I was tempted to use Relay’s spec, but found its reliance on terms like  edges and  nodes  more clinical than we wanted to expose to clients in our graph (we instead settled on returning a list of  data  3).</p><p>拿出你的研究成果，做一些对你的团队有用的东西。例如，在研究分页标准时，我很想使用Relay的规范，但发现它对边和节点等术语的依赖比我们希望在图中向客户公开的更具临床意义(相反，我们决定返回一个数据列表3)。</p><p>  Before having GraphQL provide data to real users, we tested our system in production with a shadow request: on our target page, the user requested its data from the REST API, then did the same from GraphQL after displaying the REST data (discarding the duped data). This let us compare the performance of the two APIs and fix issues before users found them.</p><p>在让GraphQL向实际用户提供数据之前，我们使用影子请求在生产环境中测试了我们的系统：在目标页面上，用户从rest API请求数据，然后在显示REST数据(丢弃复制的数据)后从GraphQL请求数据。这让我们可以比较这两个API的性能，并在用户发现问题之前修复它们。</p><p> We certainly aren’t the first people to think of this, but it was a massively important step for us. Our first draft of this API took nearly  twice the time of the REST API, which, obviously, was not cool. Releasing a shadow request allowed us to triage these performance issues without affecting real users’ experience on the site.</p><p>我们当然不是第一个想到这一点的人，但这对我们来说是非常重要的一步。我们这个API的第一个草案花费了几乎两倍于rest API的时间，这显然并不酷。发布影子请求使我们能够在不影响真实用户在站点上的体验的情况下对这些性能问题进行分类。</p><p> Check back soon for a post about the technical side of what went wrong and how we got GraphQL up to speed parity.</p><p>马上回来看一篇关于哪里出了问题的技术方面的帖子，以及我们是如何让GraphQL达到同等速度的。</p><p>  The final step was to test the new API against the old with real users! Since we already verified that the response times were similar with the shadow request, we felt confident releasing an A/B test.</p><p>最后一步是用真实用户测试新的API和旧的API！因为我们已经验证了响应时间与影子请求相似，所以我们对发布A/B测试很有信心。</p><p> Experiments where you expect  not to see a change are tricky because you are trying to prove that nothing happened. So in an experiment like this, the stats you’re tracking will, by nature, never reach significance unless there’s something wrong.</p><p>你希望看不到变化的实验是棘手的，因为你试图证明什么都没有发生。因此，在这样的实验中，你追踪的数据本质上永远不会有意义，除非出了什么问题。</p><p> So instead of looking for a significant change in stats, you should set a duration for your experiment; once you’ve reached that duration and still see no significant changes, you can launch with confidence. For us, that was a month’s run (with over 100k users in each group). And… it worked!</p><p>因此，与其寻找统计数据的显著变化，不如为您的实验设置一个持续时间；一旦达到这个持续时间，仍然没有看到显著变化，您就可以信心十足地启动了。对我们来说，这是一个月的运行时间(每组用户超过10万)。和…。啊，真灵!</p><p>  No first draft is ever perfect (nor any second draft, for me at least). While the process around releasing the API went well, there were a few technical things we learned after our release.</p><p>没有一个初稿是完美的(至少对我来说，第二稿也是如此)。虽然发布API的过程进行得很顺利，但我们在发布之后学到了一些技术知识。</p><p>  We didn’t have any structure around how we returned errors from GraphQL mutations, and by the time we realized there was a problem, we had a robust variety of ways we showed errors to our clients. A solution that seems really interesting would be to standardize on an  Error type that we can extend in a given mutation payload. This medium post has a very in-depth writeup of  good error styles.</p><p>我们没有任何关于如何从GraphQL突变返回错误的结构，当我们意识到有问题时，我们已经有了向客户显示错误的强大的各种方式。一个看起来非常有趣的解决方案是标准化错误类型，我们可以在给定的突变有效负载中扩展该错误类型。这篇中等水平的帖子对好的错误风格进行了非常深入的总结。</p><p>  When confronted with a product feature that involves a business rule, it can be tempting to add that logic to the API layer, especially if you’d otherwise be relying on another team to implement it.</p><p>当遇到涉及业务规则的产品特性时，将该逻辑添加到API层很有诱惑力，特别是如果您不是依靠另一个团队来实现它的话。</p><p> For example, we built a feature that shows a list of everyone who liked and messaged you. We show the whole list to paid users, but for free users we only show the first one, then a series of placeholders. Our first release of this feature had the logic to check a user’s paid status and replace the cards with placeholders in the API layer.</p><p>例如，我们构建了一个功能，可以显示所有喜欢你并给你发信息的人的列表。我们向付费用户显示整个列表，但对于免费用户，我们只显示第一个列表，然后显示一系列占位符。我们的第一个版本的逻辑是检查用户的付费状态，并在API层中用占位符替换卡片。</p><p> After working with the graph for a while now, we’ve realized that the business logic works best when centralized in the back-end, and that the role of our graph is to fetch, format, and present the back-end’s data in a way that makes sense to clients.</p><p>在使用图形一段时间之后，我们已经意识到业务逻辑在集中在后端时工作得最好，并且我们的图形的作用是以对客户端有意义的方式获取、格式化和呈现后端的数据。</p><p>  Overall, our process worked out really well; it allowed us to get something into production quickly to validate our technical decisions, fix errors before they got to users, and test our changes against the previous API.</p><p>总体而言，我们的流程运行得非常好；它使我们能够快速将一些东西投入生产，以验证我们的技术决策，在错误到达用户之前修复它们，并根据以前的API测试我们的更改。</p><p> If you decide to take a similar journey, we hope this roadmap will be useful. Good luck!</p><p>如果您决定踏上类似的旅程，我们希望这份路线图会对您有所帮助。祝好运!。</p><p>  Thanks to  Katherine Erickson,  Raymond Sohn, and the OkCupid web team for reading drafts of this article.</p><p>感谢凯瑟琳·埃里克森(Katherine Erickson)、雷蒙德·孙(Raymond Sohn)和OkCupid网络团队阅读本文的草稿。</p><p>    1. For us, it boiled down to: a more expressive way for clients to interact with our data, a more performant way to retrieve data with fewer network requests, more flexibility for our clients to create new features without API changes once the graph was built out a bit, and a technology that is rapidly being adopted as a community standard for APIs. 2. This was a greenfield project, built in a new repository and deployed separately from our back-end and client codebases. It runs in Node, using Apollo Server and Express. Our data was provided by calls to our REST API for the initial release, but we’ve since moved to calling our back-end directly using gRPC.</p><p>1.对我们来说，它归结为：一种让客户端与我们的数据交互更具表现力的方式，一种用更少的网络请求来检索数据的更高性能的方式，让我们的客户端在不更改API的情况下创建新功能的灵活性更高，只要稍微构建一下图形，就可以创建新的功能，以及一种正在迅速被采纳为API社区标准的技术。2.这是一个全新的项目，构建在一个新的存储库中，并与我们的后端和客户端代码库分开部署。它在Node上运行，使用阿波罗服务器和Express。我们的数据是由对初始版本的rest API的调用提供的，但后来我们转向使用GRPC直接调用后端。</p><p> The API is deployed with Docker: we build Docker images with CI, and orchestrate releasing those images to our web servers with Docker Swarm. A huge, truly enormous shout-out goes to Hugh Tipping on our ops team for putting together Docker Swarm and a launch script to interact with it, along with tons of Docker experience and support! Also emotional support.</p><p>该API与Docker一起部署：我们使用CI构建Docker镜像，并使用Docker Sarm协调将这些镜像发布到我们的web服务器。休向我们的运营团队提供了一个巨大的、真正巨大的呐喊，因为他组织了Docker Sarm和一个与之互动的启动脚本，以及大量的Docker经验和支持！还有情感上的支持。</p><p> We use Apollo Client across all platforms (desktop/mobile web, iOS, and Android), and integrated with Apollo Studio to use their Operation Registry for security and to track speed and field usage stats.</p><p>我们在所有平台(桌面/移动网络、iOS和Android)上使用Apollo Client，并与Apollo Studio集成，以使用其Operation Registry实现安全性，并跟踪速度和现场使用统计数据。</p><p> 3.  edges and  nodes didn’t feel right to us, but the Relay description of paging cursors was pretty spot on. So, we use a data array for the items, and a Relay-inspired  PageInfo entity:</p><p>3.我们觉得边和节点不太对劲，但是对分页游标的Relay描述非常准确。因此，我们对项目使用一个数据数组，并使用一个受Relay启发的PageInfo实体：</p><p> &#34;&#34;&#34; A common format to use when describing a page of paginated data. &#34;&#34;&#34;type PageInfo { &#34;&#34;&#34; The key to get the previous page of results, if available. &#34;&#34;&#34; before: String &#34;&#34;&#34; The key to get the next page of results, if available. &#34;&#34;&#34; after: String &#34;&#34;&#34; A boolean to indicate that more results are available. &#34;&#34;&#34; hasMore: Boolean! &#34;&#34;&#34; The total number of results available. &#34;&#34;&#34; total: Int!}&#34;&#34;&#34; An interface to ensure that paginated results have info about the current page. &#34;&#34;&#34;interface PageResult { pageInfo: PageInfo!}&#34;&#34;&#34; A paginated list of a user&#39;s conversations. &#34;&#34;&#34;type ConversationConnection implements PageResult { data: [Conversation]! pageInfo: PageInfo!}extend type User { &#34;&#34;&#34; A list of this user&#39;s conversations. &#34;&#34;&#34; conversations( limit: Int = 20 before: String after: String ): ConversationConnection!}</p><p>&#34；&#34；&#34；一种描述分页数据页面时使用的常用格式。&#34；&#34；&#34；键入PageInfo{&#34；&#34；&#34；获取上一页结果的密钥(如果有)。&#34；&#34；&#34；之前：字符串&#34；&#34；&#34；获取下一页结果的密钥(如果可用)。&#34；&#34；&#34；之后：字符串&#34；&#34；&#34；一个布尔值，表示提供更多结果。&#34；&#34；&#34；hasmore：布尔！&#34；&#34；&#34；可用的结果总数。&#34；&#34；&#34；Total：int！}&#34；&#34；&#34；界面，用于确保分页结果包含有关当前页面的信息。界面PageResult{pageInfo：PageInfo！}&#34；&#34；&#34；用户对话的分页列表。&#34；&#34；&#34；&#34；type ConversationConnection实现PageResult{data：[对话]！PageInfo：PageInfo！}扩展类型用户{#34；&34；此用户的对话列表。&#34；&#34；&#34；对话(LIMIT：INT=20 BEFORE：STRING AFTER：STRING)：ConversationConnection！}</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://tech.okcupid.com/moving-okcupid-from-rest-to-graphql/">https://tech.okcupid.com/moving-okcupid-from-rest-to-graphql/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/graphql/">#graphql</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/rest/">#rest</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/okcupid/">#okcupid</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/api/">#api</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1034103.html"><img src="http://img2.diglog.com/img/2020/11/thumb_feb0307586085b572c07461c5885df6e.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034103.html">如何用Ruby、Rails、Active Record和No N+1绘制QL</a></div><span class="my_story_list_date">2020-11-10 2:32</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033533.html"><img src="http://img2.diglog.com/img/2020/11/thumb_cccadfda5717fb02f0d800b74567d803.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033533.html">为什么不是GraphQL呢？REST API更胜一筹，但GraphQL仍胜出</a></div><span class="my_story_list_date">2020-11-6 18:8</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032573.html"><img src="http://img2.diglog.com/img/2020/11/thumb_390e8ddcba753f161bef2fd17e1dfc95.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032573.html">OpenAPI-to-GraphQL</a></div><span class="my_story_list_date">2020-11-1 11:19</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031558.html"><img src="http://img2.diglog.com/img/2020/10/thumb_fb0b501bde81980754d20d39df41c8e8.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031558.html">GraphQL Editor 3.0-新版本</a></div><span class="my_story_list_date">2020-10-28 2:14</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>