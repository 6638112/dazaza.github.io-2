<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>openssl 1.1.1k. </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">openssl 1.1.1k. </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-26 19:53:38</div><div class="page_narrow text-break page_content"><p>创建发布时，该分支被关掉，并且其更改内容也被叉。例如，0.9.8N后的任何更改都不会出现在其他日志中，因为在该发布后和0.9.8o之前创建了1.0.0。然而，跨分支机构合并的任何更改应该在每个分支中都有一个条目和＃39; changelog。</p><p>  这是主分支的ChangeLog，目前处于活动开发的内容。此文档的普通文本/ Markdown版本可在此处提供：changelog.md</p><p>  对于其他分支，更改曲目与源分发，但此处也可用：EVP_PKEY_PUBLIC_CHECK（）和EVP_PKEY_PARAM_CHECK（）现已为更多的关键类型工作，包括RSA，DSA，ED25519，X25519，ED448和X448。以前（在1.1.1）他们会返回-2。对于没有参数的关键类型，那么EVP_PKEY_PARAM_CHECK（）将始终返回1。</p><p> 来自众多＆＃34的产出;印刷＆＃34;已经修改了x509_signature_print（），x509_print_ex（），x509_crl_print_ex（）和其他类似功能的函数，使得在1.1.1和3.0中观察到的输出之间可能会有化妆品差异。这也适用于＆＃34; -text＆＃34;来自X509和CRL应用的输出。</p><p> Windows线程同步在OS支持时使用读/写基元（SRWLOCK），否则将继续使用临界敏捷。</p><p> 添加允许Bio_tell（）和Bio_seek（）的筛选器生物bio_f_readbufeer（）以读取不支持这些功能的Bio Source / Sinks。这允许使用STDIN缓冲到内存中的文件生物管道或重定向文件生物。这在oossl_decoder_broom_bio（）内部使用。</p><p> ossl_store_info_get_type（）现在可以返回额外的值。在1.1.1中，此函数将返回其中一个值ossl_store_info_name，ossl_store_info_pkey，ossl_store_info_params，ossl_store_info_cert或ossl_store_info_crl。以前已被报告为1.1.1中的Decoded公钥。在3.0解码的公钥时，现在报告为具有新类型ossl_store_info_pubkey。应修改使用此功能的应用程序来处理更改的返回值。 </p><p>为TSP和CMS高级电子签名（CADES）实现来改进增强安全服务（ESS，RFC 2634和RFC 5035）的遵守。根据RFC 5035的要求，请检查esscertid和esscertidv2如果两个目前。更正检查验证链中的语义，以防esscertid {，v2}包含多个证书标识符：这意味着引用的所有证书都必须是验证链的一部分。</p><p> EVP CIPHERS CAST5-ECB，CAST5-CBC，CAST5-OFB，CAST5-CFB，BF-ECB，BF-CBC，BF-OFB，BF-CFB，IDEA-ECB，IDEC-CBC，IDEA-OFB， IDE-CFB，种子-ECB，种子CBC，种子-B，种子-CFB，RC2-ECB，RC2-CBC，RC2-40-CBC，RC2-64-CBC，RC2-OFB，RC2-CFB，RC4， RC4-40，RC4-HMAC-MD5，RC5-ECB，RC5-CBC，RC5-OFB，RC5-CFB，DESX-CBC，DES-ECB，DES-CBC，DES-FOB，DES-CFB，DES-CFB1和DES-CFB8已被移至遗留提供商。使用EVP API访问这些密码的应用程序应该使用更多的现代密码。如果不可能，则这些应用程序应确保已加载传统提供商。这可以以编程方式或通过配置实现。有关详细信息，请参阅提供商（7）手册页。</p><p> EVP摘要MD2，MD4，MDC2，Whirlpool和Ripemd-160的实现已被移动到传统提供商。应用程序使用EVP API访问这些摘要应该使用更多的现代化摘要。如果不可能，则这些应用程序应确保已加载传统提供商。这可以以编程方式或通过配置实现。有关详细信息，请参阅提供商（7）手册页。</p><p>  已弃用的函数evp_pkey_get0_rsa（），evp_pkey_get0_dsa（），evp_pkey_get0_c_key（），evp_pkey_get0_dh（），evp_pkey_get0_hmac（），evp_pkey_get0_poly1305（）和evp_pkey_get0_siphash（）以及类似命名的＆＃34; get1＆＃34;函数在openssl 3.0中表现略有不同。以前，他们返回了Libcrypto内部使用的低级键的指针。来自OpenSSL 3.0此密钥现在可以在提供商中举行。调用这些函数只会在首先使用此键构造EVP_PKEY的内部键上的句柄，例如使用函数或宏如evp_pkey_assign_rsa（），evp_pkey_set1_rsa（）等。evp_pkey保存提供者托管密钥，然后这些函数现在返回键的缓存副本。在第一次访问缓存的密钥后，将在第一次进行缓存的密钥后发生的内部提供程序密钥的更改将不会反映在缓存的副本中。类似地，通过应用程序代码对缓存副本进行的任何更改都不会反映在内部提供程序密钥中。</p><p> 由于上述原因，从这些函数返回的键通常应通常被视为只读。要强调这一点，已经制作了从evp_pkey_get0_rsa（），evp_pkey_get0_cn_key（）和evp_pkey_get0_dh（）返回的值。这可能会破坏一些现有代码。应修改此更改破坏的应用程序。首选解决方案是重新推荐代码以避免使用这些已弃用功能。失败此代码应该被修改为使用Const指针。 evp_pkey_get1_rsa（），evp_pkey_get1_dsa（），evp_pkey_get1_ec_key（）和evp_pkey_get1_dh（）函数继续返回一个非const指针，以使它们能够成为＆＃34;释放＆＃34;然而，他们也应该被视为只读。</p><p> 弃用了许多函数处理低级别键或引擎，包括EVP_PKEY_SET1_ENGINE（），EVP_PKEY_GET0_ENGINE（），EVP_PKEY_GET0（），EVP_PKEY_GET0_HMAC（），EVP_PKEY_GET0_POLY1305（）和EVP_PKEY_GET0_SIPHASH（）。使用引擎的应用应该使用提供者。在EVP_PKEY中获取或设置低级键的应用程序应使用OSSL_ENCODER或OSSL_DECODER API，或者可选地使用EVP_PKEY_FROMDATA（）或EVP_PKEY_GET_PARAMS（）。</p><p> 已弃用过时evp_pkey_ctx_get0_dh_kdf_ukm（）和evp_pkey_ctx_get0_ecdh_kdf_ukm（）函数。它们不需要，并且需要从想要支持它们的提供商返回八位字节PTR参数，该提供商复杂化提供商实现。 </p><p>RAND_METHOD API已被弃用。弃用的函数是：rand_openssl（），rand_get_rand_method（），rand_set_rand_engine（）和rand_set_rand_method（）。应通过EVP_RAND（3）使用基于提供的随机数生成器。</p><p> SRP API已被弃用。旧的API不通过提供商工作，并且没有EVP接口。不幸的是，此时没有对这些API替换。</p><p> 添加编译时选项以防止提供提供者获取的算法的缓存。通过在配置时间下包括无缓存获取选项，启用了这一点。</p><p> 使用PKCS12_CREATE（）函数的PKCS12创建的默认算法被更改为更现代的PBKDF2和基于AES的算法。默认MAC迭代计数已更改为pkcs12_default_iter以使其与基于密码的加密迭代计数相同。 MAC计算的默认摘要算法已更改为SHA-256。 PKCS12应用程序现在支持-Legacy选项，该选项恢复先前的默认算法以支持与遗留系统的互操作性。</p><p> OpenSSL Speed命令不再使用低级API调用。这意味着由于较高的开销，一些性能数字可能与先前的释放可能没有完全相当。这尤其适用于测量较小数据块上的性能。</p><p>  结合配置选项No-EC和No-DH不再禁用TLSv1.3。通常，如果OpenSSL没有EC或DH算法，则它无法支持与TLSv1.3的连接。但是Openssl现在支持＆＃34;可插拔＆＃34;团体通过提供商。因此，第三方提供商即使在没有内置的地方也可以提供组实现。尝试在此构建中创建TLS连接而不在运行时或使用第三方提供程序组可能会导致握手失败的TLSv1.3。可以在编译时间使用＆＃34; no-tls1_3＆＃34可以禁用tlsv1.3;配置选项。</p><p> 未记录的函数x509_certificate_type（）已被推荐出来;应用程序可以使用x509_get0_pubkey（）和x509_get0_signature（）来获取相同的信息。 </p><p>弃用过时的bn_pseudo_rand（）和bn_pseudo_rand_range（）函数。它们分别与bn_rand（）和bn_rand_range（）相同。</p><p> 除以SSLv23的RSA填充模式（仅用于SSLv2）。这包括rsa_paddation_check_sslv23（）和rsa_padding_add_sslv23（）和debreated rsautl命令中的-ssl选项。</p><p>  常规2-Prime RSA键的默认密钥生成方法已更改为FIPS 186-4 B.3.6方法（基于辅助可能素线的条件生成可能的次要原料）。这种方法比原始方法慢。</p><p> 弃用了bn_is_prime_ex（）和bn_is_prime_fasttest_ex（）函数。它们被替换为BN_CHECK_PRIME（）函数，以避免可能误用，并且始终使用至少64轮米勒-Rabin原始测试。至少64轮米勒-Rabin测试现在也用于所有主要生成，包括RSA密钥生成。这增加了关键的生成时间，尤其是较大的键。</p><p>  弃用类型OCSP_REQ_CTX和功能OCSP_REQ_CTX_new（），OCSP_REQ_CTX_free（），OCSP_REQ_CTX_http（），OCSP_REQ_CTX_add1_header（），OCSP_REQ_CTX_i2d（），OCSP_REQ_CTX_nbio（），OCSP_REQ_CTX_nbio_d2i（），OCSP_REQ_CTX_get0_mem_bio（）和OCSP_set_max_response_length（）。这些用于收集所有必要的数据以形成HTTP请求，并使用该请求执行HTTP传输。使用OpenSSL 3.0，类型是OSSL_HTTP_REQ_CTX，并且废弃的函数与OSSL_HTTP_REQ_CTX_new（），OSSL_HTTP_REQ_CTX_free（），OSSL_HTTP_REQ_CTX_set_request_line（），OSSL_HTTP_REQ_CTX_add1_header（），OSSL_HTTP_REQ_CTX_i2d（），OSSL_HTTP_REQ_CTX_nbio（），OSSL_HTTP_REQ_CTX_sendreq_d2i（），OSSL_HTTP_REQ_CTX_get0_mem_bio（）和OSSL_HTTP_REQ_CTX_set_max_response_length（取代）。</p><p>  SM2键的验证已与常规EC键的验证分开，允许改进SM2验证过程，以拒绝不符合SM2 ISO标准的加载的私钥。特别地，在1＆lt; = k的范围之外的私人标量k。 N-1现在被正确拒绝。</p><p> 使用-check或-pubcheck交换机时，将更改pKey应用程序的行为：验证失败触发早期退出，将失败退出状态返回给父进程。 </p><p>已弃用命令行实用程序列表的-Cipher-commands和-digest-commands选项。而是使用-Cipher-algorithms和-digest-algorithms选项。</p><p> EC_KEY_OpenSSL，EC_KEY_get_default_method，EC_KEY_set_default_method，EC_KEY_get_method，EC_KEY_set_method，EC_KEY_new_method EC_KEY_METHOD_new，EC_KEY_METHOD_free，EC_KEY_METHOD_set_init，EC_KEY_METHOD_set_keygen，EC_KEY_METHOD_set_compute_key，EC_KEY_METHOD_set_sign，EC_KEY_METHOD_set_verify，EC_KEY_METHOD_get_init，EC_KEY_METHOD_get_keygen，EC_KEY_METHOD_get_compute_key，EC_KEY_METHOD_get_sign，EC_KEY_METHOD_get_verify，EC_KEY_new_ex，EC_KEY_new，EC_KEY_get_flags，EC_KEY_set_flags，EC_KEY_clear_flags，EC_KEY_decoded_from_explicit_params，EC_KEY_new_by_curve_name_ex，EC_KEY_new_by_curve_name ，EC_KEY_free，EC_KEY_copy，EC_KEY_dup，EC_KEY_up_ref，EC_KEY_get0_engine，EC_KEY_get0_group，EC_KEY_set_group，EC_KEY_get0_private_key，EC_KEY_set_private_key，EC_KEY_get0_public_key，EC_KEY_set_public_key，EC_KEY_get_enc_flags，EC_KEY_set_enc_flags，EC_KEY_get_conv_form，EC_KEY_set_conv_form，EC_KEY_set_ex_data，EC_KEY_get_ex_data，EC_KEY_set_asn1_flag，EC_KEY_generate_key，EC_KEY_check_key，EC_ KEY_CAN_SIGN，EC_KEY_SET_PUBLIC_KEY_AFFINE_COORDINATE，EC_KEY_KEY2BUF，EC_KEY_OCT2KEY，EC_KEY_OCT2PRIV，EC_KEY_PRIV2OCT和EC_KEY_PRIV2BUF。需要实现EC_KEY_METHOD的应用程序需要考虑在特殊提供者中执行功能。更换操作EC_KEY对象的函数，请参阅EVP_PKEY-EC（7）手动页面。</p><p> 另外函数读写EC_KEY对象如o2i_ECPublicKey，i2o_ECPublicKey，ECParameters_print_fp，EC_KEY_print_fp，d2i_ECPKParameters，d2i_ECParameters，d2i_ECPrivateKey，d2i_ECPrivateKey_bio，d2i_ECPrivateKey_fp，d2i_EC_PUBKEY，d2i_EC_PUBKEY_bio，d2i_EC_PUBKEY_fp，i2d_ECPKParameters，i2d_ECParameters，i2d_ECPrivateKey，i2d_ECPrivateKey_bio，i2d_ECPrivateKey_fp，i2d_EC_PUBKEY，i2d_EC_PUBKEY_bio和i2d_EC_PUBKEY_fp已也被推翻了。应用程序应使用OSSL_DECODER和OSSL_ENCODER API读取和写入EC文件。</p><p> 最后，还弃用了从EVP_PKEY（如EVP_PKEY_ASSIGN_EC_KEY，EVP_PKEY_GET0_EC_KEY，EVP_PKEY_GET1_EC_KEY和EVP_PKEY_SET1_EC_KEY）中获取EC_KEY对象的函数。应用程序应该直接使用OSSL_Decoder和OSSL_Encoder API读取或写入EVP_PKEY。或使用EVP_PKEY_FROMDATA（）直接从EC数据加载EVP_PKEY。</p><p> 弃用所有libcrypto和的libssl错误字符串加载函数：ERR_load_ASN1_strings（），ERR_load_ASYNC_strings（），ERR_load_BIO_strings（），ERR_load_BN_strings（），ERR_load_BUF_strings（），ERR_load_CMS_strings（），ERR_load_COMP_strings（），ERR_load_CONF_strings（），ERR_load_CRYPTO_strings（），ERR_load_CT_strings（） ，ERR_load_DH_strings（），ERR_load_DSA_strings（），ERR_load_EC_strings（），ERR_load_ENGINE_strings（），ERR_load_ERR_strings（），ERR_load_EVP_strings（），ERR_load_KDF_strings（），ERR_load_OBJ_strings（），ERR_load_OCSP_strings（），ERR_load_PEM_strings（），ERR_load_PKCS12_strings（），ERR_load_PKCS7_strings（），ERR_load_RAND_strings （），err_load_rsa_strings（），err_load_ossl_store_strings（），err_load_ts_strings（），err_load_ui_strings（），err_load_x509_strings（），err_load_x509v3_strings（）。</p><p> 由于openssl 1.1.0，因此不需要调用这些函数，因为OpenSSL现在自动加载错误字符串。</p><p> 已弃用函数ssl_ctx_set_tmp_dh_callback和ssl_set_tmp_dh_callback，以及宏ssl_ctx_set_tmp_dh（）和ssl_set_tmp_dh（）。这些用于设置要由需要短暂DH键的服务器使用的Diffie-Hellman（DH）参数。相反，应用程序应考虑使用调用ssl_ctx_set_dh_auto（）或ssl_set_dh_auto（）可用的内置DH参数。如果需要自定义参数，则应用程序可以使用备用函数ssl_ctx_set0_tmp_dh_pkey（）和ssl_set0_tmp_dh_pkey（）。 ＆＃34没有直接替代;回调＆＃34;功能。回调最初是有用的，以便对导出和非导出Ciphersuites具有不同的参数。 Openssl不再支持导出Ciphersuites。应使用回调函数的使用应由上述其他方法之一替换。 </p><p>为AES键WRAP逆密铃添加到EVP层的支持。该算法是：＆＃34; AES-128-Wrap-Inv＆＃34 ;,＆＃34; AES-192-Wrap-Inv＆＃34;＆＃34; AES-256-Wrap-Inv＆＃34 ;, ＃34; aes-128-wrap-pad-inv＆＃34 ;,＆＃34; aes-192-wrap-pad-inv＆＃34;和＃34; AES-256-Wrap-Pad-Inv＆＃34;逆接频使用AES解密以进行包装，以及用于展开的AES加密。</p><p> 已弃用的evp_pkey_set1_tls_encodedpoint（）和evp_pkey_get1_tls_encodedpoint（）。这些函数以前用于设置或从EVP_PKEY对象中设置或获取编码的公钥。使用OpenSSL 3.0，它们被更通用的函数替换为EVP_PKEY_SET1_ENCODED_PUBLIC_KEY（）和EVP_PKEY_GET1_ENCODED_PUBLIC_KEY（）。旧版本已被转换为已弃用的宏，即仅调用新功能。</p><p> 可以通过应用程序代码自定义的安全回调支持安全操作SSL_SECOP_TMP_DH。这被定义为在＆＃34中拍摄EVP_PKEY;其他＆＃34;范围。在大多数地方，这就是通过了什么。所有这些地方都发生了服务器端。但是，此安全操作有一个客户端调用，它通过了DH对象。根据SSL_SECOP_TMP_DH的定义，这是不正确的，并且与所有其他位置不一致。因此，此客户端呼叫已更改为传递EVP_PKEY。</p><p>  为＆＃39添加了新选项; openssl列表＆＃39;＆＃39;  - 将显示加载的提供商，名称，版本和状态的列表。它可选择显示其可加位参数。</p><p> 已弃用的evp_pkey_set_alias_type（）。此功能以前需要识别SM2键的解决方法。使用OpenSSL 3.0，内部识别此密钥类型，因此不再需要解决方法。</p><p> 功能仍然保留，但只能使用带有遗留内部密钥的EVP_PKEYS。</p><p>  改变了所有＆＃34;堆栈＆＃34;函数是宏而不是内联函数。仍然通过Helper Inline函数在编译时检查宏参数。 </p><p>RAND_DRBG API与EVP_RAND和EVP_RAND_CTX实现的新提供者概念不合适。主要原因是Rand_drbg API是＆＃39;前端＆＃39;和＃39;后端＆＃39; API调用和其一些API调用相当低级别。这特别适用于回调机制（rand_drbg_set_callbacks（））。</p><p> 添加兼容层以继续支持RAND_DRBG API作为常规弃用期的传统API，以便不必要地复制新提供程序API的价格。由于rand_drbg API仅存在自版本1.1.1以来，因此由OMC决定完全删除它。</p><p>  ＆＃39; minprotocol＆＃39;和＃39; MaxProtocol＆＃39;配置命令现在在配置基于DTLS的上下文时静默忽略TLS协议版本界限，并相反，在配置基于TLS的上下文时，默默地忽略DTLS协议版本受限。可以重复命令以设置两种类型的界限。这同样适用于相应的＆＃34; min_protocol＆＃34;和＃34; max_protocol＆＃34;命令行交换机，如果某些应用程序使用TLS和DTL。</p><p> 为固定协议版本创建的ssl_ctx实例（例如tlsv1_server_method（））也默默地忽略版本界限。以前尝试将绑定应用于这些协议版本将导致错误。现在只有＆＃34;版本灵活＆＃34; SSL_CTX实例受到命令行选项中的配置文件中的限制。</p><p>  重新制作录制的错误代码，为系统错误做出更好的空间。要区分它们，宏err_system_error（）指示给定的代码是系统错误（true）或openssl错误（false）。</p><p>  将密文窃取算法AES-128-CBC-CTS，AES-192-CBC-CTS和AES-256-CBC-CTS添加到提供商。支持CS1，CS2和CS3变体。</p><p> ＆＃39;配置＆＃39;已更改为弄清楚配置目标如果在命令行上给出。因此，＆＃39; config＆＃39;脚本现在只有一个包装纸。所有文档都更改为仅提及＆＃39;配置＆＃39; </p><p>添加了库上上下文otherl_lib_ctx，该应用程序以及其他库可以用于在执行Libcrypto操作之内形成单独的上下文。  直接通过将库上下文传递给采用此类参数的函数，例如EVP_Cipher_fetch和类似算法获取功能。  间接地，通过创建新的库上下文然后将其分配为新默认值，使用otsl_lib_ctx_set0_default将其分配为新默认值。  占用OSSL_LIB_CTX指针的所有公共openssl函数，除了与ossl_lib_ctx直接相关的函数外，accept null表示应使用默认库上下文。  使用OSSL_LIB_CTX_SET0_DEFAULT更改默认库上下文的库代码应注意在返回呼叫者之前将其恢复为第二次调用。  （  ...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.openssl.org/news/changelog.html#openssl-111">https://www.openssl.org/news/changelog.html#openssl-111</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/openssl/">#openssl</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>