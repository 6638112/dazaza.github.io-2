<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何生成唯一随机整数序列（2012） How to Generate a Sequence of Unique Random Integers (2012)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How to Generate a Sequence of Unique Random Integers (2012)<br/>如何生成唯一随机整数序列（2012） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-22 05:08:30</div><div class="page_narrow text-break page_content"><p>Suppose we wish to generate a sequence of  10000000 random 32-bit integers with  no repeats. How can we do it?</p><p>假设我们希望生成一个没有重复的10000000个随机32位整数的序列。我们该怎么做？</p><p>   I faced this problem recently, and considered several options before finally implementing a custom, non-repeating pseudo-random number generator which runs in O(1) time, requires just 8 bytes of storage, and has pretty good distribution. I thought I’d share the details here.</p><p>   我最近遇到了这个问题，在最终实现自定义的，非重复的伪随机数生成器（运行时间为O（1），仅需要8个字节的存储空间，并且分布良好）之前，考虑了几种选择。我以为我会在这里分享细节。</p><p>    There are already several well-known pseudo-random number generators (PRNGs) such as the Mersenne Twister, an excellent PRNG which distributes integers uniformly across the entire 32-bit range. Unfortunately, calling this PRNG 10000000 times does not tend to generate a sequence of 10000000 unique values. According to  Hash Collision Probabilities, the probability of all 10000000 random numbers being unique is just:</p><p>    已经有几种众所周知的伪随机数生成器（PRNG），例如Mersenne Twister，这是一种出色的PRNG，可以在整个32位范围内均匀地分配整数。不幸的是，将此PRNG调用10000000次并不会生成10000000个唯一值的序列。根据哈希冲突概率，所有10000000个随机数唯一的概率为：</p><p>    That’s astronomically unlikely. In fact, the  expected number of unique values in such sequences is only about 9988367. You can try it for yourself using Python:</p><p>    从天文学角度讲，这不太可能。实际上，此类序列中唯一值的预期数量仅约为9988367。您可以使用Python自己尝试一下：</p><p>    One obvious refinement is to reject random numbers which are already in the sequence, and continue iterating until we’ve reached 10000000 elements. To check whether a specific value is already in the sequence, we could search linearly, or we could keep a sorted copy of the sequence and use a binary search. We could even track the presence of each value explicitly, using a giant 512 MB bitfield or a sparse bitfield such as a  Judy1 array.</p><p>    一种明显的改进是拒绝序列中已经存在的随机数，并继续进行迭代，直到达到10000000个元素为止。要检查序列中是否已存在特定值，可以线性搜索，也可以保留序列的排序副本并使用二进制搜索。我们甚至可以使用巨型512 MB位域或稀疏位域（例如Judy1数组）显式跟踪每个值的存在。</p><p>  Another refinement: Instead of generating an arbitrary 32-bit integer for each element and hoping it’s unique, we could generate a random index in the range [0, N) where N is the number of remaining unused values. The index would tell us which free slot to take next. We could probably locate each free slot in logarithmic time by implementing a  trie suited for this purpose.</p><p>  另一种改进：我们可以为每个元素生成一个范围为[0，N）的随机索引，而不是为每个元素生成一个任意的32位整数，并希望它是唯一的，其中N是剩余的未使用值的数量。索引会告诉我们接下来要使用哪个空闲时段。通过实现适合此目的的特里，我们可能可以在对数时间内找到每个空闲插槽。</p><p>  Brainstorming some more, an approach based on the  Fisher-Yates Shuffle is also quite tempting. Using this approach, we could begin with an array containing all possible 32-bit integers, and shuffle the first 10000000 values out of the array to obtain our sequence. That would require 16 GB of memory. The footprint could be reduced by representing the array as a sparse associative map, such a  JudyL array, storing only those  x where A[ x] ≠  x. Or, instead of starting with an array of all possible 32-bit integers, we could start with an initial sequence of any 10000000 sorted integers. In an attempt to span the available range of 32-bit values, we could even model the initial sequence as a  Poisson process.</p><p>  集思广益，基于Fisher-Yates Shuffle的方法也很诱人。使用这种方法，我们可以从一个包含所有可能的32位整数的数组开始，然后将数组中的前10000000个值混洗以获得序列。那将需要16 GB的内存。可以通过将数组表示为稀疏关联映射（例如JudyL数组）来减少占用空间，该数组仅存储x，其中A [x]≠x。或者，我们可以从任何10000000个排序整数的初始序列开始，而不是从所有可能的32位整数的数组开始。为了扩展32位值的可用范围，我们甚至可以将初始序列建模为泊松过程。 </p><p>  All of the above approaches either run in non-linear time, or require large amounts of storage. Several of them would be workable for a sequence of just 10000000 integers, but it got me thinking whether a more efficient approach, which scales up to any sequence length, is possible.</p><p>以上所有方法要么在非线性时间内运行，要么需要大量存储。它们中的几个对于仅10000000个整数的序列都是可行的，但是让我开始思考是否有可能采用一种更有效的方法，该方法可以扩展到任意序列长度。</p><p>    The ideal PRNG for this problem is one which would generate a unique, random integer the first 2 32 times we call it, then repeat the same sequence the next 2 32 times it is called, ad infinitum. In other words, a repeating cycle of 2 32 values. That way, we could begin the PRNG at any point in the cycle, always having the guarantee that the next 2 32 values are repeat-free.</p><p>    解决此问题的理想PRNG是一个会在我们调用它的前2 32次中生成一个唯一的随机整数，然后在随后调用它的2 32次中无限期重复相同的序列。换句话说，一个2 32个值的重复循环。这样，我们可以在循环中的任何时候开始PRNG，并始终保证接下来的2 32个值是无重复的。</p><p>  One way to implement such a PRNG is to define a one-to-one function on the integers – a function which maps each 32-bit integer to another, uniquely. Let’s call such a function a  permutation. If we come up with a good permutation, all we need is to call it with increasing inputs { 0, 1, 2, 3, … }. We could even begin the input sequence at any value.</p><p>  实现此类PRNG的一种方法是在整数上定义一对一函数-该函数将每个32位整数唯一地映射到另一个整数。我们称这种功能为置换。如果我们想出一个很好的排列，我们所需要的只是用增加的输入{0，1，2，3，…}来称呼它。我们甚至可以以任何值开始输入序列。</p><p>  For some reason, I remembered from first-year Finite Mathematics that when  p is a prime number, \(x^2\,\bmod\,p \) has some interesting properties. Numbers produced this way are called  quadratic residues, and we can compute them in C using the expression  x * x % p. In particular, the quadratic residue of  x is unique as long as \(2x &lt; p \). For example, when  p = 11, the quadratic residues of 0, 1, 2, 3, 4, 5 are all unique:</p><p>  出于某种原因，我从一年级有限数学中记得，当p是素数时，\（x ^ 2 \，\ bmod \，p \）具有一些有趣的特性。以这种方式产生的数字称为二次余数，我们可以使用表达式x * x％p在C中计算它们。特别地，x的二次残基只要\（2x ＜p \）是唯一的。例如，当p = 11时，二次残基0、1、2、3、4、5都是唯一的：</p><p>     As luck would have it, it also happens that for the remaining integers, the expression  p - x * x % p fits perfectly into the remaining slots. This only works for primes  p which satisfy \(p \equiv 3\,\bmod\,4 \).</p><p>     幸运的是，对于剩余的整数，表达式p-x * x％p也恰好适合剩余的插槽。这仅适用于满足\（p \ equiv 3 \，\ bmod \，4 \）的素数p。</p><p>    This gives us a one-to-one permutation on the integers less than  p, where  p can be any prime satisying \(p \equiv 3\,\bmod\,4 \). Seems like a nice tool for building our custom PRNG.</p><p>    这使我们对小于p的整数进行一对一置换，其中p可以是满足\（p \ equiv 3 \，\ bmod \，4 \）的任何素数。似乎是构建自定义PRNG的好工具。</p><p>  In the case of our custom PRNG, we want a permutation which works on the entire range of 32-bit integers. However, 2 32 is not a prime number. The closest prime number less than 2 32 is 4294967291, which happens to satisfy \(p \equiv 3\,\bmod\,4 \). As a compromise, we can write a C++ function which permutes all integers below this prime, and simply maps the 5 remaining integers to themselves.</p><p>  就我们的自定义PRNG而言，我们需要一个排列，该排列适用于整个32位整数范围。但是，2 32不是质数。小于2 32的最接近质数是4294967291，它恰好满足\（p \ equiv 3 \，\ bmod \，4 \）。作为一种折衷方案，我们可以编写一个C ++函数，对所有低于此质数的整数进行置换，然后将剩余的5个整数相互映射。 </p><p>  unsigned  int permuteQPR( unsigned  int x){  static  const  unsigned  int prime =  4294967291;  if (x &gt;= prime)  return x;  // The 5 integers out of range are mapped to themselves.  unsigned  int residue = (( unsigned  long  long) x * x) % prime;  return (x &lt;= prime /  2) ? residue : prime - residue;}</p><p>unsigned int permuteQPR（无符号int x）{  静态const unsigned int质数= 4294967291;  如果（x＆gt; =质数）  返回x; //超出范围的5个整数将映射到它们自己。  无符号整数残基=（（（unsigned long long）x x x）％素数;  返回（x＆lt; =素数/ 2）？残留物：素-残留物;}</p><p>  This function, on its own, is not the world’s best permutation – it tends to cluster output values for certain ranges of input – but it is one-to-one. As such, we can combine it with other one-to-one functions, such as addition and XOR, to achieve a much better permutation. I found the following expression works reasonably well. The  intermediateOffset variable acts as a seed, putting a variety of different sequences at our disposal.</p><p>  此功能本身并不是世界上最好的排列-它倾向于将输出值聚集在某些输入范围内-但它是一对一的。因此，我们可以将其与其他一对一功能（例如加法和XOR）结合使用，以实现更好的置换。我发现以下表达式相当有效。 IntermediateOffset变量充当种子，使我们可以使用各种不同的序列。</p><p>    On GitHub, I’ve  posted a C++ class which implements a pseudo-random number generator based on this expression.</p><p>    在GitHub上，我发布了一个C ++类，该类基于该表达式实现了伪随机数生成器。</p><p>    I’ve also posted a  working project to verify that this PRNG really does output a cycle of 2 32 unique integers.</p><p>    我还发布了一个工作项目，以验证PRNG确实输出2 32个唯一整数的循环。</p><p>    So, how does the  randomness of this generator stack up? I’m not a PRNG expert, so I put my trust in  TestU01, a library for testing the quality of PRNGs, published by the University of Montreal.  Here’s some test code to put our newly conceived PRNG through its paces. It passes all 15 tests in TestU01’s SmallCrush test suite, which I guess is pretty decent. It also passes  140/144 tests in the more stringent Crush suite.</p><p>    那么，该发生器的随机性如何堆积？我不是PRNG专家，所以我信任由蒙特利尔大学发布的TestU01，这是一个用于测试PRNG质量的库。这是一些测试代码，可以使我们新构思的PRNG逐步发展。它通过了TestU01的SmallCrush测试套件中的所有15个测试，我认为这相当不错。它还在更严格的Crush套件中通过了140/144测试。</p><p>  ========= Summary results of SmallCrush ========= Version: TestU01 1.2.3 Generator: ursu_CreateRSU Number of statistics: 15 Total CPU time: 00:00:49.95 All tests were passed</p><p>  ========= SmallCrush的摘要结果========= 版本：TestU01 1.2.3 生成器：ursu_CreateRSU 统计数量：15 CPU总时间：00：00：49.95 所有测试均通过</p><p>  Perhaps this approach for generating a sequence of unique random numbers is already known, or perhaps it shares attributes with existing PRNGs. If so, I’d be interested to find out. If you wanted, you could probably adapt it to work on ranges of integers other than 2 32 as well. Surfing around, I noticed that OpenBSD implements  another non-repeating PRNG, though I’m not sure their implementation is cyclical or covers the entire number space.</p><p>  可能已经知道这种用于生成唯一随机数序列的方法，或者它可能与现有PRNG共享属性。如果是这样，我很想找出答案。如果需要，您可能也可以使其适应于除2 32以外的整数范围。环顾四周，我注意到OpenBSD实现了另一个非重复的PRNG，尽管我不确定它们的实现是周期性的还是覆盖整个数字空间。 </p><p>  Incidentally, this PRNG is used in my next post,  This Hash Table Is Faster Than a Judy Array.</p><p>顺便说一句，我的下一篇文章“此哈希表比Judy数组快”中使用了PRNG。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://preshing.com/20121224/how-to-generate-a-sequence-of-unique-random-integers/">https://preshing.com/20121224/how-to-generate-a-sequence-of-unique-random-integers/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/整数/">#整数</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sequence/">#sequence</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>