<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Boyer-Moore String搜索算法说明和正式验证 Boyer-Moore string search algorithm explanation and formal verification</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Boyer-Moore string search algorithm explanation and formal verification<br/>Boyer-Moore String搜索算法说明和正式验证 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-23 10:54:19</div><div class="page_narrow text-break page_content"><p>If a substring would be compared in reverse order, things may be different.For example, we search for a &#39;CAT&#39; substring in &#39;HORSE TURTLE CAT&#39; string.</p><p>如果以相反的顺序比较子字符串，事情可能会有所不同。例如，我们搜索A＆＃39; Cat＆＃39; ＆＃39;马龟猫＆＃39;细绳。</p><p> With naive algorithm, we will first compare &#39;H&#39; and &#39;C&#39;, we see they are unequal characters and we will advance substringone character ahead:</p><p> 凭借天真的算法，我们将首先比较＆＃39; h＆＃39;和＆＃39; c＆＃39;我们认为它们是不平等的字符，我们将前进的子串字符：</p><p>  Right, but what if we will start at the end of &#39;CAT&#39; substring proceeding back?We first compare &#39;R&#39; with &#39;T&#39; (last character of &#39;CAT&#39;) and we see that they are not equal.We could advance substring one character ahead, but...Can&#39;t we see that &#39;R&#39; character in the middle of &#39;HORSE&#39; part is absent in the &#39;CAT&#39; substring?Can&#39;t this tell us something useful?Yes -- since &#39;R&#39; is not in &#39;CAT&#39;, we can advance &#39;CAT&#39; substring more, because we know that this will fail for sure:</p><p>  对，但如果我们将从＆＃39的结尾开始何时何地;猫＆＃39;追溯到问题？我们首先比较＆＃39; r＆＃39;与＃39; t＆＃39; （＆＃39的最后一个字符;猫＆＃39;）我们看到他们不是相等的。我们可以提前一个角色前进，但是......可以＆＃39;我们看到它和＃39; r＆＃39;中间的性格＆＃39;马＆＃39;部分在＆＃39; cat＆＃39; Substring？可以＆＃39;这告诉我们一些有用的东西吗？是 - 自从＆＃39; r＆＃39;不是在＆＃39;猫＆＃39;我们可以推进＆＃39; cat＆＃39;细分更多，因为我们知道这将肯定会失败：</p><p>    So if we see a character not in &#39;CAT&#39;, we can advance 3 characters ahead:</p><p>    所以，如果我们看到一个人的角色而不是＃39;猫＆＃39;我们可以前进3个字符：</p><p>  But this will fail too, also, the space (&#39; &#39;) character is absent in &#39;CAT&#39; too.OK, we advance 3 characters ahead:</p><p>  但这也会失败，也是空间（＆＃39;＆＃39;）字符缺席＆＃39; cat＆＃39; TOOK，我们前进3个字符：</p><p>      This is important. &#39;A&#39; != &#39;T&#39;, but &#39;A&#39; is in the &#39;CAT&#39; substring, so this time we advance only 1 character ahead,as in naive search algorithm:</p><p>      这个很重要。 ＆＃39; a＆＃39; ！=＆＃39; t＆＃39;，但＆＃39; a＆＃39;在＆＃39; cat＆＃39;子字段，所以这次我们前进的只有1个字符，如在天真的搜索算法中：</p><p>   All this is way faster than naive string search algorith, and is a strong competitor with Knuth-Morris-Pratt algorithm.</p><p>   所有这些都比天真的字符串搜索算法快，并且是一个强大的竞争对手，具有Knuth-Morris-Pratt算法。 </p><p> This is the source code of a function that is hardcoded to search for &#39;cat&#39; substring, nothing else:</p><p>这是一个硬逻辑搜索＆＃39的函数的源代码; cat＆＃39;基下，没有其他的：</p><p> unsigned search_cat_BM_v1 (char *s, unsigned len){ if (len&lt;3) return len; // not found unsigned skip; for (unsigned i=0; i&lt;len-2; ) { skip=1; // default skip char char3=s[i+2]; // read operation if (char3==&#39;t&#39;) { char char2=s[i+1]; // read operation if (char2==&#39;a&#39;) { char char1=s[i]; // read operation if (char1==&#39;c&#39;) return i; // found else { // 1st character isn&#39;t &#39;c&#39; if ((char1!=&#39;c&#39;) &amp;&amp; (char1!=&#39;a&#39;) &amp;&amp; (char1!=&#39;t&#39;)) skip=3; } } else { // 2nd character isn&#39;t &#39;a&#39; if ((char2!=&#39;c&#39;) &amp;&amp; (char2!=&#39;a&#39;) &amp;&amp; (char2!=&#39;t&#39;)) skip=3; } } else { // 3rd character isn&#39;t &#39;t&#39; if ((char3!=&#39;c&#39;) &amp;&amp; (char3!=&#39;a&#39;) &amp;&amp; (char3!=&#39;t&#39;)) skip=3; } i=i+skip; } return len; // not found};</p><p> unsigned search_cat_bm_v1（char * s，unsigned len）{if（len＆lt 3）返回len; //找不到无符号跳过; for（无符号i = 0; i＆lt; len-2;）{skip = 1; //默认跳过char char3 = s [i + 2]; //读取操作if（char3 ==＆＃39; t＆＃39;）{char char2 = s [i + 1]; //读取操作if（char2 ==＆＃39; a＆＃39;）{char char1 = s [i]; //读取操作if（char1 ==＆＃39; c＆＃39;）返回i; //发现否则{// 1st字符ISN＆＃39; t＆＃39; c＆＃39; if（（char1！=＆＃39; c＆＃39;）＆amp;（char1！=＆＃39; a＆＃39;）＆amp;（char1！=＆＃39; t＆＃39;）） Skip = 3; }}别的{// 2nd字符ISN＆＃39; T＆＃39; A＆＃39; if（（char2！=＆＃39; c＆＃39;）＆amp;（char2！=＆＃39; a＆＃39;）＆amp;（char2！=＆＃39; t＆＃39;）） Skip = 3; }} else {//第3个字符ISN＆＃39; t＆＃39; t＆＃39; if（（char3！=＆＃39; c＆＃39;）＆amp;（char3！=＆＃39; a＆＃39;）＆amp;（char3！=＆＃39; t＆＃39;）） Skip = 3;我= i +跳过;返回len; // 未找到};</p><p>  ** cacatsearch_cat_brute read_ops=7search_cat_BM_v1 read_ops=5** cac catsearch_cat_brute read_ops=10search_cat_BM_v1 read_ops=5** cac cac catsearch_cat_brute read_ops=17search_cat_BM_v1 read_ops=7** horse turtle catsearch_cat_brute read_ops=16search_cat_BM_v1 read_ops=8** horse cat turtlesearch_cat_brute read_ops=9search_cat_BM_v1 read_ops=5</p><p>  ** cacatsearch_cat_brute read_ops = 7search_cat_BM_v1 read_ops = 5 ** CAC catsearch_cat_brute read_ops = 10search_cat_BM_v1 read_ops = 5 ** CAC CAC catsearch_cat_brute read_ops = 17search_cat_BM_v1 read_ops = 7 **马龟catsearch_cat_brute read_ops = 16search_cat_BM_v1 read_ops = 8 **马猫turtlesearch_cat_brute read_ops = 9search_cat_BM_v1 read_ops = 5</p><p>  Now the next observation. If we search for &#39;CAT&#39; and &#39;CACAT&#39;, we see that &#39;C&#39; != &#39;T&#39;, but &#39;C&#39; is in the &#39;CAT&#39; substring, so we wouldadvance by one character.</p><p>  现在下一次观察。如果我们搜索＆＃39; cat＆＃39;和＃39; Cacat＆＃39;我们看到了它和＃39; C＆＃39; ！=＆＃39; t＆＃39 ;,,,,,,,,,,,,,,）在＆＃39; cat＆＃39;子字符串，所以我们是一个角色的人。</p><p>  But... we can also  align substring so that the first &#39;C&#39; character in &#39;CAT&#39; would match the next &#39;C&#39; in &#39;CACAT&#39;,by advancing for 2 characters ahead:</p><p>  但是......我们还可以对齐子字符串，使第一个＆＃39; c＆＃39; ＆＃39; cat＆＃39;会匹配下一个＆＃39; c＆＃39;在＆＃39; cacat＆＃39;，通过推进2个字符：</p><p>  We add a rule:&#34;if a mismatched character in string exist in substring,  align substring so that they would match&#34;or, in other words,&#34;if &#39;C&#39; in string isn&#39;t equal to the last character in &#39;CAT&#39; substring, advance by 2 characters&#34;:</p><p>  我们添加规则：＆＃34;如果字符串中存在错配的字符，则对齐子字符串，使它们与其匹配＆＃34;或者，换句话说，＆＃34;如果＆＃39; c＆＃39;在字符串中＆＃39; t等于＆＃39的最后一个字符; cat＆＃39;细分，提前2个字符＆＃34 ;:</p><p> if (char3==&#39;t&#39;) { ... } else { // 3rd character isn&#39;t &#39;t&#39; if ((char3!=&#39;c&#39;) &amp;&amp; (char3!=&#39;a&#39;) &amp;&amp; (char3!=&#39;t&#39;)) skip=3; if (char3==&#39;c&#39;) // added skip=2; // added } i=i+skip;</p><p> if（char3 ==＆＃39; t＆＃39;）{...} else {// 3rd字符ISN＆＃39; t＆＃39; t＆＃39; if（（char3！=＆＃39; c＆＃39;）＆amp;（char3！=＆＃39; a＆＃39;）＆amp;（char3！=＆＃39; t＆＃39;）） Skip = 3; if（char3 ==＆＃39; c＆＃39;）//添加skip = 2; //添加} i = i + skip; </p><p>   As of aligning &#39;A&#39; character in the middle of &#39;CAT&#39; substring --we wouldn&#39;t bother, because advancing substring by one character it&#39;s the same as is done by default.</p><p>＆＃39; a＆＃39; ＆＃39中间的角色; cat＆＃39;子字符串 - 我们＆＃39; t打扰，因为推进一个字符的子字符串它＆＃39;默认情况下相同。</p><p>  And this is the universal algorithm from the R.Sedgewick&#39;s book, the first function construct a table of &#39;skips&#39;,the second does the actual search (Java code):</p><p>  这是来自R.Sedgewick＆＃39;书籍的通用算法，第一个功能构建了一个＆＃39;跳过＆＃39;，第二个是实际的搜索（Java代码）：</p><p> public BoyerMoore(String pat) { this.R = 256; this.pat = pat; // position of rightmost occurrence of c in the pattern right = new int[R]; for (int c = 0; c &lt; R; c++) right[c] = -1; for (int j = 0; j &lt; pat.length(); j++) right[pat.charAt(j)] = j; }... public int search(String txt) { int m = pat.length(); int n = txt.length(); int skip; for (int i = 0; i &lt;= n - m; i += skip) { skip = 0; for (int j = m-1; j &gt;= 0; j--) { if (pat.charAt(j) != txt.charAt(i+j)) { skip = Math.max(1, j - right[txt.charAt(i+j)]); break; } } if (skip == 0) return i; // found } return n; // not found</p><p> 公共博伊奥雷（String Pat）{this.r = 256;这个.pat = pat; //模式在模式中最右边的位置右= new int [r]; for（int c = 0; c＆lt; r; c ++）右[c] = -1; for（int j = 0; j＆lt; pat.length（）; j ++）右[pat.charat（j）] = j; } ...公共int搜索（字符串txt）{int m = pat.length（）; int n = txt.length（）; int skip; for（int i = 0; i＆lt; = n  -  m; i + = skip）{skip = 0; for（int j = m-1; j＆gt; = 0; j--）{if（pat.charat（j）！= txt.charat（i + j））{skip = math.max（1，j  - 对[txt.charat（i + j）]）;休息; }}如果（skip == 0）返回i; //发现}返回n; // 未找到</p><p>  And what if we search for &#39;COCOS&#39; substring?What if characters are repeating within search pattern?Well, we will count only rightmost characters, ignoring two first &#39;CO&#39;.</p><p>  如果我们搜索＆＃39; cocos＆＃39; Substring？如果字符在搜索模式中重复字符是什么？好吧，我们只计算最右边的角色，忽略两个第一个和＃39; CO＆＃39;</p><p>    ...Unwinding loop search_cat_BM_v1.0 iteration 42 file BM_cat_v1.c line 36 function search_cat_BM_v1 thread 0Unwinding loop search_cat_BM_v1.0 iteration 43 file BM_cat_v1.c line 36 function search_cat_BM_v1 thread 0Unwinding loop search_cat_BM_v1.0 iteration 44 file BM_cat_v1.c line 36 function search_cat_BM_v1 thread 0Unwinding loop search_cat_BM_v1.0 iteration 45 file BM_cat_v1.c line 36 function search_cat_BM_v1 thread 0Unwinding loop search_cat_BM_v1.0 iteration 46 file BM_cat_v1.c line 36 function search_cat_BM_v1 thread 0Unwinding loop search_cat_BM_v1.0 iteration 47 file BM_cat_v1.c line 36 function search_cat_BM_v1 thread 0...</p><p>    ...展开循环搜索_cat_bm_v1.0迭代42文件bm_cat_v1.c线36函数search_cat_bm_v1线程0unwinding loop search_cat_bm_v1.0迭代43文件bm_cat_v1.c线36函数search_cat_bm_v1线程0unwinding循环搜索_cat_bm_v1.0迭代44文件bm_cat_v1.c行36功能search_cat_bm_v1线程0unwinding循环搜索_cat_bm_v1.0迭代45文件bm_cat_v1.c线36函数search_cat_bm_v1线程0unwinding循环搜索_cat_bm_v1.0迭代46文件bm_cat_v1.c线36功能search_cat_bm_v1线程0unwinding循环搜索_cat_bm_v1.0迭代47文件bm_cat_v1.c线36功能search_cat_bm_v1线程0 ......</p><p>  for (unsigned i=0; i&lt;len-2; ) { skip=1; ... { if ((char3!=&#39;c&#39;) &amp;&amp; (char3!=&#39;a&#39;) &amp;&amp; (char3!=&#39;t&#39;)) skip=3; } i=i+skip; }</p><p>  for（无符号i = 0; i＆lt; len-2;）{skip = 1; ... {if（（char3！=＆＃39; c＆＃39;）＆amp;（char3！=＆＃39; a＆＃39;）＆amp;（char3！=＆＃39; t＆＃ 39;））Skip = 3;我= i +跳过; }</p><p>   unsigned search_cat_brute (char *s, unsigned len){ if (len&lt;3) return len; // not found for (unsigned i=0; i&lt;len-2; i++) { if (s[i]==&#39;c&#39; &amp;&amp; s[i+1]==&#39;a&#39; &amp;&amp; s[i+2]==&#39;t&#39;) return i; }; return len; // not found};unsigned loop_body (char *s, unsigned *i_ptr){ unsigned i=*i_ptr; // get i unsigned skip=1; // default skip char char3=s[i+2]; // read operation if (char3==&#39;t&#39;) { char char2=s[i+1]; // read operation if (char2==&#39;a&#39;) { char char1=s[i]; // read operation if (char1==&#39;c&#39;) { return 1; // found } else { // 1st character isn&#39;t &#39;c&#39; if ((char1!=&#39;c&#39;) &amp;&amp; (char1!=&#39;a&#39;) &amp;&amp; (char1!=&#39;t&#39;)) skip=3; } } else { // 2nd character isn&#39;t &#39;a&#39; if ((char2!=&#39;c&#39;) &amp;&amp; (char2!=&#39;a&#39;) &amp;&amp; (char2!=&#39;t&#39;)) skip=3; } } else { // 3rd character isn&#39;t &#39;t&#39; if ((char3!=&#39;c&#39;) &amp;&amp; (char3!=&#39;a&#39;) &amp;&amp; (char3!=&#39;t&#39;)) skip=3; if (char3==&#39;c&#39;) skip=2; } i=i+skip; *i_ptr=i; // store back return 0;};unsigned search_cat_unrolled_v2 (char *s, unsigned len){ if (len&lt;3) return len; // not found unsigned i=0; // for len=[3..15] if (loop_body(s, &amp;i)) return i; if (i&gt;=(len-2)) return len; if (loop_body(s, &amp;i)) return i; if (i&gt;=(len-2)) return len; if (loop_body(s, &amp;i)) return i; if (i&gt;=(len-2)) return len; if (loop_body(s, &amp;i)) return i; if (i&gt;=(len-2)) return len; if (loop_body(s, &amp;i)) return i; if (i&gt;=(len-2)) return len; if (loop_body(s, &amp;i)) return i; if (i&gt;=(len-2)) return len; if (loop_body(s, &amp;i)) return i; if (i&gt;=(len-2)) return len; if (loop_body(s, &amp;i)) return i; if (i&gt;=(len-2)) return len; if (loop_body(s, &amp;i)) return i; if (i&gt;=(len-2)) return len; if (loop_body(s, &amp;i)) return i; if (i&gt;=(len-2)) return len; if (loop_body(s, &amp;i)) return i; if (i&gt;=(len-2)) return len; if (loop_body(s, &amp;i)) return i; if (i&gt;=(len-2)) return len; if (loop_body(s, &amp;i)) return i; if (i&gt;=(len-2)) return len; return len; // not found};#ifdef CBMCvoid check(){ unsigned len=LEN; char s[len]; __CPROVER_assert (search_cat_brute(s, len)==search_cat_unrolled_v2(s, len), &#34;assert&#34;);};#endif</p><p>   unsigned search_cat_brute（char * s，unsigned len）{if（len＆lt; 3）返回len; //找不到（无符号i = 0; i＆lt; len-2; i ++）{if（s [i] ==＆＃39; c＆＃39;＆amp;＆amp;＆amp; s [i + 1] ==＆＃ 39; A＆＃39;＆amp;＆amp; s [i + 2] ==＆＃39; t＆＃39;）返回我; };返回len; //找不到};未签名的循环（char * s，unsigned * i_ptr）{unsigned i = * i_ptr; //获得unsigned skip = 1; //默认跳过char char3 = s [i + 2]; //读取操作if（char3 ==＆＃39; t＆＃39;）{char char2 = s [i + 1]; //读取操作if（char2 ==＆＃39; a＆＃39;）{char char1 = s [i]; //读取操作if（char1 ==＆＃39; c＆＃39;）{返回1; //找到} els {// 1st字符ISN＆＃39; T＆＃39; C＆＃39; if（（char1！=＆＃39; c＆＃39;）＆amp;（char1！=＆＃39; a＆＃39;）＆amp;（char1！=＆＃39; t＆＃39;）） Skip = 3; }}别的{// 2nd字符ISN＆＃39; T＆＃39; A＆＃39; if（（char2！=＆＃39; c＆＃39;）＆amp;（char2！=＆＃39; a＆＃39;）＆amp;（char2！=＆＃39; t＆＃39;）） Skip = 3; }} else {//第3个字符ISN＆＃39; t＆＃39; t＆＃39; if（（char3！=＆＃39; c＆＃39;）＆amp;（char3！=＆＃39; a＆＃39;）＆amp;（char3！=＆＃39; t＆＃39;）） Skip = 3; if（char3 ==＆＃39; c＆＃39;）skip = 2;我= i +跳过; * i_ptr = i; //返回返回0;};未签名搜索_cat_unrolled_v2（char * s，unsigned len）{if（len＆lt 3）返回len; //找不到无符号i = 0; //对于len = [3..15] if（loop_body（s，＆amp; i））返回i;如果（i＆gt; =（len-2））返回len;如果（Loop_Body（s，＆amp; i））返回i;如果（i＆gt; =（len-2））返回len;如果（Loop_Body（s，＆amp; i））返回i;如果（i＆gt; =（len-2））返回len;如果（Loop_Body（s，＆amp; i））返回i;如果（i＆gt; =（len-2））返回len;如果（Loop_Body（s，＆amp; i））返回i;如果（i＆gt; =（len-2））返回len;如果（Loop_Body（s，＆amp; i））返回i;如果（i＆gt; =（len-2））返回len;如果（Loop_Body（s，＆amp; i））返回i;如果（i＆gt; =（len-2））返回len;如果（Loop_Body（s，＆amp; i））返回i;如果（i＆gt; =（len-2））返回len;如果（Loop_Body（s，＆amp; i））返回i;如果（i＆gt; =（len-2））返回len;如果（Loop_Body（s，＆amp; i））返回i;如果（i＆gt; =（len-2））返回len;如果（Loop_Body（s，＆amp; i））返回i;如果（i＆gt; =（len-2））返回len;如果（Loop_Body（s，＆amp; i））返回i;如果（i＆gt; =（len-2））返回len;如果（Loop_Body（s，＆amp; i））返回i;如果（i＆gt; =（len-2））返回len;返回len; //找不到};＃ifdef cbmcvoid检查（）{unsigned len = len; char s [len]; __cprover_assert（search_cat_brute（s，len）== search_cat_unrolled_v2（s，len），＆＃34;断言＆＃34;）;＃结束 </p><p>  % time cbmc --trace --function check -DLEN=14 -DCBMC BM_cat_1_v2.cCBMC version 5.10 (cbmc-5.10) 64-bit x86_64 linuxParsing BM_cat_1_v2.cConvertingType-checking BM_cat_1_v2Generating GOTO ProgramAdding CPROVER library (x86_64)Removal of function pointers and virtual functionsGeneric Property InstrumentationRunning with 8 object bits, 56 offset bits (default)Starting Bounded Model CheckingUnwinding loop search_cat_brute.0 iteration 1 file BM_cat_1_v2.c line 11 function search_cat_brute thread 0Unwinding loop search_cat_brute.0 iteration 2 file BM_cat_1_v2.c line 11 function search_cat_brute thread 0Unwinding loop search_cat_brute.0 iteration 3 file BM_cat_1_v2.c line 11 function search_cat_brute thread 0Unwinding loop search_cat_brute.0 iteration 4 file BM_cat_1_v2.c line 11 function search_cat_brute thread 0Unwinding loop search_cat_brute.0 iteration 5 file BM_cat_1_v2.c line 11 function search_cat_brute thread 0Unwinding loop search_cat_brute.0 iteration 6 file BM_cat_1_v2.c line 11 function search_cat_brute thread 0Unwinding loop search_cat_brute.0 iteration 7 file BM_cat_1_v2.c line 11 function search_cat_brute thread 0Unwinding loop search_cat_brute.0 iteration 8 file BM_cat_1_v2.c line 11 function search_cat_brute thread 0Unwinding loop search_cat_brute.0 iteration 9 file BM_cat_1_v2.c line 11 function search_cat_brute thread 0Unwinding loop search_cat_brute.0 iteration 10 file BM_cat_1_v2.c line 11 function search_cat_brute thread 0Unwinding loop search_cat_brute.0 iteration 11 file BM_cat_1_v2.c line 11 function search_cat_brute thread 0Unwinding loop search_cat_brute.0 iteration 12 file BM_cat_1_v2.c line 11 function search_cat_brute thread 0size of program expression: 2118 stepssimple slicing removed 2 assignmentsGenerated 1 VCC(s), 1 remaining after simplificationPassing problem to propositional reductionconverting SSARunning propositional reductionPost-processingSolving with MiniSAT 2.2.1 with simplifier29262 variables, 75920 clausesSAT checker: instance is UNSATISFIABLERuntime decision procedure: 0.36729s** Results:[check.assertion.1] assert: SUCCESS** 0 of 1 failed (1 iteration)VERIFICATION SUCCESSFUL</p><p>％time cbmc -trace  - 障碍校验-dlen = 14 -dcbmc bm_cat_1_v2.ccbmc 5.10（cbmc-5.10）64位x86_64 linuxparsing bm_cat_1_v2.cconvertingtype-checking bm_cat_1_v2generation goto程序加工cprover库（x86_64）删除函数指针和虚拟函数generic属性使用8个对象位，56偏移位（默认）启动界限模型检查unwinding loop search_cat_brute.0迭代1文件bm_cat_1_v2.c行11函数search_cat_brute thread 0unwinding循环搜索_cat_brute.0迭代2文件bm_cat_1_v2.c行11函数search_cat_brute thread 0unwinding循环搜索_cat_brute.0迭代3文件bm_cat_1_v2.c行函数search_cat_brute线程0unwinding loop search_cat_brute.0迭代4文件bm_cat_1_v2.c行11函数search_cat_brute thread 0unwinding循环搜索_cat_brute.0迭代5 file bm_cat_1_v2.c行11函数search_cat_brute线程0unwinding循环搜索_cat_brute .0迭代6文件bm_cat_1_v2.c行11 fu nuple search_cat_brute thread 0unwinding循环搜索_cat_brute.0迭代7文件bm_cat_1_v2.c行11函数search_cat_brute thread 0unwinding循环搜索_cat_brute.0迭代8文件bm_cat_1_v2.c行11函数search_cat_brute thread 0unwinding循环搜索_cat_brute.0迭代9文件bm_cat_1_v2.c行11函数search_cat_brute线程0unwinding循环搜索_cat_brute.0迭代10文件bm_cat_1_v2.c行11函数search_cat_brute thread 0unwinding循环搜索_cat_brute.0迭代11文件bm_cat_1_v2.c行11函数search_cat_brute thread 0unwinding循环搜索_cat_brute.0迭代12文件bm_cat_1_v2.c行11函数search_cat_brute线程0size程序表达式：2118步骤Simple Slicing删除了2分配1.剩余的1 VCC（S），1剩余的问题在简化的问题上归因于将Sarunning命令转移的Ssarunning命令转移降低 - 处理为MiniSAT 2.2.1与简单的29262变量，75920 Clausessat检查器：实例一s Unsatefiableruntime决定程序：0.36729S **结果：[Check.Assertion.1]断言：成功** 0的1失败（1次迭代）验证成功</p><p>  If you modify these lines so that this conditional expression would compare with other characters...</p><p>  如果修改这些行，以便此条件表达式与其他字符相比......</p><p>  CBMC will still verify this algorithm and prove its correctness, because a bug here wouldn&#39;t make the algorithm incorrect.It will degrade its performance to a level of naive string search algorithm, as if &#39;skip=3&#39; here would be replaced with &#39;skip=1&#39;.It will still work correctly, but slower.</p><p>  CBMC仍将验证此算法并证明其正确性，因为这里的错误不会使算法不正确。它会降低其对天真字符串搜索算法的级别，as＆＃39; skip = 3＆＃39 ;这里将被替换为＆＃39; skip = 1＆＃39;。它仍然可以正常工作，但慢。</p><p>     It coincides with &#39;delta1&#39; rule from  the original Boyer-Moore paper.But there is also a &#39;delta2&#39; rule, which is just another story for another blog post.</p><p>     它与＆＃39; delta1＆＃39一致;来自原来的博伊尔摩尔纸的规则。但还有一个＆＃39; delta2＆＃39;规则，这只是另一个博客帖子的另一个故事。</p><p>     Please drop me email about bug(s) and/or suggestion(s):  blog@yurichev.com. List of other blog posts.BTW,  I&#39;m teaching.Follow me in social networks: Twitter, Telegram, GitHub, Discord, Facebook.</p><p>     请将我删除关于Bug（s）和/或建议的电子邮件：blog@yurichev.com。其他博客文章列表.BTW，我＆＃39;米教学。在社交网络中关注我：Twitter，电报，Github，Discord，Facebook。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://yurichev.com/news/20210421_boyer_moore/">https://yurichev.com/news/20210421_boyer_moore/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/算法/">#算法</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/moore/">#moore</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/字符/">#字符</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>