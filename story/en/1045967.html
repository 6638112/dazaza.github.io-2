<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我们可以谈谈客户端证书吗？ Can we talk about client-side certificates?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Can we talk about client-side certificates?<br/>我们可以谈谈客户端证书吗？ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-23 15:00:42</div><div class="page_narrow text-break page_content"><p>I’m working on improving the means by which API users authenticate with theSourceHut API. Today, I was reading  RFC 6749 (OAuth2) for this purpose,and it got me thinking about the original OAuth spec. I recalled vaguely that ithad the API clients actually  sign every request, and…  yep, indeed itdoes. This also got me thinking: what else signs requests? TLS!</p><p>我正在努力改进API用户通过SourceHut API进行身份验证的方式。今天，我正在为此目的阅读RFC 6749（OAuth2），这让我开始思考原始的OAuth规范。我隐约地回忆起，API客户端实际上在每个请求上签名了，是的，确实如此。这也让我开始思考：还有什么要求？ TLS！</p><p> OAuth is very complicated. The RFC is 76 pages long, the separate bearer tokenRFC (6750) is another 18, and no one has ever read either of them. Add JSON WebTokens (RFC 7519, 30 pages), too. The process is complicated and everyoneimplements it themselves — a sure way to make mistakes in asecurity-critical component. Not all of the data is authenticated, nocryptography is involved at any step, and it’s easy for either party to end upin an unexpected state. The server has to deal with problems of revocation andgenerating a secure token itself. Have you ever met anyone who feels positivelyabout OAuth?</p><p> OAuth非常复杂。 RFC的长度为76页，单独的承载令牌RFC（6750）的长度为18页，并且从未有人阅读过它们。还要添加JSON WebToken（RFC 7519，30页）。该过程很复杂，每个人都可以自己执行-这是在安全性至关重要的组件中犯错误的可靠方法。并非所有数据都经过身份验证，任何步骤都涉及加密，而且任何一方很容易以意外状态结束。服务器必须处理自身撤消和生成安全令牌的问题。您是否遇到过对OAuth持肯定态度的人？</p><p> Now, take a seat. Have a cup of coffee. I want to talk about client-sidecertificates. Why didn’t they take off? Let’s sketch up a hypothetical TLS-basedprotocol as an alternative to OAuth. Picture the following…</p><p> 现在坐喝杯咖啡。我想谈谈客户端证书。他们为什么不起飞？让我们草拟一个假设的基于TLS的协议，以替代OAuth。图片如下...</p><p> You, an API client developer, generate a certificate authority andintermediate, and you upload your CA certificate to the Service Provider aspart of your registration as a user agent.</p><p> 作为API客户端开发人员，您需要生成证书颁发机构和中级证书，然后将CA证书作为注册为用户代理的一部分上载到服务提供商。</p><p> When you want a user to authorize you to access their account, you generate acertificate for them, and redirect them to the Service Provider’sauthorization page with a  CSRin tow. Your certificate includes, among other things, the list of authorizedscopes for which you want to be granted access. It is already signed withyour client CA key, or one of its intermediates.</p><p> 如果您希望用户授权您访问其帐户，则会为其生成证书，然后将其重定向到带有CSRin拖曳的服务提供商的授权页面。您的证书包括（其中包括）您想要被授予访问权限的授权范围列表。它已经使用您的客户端CA密钥或其中间体之一进行了签名。</p><p> The client reviews the desired access, and consents. They are redirected backto your API client application, along with the signed certificate.</p><p> 客户检查所需的访问权限并表示同意。它们连同签名的证书一起被重定向回您的API客户端应用程序。</p><p>  TLS is basically the single most ironclad, battle-tested security mechanism onthe internet, and mature implementations are available for every platform.Everyone implements OAuth themselves, and often poorly.</p><p>  TLS基本上是互联网上经过最严格，最可靠的安全测试的机制，并且每个平台都可以使用成熟的实现方式。每个人都自己实现OAuth，而且通常实施情况很差。 </p><p> Client-side certificates are stateless. They contain all of the informationnecessary to prove that the client is entitled to access.</p><p>客户端证书是无状态的。它们包含证明客户有权访问的所有必要信息。</p><p> If you handle SSL termination with nginx, haproxy, etc, you can rejectunauthorized requests before your application backend ever even sees them.</p><p> 如果您使用nginx，haproxy等处理SSL终止，则可以在应用程序后端甚至看到未经授权的请求之前就拒绝它们。</p><p> The service provider can untrust the client’s CA in a single revocation, ifthey are malicious or lose their private keys.</p><p> 如果服务提供商是恶意的或丢失了其私钥，则可以通过一次吊销来取消信任客户的CA。</p><p> The API client and service provider are both always certain that the processwas deliberately initiated by the API client. No weird state tokens to carrythrough the process like OAuth uses!</p><p> API客户端和服务提供者都始终确定该过程是由API客户端故意启动的。没有像OAuth一样使用怪异的状态令牌来进行该过程！</p><p> Lots of free features: any metadata you like, built-in expirations, APIclients can self-organize into intermediates at their discretion, and so on.</p><p> 许多免费功能：您喜欢的任何元数据，内置的到期时间，APIclients都可以自行决定将其自组织为中间体，等等。</p><p> Security-concious end users can toggle a flag in their account which would, aspart of the consent process, ask them to sign the API client’s certificatethemselves, before the signed certificate is returned to the API client. Thenany API request authorized for that user’s account has to be signed by the APIclient, the service provider,  and the user to be valid.</p><p> 具有安全意识的最终用户可以在其帐户中切换一个标志，该标志将作为同意过程的一部分，要求他们在将签名的证书返回给API客户端之前自行对API客户端的证书进行签名。然后，必须由API客户端，服务提供商和用户对授权用于该用户帐户的任何API请求进行签名。</p><p> Here’s another example: say your organization has several services, each ofwhich interacts with a subset of Acme Co’s API on behalf of their users. Yourorganization generates a single root CA, and signs up for Acme Co’s API with it.Then you issue intermediate CAs to each of your services, which are  onlyallowed to issue CSRs for the subset of scopes they require. If any service iscompromised, it can’t be used to get more access than it already had, and youcan revoke just that one intermediate without affecting the rest.</p><p> 再举一个例子：假设您的组织有多个服务，每个服务代表用户与Acme Co的API子集进行交互。您的组织会生成一个单一的根CA，并使用它注册Acme Co的API。然后，您将中间CA颁发给您的每项服务，只允许为其所需范围子集颁发CSR。如果任何一项服务遭到破坏，就无法使用它来获得比现有服务更多的访问权限，并且您可以仅撤销其中一种中间产品，而不会影响其余部分。 </p><p> Even some famous downsides, such as  CRLs and  OCSP, are mitigated here, because the system is much morecentralized. You control all of the endpoints which will be validatingcertificates, you can just distribute revocations directly to them as soon asthey come in.</p><p>由于该系统更加集中，因此即使在某些著名的缺点（例如CRL和OCSP）也得以缓解。您控制将要验证证书的所有端点，只要它们进入就可以直接将撤销分配给它们。</p><p> The advantages are clearly numerous. Let’s wrap it up in a cute, Google-ablename, write some nice tooling and helper libraries for it, and ship it!</p><p> 优势显而易见。让我们将其包装成一个可爱的Google-ableable，为其编写一些漂亮的工具和帮助程序库，然后发布它！</p><p> Or, maybe not. I have a nagging feeling that I’m missing something here. Itdoesn’t seem right that such an obvious solution would have been left on thetable, by everyone, for decades. Maybe it’s just that the whole certificatesigning dance has left a bad taste in everyone’s mouth — many of us havenot-so-fond memories of futzing around with the awful OpenSSL CLI to generate aCSR. But, there’s no reason why we couldn’t do it better, and more streamlined,if we had the motivation to.</p><p> 或者可能不是。我a不安，觉得自己在这里错过了一些东西。几十年来，每个人都将这样一个显而易见的解决方案留在桌面上似乎并不对。也许仅仅是整个证书签名舞在每个人的口中都留下了不好的味道-我们中的许多人对使用糟糕的OpenSSL CLI生成aCSR不太满意。但是，如果有动力，我们没有理由不能做得更好，更精简。</p><p> There are also more use-cases for client-side certificates that seem rathercompelling, such as an alternative to user passwords. Web browser support forclient-side certificates totally sucks, but that is a solvable problem.</p><p> 客户端证书还有更多用例，这些用例似乎很引人注目，例如用户密码的替代品。 Web浏览器对客户端证书的支持完全糟透了，但这是一个可解决的问题。</p><p> For the record, I have no intention of using this approach for the SourceHutAPI. This thought simply occurred to me, and I want to hear what you think. Whyaren’t we using client-side certificates?</p><p> 出于记录，我无意将这种方法用于SourceHutAPI。这个想法只是发生在我身上，我想听听你的想法。为什么我们不使用客户端证书？ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://drewdevault.com/2020/06/12/Can-we-talk-about-client-side-certs.html">https://drewdevault.com/2020/06/12/Can-we-talk-about-client-side-certs.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/客户端/">#客户端</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/client/">#client</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>