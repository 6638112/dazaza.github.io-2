<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我编写JSON-REST API的演变 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">我编写JSON-REST API的演变 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-15 05:43:37</div><div class="page_narrow text-break page_content"><p>我已经用Python编写JSON-REST API多年了，在那段时间里，我发现工具有了很大的改进。为了向您展示如何使我受益，我将向您展示我如何发展。但是，如果您想跳到我今天使用的工具，请看一下Quart-Schema。</p><p>  使用Flask / Quart用Python编写JSON-REST API一直很高兴。尚未将API结构（路线，数据等）传达给第三方以及我自己的未来。很难保证API能够像文档所述那样工作。这导致在生产中我不得不避免的问题，错误和滥用。</p><p>          def（）：data = request.get_json（）todo_id = create_todo（data [＆＃34; task＆＃34;]，data [＆＃34; due＆＃34;]）todo = {＆＃34; id＆＃34; ：todo_id，＆＃34; task＆＃34 ;：数据[＆＃34; task＆＃34;]，＆＃34; due＆＃34 ;：数据[＆＃34; due＆＃34;]}返回jsonify（todo） ，201</p><p>  效果很好，但没有达到我的目标。本人和第三方用户都必须阅读代码以了解API发送和返回的内容。</p><p>  这也无助于知道何时发送了错误的数据。例如，到期应为日期，但如果不是，则create_todo函数将引发ValueError，导致API返回500响应。它应该返回400响应，以便第三方和我可以知道这是数据错误，而不是服务器或编程问题。</p><p>    为了解决简单的Flask设置遇到的文档问题，我尝试了sphinx autohttp扩展，</p><p>  def（）：＆＃34;＆＃34;＆＃34;创建TODO任务。 ..：quickref：创建一个待办事项。 ：reqheader接受：application / json：＆lt; json字符串任务：任务描述：＆lt; json字符串到期：todo截止日期：＆gt; json int id：todo唯一标识符：＆gt; json字符串task：任务描述：＆gt; json字符串截止日期：待办事项截止日期：resheader内容类型：application / json：状态201：创建的帖子＆＃34;＆＃34;＆＃34; data = request.get_json（）todo_id = create_todo（data [＆＃34; task＆＃34;]，data [＆＃34; due＆＃34;]）todo = {＆＃34; id＆＃34 ;: todo_id，＆ ＃34; task＆＃34 ;: data [＆＃34; task＆＃34;]，＆＃34; due＆＃34 ;: data [＆＃34; due＆＃34;]}返回jsonify（todo），201 </p><p>通过手动指定文档字符串中的数据结构，可以创建文档。</p><p>  尽管这对文档有帮助，但它与简单的Flask示例有相同的问题，因为它不验证发送到路由的数据，也不验证返回的数据。它还对任何短毛绒都无济于事，例如，像data [＆＃34; duo＆＃34;]之类的简单错字只会在测试过程中产生错误，或者在生产中变得更糟。</p><p>  但是，更大的问题是编写文档字符串文档，因为它很耗时，而且我（和我的同事）会忘记做无聊的工作。随着时间的流逝，这会导致文档错误，从而导致不信任和缺乏使用。</p><p>  我最终停止使用此技术，并返回到更简单的示例，因为此文档最终导致了误导。还很清楚，获胜的文档标准是OpenAPI，而不是sphinx文档。</p><p>    大约在这个时候，我从用Flask编写API转向了用Quart编写API。现在，本文中的片段将采用Quart，但唯一的区别是使用了async / await关键字，您可以删除它们以获得Flask等效项。</p><p>  我写Quart的时候就想开始使用async await关键字和库。您可以从示例中删除异步，等待以获取Flask等效项。</p><p>    我编写的API中发送和接收的数据格式为JSON。这意味着JSONSchema可用于描述结构，并用于验证任何数据与之匹配。这使我能够编写接受JSONSchema的装饰器，以验证请求和响应数据， </p><p>从functools import换行，从输入import Any，可调用，Dict导入，从quart导入中止，make_response，请求def（模式：Dict [str，Any]）-＆gt;可调用的：＆＃34;＆＃34;＆＃34;验证请求JSON。如果正文中没有JSON，或者JSON无法验证，则将触发400响应。 ＆＃34;＆＃34;＆＃34;验证程序= fastjsonschema。编译（schema）def（func：Callable）-＆gt;可调用的：异步def（* args：任何，** kwargs：任何）-＆gt;任意：数据=等待request.get_json（）尝试：验证器（数据）除了fastjsonschema.JsonSchemaException：中止（400）其他：返回等待函数（* args，** kwargs）返回包装器返回装饰器def（模式：Dict [ Dict [str，Any]]）->可调用的：＆＃34;＆＃34;＆＃34;验证响应JSON。架构由状态代码键控。 ＆＃34;＆＃34;＆＃34;验证程序= {状态：fastjsonschema。编译（schema）状态，schema中的schema.items（）} def（func：Callable）-＆gt;可调用的：异步def（* args：任何，** kwargs：任何）-＆gt;任意：result = await func（* args，** kwargs）response = await make_response（result），如果validator中的response.status_code：validators [response.status_code]（await response.get_json（））return response return wrapper return decorator</p><p>    {＆＃34; type＆＃34 ;:＆＃34; object＆＃34 ;,＆＃34; properties＆＃34 ;: {＆＃34; due＆＃34 ;: {＆＃34; type＆＃34 ;:＆＆ 34; string＆＃34 ;、＆＃34; format＆＃34 ;:＆＃34; date＆＃34;}，＆＃34; task＆＃34 ;: {＆＃34; type＆＃34 ;:＆＃34; string＆ ＃34;}，}，＆＃34;必需＆＃34;：[＆＃34; due＆＃34;，＆＃34; task＆＃34;]，＆＃34; additionalProperties＆＃34 ;： False，}）{ 201：{＆＃34; type＆＃34 ;:＆＃34; object＆＃34 ;,＆＃34; properties＆＃34 ;: {＆＃34; due＆＃34 ;: {＆＃34; type＆＃34 ;: ＆＃34; string＆＃34 ;、＆＃34; format＆＃34 ;:＆＃34; date＆＃34;}，＆＃34; id＆＃34 ;： {＆＃34; type＆＃34 ;：＆＃34 ; number＆＃34;}，＆＃34; task＆＃34 ;: {＆＃34; type＆＃34 ;:＆＃34; string＆＃34;}，}，＆＃34; required＆＃34 ;: [＆＃ 34; due＆＃34;，＆＃34; id＆＃34;，＆＃34; task＆＃34;]，＆＃34; additionalProperties＆＃34 ;： False，}，}）异步def（）：数据=等待请求.get_json（）todo_id = create_todo（data [＆＃34; task＆＃34;]，data [＆＃34; due＆＃34;]）todo = {＆＃34; id＆＃34 ;: todo_id，＆＃34; task＆＃34 ;: data [＆＃34; task＆＃34;]，＆＃34; due＆＃34 ;: data [＆＃34; due＆＃34;]}返回待办事项，201</p><p>  然后，在开发或为第三方创建API的openapi规范时，可以将JSONSchemas用作文档。</p><p>  这解决了验证和文档编制问题，同时确保文档保持正确。但是，编写代码与狮身人面像文档字符串一样痛苦（尽管现在无法忽略）。这也没有帮助linters了解我们在处理数据。</p><p>    为了从整理工具中获得帮助，需要在他们理解的结构中定义数据。方便地，Python 3.7附带了数据类，我们可以使用它们来定义结构，并使IDE和linter可以向我发出任何问题的警报。通过更改装饰器以将数据类转换为JSONSchema，可以改为使用数据类，</p><p>  类别：到期日：日期任务：str类别（TodoData）：id：int异步def（）-> Todo：数据=等待请求。get_json（）todo_data = TodoData（** data）todo_id = create_todo（todo_data.task，todo_data.due）return Todo（id = todo_id，task = todo_data.task，due = todo_data.due）， 201</p><p>  与以前的任何示例相比，这实际上是令人愉悦的代码编写，并使其（借助IDE自动完成功能）更快。 </p><p>我一直在尝试使用代码来使数据类装饰器工作一段时间，但这并不是最简单的。值得庆幸的是，我最近遇到了pydantic的数据类，这些数据类可验证参数并可以生成文档的架构。</p><p>    Quart-Schema是Quart扩展，提供了验证修饰符和自动生成的文档。全文中的示例是，</p><p>  从datetime从pydantic.dataclasses导入日期从quart导入dataclass从quart_schema导入Quart导入QuartSchema，validate_request，validate_responseapp = Quart（__ name __）QuartSchema（app）class：due：date task：str class（TodoData）：id：int async def（数据：TodoData）->待办事项：待办事项=等待create_todo（data）返回待办事项，201</p><p>    我认为，借助Quart-Schema，我终于以一种非常清晰且易于编写的形式实现了我的所有最初目标。这只有在过去几年中对async / await，类型提示和对Python的数据类改进后才可能实现。</p><p>  我很想知道您对此的看法-我在Twitter @pdgjones上。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://pgjones.dev/blog/rest-api-evolution-2020/">https://pgjones.dev/blog/rest-api-evolution-2020/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/json/">#json</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/writing/">#writing</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文档/">#文档</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1036309.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c9cdbcc7e1e7e561bd94deab5c60e5e3.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1036309.html">从HTML表单发布JSON</a></div><span class="my_story_list_date">2020-11-24 22:15</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033611.html"><img src="http://img2.diglog.com/img/2020/11/thumb_921fe46af84138433036e5d1695d14d1.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033611.html">GRON-让JSON变得可升级</a></div><span class="my_story_list_date">2020-11-7 11:13</span></div><div class="col-sm"><div><a target="_blank" href="/story/1014974.html"><img src="http://img.diglog.com/img/2020/7/thumb_f017c4a264b2cbd7b6d570b830148e0c.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1014974.html">.org-所有常见JSON文件格式的模式</a></div><span class="my_story_list_date">2020-7-30 0:42</span></div><div class="col-sm"><div><a target="_blank" href="/story/1013504.html"><img src="http://img.diglog.com/img/2020/7/thumb_d210626783f03e99269977a2a84ee350.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1013504.html">JSON的兴起与崛起</a></div><span class="my_story_list_date">2020-7-22 23:27</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>