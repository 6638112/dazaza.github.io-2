<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Snes仿真器如何从完全完美中获得几个像素 How SNES emulators got a few pixels from complete perfection</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How SNES emulators got a few pixels from complete perfection<br/>Snes仿真器如何从完全完美中获得几个像素 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-29 23:53:00</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/886f30418296e2e9002ebacfdafd950f.jpg"><img src="http://img2.diglog.com/img/2021/6/886f30418296e2e9002ebacfdafd950f.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Update, June 28, 2021: Ars was saddened to learn that the author of this piece, who also used the handle Near in online interactions,  reportedly took their own life over the weekend. We&#39;re republishing this piece today in memory of their towering contributions to the classic gaming emulation community and to Ars. You can also read  their 2011 piece on the quest for accuracy in bsnes development.</p><p>据报道，6月28日，ars令人遗憾的是，他难以理解，他也令人遗憾地了解这篇文章的作品，他在线互动附近的手柄，据报道，周末在线互动。我们今天重新传中这篇文章，以记住他们对经典游戏仿真界和ARS的巨大贡献。您还可以阅读2011件关于BSNES开发准确性的追求。</p><p>  If you or someone you know is struggling with suicidal thoughts, please contact  the National Suicide Prevention Lifeline at 800-273-8255, or  reach out to a similar international hotline. We&#39;d also encourage readers to  donate to the American Federation for Suicide Prevention if they&#39;re so moved.</p><p>  如果您或您所知的人正在努力与自杀思想斗争，请在800-273-8255联系国家自杀预防寿命，或达到类似的国际热线。我们＆＃39; D还鼓励读者捐赠给美国联邦的自杀预防，如果他们＆＃39所搬家。</p><p>   As the lead coder of  bsnes, I&#39;ve been attempting to perfect Super Nintendo emulation  for the past 15 years. We are now at a point where that goal is in sight, but there we face one last challenge: accurate cycle timing of the SNES video processors. Getting that final bit of emulation accuracy will require a community effort that I hope some of you can help with. But first, let me recap how far we&#39;ve come.  Today, SNES emulation is in a very good place. Barring unusual peripherals that are resistant to emulation (such as  a light-sensor based golf club, an  exercise bike, or a dial-up modem  used to place real-money bets on live horse races in Japan), every officially licensed SNES title is fully playable, and no game is known to have any glaring issues.</p><p>   作为BSNES的首席编码器，我一直在尝试在过去的15年里完善超级任天堂仿真。我们现在处于这个目标的观点，但我们面临着最后一个挑战：SNES视频处理器的准确周期定时。获得最终的仿真精度将需要社区努力，我希望有些人可以帮助。但首先，让我回顾我们和＃39的距离。今天，Snes仿真在一个非常好的地方。禁止对仿真的不寻常外围设备（例如基于光传感器的高尔夫俱乐部，运动自行车或用于在日本的活赛马比赛上放置真实赌注的拨号调制解调器），每个官方许可的SNES标题都是完全播放，没有众所周知的游戏有任何辉煌的问题。</p><p> SNES emulation has gotten so precise that I&#39;ve even taken to splitting my emulator into two versions:  higan, which focuses on absolute accuracy and hardware documentation; and  bsnes, which focuses on performance, features, and ease of use.</p><p> SNES仿真使我精确的是i＆＃39;甚至被认为将我的仿真器分成两个版本：Higan，它侧重于绝对准确性和硬件文档;和BSNES，专注于性能，功能和易用性。</p><p>    So that&#39;s it, right? Kudos on a job well done, thanks for all the fish? Well... not quite.</p><p>    所以它，吧？在一份工作中做得很好的荣誉，谢谢你所有的鱼？好吧......不太。</p><p> Today, we enjoy cycle-level accuracy for nearly every component of the SNES. The sole exception is the PPUs (picture processing units), which are used to generate the video frames sent to your screen. We  mostly know how the PPUs work, but we have to make guesses for some functionality that result in less than total perfection.</p><p> 今天，我们为几乎每个狭小带的组件享受循环级别准确性。唯一的例外是PPU（图片处理单元），用于生成发送到屏幕的视频帧。我们大多了解PPU的工作方式，但我们必须猜测一些导致少于完全完美的功能。</p><p> The remaining issues are relatively small ones, in the grand scheme of things. If you&#39;re not interested in the pursuit of one hundred percent faithful emulation perfection for its own sake, I am not going to be able to convince you of the need for improving SNES PPU emulation further. As with any goal in life, the closer we get to perfection, the smaller the returns.</p><p> 剩下的问题是相对较小的问题，在盛大的事情方案中。如果你＆＃39;重复追求追求百分之百的忠实仿真完善的奉献，我并不能让你进一步改善SNES PPU仿真的必要性。与生活中的任何目标一样，我们越来越靠完美，回报越小。 </p><p> I can tell you why this is important to  me: it&#39;s my life&#39;s work, and I don&#39;t want to have to say I came  this close to finishing without getting the last piece of it right. I&#39;m getting older, and I won&#39;t be around forever. I want this final piece solved so that I can feel confident in my retirement that the SNES has been faithfully and completely preserved through emulation. No stone was left unturned, no area left unfinished. I want to say that it&#39;s  done.</p><p>我可以告诉你为什么这对我来说很重要：它的生活和＃39;工作，我不想说我这靠近完成而没有得到最后一块。我变老了，我赢了，我赢了。我希望这个最后的事情解决了，所以我可以对我的退休感到充满信心，因为SNES一直忠实地通过仿真完全保存。没有石头被遗忘，没有区域未完成。我想说它＆＃39所做的。</p><p> If you&#39;re still intrigued, read on for a deep dive into the background of the problem and my proposed solutions.</p><p> 如果您＆＃39;仍然有兴趣，请阅读深入潜入问题的背景和我提出的解决方案。</p><p>    The arrows indicate the direction that the various processors in the SNES can communicate with one another, and the dotted lines represent memory chip connections.</p><p>    箭头表示SNE中的各种处理器可以彼此通信的方向，并且虚线表示存储器芯片连接。</p><p> The key thing to take away right now is to note that the video and audio output are sent directly from the PPU and DSP specifically. That means they function like “black boxes” where we don’t have any visibility into what happens inside. This will be important later on.</p><p> 现在要带走的关键是要注意的，视频和音频输出专门从PPU和DSP发送。这意味着它们像“黑匣子”一样，我们在内部没有任何可见性。后来这将是重要的。</p><p>  Imagine you are emulating a CPU&#39;s &#34;multiply&#34; instruction, which takes two registers (variables), multiplies them together, and produces a result and some flags that represent the status of the result (such as  overflow).</p><p>  想象一下，你正在模仿CPU＆＃39; s＆＃34;乘法＆＃34;需要两个寄存器（变量）的指令将它们乘以，并生成结果和一些表示结果状态（例如溢出）的标志。</p><p> We could devise a software program that multiplies every possible value from 0 to 255 as both the multiplier and multiplicand. Then we could output both the numeric and flag results of the multiplication. This would produce two 65,536-entry tables.</p><p> 我们可以设计一个软件程序，该软件程序将每个可能的值从0到255乘以乘法器和多样性。然后我们可以输出乘法的数字和标志结果。这将产生两个65,536个条目表。</p><p>    By analyzing these tables, we could determine exactly how and when the CPU results were set certain ways. Then we could modify our emulators so, when running the same test, we produce exactly the same tables at the same times.</p><p>    通过分析这些表，我们可以准确地确定CPU结果设置某种方式。然后我们可以修改我们的仿真器，所以在运行相同的测试时，我们在同一时间产生完全相同的表。 </p><p> Now let&#39;s say the CPU had 16-bit x 16-bit multiplications. Testing every possible value would generate 4 billion results, which is starting to push what is practical to test in a reasonable amount of time. If the CPU had 32-bit x 32-bit multiplications, it wouldn’t be practical to test all combinations of inputs before the heat death of the universe (with current technology, at least).</p><p>现在让＆＃39; S说CPU有16位x 16位乘法。测试每个可能的值都会产生40亿个结果，这开始推动在合理的时间内测试的实际测试。如果CPU具有32位x 32位乘法，则测试宇宙热死前的所有输入组合是不可行的（至少有当前技术，至少）。</p><p> In cases like this, we would have to get more selective with our tests and try to determine exactly when flags might change, when results might overflow, and so forth. Otherwise we&#39;d have tests that would never complete.</p><p> 在这样的情况下，我们必须使用测试来获得更多选择性，并尝试何时何时可以更改标记可能会更改时，结果可能会溢出。否则我们＆＃39; D有一个永远不会完成的测试。</p><p> Multiplication is a fairly trivial operation, but this is the general process behind reverse engineering, and it extends to more complex operations such as how the SNES&#39; horizontal blanking DMA (direct memory access) transfers work. We create tests that try to detect what happens on edge cases, then confirm that our emulation behaves identically to a real SNES.</p><p> 乘法是一个相当琐碎的操作，但这是逆向工程背后的一般过程，它延伸到更复杂的操作，例如snes＆＃39;水平消隐DMA（直接内存访问）转移工作。我们创建了试图检测到边缘案例发生的情况的测试，然后确认我们的仿真表现与真正的SNES相同。</p><p>  The SNES contains two oscillators: a crystal clock that runs at ~21MHz, which controls the CPU and PPUs; and a ceramic resonator that runs at ~24MHz, which controls the SMP and DSP. Cartridge coprocessors will sometimes use the ~21MHz CPU oscillator and sometimes include their own oscillators that run at different frequencies.</p><p>  SNES包含两个振荡器：在〜21MHz上运行的晶时钟，控制CPU和PPU;和一个在〜24MHz上运行的陶瓷谐振器，用于控制SMP和DSP。盒式切割器有时会使用〜21MHz CPU振荡器，有时包括在不同频率下运行的自己的振荡器。</p><p>  A clock is the core timing element of any system, and the SNES is designed to perform various tasks at certain frequencies and times.</p><p>  时钟是任何系统的核心定时元素，并且SNES旨在以某些频率和时间执行各种任务。</p><p> If you imagine a 100Hz clock, it is a device with a digital pin that transitions to logic high (+5 volts, for instance), and then back to logic low (0 volts, or ground) 100 times per second. So every second, the pin voltage will fluctuate 200 times total: 100 rising clock edges and 100 falling clock edges.</p><p> 如果您想象一个100Hz时钟，它是一种带有数字引脚的设备，该设备转换为逻辑高（例如+5伏），然后返回到每秒100次逻辑低（0伏或地）。因此，每一秒，销电压都会波动200次：100个上升时钟边缘和100个下降时钟边缘。</p><p> A clock cycle is generally treated as one full transition, so a 100Hz clock would generate 100 clock cycles per second. There are some systems that require distinguishing between rising and falling edges, and for those, we break this further down into half-cycles to denote each phase (high or low) of the clock signal.</p><p> 时钟周期通常被视为一个完整的转换，因此100Hz时钟将产生每秒100个时钟周期。有一些系统需要区分上升和下降边缘，并且对于那些，我们将其进一步分解成半循环以表示时钟信号的每个相（高或低）。 </p><p> The key goal of an authentic emulator is to perform tasks in exactly the same ways and at exactly the same times as the real hardware. It doesn&#39;t much matter specifically  how the tasks are performed. All that matters is that the emulator, when given the same inputs, generates the same outputs with the same timing as real hardware.</p><p>真实仿真器的关键目标是以完全相同的方式执行任务，并且与真实硬件完全相同。它不得不具体地执行任务的问题。重要的是，在给出相同的输入时，模拟器会生成与真实硬件相同的时机相同的输出。</p><p>  Sometimes, operations happen over time. Take SNES CPU multiplication, for instance. Rather than pausing to wait for multiplication to complete, the SNES CPU calculates the multiplication result one bit at a time in the background over eight CPU opcode cycles. This allows your code to possibly do other things while waiting on the multiplication to complete.</p><p>  有时，操作随着时间的推移而发生。例如，拍摄CPU乘法。 SNE CPU在八个CPU OPOD循环中，SNE CPU在后台计算乘法结果，而不是暂停等待乘法来完成乘法。这允许您的代码在等待乘法时才能完成其他事情。</p><p> Any commercially released software is likely to wait those eight cycles, because if you try to read the result before it&#39;s ready, you will get a partially computed result instead. Yet earlier SNES emulators gave correct results  immediately, without waiting these extra cycles.</p><p> 任何商业发布的软件都可能等待这一点八个周期，因为如果您在它之前尝试阅读结果＆＃39;准​​备好，您将获得部分计算的结果。然而，早期的Snes仿真器立即给出了正确的结果，而不等待这些额外的周期。</p><p> When hobbyists started creating and testing homebrew software via emulators, this discrepancy started to cause some problems. Some of this software, such as many early  Super Mario World ROM hacks, only worked correctly on these earlier emulators, and not on real SNES hardware. That&#39;s because they were designed with the emulator&#39;s immediate (and inauthentic-to-real-hardware) multiplication results in mind.</p><p> 当Hobbyists开始通过仿真器创建和测试Homebrew软件时，这种差异开始导致一些问题。这些软件中的一些，例如许多早期的超级马里奥世界ROM黑客，这些软件只在这些早期的仿真器上正确工作，而不是真正的SNES硬件。那个＆＃39;因为它们是用仿真器设计的直接（和不真实的 - 与实际硬件）乘法的设计。</p><p> As emulators improved, this old software broke, and we have had to subsequently offer compatibility options in our newer emulators in order to not lose this software to time. Yes, as surreal as it is to say, these days our emulators have to emulate other emulators! How meta!</p><p> 随着仿真器的改进，这款旧软件已破坏，我们必须随后在我们的较新的模拟器中提供兼容性选项，以便不会失去此软件。是的，就像要说的那样，我们的仿真者必须模仿其他仿真器！梅塔！</p><p>    The nice thing about the CPU multiplication delay is that it&#39;s very predictable: the eight computation cycles start immediately after requesting a multiplication. By writing code to read the results after every cycle, we were able to confirm that the SNES CPU was using the  Booth  algorithm for multiplication.</p><p>    关于CPU乘法延迟的好处是它非常可预测：八个计算周期在请求乘法后立即启动。通过编写代码来读取每个周期后的结果，我们能够确认SNES CPU正在使用展位算法进行乘法。</p><p>  Other operations are not so simple to model, since they happen asynchronously in the background. The SNES CPU&#39;s DRAM refresh is one such case.</p><p>  其他操作对模型并不那么简单，因为它们在后台异步发生。 SNES CPU＆＃39; S DRAM刷新是一个这样的案例。 </p><p> During the rendering of every scanline, at a certain point, the entire SNES CPU freezes for a short duration as the contents of the RAM chip are refreshed. This is needed because, as a cost-cutting measure, the SNES used dynamic RAM (rather than static RAM) for its main CPU memory. Dynamic RAM must be periodically refreshed in order to preserve its contents over time.</p><p>在每个扫描线的渲染过程中，在某个点处，整个SNE CPU冻结短时间，随着RAM芯片的内容刷新。需要这是因为作为成本切割度量，SNES为其主CPU存储器使用动态RAM（而不是静态RAM）。必须定期刷新动态RAM，以随着时间的推移保持其内容。</p><p>  The key insight to figuring out the precise timing of these operations was to take advantage of the SNES PPU’s horizontal and vertical counters. These counters advance and are reset after each horizontal and vertical blanking period. However, their precision is only a quarter of the SNES&#39; CPU oscillator frequency; that is to say, the horizontal counter increments only once every four clock cycles.</p><p>  弄清楚这些操作的精确时间的关键洞察是利用SNES PPU的水平和垂直计数器。这些计数器前进并在每个水平和垂直消隐时段后复位。然而，他们的精确度只是Snes＆＃39的四分之一; CPU振荡器频率;也就是说，水平计数器仅增量一次每四个时钟周期一次。</p><p> By reading the counters multiple times, I was able to determine which quarter of a clock cycle the counter was aligned with. By combining that insight with a specially crafted function that could step by a precise, user-specified number of clock cycles, it became possible to perfectly align the SNES CPU to any exact clock cycle position I wanted.</p><p> 通过多次读取计数器，我能够确定计数器对准的时钟周期的哪个四分之一。通过将此洞察力与专门制作的功能相结合，可以通过精确，用户指定的时钟周期循环，可以完全将SNES CPU完全对准到我想要的任何精确的时钟周期位置。</p><p> By iterating over a range of clock cycles in a loop, I could determine exactly when certain operations (such as DRAM refresh, HDMA transfers, interrupt polling, etc.) would occur, and I was able to reproduce this precisely under emulation.</p><p> 通过迭代循环中的一系列时钟周期，我可以完全确定发生某些操作（例如DRAM刷新，HDMA传输，中断轮询等），并且我能够精确地在仿真下再现。</p><p> The SNES  SMP chip has its own timers as well, and similar reverse engineering was successful against that processor as well. I could spend an entire article talking about the SMP TEST register alone, which allows coders to control the clock divider of the SMP and its timers, among other horrible things. Suffice it to say that, while it was not an easy or fast process, we were ultimately victorious.</p><p> SNES SMP芯片也有自己的定时器，并且同样的逆向工程也成功地反对该处理器。我可以单独花一整篇文章谈论SMP测试寄存器，这允许编码器控制SMP的时钟分频器及其定时器，以及其他可怕的东西。就这样说，虽然这不是一种简单或快速的过程，但我们最终胜利。</p><p>  There were a whole host of SNES coprocessors used inside various game cartridges that needed to be tamed as well. From dedicated general-purpose CPUs like the  SuperFX and  SA-1, to digital signal processors like the DSP-1 and Cx4, to decompression accelerators like the S-DD1 and SPC7110, to real-time clocks from Sharp and Epson, and more...</p><p>  在需要被驯服的各种游戏盒内，有一系列SNES协处理器。从专用通用CPU如Superfx和SA-1，与DSP-1和CX4等数字信号处理器，与S-DD1和SPC7110这样的解压缩加速器，到来自Sharp和Epson的实时时钟，以及更多。 ..</p><p> That means an SNES emulator needs to be able to handle the instruction and pixel caches of the SuperFX; the memory bus conflict arbitrator of the SA-1 (which allowed the SNES CPU and SA-1 to share the same ROM and RAM chips simultaneously); the embedded firmware of the DSP-1 and Cx4; the prediction-based arithmetic coders of the S-DD1 and SPC7110; and the odd BCD (binary-coded decimal) edge cases of the real-time clocks. Slowly but surely, by applying the above techniques to determine correctness and timing, we were able to near-perfectly emulate all of these chips.</p><p> 这意味着SNES仿真器需要能够处理Superfx的指令和像素缓存; SA-1的内存总线冲突仲裁器（允许SNES CPU和SA-1同时共用相同的ROM和RAM芯片）; DSP-1和CX4的嵌入式固件; S-DD1和SPC7110的基于预测的算术编码器;和奇数BCD（二进制编码的小数）的实时时钟边缘情况。慢慢但肯定地，通过应用上述技术来确定正确和时间，我们能够接近完美地模拟所有这些芯片。 </p><p> It actually took a massive effort and thousands of dollars to decap and extract the programming firmware from the digital signal processors used in various games. In one instance, emulation of the NEC uPD772x led to  code from higan being used to save the late professor Stephen Hawking&#39;s voice!</p><p>它实际上采取了巨大的努力，数千美元来从各种游戏中使用的数字信号处理器中取出并提取编程固件。在一个例子中，NEC UPD772X的仿真导致了来自Higan的代码，用于挽救斯蒂芬霍金的后期教授＆＃39;声音！</p><p> In another case, we had to reverse-engineer the entire instruction set of the Hitachi HG51B architecture, because this architecture was never publicly documented. In yet another, one game ( Hayazashi Nidan Morita Shougi 2) ended up containing a full-blown 32-bit, 21MHz ARM6 CPU to accelerate its Japanese chess engine!</p><p> 在另一个情况下，我们必须反向工程师的日立HG51B架构的整个指令集，因为这种架构从未被公开记录过。在另一个游戏（Hayazashi Nidan Morita Shougi 2）最终包含一个完整的32位，21MHz ARM6 CPU，以加速其日本国际象棋引擎！</p><p> Preserving all of the SNES coprocessors alone was a multi-year journey full of challenges and surprises.</p><p> 仅保留所有SNES协处理器是一个充满挑战和惊喜的多年旅程。</p><p>  Not to be confused with the DSP-1 cartridge coprocessor, the Sony S-DSP (digital signal processor) chip is what generated the distinctive sound from the SNES. This chip combined eight voice channels with 4-bit ADPCM encoding to produce a 16-bit stereo signal.</p><p>  不要与DSP-1盒式切割机混淆，索尼S-DSP（数字信号处理器）芯片是从SNES产生独特的声音。该芯片组合了八个语音通道，具有4位ADPCM编码以产生16位立体声信号。</p><p> On the surface, and per the system diagram from earlier, the DSP initially looks like a black box: you configure the voice channels and mixer settings and sit back as it generates sound to be sent to your speakers.</p><p> 在表面上，并且根据前面的系统图，DSP最初看起来像一个黑色盒子：您可以配置语音通道和混音器设置，并坐下，因为它会将声音发送到扬声器时。</p><p> But one key feature allowed a developer by the name of blargg to fully reverse-engineer this chip: the echo buffer. The SNES DSP has a feature that mixes the outputs from previous samples together to produce an echo effect. This happens at the very end of the audio generation process (aside from one last final mute flag that can be applied to silence all audio output.)</p><p> 但是一个关键的功能允许开发人员通过BlarGG的名称来完全反向工程师这个芯片：Echo缓冲区。 SNES DSP具有一个功能，将从先前样本的输出混合在一起以产生回声效果。这发生在音频生成过程的最终（除了可以应用于静默所有音频输出的最后一个最终静音标志。）</p><p> By writing carefully cycle-timed code and monitoring those echo results, it became possible to discover the exact order of operations the SNES DSP would take to generate each sample and to produce cycle-accurate, bit-perfect audio.</p><p> 通过仔细循环定时代码并监视这些回声结果，可以发现SNES DSP将采用SNES DSP的确切操作顺序，以生成每个样本，并产生周期准确的位完美音频。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://arstechnica.com/gaming/2021/06/how-snes-emulators-got-a-few-pixels-from-complete-perfection/">https://arstechnica.com/gaming/2021/06/how-snes-emulators-got-a-few-pixels-from-complete-perfection/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/snes/">#snes</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/emulators/">#emulators</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>