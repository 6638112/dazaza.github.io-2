<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>置换解析器，不验证 Permutate Parsers, Don't Validate</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Permutate Parsers, Don't Validate<br/>置换解析器，不验证 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-15 22:27:05</div><div class="page_narrow text-break page_content"><p>“Parse, don’tvalidate”has been one of my favourite programming articles for some time. The maingist of the article is that, when writing in a type-driven fashion, yoursnappy slogan should be:</p><p>一段时间以来，“解析，不验证”一直是我最喜欢的编程文章之一。这篇文章的主旨是，当以类型驱动的方式编写时，您的贪婪口号应该是：</p><p>  The core difference between parsing and validating can be explained bylooking at two very similar functions:</p><p>  可以通过查看两个非常相似的函数来解释解析和验证之间的核心区别：</p><p> parseInt  ::  String  -&gt;  Maybe  Int parseInt  str  =  Text.Read.readMaybe  str validateInt  ::  String  -&gt;  Bool validateInt  str  =  Text.Read.readMaybe  str  /=  Nothing</p><p> parseInt ::字符串-＆gt;也许Int parseInt str = Text.Read.readMaybe str validateInt :: String-＆gt; Bool validateInt str = Text.Read.readMaybe str / =什么都没有</p><p> As you can see, they look very similar. The main difference is that parseInt returns a useful value, the  Int that we wanted to parse, while validateInt takes that useful value and throws it away. This is alsomentioned in the wonderful  Haskell Mini-PatternsHandbookas the “Evidence” pattern.</p><p> 如您所见，它们看起来非常相似。主要区别在于parseInt返回一个有用的值，即我们要解析的Int，而validateInt接受了该有用的值并将其丢弃。在奇妙的Haskell迷你模式手册中也提到了“证据”模式。</p><p> The key issue here is that by calling a function that returns Bool youlose the information about earlier performed validation. Instead, you cankeep this information by explicitly pattern-matching on the validation orresult.</p><p> 此处的关键问题是，通过调用返回Bool的函数，您会丢失有关较早执行的验证的信息。相反，您可以通过对验证或结果进行显式模式匹配来保留此信息。</p><p> In this post, I would like to go through a practical example that shows thepower of bringing this concept to its limits. Which brings us to…</p><p> 在本文中，我想通过一个实际的例子来展示将这个概念发挥到极致的力量。带我们去…</p><p>   - byr (Birth Year)- iyr (Issue Year)- eyr (Expiration Year)- hgt (Height)- hcl (Hair Color)- ecl (Eye Color)- pid (Passport ID)- cid (Country ID)</p><p>   -拜尔（出生年）-伊尔（签发年）-年（到期年）-hgt（身高）-hcl（头发颜色）-ecl（眼睛颜色）-pid（护照ID）-cid（国家ID） </p><p> All the fields are required except for the  cid field, which is optional.Note that the fields can be written in any order, this will be importantlater. Our batch is composed of multiple passports separated by empty lines(the  input.txt):</p><p>除cid字段外，所有字段都是必填字段，cid字段是可选字段。请注意，这些字段可以按任何顺序写入，这将在以后变得很重要。我们的批次由多行护照组成，并用空行（input.txt）隔开：</p><p> ecl:gry pid:860033327 eyr:2020 hcl:#fffffdbyr:1937 iyr:2017 cid:147 hgt:183cmiyr:2013 ecl:amb cid:350 eyr:2023 pid:028048884hcl:#cfa07d byr:1929hcl:#ae17e1 iyr:2013eyr:2024ecl:brn pid:760753108 byr:1931hgt:179cmhcl:#cfa07d eyr:2025 pid:166559648iyr:2011 ecl:brn hgt:59in</p><p> ecl：gry pid：860033327 eyr：2020 hcl：#fffffdbyr：1937 iyr：2017 cid：147 hgt：183cmiyr：2013 ecl：amb cid：350 eyr：2023 pid：028048884hcl：＃cfa07d byr：1929hcl：＃ae17e1 iyr：2013eyr ：2024ecl：brn pid：760753108 byr：1931hgt：179cmhcl：＃cfa07d eyr：2025 pid：166559648iyr：2011 ecl：brn hgt：59in</p><p> The third passport is interesting: the only missing field is the optional  cid, which makes it  valid.</p><p> 第三本护照很有趣：唯一缺少的字段是可选的cid，这使其有效。</p><p> The fourth passport is missing two fields,  cid and  byr. Missing  cid is fine, but missing  byr is not, so this passport is  invalid.</p><p> 第四本护照缺少两个字段，cid和byr。缺少身份证件是可以的，但缺少伯尔先生则不能，因此该护照无效。</p><p>  Let’s write some code to open the file and parse each group of passportfields:</p><p>  让我们编写一些代码来打开文件并解析每组护照字段：</p><p> module  Main  where  import  qualified Data.List.Split  as S main  ::  IO  ( ) main  =  do  contents  &lt;-  readFile  &#34;input.txt&#34;  let  entries  =  map  parseEntry  ( S.splitOn  &#34;\n\n&#34;  contents )  print  entries data  PassportEntry  =  PassportEntry  deriving  ( Show ) parseEntry  ::  String  -&gt;  PassportEntry parseEntry  text  =  undefined</p><p> 模块Main，在其中导入合格的Data.List.Split作为S main :: IO（）main =做内容＆lt;-readFile＆＃34; input.txt＆＃34; let条目=映射parseEntry（S.splitOn＆＃34; \ n \ n＆＃34;内容）打印条目数据PassportEntry =派生（显示）parseEntry :: String-＆gt;的PassportEntry PassportEntry parseEntry文本=未定义</p><p> Nothing too fancy here, we’re using  Data.List.Split from the  splitpackage to do the heavy lifting. And the implementation of  parseEntry hasbeen conveniently stubbed so that the code compiles.</p><p> 这里没什么好想的，我们使用splitpackage中的Data.List.Split进行繁重的工作。并且parseEntry的实现已被方便地取消了代码的编译范围。 </p><p> Now how should our  PassportEntry data structure look like? I’d love toeventually represent passports as:</p><p>现在，我们的PassportEntry数据结构应该如何？我最终希望将护照表示为：</p><p> data  Passport  =  Passport  {  birthYear  ::  Int ,  issueYear  ::  Int ,  expirationYear  ::  Int ,  height  ::  String ,  hairColor  ::  String ,  eyeColor  ::  String ,  passportId  ::  String ,  countryId  ::  Maybe  Int  }</p><p> 数据Passport = Passport {birthYear :: Int，issueYear :: Int，expirationYear :: Int，height :: String，hairColor :: String，eyeColor :: String，passportId :: String，countryId :: Maybe Int}</p><p> If we imagine parsing each field sequentially, we can see that we won’t beable to construct this data structure in a single operation. We’ll have toaccumulate the data up until we’re ready to create a proper  Passport.</p><p> 如果我们想象顺序地解析每个字段，那么我们将无法在单个操作中构造该数据结构。在准备好创建适当的护照之前，我们必须累积数据。</p><p> One way to store the fields is to insert them into a hash. First of all,we’re going to use a custom data type to represent the keys of the hash.Why is that? We really don’t want to be making typos later when comparingraw strings like  &#34;ecl&#34; and  &#34;elc&#34;. We’ll use a  HashMap from the Data.HashMap.Strict module:</p><p> 存储字段的一种方法是将它们插入哈希。首先，我们将使用自定义数据类型来表示哈希键。为什么？我们真的不希望稍后在比较＆＃34; ecl＆＃34;和＆＃34; elc＆＃34;。我们将使用Data.HashMap.Strict模块中的HashMap：</p><p> import  qualified Data.HashMap.Strict  as HM data  PassportField  =  BirthYear  |  IssueYear  |  ExpirationYear  |  Height  |  HairColor  |  EyeColor  |  PassportId  |  CountryId  deriving  ( Eq ,  Show ) type  PassportEntry  =  HM.HashMap  PassportField  String</p><p> 将合格的Data.HashMap.Strict导入为HM数据PassportField = BirthYear |发行年份|到期年份|身高|发色| EyeColor | PassportId | CountryId派生（Eq，Show）类型PassportEntry = HM.HashMap PassportField字符串</p><p> Of course things can’t be that easy. We also need to make our typeimplement the  Hashable typeclass:</p><p> 当然，事情不可能那么容易。我们还需要使我们的类型实现成为Hashable类型类：</p><p> {-# LANGUAGE DeriveGeneric #-}  import  qualified Data.HashMap.Strict  as HM  import Data.Hashable  import GHC.Generics  ( Generic ) data  PassportField  =  BirthYear  |  IssueYear  |  ExpirationYear  |  Height  |  HairColor  |  EyeColor  |  PassportId  |  CountryId  deriving  ( Eq ,  Show ,  Generic ) instance  Hashable  PassportField type  PassportEntry  =  HM.HashMap  PassportField  String</p><p> {-＃LANGUAGE DeriveGeneric＃-}导入合格的Data.HashMap.Strict作为HM导入Data.Hashable导入GHC.Generics（Generic）数据PassportField = BirthYear |发行年份|到期年份|身高|发色| EyeColor | PassportId | CountryId派生（Eq，Show，Generic）实例Hashable PassportField类型PassportEntry = HM.HashMap PassportField字符串 </p><p> Don’t worry about what we’ve added. Just take them as God-given truths. 👼</p><p>不用担心我们添加的内容。只要把它们当作上帝赐予的真理。 👼</p><p>  import Data.Maybe  ( mapMaybe )  import  qualified Data.Char  as Char parseEntry  ::  String  -&gt;  PassportEntry parseEntry  line  =  HM.fromList  $  mapMaybe  parseTag  $  S.splitWhen  Char . isSpace  line parseTag  ::  String  -&gt;  Maybe  ( PassportField ,  String ) parseTag  value  =  case  S.splitOn  &#34;:&#34;  value  of  [ &#34;byr&#34; ,  byr ]  -&gt;  Just  ( BirthYear ,  byr )  [ &#34;iyr&#34; ,  iyr ]  -&gt;  Just  ( IssueYear ,  iyr )  [ &#34;eyr&#34; ,  eyr ]  -&gt;  Just  ( ExpirationYear ,  eyr )  [ &#34;hgt&#34; ,  height ]  -&gt;  Just  ( Height ,  height )  [ &#34;hcl&#34; ,  color ]  -&gt;  Just  ( HairColor ,  color )  [ &#34;ecl&#34; ,  color ]  -&gt;  Just  ( EyeColor ,  color )  [ &#34;pid&#34; ,  pid ]  -&gt;  Just  ( PassportId ,  pid )  [ &#34;cid&#34; ,  cid ]  -&gt;  Just  ( CountryId ,  cid )  _  -&gt;  Nothing</p><p>  import Data.Maybe（mapMaybe）将合格的Data.Char导入为char parseEntry :: String-＆gt; PassportEntry parseEntry行= HM.fromList $ mapMaybe parseTag $ S.splitWhen Char。 isSpace行parseTag :: String-＆gt;也许（PassportField，String）parseTag值= case S.splitOn＆＃34;：＆＃34; [＆＃34; byr＆＃34; ，byr]-＆gt;只是（BirthYear，byr）[＆＃34; iyr＆＃34; ，iyr]-＆gt;只是（IssueYear，iyr）[＆＃34; eyr＆＃34; ，eyr]-＆gt;只是（ExpirationYear，eyr）[＆＃34; hgt＆＃34; ，高度]-＆gt;只是（身高，身高）[＆＃34; hcl＆＃34; ，颜色]-＆gt;只是（HairColor，color）[＆＃34; ecl＆＃34; ，颜色]-＆gt;只是（EyeColor，color）[＆＃34; pid＆＃34; ，pid]-＆gt;只是（PassportId，pid）[＆＃34; cid＆＃34; ，cid]-＆gt;只是（CountryId，cid）_-＆gt;没有</p><p> We try to parse each field (such as  byr:2002) into a  PassportFieldtype, then end up building a hash using  HM.fromList. We can take this fora spin:</p><p> 我们尝试将每个字段（例如byr：2002）解析为PassportFieldtype，然后最终使用HM.fromList构建哈希。我们可以进行以下讨论：</p><p> Prelude &gt;  : l  Main.hs * Main &gt;  main [  fromList  [  ( CountryId ,  &#34;147&#34; ) ,  ( BirthYear ,  &#34;1937&#34; ) ,  ( IssueYear ,  &#34;2017&#34; ) ,  ( HairColor ,  &#34;#fffffd&#34; ) ,  ( ExpirationYear ,  &#34;2020&#34; ) ,  ( EyeColor ,  &#34;gry&#34; ) ,  ( Height ,  &#34;183cm&#34; ) ,  ( PassportId ,  &#34;860033327&#34; )  ] ,  fromList  [  ( CountryId ,  &#34;350&#34; ) ,  ( BirthYear ,  &#34;1929&#34; ) ,  ( IssueYear ,  &#34;2013&#34; ) ,  ( HairColor ,  &#34;#cfa07d&#34; ) ,  ( ExpirationYear ,  &#34;2023&#34; ) ,  ( EyeColor ,  &#34;amb&#34; ) ,  ( PassportId ,  &#34;028048884&#34; )  ] ,  fromList  [  ( BirthYear ,  &#34;1931&#34; ) ,  ( IssueYear ,  &#34;2013&#34; ) ,  ( HairColor ,  &#34;#ae17e1&#34; ) ,  ( ExpirationYear ,  &#34;2024&#34; ) ,  ( EyeColor ,  &#34;brn&#34; ) ,  ( Height ,  &#34;179cm&#34; ) ,  ( PassportId ,  &#34;760753108&#34; )  ] ,  fromList  [  ( IssueYear ,  &#34;2011&#34; ) ,  ( HairColor ,  &#34;#cfa07d&#34; ) ,  ( ExpirationYear ,  &#34;2025&#34; ) ,  ( EyeColor ,  &#34;brn&#34; ) ,  ( Height ,  &#34;59in&#34; ) ,  ( PassportId ,  &#34;166559648&#34; )  ] ]</p><p> 前奏＆gt; ：l Main.hs * Main＆gt; main [fromList [（CountryId，＆＃34; 147＆＃34;），（BirthYear，＆＃34; 1937＆＃34;），（IssueYear，＆＃34; 2017＆＃34;），（HairColor，＆＃34; ＃fffffd＆＃34;），（ExpirationYear，＆＃34; 2020＆＃34;），（EyeColor，＆＃34; gry＆＃34;），（Height，＆＃34; 183cm＆＃34;），（PassportId，＆ ＃34; 860033327＆＃34;）]，从列表[（CountryId，＆＃34; 350＆＃34;），（出生年份，＆＃34; 1929＆＃34;），（IssueYear，＆＃34; 2013＆＃34;） ，（HairColor，＆＃34;＃cfa07d＆＃34;），（ExpirationYear，＆＃34; 2023＆＃34;），（EyeColor，＆＃34; amb＆＃34;），（PassportId，＆＃34; 028048884＆＃ 34;）]，fromList [（BirthYear，＆＃34; 1931＆＃34;），（IssueYear，＆＃34; 2013＆＃34;），（HairColor，＆＃34;＃ae17e1＆＃34;），（ExpirationYear， ＆＃34; 2024＆＃34;），（EyeColor，＆＃34; brn＆＃34;），（Height，＆＃34; 179cm＆＃34;），（PassportId，＆＃34; 760753108＆＃34;）]， fromList [（IssueYear，＆＃34; 2011＆＃34;），（HairColor，＆＃34;＃cfa07d＆＃34;），（ExpirationYear，＆＃34; 2025＆＃34;），（EyeColor，＆＃34 ; brn＆＃34; ），（高度，＆＃34; 59in＆＃34;），（PassportId，＆＃34; 166559648＆＃34;）]]]</p><p>  Now our goal is to verify which one of these groups is valid. First of all,we should define a list of required fields:</p><p>  现在，我们的目标是验证这些组中的哪一个有效。首先，我们应该定义一个必填字段列表：</p><p>     main  ::  IO  ( ) main  =  do  contents  &lt;-  readFile  &#34;input.txt&#34;  let  entries  =  map  parseEntry  ( S.splitOn  &#34;\n\n&#34;  contents )  print  $  length  $  filter  isEntryValid  entries</p><p>     main :: IO（）main =做内容＆lt;-readFile＆＃34; input.txt＆＃34;让entry =映射parseEntry（S.splitOn＆＃34; \ n \ n＆＃34;内容）打印$长度$过滤器isEntryValid条目</p><p> Running this yields  2, which is the correct answer! Here isall the code we have written so far, if you’re feeling like you need arefresher.</p><p> 运行此生成2，这是正确的答案！如果您觉得自己需要重新整理，这里是到目前为止我们编写的所有代码。 </p><p>   - byr (Birth Year) - four digits; between 1920 and 2002.- iyr (Issue Year) - four digits; between 2010 and 2020.- eyr (Expiration Year) - four digits; between 2020 and 2030.- hgt (Height) - a number followed by either cm or in: - If cm, the number must be between 150 and 193. - If in, the number must be between 59 and 76.- hcl (Hair Color) - a &#39;#&#39; followed by six chars 0-9 or a-f.- ecl (Eye Color) - one of: amb blu brn gry grn hzl oth.- pid (Passport ID) - a nine-digit number.- cid (Country ID) - ignored, missing or not.</p><p>-拜尔（生日）-四位数；在1920年至2002年之间。-年（发行年份）-四位数；在2010年至2020年之间。-eyr（有效年）-四位数；在2020年至2030年之间。-hgt（高度）-一个数字，后跟cm或in：-如果为cm，则该数字必须介于150和193之间。-如果为cm，则该数字必须介于59和76之间。-hcl（毛发颜色）-＆＃39;＃＆＃39;后面跟着六个字符0-9或af。-ecl（眼睛颜色）-以下之一：-pid（护照ID）-九位数字。-cid（国家ID）-被忽略，缺少或没有。</p><p>    These new requirements are a bit annoying. Our simple approach of checkingif all required fields are present won’t work any longer. We can insteadimplement a  isFieldValid function to check if all fields are valid.</p><p>    这些新要求有点烦人。我们检查所有必填字段是否存在的简单方法将不再起作用。我们可以改为执行isFieldValid函数来检查所有字段是否有效。</p><p> isFieldValid  ::  ( PassportField ,  String )  -&gt;  Bool isFieldValid  ( field ,  value )  =  case  field  of  BirthYear  -&gt;  let  v  =  toInt  value  in  length  value  ==  4  &amp;&amp;  v  &gt;=  1920  &amp;&amp;  v  &lt;=  2002  IssueYear  -&gt;  let  v  =  toInt  value  in  length  value  ==  4  &amp;&amp;  v  &gt;=  2010  &amp;&amp;  v  &lt;=  2020  ExpirationYear  -&gt;  let  v  =  toInt  value  in  length  value  ==  4  &amp;&amp;  v  &gt;=  2020  &amp;&amp;  v  &lt;=  2030  Height  -&gt;  case  span  Char . isDigit  value  of  ( num ,  &#34;cm&#34; )  -&gt;  let  n  =  toInt  num  in  n  &gt;=  150  &amp;&amp;  n  &lt;=  193  ( num ,  &#34;in&#34; )  -&gt;  let  n  =  toInt  num  in  n  &gt;=  59  &amp;&amp;  n  &lt;=  76  _  -&gt;  False  HairColor  -&gt;  case  ( length  value ,  value )  of  ( 7 ,  &#39;#&#39;  :  rest )  -&gt;  all  (` elem`  allowedHexChars )  rest  _  -&gt;  False  EyeColor  -&gt;  value ` elem`  validEyeColors  PassportId  -&gt;  length  value  ==  9  &amp;&amp;  all  Char . isDigit  value  CountryId  -&gt;  all  Char . isDigit  value toInt  ::  String  -&gt;  Int toInt  =  read validEyeColors  ::  [ String ] validEyeColors  =  [ &#34;amb&#34; ,  &#34;blu&#34; ,  &#34;brn&#34; ,  &#34;gry&#34; ,  &#34;grn&#34; ,  &#34;hzl&#34; ,  &#34;oth&#34; ] allowedHexChars  ::  [ Char ] allowedHexChars  =  [ &#39;0&#39;  ..  &#39;9&#39; ]  &lt;&gt;  [ &#39;a&#39;  ..  &#39;f&#39; ]</p><p> isFieldValid ::（PassportField，String）-＆gt; Bool isFieldValid（field，value）= BirthYear的case字段->令v ＝长度值＝＝ 4的inInt值。 v＆gt; = 1920＆amp;＆amp; v＆lt; = 2002 IssueYear-＆gt;令v ＝长度值＝＝ 4的inInt值。 v＆gt; = 2010＆amp;＆amp; v＆lt; = 2020年有效期-＆gt;令v ＝长度值＝＝ 4的inInt值。 v＆gt; = 2020＆amp;＆amp; v＆lt; = 2030高度-＆gt;案例跨度Char。 （num，＆＃34; cm＆＃34;）-＆gt;的isDigit值设n = toInt num in n＆gt; = 150＆amp; n＆lt; = 193（num，＆＃34; in＆＃34;）-＆gt;设n = toInt num in n＆gt; = 59＆amp;＆amp; n＆lt; = 76 _-＆gt;假发色-＆gt; case（length value，value）为（7，＆＃39;：rest）-＆gt;全部（`elem` allowedHexChars）其余_-＆gt;假EyeColor-＆gt;值`elem` validEyeColors PassportId-＆gt;长度值== 9＆amp;＆amp;所有字符。 isDigit值CountryId-＆gt;所有字符。 isDigit值toInt ::字符串-＆gt; Int toInt =读取validEyeColors :: [String] validEyeColors = [＆＃34; amb＆＃34; ，＆＃34; blu＆＃34; ，＆nbn＆＃34; ，＆gry＆＃34; ，＆＃34; grn＆＃34; ，＆＃34; hzl＆＃34; ，＆oth＆＃34; ] allowedHexChars :: [Char] allowedHexChars = [＆＃39; 0＆＃39; ..＆＃39; 9＆＃39; ]＆lt;＆gt; [＆＃39; a＆＃39; ..＆＃39; f＆＃39; ]</p><p>  isEntryValid  ::  PassportEntry  -&gt;  Bool isEntryValid  entry  =  requiredFieldsPresent  &amp;&amp;  allFieldsValid  where  requiredFieldsPresent  =  all  ( `HM.member`  entry )  requiredFields  allFieldsValid  =  all  isFieldValid  ( HM.toList  entry )</p><p>  isEntryValid :: PassportEntry-＆gt;布尔isEntryValid条目= requiredFieldsPresent＆amp;＆amp; allFieldsValid其中requiredFieldsPresent =所有（“ HM.member”条目）requiredFields allFieldsValid =所有isFieldValid（HM.toList条目）</p><p> Running this program on our second data sample yields  1, and it will begood enough to solve the Advent of Code challenge and get us those sweetsweet stars.</p><p> 在我们的第二个数据样本上运行该程序将得到1，这足以解决代码的到来挑战，并为我们赢得那些甜蜜的星星。</p><p>   If we look back at the  currentstate ofour code, we can see that we are doing a lot of validations.</p><p>   如果我们回顾一下代码的当前状态，可以看到我们正在做很多验证。</p><p> We do a lot of work to verify if something is valid, then throw it all outof the window to return a meagre  Bool. German folks from the  sixteenthcenturywould have told us snarkily:</p><p> 我们做了很多工作来验证某些东西是否有效，然后将其全部扔出窗口以返回一个微不足道的布尔。十六世纪的德国人会偷偷地告诉我们： </p><p>     With our current code, we know which passport is valid, but we have no wayof extracting the eye color of a valid passport. This is why earlier wewere mentioning this sort of  Passport representation:</p><p>使用我们当前的代码，我们知道哪本护照有效，但是我们无法提取有效护照的眼睛颜色。这就是为什么我们前面提到这种Passport表示的原因：</p><p> data  Passport  =  Passport  {  birthYear  ::  Int ,  issueYear  ::  Int ,  expirationYear  ::  Int ,  height  ::  String ,  hairColor  ::  String ,  eyeColor  ::  String ,  passportId  ::  String ,  countryId  ::  Maybe  Int  }</p><p> 数据Passport = Passport {birthYear :: Int，issueYear :: Int，expirationYear :: Int，height :: String，hairColor :: String，eyeColor :: String，passportId :: String，countryId :: Maybe Int}</p><p> If we had a function like  parsePassport that went from  String to  MaybePassport we could then write some code like this:</p><p> 如果我们有一个像parsePassport这样的函数，它从String变为MaybePassport，那么我们可以编写如下代码：</p><p>  But let’s not get too ahead of ourselves. Let’s try to refactor our currentcode to do something similar. First we can try to write a function likethis one:</p><p>  但是，不要让自己过分领先。让我们尝试重构当前代码以执行类似的操作。首先，我们可以尝试编写一个像这样的函数：</p><p>  This function takes the intermediate representation of a collection ofpassport fields and returns a ‘validated’ passport. We can also reuse our isFieldValid function by using this trick:</p><p>  此函数采用一系列护照字段的中间表示形式，并返回“已验证”护照。我们还可以使用以下技巧重用isFieldValid函数：</p><p> parseField  ::  ( PassportField ,  String )  -&gt;  Maybe  ( PassportField ,  String ) parseField  tuple  =  if  isFieldValid  tuple  then  Just  tuple  else  Nothing</p><p> parseField ::（PassportField，String）-＆gt;也许（PassportField，String）parseField元组=如果isFieldValid元组，则只是元组，否则</p><p> We are still reusing the validating logic, but we end up returningsomething useful instead. Remember, we are slowly migrating our code fromvalidating data to parsing data.</p><p> 我们仍然在重用验证逻辑，但是最终返回了一些有用的东西。记住，我们正在缓慢地将代码从验证数据迁移到解析数据。 </p><p> Using our new helper we can finally implement the  entryToPassportfunction. We’ll do that in two separate steps. First we’ll get all thevalues of the required fields:</p><p>使用新的帮助程序，我们最终可以实现entryToPassport函数。我们将分两个步骤进行操作。首先，我们将获得必填字段的所有值：</p><p> getAllRequiredFields  ::  PassportEntry  -&gt;  Maybe  [ String ] getAllRequiredFields  e  =  traverse  (  \ field  -&gt;  do  v  &lt;-  HM . lookup  field  e  ( _field ,  text )  &lt;-  parseField  ( field ,  v )  return  text  )  requiredFields</p><p> getAllRequiredFields :: PassportEntry-＆gt;也许[String] getAllRequiredFields e =遍历（\ field-＆gt; do v＆lt;-HM.lookup field e（_field，text）＆lt;-parseField（field，v）返回text）requiredFields</p><p> The  traverse magic ensures that we either get all the values we’relooking for wrapped in a  Just, or  Nothing if any of those fields wereinvalid. Ok, we’re ready to roll now!</p><p> 遍历魔术可以确保我们将要查找的所有值包装在Just中，如果其中任何一个无效，则为Nothing。好的，我们现在就可以开始滚动！</p><p> entryToPassport  ::  PassportEntry  -&gt;  Maybe  Passport entryToPassport  entry  =  do  case  getAllRequiredFields  entry  of  Just  [ byr ,  iyr ,  eyr ,  hgt ,  hcl ,  ecl ,  pid ]  -&gt;  Just  $  Passport  {  birthYear  =  toInt  byr ,  issueYear  =  toInt  iyr ,  expirationYear  =  toInt  eyr ,  height  =  hgt ,  hairColor  =  hcl ,  eyeColor  =  ecl ,  passportId  =  pid ,  countryId  =  toInt  &lt;$&gt;  HM . lookup  CountryId  entry  }  _  -&gt;  Nothing</p><p> entryToPassport :: PassportEntry-＆gt;也许Passport entryToPassport entry = Just [byr，iyr，eyr，hgt，hcl，ecl，pid]的case getAllRequiredFields条目->只需$护照{birthYear = toInt byr，issueYear = toInt iyr，expirationYear = toInt eyr，height = hgt，hairColor = hcl，eyeColor = ecl，passportId = pid，countryId = toInt＆lt; $＆gt; HM。查找CountryId条目} _-＆gt;没有</p><p> We end up having to pass  String values around, which need to be parsedagain into the exact types that we desire. Also we need to pass thesevalues into a list and hope not to mess up the ordering of the fields. Soit’s far from perfect, but we’re getting somewhere.</p><p> 我们最终不得不传递字符串值，需要再次将其解析为所需的确切类型。另外，我们需要将这些值传递到列表中，并希望不要弄乱字段的顺序。 Soit远非完美，但我们正在取得进展。</p><p> In order to use this function in our main, we replace the last line of themain fuction from:</p><p> 为了在我们的main中使用此功能，我们从以下位置替换main函数的最后一行：</p><p>    Running this onour test batch still returns  1, which is a good sign we haven’t brokenanything.</p><p>    运行此ontest批处理仍会返回1，这表明我们没有做任何事情。 </p><p> Still, there is one thing that I’m particularly unhappy about in this code:we use an intermediate representation of the passport that has no realdomain value. Nobody cares about  PassportField and  PassportEntry, butwe need to have these types in order to build our  Passport.</p><p>不过，这段代码令我特别不满意的一件事：我们使用的护照的中间表示形式没有实域值。没有人关心PassportField和PassportEntry，但是我们需要具有这些类型才能构建我们的Passport。</p><p> Not only that, but having these intermediate types means that there arebugs waiting to happen when we transform them to our desired data type:</p><p> 不仅如此，拥有这些中间类型还意味着当我们将它们转换为所需的数据类型时，有一些错误等待发生：</p><p>   Shotgun parsing is a programming antipattern whereby parsing and input-validating code is mixed with and spread across processing code—throwing a cloud of checks at the input, and hoping, without any systematic justification, that one or another would catch all the “bad” cases.</p><p>   Shotgun解析是一种编程反模式，解析和输入验证代码与处理代码混合并分布在处理代码之间，从而在输入处抛出一堆检查，并希望在没有任何系统理由的情况下，一个或另一个将捕获所有“不良”信息案件。</p><p> In “Parse, don’t validate”, Alexis King goes on to describe how this isspecifically related to parsing and validating:</p><p> 亚历克西斯·金（Alexis King）在“解析，不验证”一书中继续描述了它与解析和验证之间的特定关系：</p><p> It may not be immediately apparent what shotgun parsing has to do with validation—after all, if you do all your validation up front, you mitigate the risk of shotgun parsing. The problem is that validation-based approaches make it extremely difficult or impossible to determine if everything was actually validated up front or if some of those so-called “impossible” cases might actually happen. The entire program must assume that raising an exception anywhere is not only possible, it’s regularly necessary.</p><p> shot弹枪解析与验证有什么关系可能尚不明显，毕竟，如果您事先进行了所有验证，就可以减轻of弹枪解析的风险。问题在于，基于验证的方法使得很难或不可能确定所有事情是否都经过了预先验证，或者是否确实可能发生了一些所谓的“不可能”情况。整个计划都必须假设，不仅在任何地方都可能引发异常，而且这是经常性的。</p><p>   We’re going to write the same program using parsec, a monadic parsercombinator library. I’ve recently bumpedinto this excellent  walkthrough to parsercombinators, whichI thouroughly recommend reading.</p><p>   我们将使用monsec的parsercombinator库parsec编写相同的程序。我最近接触了Parsercombinator的出色演练，我一直建议阅读。</p><p>   It works by consuming input characters from the input string and returninga tuple with two values:</p><p>   它通过使用输入字符串中的输入字符并返回具有两个值的元组来工作： </p><p> The first value is what’s left of the input string, so that otherparsers can keep parsing the rest of the input.</p><p>第一个值是输入字符串的剩余值，以便其他解析器可以继续解析其余的输入。</p><p> The second value contains either a parse error or a properly parsed value of type  a.</p><p> 第二个值包含解析错误或类型为a的正确解析值。</p><p>    -- byr (Birth Year) - four digits; between 1920 and 2002. byrParser  ::  Parser  Int byrParser  =  do  P.string  &#34;byr&#34;  P.char  &#39;:&#39;  value  &lt;-  P.count  4  P.digit  P.spaces  let  int  =  read  value  guard  ( int  &gt;=  1920  &amp;&amp;  int  &lt;=  2002 )  return  int -- iyr (Issue Year) - four digits; between 2010 and 2020. iyrParser  ::  Parser  Int iyrParser  =  do  P.string  &#34;iyr&#34;  P.char  &#39;:&#39;  value  &lt;-  P.count  4  P.digit  P.spaces  let  int  =  read  value  guard  ( int  &gt;=  2010  &amp;&amp;  int  &lt;=  2020 )  return  int -- eyr (Expiration Year) - four digits; between 2020 and 2030. eyrParser  ::  Parser  Int eyrParser  =  do  P.string  &#34;eyr&#34;  P.char  &#39;:&#39;  value  &lt;-  P.count  4  P.digit  P.spaces  let  int  =  read  value  guard  ( int  &gt;=  2020  &amp;&amp;  int  &lt;=  2030 )  return  int</p><p>    -拜尔（生日）-四位数；在1920年到2002年之间。byrParser ::解析器Int byrParser = do P.string＆＃34; byr＆＃34; P.char＆＃39;：＆＃39;值＆lt;-P.count 4个P.digit P.spaces，让int =读取值保护（int＆gt; = 1920＆amp; int＆lt; = 2002）return int-iyr（Issue Year）-四位数字;在2010年至2020年之间。iyrParser :: Parser Int iyrParser = do P.string＆＃34; iyr＆＃34; P.char＆＃39;：＆＃39;值＆lt;-P.count 4个P.digit P.spaces，让int =读取值保护（int＆gt; = 2010＆amp; int＆lt; = 2020）return int-eyr（有效年）-四位数字;在2020年到2030年之间。eyrParser :: Parser Int eyrParser = do P.string＆＃34; eyr＆＃34; P.char＆＃39;：＆＃39;值＆lt;-P.count 4个P.digit P.spaces，让int =读取值保护（int＆gt; = 2020＆amp;＆amp; int＆lt; = 2030）返回int</p><p> Here we use the  guard function to introduce an assertion that will makethe parser fail when the condition is not met. In general I feel that thiscode is quite readable, but we might want to extract a reusable helper toparse years:</p><p> 在这里，我们使用保护功能引入一个断言，当不满足条件时，该断言将使解析器失败。总的来说，我觉得这段代码可读性很强，但是我们可能想提取一个可重用的帮助器来分析几年：</p><p> yearParser  ::  String  -&gt;  ( Int ,  Int )  -&gt;  Parser  Int yearParser  value  ( rangeStart ,  rangeEnd )  =  do  P.string  value  P.char  &#39;:&#39;  value  &lt;-  P.count  4  P.digit  P.spaces  let  int  =  read  value  guard  ( int  &gt;=  rangeStart  &amp;&amp;  int  &lt;=  rangeEnd )  return  int byrParser  ::  Parser  Int byrParser  =  do  yearParser  &#34;byr&#34;  ( 1920 ,  2002 ) iyrParser  ::  Parser  Int iyrParser  =  do  yearParser  &#34;iyr&#34;  ( 2010 ,  2020 ) eyrParser  ::  Parser  Int eyrParser  =  do  yearParser  &#34;eyr&#34;  ( 2020 ,  2030 )</p><p> yearParser ::字符串-＆gt; （Int，Int）-> Parser Int yearParser值（rangeStart，rangeEnd）=做P.string值P.char＆＃39;：＆＃39;值＆lt;-P.count 4个P.digit P.spaces，让int =读取值保护（int＆gt; = rangeStart＆amp;＆amp; int＆lt; = rangeEnd）返回int byrParser :: Parser Int byrParser = do yearParser＆＃34 ; byr＆＃34; （1920年，2002年）iyrParser :: Parser Int iyrParser = do yearParser＆＃34; iyr＆＃34; （2010年，2020年）eyrParser :: Parser Int eyrParser = do yearParser＆＃34; eyr＆＃34; （2020，2030）</p><p>  This is the beauty of writing parser combinators. They are  extremely easy toreuse and combine.</p><p>  这就是编写解析器组合器的美妙之处。它们非常易于重用和组合。</p><p> Now we want to write a parser for the height field. It might be nice to usea more specialized data type to represent that:</p><p> 现在我们要为高度字段编写一个解析器。使用更专业的数据类型来表示可能会很好： </p><p>   -- hgt (Height) - a number followed by either cm or in: -- If cm, the number must be between 150 and 193. -- If in, the number must be between 59 and 76. heightParser  ::  Parser  Height heightParser  =  do  P.string  &#34;hgt&#34;  P.char  &#39;:&#39;  digits  &lt;-  P.many1  P.digit  let  value  =  read  digits  result  &lt;-  unitParser  value  case  result  of  InCms  _  -&gt;  guard  ( value  &gt;=  150  &amp;&amp;  value  &lt;=  193 )  InInches  _  -&gt;  guard  ( value  &gt;=  59  &amp;&amp;  value  &lt;=  76 )  P.spaces  return  result</p><p>-hgt（高度）-一个数字，后跟cm或in：–如果为cm，则该数字必须介于150和193之间。–如果为cm，则该数字必须介于59和76之间。heightParser :: Parser Height heightParser =做P.string＆＃34; hgt＆＃34; P.char＆＃39;：＆＃39;位数＆lt;-P.many1 P.digit let value =读取的数字结果＆lt;-InCms _ unitParser值大小写结果_-＆gt;保护（值＆gt; = 150＆amp;＆amp;值＆lt; = 193）InInches _-＆gt;保护（值＆gt; = 59＆amp;＆amp;值＆lt; = 76）P.spaces返回结果</p><p>  unitParser  ::  Int  -&gt;  Parser  Height unitParser  value  =  let  cmParser  =  do  P.string  &#34;cm&#34;  return  ( InCms  value )  inParser  =  do  P.string  &#34;in&#34;  return  ( InInches  value )  in  P.choice  [ cmParser ,  inParser ]</p><p>  unitParser :: Int-＆gt;分析器高度unitParser值=让cmParser =执行P.string＆＃34; cm＆＃34; return（InCms value）inParser =做P.string＆＃34; in＆＃34;在P.choice [cmParser，inParser]中返回（InInches值）</p><p> The rest of the parsers are basically a step by step translation of therequirements in English:</p><p> 其余的解析器基本上是对英语要求的逐步翻译：</p><p> -- hcl (Hair Color) - a &#39;#&#39; followed by six chars 0-9 or a-f. hairColorParser  ::  Parser  String hairColorParser  =  do  P.string  &#34;hcl&#34;  P.char  &#39;:&#39;  P.char  &#39;#&#39;  v  &lt;-  P.count  6  ( P.oneOf  &#34;0123456789abcdef&#34; )  P.spaces  return  v</p><p> -hcl（发色）-a＆＃39;＃＆＃39;随后是六个字符0-9或a-f。 hairColorParser ::解析器字符串hairColorParser = do P.string＆＃34; hcl＆＃34; P.char＆＃39;：＆＃39;夏尔＆＃39;＃＆＃39; v＆lt;-P.count 6（P.oneOf＆＃34; 0123456789abcdef＆＃34;）P.spaces返回v</p><p> -- pid (Passport ID) - a nine-digit number. passportIdParser  ::  Parser  String passportIdParser  =  do  P.string  &#34;pid&#34;  P.char  &#39;:&#39;  v  &lt;-  P.count  9  P.digit  P.spaces  return  v</p><p> -pid（护照ID）-一个九位数的数字。 passwordIdParser ::解析器字符串passwordIdParser =做P.string＆＃34; pid＆＃34; P.char＆＃39;：＆＃39; v＆lt;-P.count 9个P位数字P.spaces返回v</p><p> -- cid (Country ID) - ignored, missing or not. countryIdParser  ::  Parser  Int countryIdParser  =  do  P.string  &#34;cid&#34;  P.char  &#39;:&#39;  value  &lt;-  P.many1  P.digit  P.spaces  return  $  read  value</p><p> -cid（国家/地区ID）-已忽略，缺失或缺失。 countryIdParser ::解析器Int countryIdParser =做P.string＆＃34; cid＆＃34; P.char＆＃39;：＆＃39;值＆lt;-P.many1 P.digit P.spaces返回$读取值</p><p> -- ecl (Eye Color) - one of: amb blu brn gry grn hzl oth. eyeColorParser  ::  Parser  String eyeColorParser  =  do  P.string  &#34;ecl&#34;  P.char  &#39;:&#39;  v  &lt;-  P.choice  $  map  ( P.try  .  P.string )  [  &#34;amb&#34; ,  &#34;blu&#34; ,  &#34;brn&#34; ,  &#34;gry&#34; ,  &#34;grn&#34; ,  &#34;hzl&#34; ,  &#34;oth&#34;  ]  P.spaces  return  v</p><p> -ecl（眼睛颜色）-其中之一：amb blu brn gry grn hzl oth。 eyeColorParser ::解析器字符串eyeColorParser = do P.string＆＃34; ecl＆＃34; P.char＆＃39;：＆＃39; v＆lt;-P.choice $ map（P.try。P.string）[＆＃34; amb＆＃34; ，＆＃34; blu＆＃34; ，＆nbn＆＃34; ，＆gry＆＃34; ，＆＃34; grn＆＃34; ，＆＃34; hzl＆＃34; ，＆oth＆＃34; P.spaces返回v </p><p> You will notice we had to use this mysterious  P.try function in the lastsnippet. This is very useful when we need to look ahead in the inputstring. Consider the example of  blu and  brn: after consuming an initial b character we land in the  blu branch. If at that point we encounter a r character, we realize we need to go back and choose the  brn branchinstead. But by default the parsing would stop because we have alreadyconsumed the first character.  P.try will make it so our parser pretendsit hasn’t consumed any input so that we can keep trying otheralternatives.</p><p>您会注意到我们必须在最后一个片段中使用此神秘的P.try函数。当我们需要在输入字符串中向前看时，这非常有用。考虑一下blu和brn的示例：消费了初始b字符后，我们进入了blu分支。如果此时遇到r字符，我们意识到我们需要返回并选择brn分支。但是默认情况下，解析将停止，因为我们已经消耗了第一个字符。 P.try会这样做，因此我们的解析器不会假装使用任何输入，因此我们可以继续尝试其他替代方案。</p><p> We have now written parsers for each individual field. So now it’s time tocombine them all together…</p><p> 现在，我们已经为每个字段编写了解析器。现在是时候将它们组合在一起了……</p><p>   Since our parser tries to consume input one character at a time, how theheck can we write one that has to deal with randomly ordered input?</p><p>   由于我们的解析器尝试一次消耗一个字符，因此我们该如何编写一个必须处理随机输入的字符呢？</p><p>    This module implements permutation parsers. A permutation phrase is asequence of elements (possibly of different types) in which each elementoccurs exactly once and the order is irrelevant. Some of the permutableelements may be optional.</p><p>    此模块实现置换解析器。排列短语是元素（可能是不同类型）的序列，其中每个元素恰好出现一次且顺序无关紧要。一些置换元素可能是可选的。</p><p>    permute is the last call that will wrap everything up and return aparser of something.</p><p>    permute是最后一个调用，它将包装所有内容并返回某些解析器。</p><p> &lt;$$&gt; is used to assign all the fields that we parsed to something. Inour case it will be a  Passport.</p><p> ＆lt; $$＆gt;用于将我们解析的所有字段分配给某些内容。在这种情况下，它将是护照。</p><p>  passportParser  ::  Parser  Passport passportParser  =  permute  $  Passport  &lt;$$&gt;  byrParser  &lt;||&gt;  iyrParser  &lt;||&gt;  P.try  eyrParser  &lt;||&gt;  P.try  heightParser  &lt;||&gt;  P.try  hairColorParser  &lt;||&gt;  P.try  eyeColorParser  &lt;||&gt;  passportIdParser  &lt;|?&gt;  ( Nothing ,  Just  &lt;$&gt;  countryId</p><p>  PassportParser :: Parser Passport PassportParser =置换$ Passport＆lt; $$＆gt; byrParser＆lt; ||＆gt; iyrParser＆lt; ||＆gt; P.try eyrParser＆lt; ||＆gt; P.try heightParser＆lt; ||＆gt; P.try hairColorParser＆lt; ||＆gt; P.try eyeColorParser＆lt; ||＆gt; PassportIdParser＆lt; |？＆gt; （没什么，只要＆lt; $＆gt; countryId </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://juliu.is/permutate-parsers/">https://juliu.is/permutate-parsers/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/置换/">#置换</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parsers/">#parsers</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>