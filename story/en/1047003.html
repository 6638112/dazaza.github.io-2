<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>低代码缺失的五件事 Five Things Low-Code Is Missing</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Five Things Low-Code Is Missing<br/>低代码缺失的五件事 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-31 07:13:53</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/31c8816d51a8828b12c0e9cf1b62cee1.png"><img src="http://img2.diglog.com/img/2021/1/31c8816d51a8828b12c0e9cf1b62cee1.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Currently, the ‘Low-Code’/’No-Code’ (LC/NC) space is a ‘hot’ market with a growing number of high-profile venture capital investments. Startups are receiving funding to forge various visions of ‘the future of software development’. These platforms have a spectrum of target users ranging from the non-technical ‘citizen developer’ to more technical developers. They also have varying use cases that range from interface/GUI front-end building to backend event processing with logic.</p><p>当前，“低代码” /“无代码”（LC / NC）空间是一个“热门”市场，越来越多的高端风险投资投入。初创企业正在获得资金以树立“软件开发的未来”的各种愿景。这些平台的目标用户范围广泛，从非技术性的“公民开发人员”到更多技术性开发人员。它们还具有不同的用例，范围从接口/ GUI前端构建到使用逻辑进行后端事件处理。</p><p> Low-Code has the power to materially improve the lives of developers looking to rapidly build production tooling. However, many ‘visual programming’ platforms are architected in ways that limit usability by developers.</p><p> Low-Code可以从根本上改善希望快速构建生产工具的开发人员的生活。但是，许多“视觉编程”平台的构建方式都限制了开发人员的可用性。</p><p> A  disclaimer, I am a co-founder @  WayScript — a development hub for internal tooling. We have been building a platform in the developer tooling space (which happens to have some low-code overlap which I’ll get to later). I am a backend software developer and come from a background in application development. As we continue to learn and build, we’ve studied myriad features/decisions in the spectrum of low-code products coming to market.</p><p> 免责声明，我是@ WayScript的共同创始人-内部工具的开发中心。我们已经在开发人员工具空间中构建了一个平台（碰巧会有一些低代码重叠，稍后再讲）。我是一名后端软件开发人员，具有应用程序开发背景。随着我们不断学习和构建，我们研究了投放市场的低代码产品的众多功能/决定。</p><p> So here’s 5 missing components from current platforms that would be game-changing for developers.</p><p> 因此，这是当前平台上缺少的5个组件，它们将对开发人员产生巨大的变化。</p><p>  As a software developer, my workflow is building software in a local dev environment which is subsequently stored in a cloud based git repository such as GitHub. When I am writing scripts, they are often built in a virtual environment which contains code, a complex file directory structure, and third-party dependencies. The trouble is that in order to turn these local command-line scripts into production tools, I need to do a lot more work for basic production (provisioning servers, deploying source code, configuration files, etc.). I also have to do much, much more work for robustness (CI/CD, unit testing, etc.). A lot of this infrastructure work ends up taking as much or more time than the core application.  What  I want is a cloud based development environment that feels like my local host environment, but seamlessly converts my script directories into stable production software.</p><p>  作为软件开发人员，我的工作流程是在本地开发环境中构建软件，该环境随后存储在基于云的git存储库（例如GitHub）中。在编写脚本时，它们通常是在包含代码，复杂的文件目录结构和第三方依赖关系的虚拟环境中构建的。麻烦在于，为了将这些本地命令行脚本转换为生产工具，我需要为基本生产做更多的工作（配置服务器，部署源代码，配置文件等）。我还必须做很多工作才能提高鲁棒性（CI / CD，单元测试等）。与基础应用程序相比，许多此类基础结构工作最终需要花费更多或更多的时间。我想要的是一个基于云的开发环境，感觉就像我的本地主机环境，但是将我的脚本目录无缝转换为稳定的生产软件。</p><p>  At their core, many LC/NC platforms are ‘JSON parsing’ utilities. Mainly, the platforms enable users to pull JSON data (usually from third party apis), and parse particular key/value pairs to pass to another API or interface.</p><p>  许多LC / NC平台的核心都是“ JSON解析”实用程序。主要是，该平台使用户能够提取JSON数据（通常从第三方api），并解析特定的键/值对以传递给另一个API或接口。</p><p>  As an example, users are empowered to pass  sample_json_data.email from an event trigger to another API without having to build the underlying API queries.</p><p>  例如，用户有权将sample_json_data.email从事件触发器传递到另一个API，而无需构建基础API查询。 </p><p> I want to mention that of course JSON parsing services are useful and can be used to build compelling automations / interfaces.  However, core product architecture built around JSON Parsing limits the types of applications that can be enhanced by low-code.</p><p>我想提一下，JSON解析服务当然很有用，可用于构建引人注目的自动化/接口。但是，围绕JSON解析构建的核心产品架构限制了可以通过低代码增强的应用程序类型。</p><p>  A low-code platform architecture built as a virtual environment file-system which can read, write, and delete arbitrary file structures. When ready for production, any project can be executed through the core platform engine on a dedicated cloud service. JSON data from an event trigger can be passed into the script as an importable variable (e.g. runs when a new customer is added to Salesforce and passes the data). Moreover, this virtual file system can support various programming languages and dependencies out of the box (python, java, c#, …). The virtual environment is cloud based and serves as a uniform runtime environment across varying devices and operating systems. Even when working on my local desktop, this environment runs in the cloud but feels indistinguishable from my local machine. Finally, this virtual environment can interact with third party file structures such as GitHub, S3, Dropbox, etc.  The system is seamless because a configuration file for production execution on a cloud server is automatically constructed by the platform (and editable if more customization is required).</p><p>  低代码平台体系结构，构建为虚拟环境文件系统，可以读取，写入和删除任意文件结构。准备投入生产后，可以通过专用云服务上的核心平台引擎来执行任何项目。可以将来自事件触发器的JSON数据作为可导入变量传递到脚本中（例如，在将新客户添加到Salesforce并传递数据时运行）。而且，该虚拟文件系统可以支持各种编程语言和开箱即用的依赖项（python，java，c＃等）。虚拟环境是基于云的，并且可以作为跨各种设备和操作系统的统一运行时环境。即使在我的本地桌面上工作时，该环境也可以在云中运行，但是与我的本地计算机没有区别。最后，该虚拟环境可以与第三方文件结构（例如GitHub，S3，Dropbox等）进行交互。该系统是无缝的，因为该平台可自动构建用于在云服务器上执行生产的配置文件（如果需要更多自定义，则可以编辑需要）。</p><p>  A platform that offers the ease of event-triggering and software hosting/running for any code repository (servers, tasks, etc.).</p><p>  一个平台，可以轻松地为任何代码存储库（服务器，任务等）进行事件触发和软件托管/运行。</p><p>  When most people think low-code, they think visual programming (a.k.a.  end-user development). Although visual programming is an example, in reality just about everything in software development is  ‘low-code’ — the abstraction of lower-level code through a higher-level interface. For example, the Python programming language can be interpreted as a low-code abstraction of the C programming language. Secondly, a popular API such as Twilio is a low-code improvement over building a text-messaging interface from scratch. In other words, an API is just as much a low-code product as a visual programming interface. The important point here is just that there should be a distinction between low-code and visual programming.</p><p>  当大多数人想到低代码时，他们就会想到可视化编程（也就是最终用户开发）。尽管可视化编程是一个示例，但实际上，软件开发中的几乎所有内容都是“低代码”，即通过较高级别的界面对较低级别的代码的抽象。例如，Python编程语言可以解释为C编程语言的低代码抽象。其次，诸如Twilio之类的流行API与从头开始构建文本消息接口相比，是一个低代码的改进。换句话说，API和可视编程接口一样，都是低代码产品。这里的重点是，低代码和可视编程之间应该有所区别。</p><p> This distinction fosters two questions. First, is visual programming the right paradigm for production grade scripting and tooling? Secondly, what are the most valuable features of these platforms?</p><p> 这种区别引发了两个问题。首先，可视化编程是生产级脚本和工具的正确范例吗？其次，这些平台最有价值的功能是什么？</p><p> For the first question, the answer is that visual programming can be a useful aid in software development, but it can also be a hindrance when it’s forced for its own sake. An example of a useful visual interface might be setting up a cron job to execute a script or interacting with a simple API.  Often, the use cases that benefit from visual programming are components of software that require a lot of specialized code to deliver simple and common functionality.  However, by forcing an entire platform to use visual programming, you end up stuck in places where it becomes a hindrance. Often, code is the simplest and fastest way to express what you want to do. For example, building boolean logic such as  if/else statements with visual programming quickly become unruly to setup and manage.  As a developer, I’d rather just write my logic in python.</p><p> 对于第一个问题，答案是视觉编程可以在软件开发中提供有用的帮助，但是当它被迫为自己着想时也可以成为障碍。有用的可视界面的一个示例可能是设置cron作业以执行脚本或与简单的API交互。通常，受益于视觉编程的用例是软件的组件，这些组件需要大量专门的代码才能提供简单而通用的功能。但是，通过强制整个平台使用可视化编程，您最终会陷入阻碍的境地。通常，代码是表达您想要做的事情的最简单，最快的方法。例如，使用可视化程序构建布尔逻辑（例如if / else语句）很快就变得难以设置和管理。作为开发人员，我宁愿只用python编写逻辑。</p><p> So what are the most valuable features of visual programming platforms? First, the builtin event based triggering mechanisms are a great benefit (e.g. run whenever a new customer is added to my database or CRM). This is useful because setting up this type of trigger system requires another coding project (hosting a server for incoming webhooks) and distracts me from the core problem I am trying to solve. Secondly, the ability of these platforms to seamlessly run the constructed automations in the cloud without any dev ops process is beneficial.</p><p> 那么可视化编程平台最有价值的功能是什么？首先，基于事件的内置触发机制有很大的好处（例如，每当有新客户添加到我的数据库或CRM时就运行）。这很有用，因为设置这种类型的触发系统需要另一个编码项目（为传入的Webhooks托管服务器），并使我无法解决要解决的核心问题。其次，这些平台无需任何开发流程即可在云中无缝运行已构建的自动化功能的能力是有益的。 </p><p>  A virtual environment platform with integrated event triggering from third party APIs (at the least a generalizable HTTP endpoint) that can push the request response data into scripts at execution of the application. Secondly, baked in APIs that handle oauth/credentialing, easy parameter inputs, and proper querying can save time. These APIs also benefit from visual interfaces (sending a custom email, slack message, etc.).</p><p>一个虚拟环境平台，具有从第三方API（至少是可通用化的HTTP端点）触发的集成事件触发，可以在应用程序执行时将请求响应数据推送到脚本中。其次，在处理oauth /凭证，易于输入参数和正确查询的API中进行烘焙可以节省时间。这些API还受益于可视界面（发送自定义电子邮件，松弛消息等）。</p><p>  The service should be ‘smart’ about understanding dependencies and treat this as a first class problem to solve. For example, if an internal tool relies on a file in a particular directory location, a particular db schema, or another constant then at a minimum the platform should  recognize breaking changes and alert stakeholders immediately with an explanation of what changed. The best experience would allow users to easily build unit-tests with minimal added work.</p><p>  该服务应该“聪明”地了解依赖关系，并将其视为要解决的头等问题。例如，如果内部工具依赖于特定目录位置，特定数据库模式或另一个常量中的文件，则平台至少应识别出重大更改，并立即向涉众报告警告更改内容。最好的体验将使用户以最少的工作量轻松构建单元测试。</p><p>  When working with teams building internal scripts and workflow automations, we often find that shared files are a potential pressure point / weakness in production stability. For example, we worked with a company that was running workflow automations on a Google Sheet which was simultaneously being edited by employees. If a sheet, column, or particular cell was accidentally edited, the automations would break without any indication (at least not immediately). Tracking down the root cause here when debugging is hard, time consuming, and doesn’t prevent this issue in the future. In another case, a company had a few internal tools that expected a database schema to be in a certain format and the tools all crashed when the db was upgraded.  The reality is that both file dependencies and real world data is messy, and many platforms expect users to manage this mess.</p><p>  与团队一起构建内部脚本和工作流自动化时，我们经常发现共享文件是潜在的压力点/生产稳定性的弱点。例如，我们与一家在Google表格上运行工作流程自动化的公司合作，该工作表同时由员工进行编辑。如果不小心编辑了工作表，列或特定单元格，则自动化将中断而没有任何指示（至少不是立即显示）。当调试困难，耗时且在将来无法避免此问题时，在此处查找根本原因。在另一种情况下，一家公司有一些内部工具，它们期望数据库架构采用某种格式，并且这些工具在升级数据库时都崩溃了。现实情况是文件依赖性和真实世界的数据都是混乱的，许多平台都希望用户能够管理这种混乱。</p><p>  The platform’s auto-generated configuration file for each program should include a mapping of all files and folders utilized within the program. Any references to these files should be stored in the metadata.  In other words, the application ‘understands’ file dependencies and the nature of the dependency (directory location, internal data structures, typing, etc.). With this architecture, one can envision a low-code mapping that shows all file interdependencies within a system of scripts and tools that are running.</p><p>  该平台为每个程序自动生成的配置文件应包括该程序中使用的所有文件和文件夹的映射。对这些文件的任何引用都应存储在元数据中。换句话说，应用程序“了解”文件依赖关系和依赖关系的性质（目录位置，内部数据结构，类型等）。通过这种体系结构，可以预见一个低代码映射，该映射显示正在运行的脚本和工具系统中所有文件的相互依赖性。</p><p>  A platform paradigm that enables users to seamlessly run code, scripts, and servers in a cloud virtual environment without dev ops or setup (it feels like your local environment). Versioning and collaboration are much easier to apply to a file architecture than to a proprietary program saved in a third party services database. In other words,  the user owns the source code instead of the service.</p><p>  一种平台范例，使用户可以在云虚拟环境中无缝运行代码，脚本和服务器，而无需进行开发操作或设置（感觉就像您的本地环境）。与存储在第三方服务数据库中的专有程序相比，版本控制和协作要容易得多地应用于文件体系结构。换句话说，用户拥有源代码而不是服务。</p><p>  Many End-User Programming LC/NC platforms are architected so that the program content lives in the company database (Zapier stores your ‘zaps’, etc.). This paradigm is antithetical to the git/repository paradigm utilized by most developers when building tooling. The benefits of a git paradigm like GitHub are version control, shareability, portability, and collaboration (open source repos as an example).  For building tooling, a paradigm that empowers developers to store and collaborate on a program by treating all elements as files in a directory is crucial. This returns to the notion that the low code program at its core should work as an editable file within a system where the purpose of the platform is to aid users in configuration (whether through visual programming or great documentation). This paradigm unlocks the ability for more sophisticated tooling and can leverage many of the tools software developers already use such as GitHub for source control. As an added benefit, this same architecture unlocks a more modular development experience where more fundamental pieces can be manipulated (in other words, users can edit / understand the lowest level code if they need to).</p><p>  许多最终用户编程LC / NC平台都是经过架构设计的，因此程序内容位于公司数据库中（Zapier存储您的“ Zap”等）。此范例与大多数开发人员在构建工具时使用的git /存储库范例相反。像GitHub这样的git范例的好处是版本控制，可共享性，可移植性和协作（以开放源代码存储库为例）。对于构建工具而言，通过将所有元素都视为目录中的文件，使开发人员能够在程序上进行存储和协作的范例至关重要。这回到了一个想法，即低代码程序的核心应该在系统中以平台上的目的是帮助用户进行配置（无论是通过可视化编程还是编写出色的文档）来作为可编辑文件工作。这种范例释放了开发更复杂工具的能力，并且可以利用软件开发人员已经使用的许多工具（例如GitHub）进行源代码控制。另外一个好处是，这种相同的体系结构可带来更多模块化的开发体验，在该体验中，可以操纵更多基本部分（换句话说，用户可以根据需要编辑/理解最低级别的代码）。</p><p> In my opinion, the platform  GitBook does this well for building documentation. Mainly, the visual interface GitBook provides makes it super easy to build dynamic documentation and the underlying content is stored in each users GitHub account as a repository of markdown files (see our own  docs here and the  underlying file structure). By utilizing GitHub, GitBook is able to leverage the platform for conflict management and facilitates better low-level capabilities for devs.</p><p> 我认为，平台GitBook在构建文档方面做得很好。主要是，GitBook提供的可视界面使构建动态文档变得非常容易，基础内容作为markdown文件的存储库存储在每个用户的GitHub帐户中（请参阅此处的文档和基础文件结构）。通过利用GitHub，GitBook能够利用该平台进行冲突管理，并为开发人员提供更好的底层功能。 </p><p>  A LC platform that aids/automatically constructs a configuration file in the source code to run arbitrary code on a cloud service (scripts, servers/endpoints, etc.). All the files related to the script are owned and stored by the user instead of the services database. All the service stores is references to where these files are stored (GitHub, S3, Dropbox, etc.)</p><p>一个可在源代码中辅助/自动构造配置文件的LC平台，以在云服务（脚本，服务器/端点等）上运行任意代码。与脚本相关的所有文件均由用户而非服务数据库拥有和存储。所有服务存储都引用了这些文件的存储位置（GitHub，S3，Dropbox等）。</p><p>  Forced vendor lock in creates a true barrier for developers. What happens if a company goes out of business or spikes their pricing? What happens if I suddenly need a feature or more resources that the service is unable to provide? In these instances, it is a problem if I am locked in.</p><p>  强制供应商锁定对开发人员造成了真正的障碍。如果公司停业或提高价格会怎样？如果我突然需要该服务无法提供的功能或更多资源，该怎么办？在这些情况下，如果我被锁定，将是一个问题。</p><p>  When building software tools, many tend to become mission critical over time. As a developer, a huge value proposition of building my tooling from scratch is that I have complete autonomy. I can decide which frameworks to use, where to host, etc.</p><p>  在构建软件工具时，随着时间的流逝，许多工具往往变得至关重要。作为开发人员，从头开始构建工具的巨大价值主张是我拥有完全的自主权。我可以决定使用哪些框架，在何处托管等。</p><p> Today, most visual programming platforms inherently lock users into their system with their paradigm and treat this ‘stickiness’ as a business benefit. For example, using AirTable is highly convenient in many cases but also creates some uneasiness as a choice when building tooling. Mainly, I do not have the ability to access the underlying relational database if I needed/wanted to.</p><p> 如今，大多数可视化编程平台都固有地以其范式将用户锁定在他们的系统中，并将这种“粘性”视为商业利益。例如，在许多情况下，使用AirTable极为方便，但是在构建工具时，也会产生一些不安作为选择。主要地，如果我需要/想要的话，我没有访问基础关系数据库的能力。</p><p>  A platform that treats each component of the service it offers (such as event triggering, hosting, credentials, etc.) as a file inside a repository. With this paradigm, I can write all my code however I want and could always replace a configuration file with another service (swap a Heroku ProcFile for an AWS config file as an example). Yes, sometimes this work is tedious BUT I need to have the option. Secondly,  this architecture aligns incentives for the service to offer best in class service of their components or those pieces will be swapped for a better service.</p><p>  一个平台，将其提供的服务的每个组件（例如事件触发，托管，凭据等）都视为存储库中的文件。通过这种范例，我可以编写自己的所有代码，并且可以始终用其他服务替换配置文件（例如，将AWS config文件的Heroku ProcFile交换为示例）。是的，有时这项工作很乏味，但我需要选择。其次，此体系结构调整了对服务的激励，以为其组件提供一流的服务，否则这些组件将被交换为更好的服务。</p><p>  Low-code has the power to materially improve the lives of developers looking to rapidly build production tooling. However, ‘visual programming’ platforms which leverage low-code are often architected in ways that limit use by developers. A service that solves these problems would be a major value prop to all developers.</p><p>  低代码可以有效改善希望快速构建生产工具的开发人员的生活。但是，利用低代码的“可视化编程”平台通常以限制开发人员使用的方式进行设计。解决这些问题的服务将是所有开发人员的主要价值支持。</p><p> What do you think? Do you have other major problems with these platforms as a developer?</p><p> 你有什么感想？作为开发人员，这些平台是否还有其他主要问题？ </p><p> At   WayScript , we are building a platform for developers looking to quickly build internal tooling. In a future post, I will write a follow-up as to how our platform is architected to address the issues raised in this article.</p><p>在WayScript上，我们正在为希望快速构建内部工具的开发人员构建一个平台。 在以后的文章中，我将写一篇关于如何构建我们的平台以解决本文提出的问题的后续文章。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://orshanjesse.medium.com/5-things-low-code-is-missing-377221936a5d">https://orshanjesse.medium.com/5-things-low-code-is-missing-377221936a5d</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/code/">#code</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/构建/">#构建</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>