<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在Python中实现Rust的Dbg Implementing Rust's Dbg in Python</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Implementing Rust's Dbg in Python<br/>在Python中实现Rust的Dbg </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-12 00:35:54</div><div class="page_narrow text-break page_content"><p>Rust has an  amazing dbg macro that lets you quickly set up an expression printer that will also put in the source line. It also returns the value of the expression so you can even easily inline the printing when you want to!</p><p>Rust具有令人惊叹的dbg宏，可让您快速设置一个表达式打印机，该打印机也将放在源代码行中。它还返回表达式的值，因此您甚至可以在需要时轻松地内联打印！</p><p> let   a   =   2 ;  let   b   =   dbg! ( a   *   2 )   +   1 ;  // ^-- prints: [src/main.rs:2] a * 2 = 4 assert_eq! ( b ,   5 );</p><p> 令a = 2;让b = dbg！ （a * 2）+1; // ^-打印：[src / main.rs：2] a * 2 = 4 assert_eq！ （b，5）;</p><p> Doing a bunch of Python, I  want this in Python as well. I want a debug macro, one that gives me the file location + the expression used to calculate the value.</p><p> 做一堆Python，我也希望在Python中做到这一点。我想要一个调试宏，它为我提供了文件位置+用于计算值的表达式。</p><p>     This is annoying because you end up typing the same expression twice, you can&#39;t inline it, and it just doesn&#39;t look very cool.</p><p>     这很烦人，因为您最终两次键入相同的表达式，无法内联它，而且看起来也不是很酷。</p><p> The first thing when trying to implement this is to come to terms with Python&#39;s lack of macros. You can&#39;t really mess with the syntax tree, so you&#39;re really only operating on calculated values. So it&#39;s really hard to capture an expression  and its result in a single operation because, well, your expressions get evaluated.</p><p> 尝试实现此功能时，第一件事就是要接受Python缺少宏的情况。您不会真正弄混语法树，因此实际上只对计算出的值进行运算。因此，实际上很难在单个操作中捕获表达式及其结果，因为表达式会被求值。</p><p> So it&#39;ll be hard, to print  some_expr = &lt;result of some_expr&gt; without providing the string of  some_expr at one point.</p><p> 因此，要打印some_expr =＆lt; some_expr的结果＆gt;一次不提供some_expr字符串。</p><p> However, thanks to  eval, you can flip this idea on its head. You  need the string for the expression, but you don&#39;t need the expression itself!</p><p> 但是，由于有了eval，您可以颠倒这个想法。您需要表达式的字符串，但是您不需要表达式本身！ </p><p>  One step backwards, let&#39;s now go two steps forward. We can start writing our  dbg helper function</p><p>向后退一步，现在向前两步。我们可以开始编写dbg helper函数</p><p> foo  =  {  &#34;bar&#34; :  3 } def  dbg ( expr ):  result  =  eval ( expr )  print ( f &#34; { expr }  =  { result } &#34; ) dbg ( &#34;foo[&#39;bar&#39;]&#34; )  # foo[&#39;bar&#39;] = 3</p><p> foo = {＆＃34; bar＆＃34; ：3} def dbg（expr）：result = eval（expr）print（f＆＃34; {expr} = {result}＆＃34;）dbg（＆＃34; foo [＆＃39; bar＆＃39; ]＆＃34;）＃foo [＆＃39; bar＆＃39;] = 3</p><p> So far so good, we have a nice pretty printer here at the cost of two quotation marks.</p><p> 到目前为止，到目前为止，我们在这里有一台漂亮的漂亮打印机，但使用了两个引号。</p><p>   Turns out that when calling  eval without arguments we are evaluating  within the scope of  dbg. Our examples work because  dbg is defined alongside our expressions (so  foo is accessible within  dbg) but it&#39;s susceptible to name shadowing or outright not being able to calculate the expression because it could be defined in a different scope</p><p>   事实证明，在不带参数的情况下调用eval时，我们将在dbg范围内进行评估。我们的示例之所以有效，是因为dbg是在表达式旁边定义的（因此foo在dbg中是可访问的），但是由于名称可以在不同的范围内定义，因此很容易出现名称阴影或无法计算表达式的情况</p><p> def  dbg ( expr ):  # we&#39;re calculating the result here....  result  =  eval ( expr )  print ( f &#34; { expr }  =  { result } &#34; ) # but actually want to calculate # the result within this scope dbg ( &#34;expr&#34; )</p><p> def dbg（expr）：＃我们在这里计算结果.... result = eval（expr）print（f＆＃34; {expr} = {result}＆＃34;）＃但实际上想要计算此范围内的结果dbg（＆＃34; expr＆＃34;）</p><p> eval by default will evaluate the expression within the current frame. But we can pass in our own globals and locals to instead evaluate the expression within an arbitrary environment</p><p> 默认情况下，eval将计算当前帧内的表达式。但是我们可以传入自己的全局变量和局部变量来代替在任意环境中评估表达式</p><p>   There are four main kinds of services provided by this module: type checking,  getting source code, inspecting classes and functions, and  examining the interpreter stack.</p><p>   此模块提供四种主要服务：类型检查，获取源代码，检查类和函数以及检查解释器堆栈。 </p><p>  import  inspect def  dbg ( expr ):  print ( inspect . stack ()[ 0 ] . code_context )  result  =  eval ( expr )  print ( f &#34; { expr }  =  { result } &#34; )  return  result dbg ( &#34;foo[&#39;bar&#39;]&#34; ) expr  =  5 dbg ( &#34;expr&#34; ) if  dbg ( &#34;True&#34; ):  print ( &#34;Passed&#34; )</p><p>导入检查def dbg（expr）：打印（检查。stack（）[0]。code_context）结果= eval（expr）打印（f＆＃34; {expr} = {结果}＆＃34;）返回结果dbg（ ＆＃34; foo [＆＃39; bar＆＃39;）expr = 5 dbg（＆＃34; expr＆＃34;）如果dbg（＆＃34; True＆＃34;）：打印（＆ ＃34;通过＆＃34;）</p><p>   Since this is in a function call we&#39;ll actually need to go up the stack one frame ( inspect.stack()[1]) to get the proper line:</p><p>   由于这是在函数调用中，因此我们实际上需要将堆栈上移一帧（inspect.stack（）[1]）以获取正确的行：</p><p>  OK, now we are getting closer to where we need. the second element in our stack is where we&#39;ll also get the file path and the line number. Let&#39;s clean this up a bit and now we get:</p><p>  好的，现在我们离需要的地方越来越近。堆栈中的第二个元素是我们还将获取文件路径和行号的位置。让我们清理一下，现在我们得到：</p><p>  Here we have the full file path... one might do a trick here to stick with the file name:</p><p>  这里我们有完整的文件路径...在这里可能有人想办法坚持使用文件名：</p><p> def  dbg ( expr ):  frame  =  inspect . stack ()[ 1 ] . frame  filename  =  frame . filename . split ( &#34;/&#34; )[ - 1 ]  print ( f &#34;[ { filename } :  { frame . lineno } ]  { expr }  =  { result } &#34; )  return  result</p><p> def dbg（expr）：frame =检查。 stack（）[1]。框架文件名=框架。文件名 。 split（＆＃34; /＆＃34;）[-1] print（f＆＃34; [{文件名}：{frame。lineno}] {expr} = {result}＆＃34;）返回结果</p><p>   OK so this is good on the formatting. But we still haven&#39;t fixed  eval! That&#39;s a tiny fix this:</p><p>   好的，这样对格式化很有好处。但是我们还没有修复评估！这是一个小小的解决方案：</p><p> def  dbg ( expr ):  frame  =  inspect . stack ()[ 1 ] . frame  result  =  eval ( expr ,  frame . f_globals ,  frame . f_locals )  print ( f &#34; { expr }  =  { result } &#34; )  return  result</p><p> def dbg（expr）：frame =检查。 stack（）[1]。 frame result = eval（expr，frame.f_globals，frame.f_locals）print（f＆＃34; {expr} = {result}＆＃34;）返回结果 </p><p> This gets us the right values, properly evaluating  expr from the calling scope instead of  dbg:</p><p>这为我们提供了正确的值，可以从调用范围而不是dbg正确评估expr：</p><p>  The  f_globals and  f_locals on the frames is still one of my favorite Python features. It lets basically anyone write very good debugging tools without having to do a bunch of magic.</p><p>  框架上的f_globals和f_locals仍然是我最喜欢的Python功能之一。基本上，任何人都可以编写非常好的调试工具，而无需做很多魔术。</p><p> As an added bonus, if you&#39;re an IPython user you can add this to  a startup script over in  ~/.ipython/profile_default/ and make this available in any interactive shell.</p><p> 另外，如果您是IPython用户，则可以在〜/ .ipython / profile_default /中将其添加到启动脚本中，并在任何交互式shell中使用它。</p><p> For those who value silly things like correctness, performance, and intellectual integrity your journey ends here. This is a nice little helper that you can use in your projects, and there&#39;s nothing else for you to see here.</p><p> 对于那些珍视正确性，性能和知识完整性等愚蠢事物的人，您的旅程就此结束。这是一个很好的小帮手，可以在您的项目中使用，这里什么也看不到。</p><p>   Inside the frame, we have a bunch of information, but one thing that&#39;s pretty nice for explorative debugging is the  code_context</p><p>   在框架内部，我们有一堆信息，但是对于探索性调试非常有用的一件事是code_context</p><p>     Now, if we ran such a function, the body would receive the  value of  foo[&#39;bar&#39;] and not the expression.  But thanks to the stack we could theoretically recover the original expression!</p><p>     现在，如果我们运行这样的函数，主体将接收foo [＆bar]＃的值，而不是表达式。但是由于有了堆栈，理论上我们可以恢复原始表达式！</p><p>    If you have the source code line with the  dbg call, how can you recover the expression being debugged?</p><p>    如果您的源代码行带有dbg调用，那么如何恢复正在调试的表达式？ </p><p> The first thing is just to find the beginning of the expression. That&#39;s pretty easy, just look for  dbg(</p><p>第一件事就是找到表达式的开头。相当简单，只需查找dbg（</p><p>  So we find the beginning of the expression, right? And since a function call in Python is an open parentheses, some expressions, then a close parentheses, we just have to find the close parentheses and we have the string fragment representing our expression. Let&#39;s apply the logic here:</p><p>  因此，我们找到了表达式的开头，对吗？而且由于Python中的函数调用是一个开放括号，一些表达式，然后是一个封闭括号，因此我们只需要找到该封闭括号，就可以得到表示表达式的字符串片段。让我们在这里应用逻辑：</p><p>   This is one of those things where the only way to parse out an expression is to actually parse it out. Simple string matching won&#39;t cut it, especially when you start getting inner function calls in the mix.</p><p>   这是解析表达式的唯一方法是实际解析表达式的事情之一。简单的字符串匹配不会削减它，尤其是当您开始在混合函数中获取内部函数调用时。</p><p> You could write a simple parser, try and count parens, open quotes, escaping in quotes, all the fun little games. But honestly I want a thing that works, and I don&#39;t want to think about it too hard.</p><p> 您可以编写一个简单的解析器，尝试计算括号，打开引号，转义引号以及所有有趣的小游戏。但老实说，我想要一种可行的方法，并且我不想太想这件事。</p><p>   ast . parse ( &#39;my_func(3, foo[&#34;bar&#34;] + &#34;()&#34;)) == 5:&#39; ) # fails ast . parse ( &#39;my_func(3, foo[&#34;bar&#34;] + &#34;()&#34;)) == 5&#39; ) # fails ast . parse ( &#39;my_func(3, foo[&#34;bar&#34;] + &#34;()&#34;)) == &#39; ) # fails ... ast . parse ( &#39;my_func(3, foo[&#34;bar&#34;] + &#34;()&#34;)&#39; ) # doesn&#39;t fail =&gt; I have my expression!</p><p>   ast。解析（＆＃39; my_func（3，foo [＆＃34; bar＆＃34;] +＆＃34;（）＆＃34;））== 5：＆＃39; ）＃ast失败。解析（＆＃39; my_func（3，foo [＆＃34; bar＆＃34;] +＆＃34;（）＆＃34;））== 5＆＃39; ）＃ast失败。解析（＆＃39; my_func（3，foo [＆＃34; bar＆＃34;] +＆＃34;（）＆＃34;））==＆＃39; ）＃失败... ast。 parse（＆＃39; my_func（3，foo [＆＃34; bar＆＃34;] +＆＃34;（）＆＃34;）＆＃39;）＃不会失败=＆gt;我有我的表情！</p><p> I just start with the longest possible string, and slowly shrink it until I find something that looks like an expression. Because the  ) from the debug call imbalances everything I&#39;m like... 80% sure that this way of finding the expression is correct.</p><p> 我只是从尽可能长的字符串开始，然后慢慢缩小它，直到找到看起来像表达式的东西。因为debug调用中的）会使所有内容失去平衡，例如... 80％确保这种查找表达式的方式是正确的。</p><p> There are some edge cases that make this strategy not work. For example if you do something like:</p><p> 在某些情况下，使该策略不起作用。例如，如果您执行以下操作： </p><p>  You have two  dbgs on the same line, so it&#39;s hard to know  which call you&#39;re in, because you&#39;re only provided the line number. (On some other project I spent a lot of time hand-wringing on this exact problem and could not find a solution, even with tricks like counting executions. I&#39;m fairly convinced this is equivalent to the halting problem somehow)</p><p>您在同一行上有两个dbg，因此很难知道您在哪个呼叫中，因为仅提供了行号。 （在其他一些项目上，我花了很多时间解决这个确切的问题，即使有诸如计数执行次数之类的技巧，也找不到解决方案。我相当确信这在某种程度上等同于停止问题）</p><p> And to be honest my solution here isn&#39;t battle-tested, it just feels right and works with the complicated expressions I&#39;ve thrown at it. But it was a fun thing to write and now the following works:</p><p> 老实说，我的解决方案未经考验，它感觉很不错，并且可以与我抛出的复杂表达式结合使用。但这是一件有趣的事情，现在可以进行以下工作：</p><p> dbg ( foo [ &#34;bar&#34; ]) # [pyhelpers.py: 49] foo[&#34;bar&#34;] = 3 if  dbg ( my_func ( 3 ,  foo [ &#34;bar&#34; ]  +  &#34;()&#34; ))  ==  5 : # [pyhelpers.py: 52] my_func(3, foo[&#34;bar&#34;] + &#34;()&#34;) = 5  print ( &#34;Success&#34; )</p><p> dbg（foo [＆＃34; bar＆＃34;]）＃[pyhelpers.py：49] foo [＆＃34; bar＆＃34;] = 3如果dbg（my_func（3，foo [＆＃34; bar＆＃ 34;] +＆＃34;（）＆＃34;））== 5：＃[pyhelpers.py：52] my_func（3，foo [＆＃34; bar＆＃34;] +＆＃34;（） ＆＃34;）= 5次打印（＆＃34; Success＆＃34;）</p><p> No more stringifying silliness, no more calls to  eval, just a really silly parsing hack that has no real foundation except my gut feeling.</p><p> 没有更多的愚蠢的傻瓜，没有更多的对eval的调用，只是一个真正愚蠢的解析技巧，除了我的直觉之外没有任何真正的基础。</p><p>   def  dbg ( result ):  &#34;&#34;&#34;  Recover the expression giving the result, and then  print a helpful debug statement showing this  &#34;&#34;&#34;  frame  =  inspect . stack ()[ 1 ]  expr  =  extract_dbg ( frame . code_context [ 0 ])  filename  =  frame . filename . split ( &#34;/&#34; )[ - 1 ]  print ( f &#34;[ { filename } :  { frame . lineno } ]  { expr }  =  { result } &#34; )  return  result def  extract_dbg ( code_fragment ):  # from a line of source text, try and find the expression   # given to a call to dbg  expression_options  =  code_fragment . split ( &#34;dbg(&#34; )  if  len ( expression_options )  !=  2 :  # if there are either multiple dbg statements  # or I can&#39;t find the dbg line, bail  return  &#34;???&#34;  # get the part to the right of dbg(  expr_candidate  =  expression_options [ 1 ]  while  expr_candidate :  try :  ast . parse ( expr_candidate )  return  expr_candidate  except  SyntaxError :  expr_candidate  =  expr_candidate [: - 1 ]  # didn&#39;t find anything, also give up  return  &#34;???&#34;</p><p>   def dbg（result）：＆＃34;＆＃34;＆＃34;恢复给出结果的表达式，然后打印一条有用的调试语句，显示此＆＃34;＆＃34;＆＃34;框架=检查。 stack（）[1] expr = extract_dbg（框架。code_context [0]）文件名=框架。文件名 。分割（＆＃34; /＆＃34;）[-1]打印（f＆＃34; [{文件名}：{frame。lineno}] {expr} = {结果}＆＃34;）返回结果def extract_dbg （code_fragment）：＃从一行源文本中，尝试找到表达式＃赋予对dbg的调用expression_options = code_fragment。 split（＆＃34; dbg（＆＃34;）如果len（expression_options）！= 2：＃＃如果有多个dbg语句＃或我找不到dbg行，则保释金返回＆＃34 ;？ ??＆＃34;＃获取dbg（expr_candidate = expression_options [1]的部分，而expr_candidate：try：ast。parse（expr_candidate）返回expr_candidate，但SyntaxError除外：expr_candidate = expr_candidate [：-1]＃did＆＃39 ；找不到任何东西，也放弃回报＆＃34; ???＆＃34; </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://rtpg.co/2020/12/11/dbg-in-python.html">https://rtpg.co/2020/12/11/dbg-in-python.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/表达式/">#表达式</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>