<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>彼得·纳尔（Peter Naur）的编程观点 Peter Naur's view of programming</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Peter Naur's view of programming<br/>彼得·纳尔（Peter Naur）的编程观点 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-06 19:45:52</div><div class="page_narrow text-break page_content"><p>Let me ask you a question: How much value do you think your source code has?</p><p>让我问一个问题：您认为源代码有多少价值？</p><p> To answer this question, let me take you a few years back, when I worked with a small high tech startup. We were working on a pretty complex augmented reality system spanning all layers from low-level computer vision components to cross-platform mobile and web apps. Especially for the lower-level components, a good amount of research had been involved. We worked closely with an academic institute that specialized in computer vision.</p><p> 为了回答这个问题，让我带您回到几年前，当时我与一家小型高科技初创公司合作。我们正在开发一个非常复杂的增强现实系统，该系统涵盖从低层计算机视觉组件到跨平台的移动和Web应用程序的所有层。特别是对于较低级别的组件，已经进行了大量的研究。我们与一家专门从事计算机视觉的学术机构紧密合作。</p><p> In short, this project wasn’t something that anybody could just easily recreate. So one of the assumptions we had implicitly made was that our source code was one of the company’s major assets.</p><p> 简而言之，这个项目并不是任何人都可以轻松地重新创建的。因此，我们隐含地做出的假设之一是我们的源代码是该公司的主要资产之一。</p><p> When we hired a new COO, who had mainly worked at bigger companies before, he was shocked to hear that all our code, communication infrastructure and internal systems were living in the cloud. He argued that we should move to on-premise solutions as soon as possible, partially out of fear of intellectual property theft, partially to appease investors with similar fears.</p><p> 当我们雇用新的首席运营官时，他曾经在大型公司工作过，他震惊地听到我们所有的代码，通信基础架构和内部系统都生活在云中。他认为，我们应该尽快转向本地解决方案，部分是出于对知识产权盗窃的恐惧，部分是为了安抚具有类似担忧的投资者。</p><p> While I had no say in it, his arguments seemed somewhat unreasonable to me at the time and I couldn’t put my finger on it. But the CTO was on board. So we installed a cheapo server in one of our office’s closets, even though someone had just broken into our building earlier that month. We got rid of GitLab, and moved away from Slack and Trello in favor of an on-prem Jira installation. The whole ordeal took months to complete, and I’m guessing that all things considered, it cost the small company of ~6 people about half a year of development time. There was also the ongoing opportunity cost of no longer being able to use any new tools that involved the cloud.</p><p> 虽然我没有发言权，但当时他的论点对我来说似乎有点不合理，我无法全力以赴。但是首席技术官已经加入了。因此，即使有人在那个月初闯入我们的办公楼，我们仍在我们办公室的一个壁橱中安装了一个Cheapo服务器。我们摆脱了GitLab，转而从Slack和Trello转移到本地Jira安装。整个过程花了几个月的时间才能完成，我想所有事情都考虑到了，这花费了大约6人的小公司大约半年的开发时间。此外，由于无法再使用涉及云的任何新工具而产生的持续机会成本。</p><p> But the whole thing got me thinking about an interesting question: What would happen if someone just took all our code? Going even further, what would happen if we ourselves just put it all on GitHub, with a permissive license like MIT? Short of making investors think we’re crazy, what direct impact would that have had on the company?</p><p> 但是整个事情让我想到了一个有趣的问题：如果有人只接受了我们所有的代码，将会发生什么？更进一步，如果我们自己将其全部放到具有MIT等宽松许可的GitHub上，将会发生什么？如果不让投资者认为我们疯了，这会对公司产生什么直接影响？</p><p> I thought long and hard about these questions, and I think in our situation back then, the answer would have been: absolutely none.</p><p> 我对这些问题进行了漫长而艰苦的思考，而我认为在当时的情况下，答案是：绝对没有。 </p><p>  Let’s face it, we were still a fast-moving startup, even if the above anecdote might give you the opposite picture. Our code was still changing drastically every couple weeks. Changes of the entire architecture or complete re-writes of components were not uncommon, as is usual for some early stage startups. And as you might expect in such a situation, the code wasn’t of the highest quality either: Half the time, the build would be broken. Testing and documentation were basically non-existent. It was unlikely that anyone from outside the team would even have gotten the thing up and running. Even if they did, it would be outdated a moment later.</p><p>面对现实吧，即使上述轶事可能给您带来相反的印象，我们仍然是一家快速发展的创业公司。我们的代码每两周仍在发生巨大变化。更改整个体系结构或完全重写组件并不罕见，这在某些早期初创公司中很常见。就像您在这种情况下可能期望的那样，代码也不是最高质量的：一半的时间，构建会被破坏。基本上不存在测试和文档。团队外部的任何人都不太可能启动并运行该程序。即使他们这样做，过一会儿也会过时。</p><p> One of the fears from management was that a big company like Google could take our code and build a competing service. After thinking about this in more detail, the idea now seems laughable to me: They would be much faster just building it themselves from scratch, than trying to understand the crummy code we had hacked together.</p><p> 管理层担心的一个问题是，像Google这样的大公司可能会采用我们的代码来构建竞争性服务。在更详细地考虑了这一点之后，现在这个想法对我来说似乎是可笑的：与尝试理解我们一起编写的拙劣代码相比，从头开始自行构建它会更快。</p><p> But let’s take a step back and assume the opposite for a moment: Beautifully written, clean code with complete test coverage. One-click build process. Exceptionally well-written documentation of the architecture and components. Would this have changed the situation? I really don’t think it would have.</p><p> 但是，让我们退后一步，做一下相反的假设：编写精美，干净的代码，并覆盖完整的测试范围。一键式构建过程。出色的架构和组件文档。这会改变情况吗？我真的不这么认为。</p><p> You see, in 2017, there actually was an incident of a high profile source code theft: Panic, a company that makes high quality Mac and iOS software, had the full source code for most of their apps  stolen by hackers. While the attackers demanded a ransom to prevent the public release of the code, Panic refused to pay. They came to the conclusion that the worst thing that could happen would be people building cracked versions of their Apps, full of malware. But that was already happening anyways (as with most software), even before the source code was stolen. Don’t get me wrong, I’m sure this was a pretty bad blow for Panic, and I’m in no way arguing that source code theft can’t be damaging. But even Panic says in their blog post that they were not too concerned with competitors using their code either, mainly because it would quickly become outdated:</p><p> 您会看到，在2017年，实际上发生了一起高调的源代码盗窃事件：Panic是一家生产高质量Mac和iOS软件的公司，其大部分应用程序的完整源代码都被黑客窃取了。当攻击者要求赎金以防止代码公开发布时，Panic拒绝付款。他们得出的结论是，最糟糕的事情可能是人们在构建充满恶意软件的应用程序的破解版本。但这已经发生了（就像大多数软件一样），甚至在源代码被盗之前。不要误会我的意思，我确定这对Panic来说是一个沉重的打击，而且我绝不认为盗窃源代码不会造成损害。但是，甚至Panic在他们的博客文章中也表示，他们也不太担心竞争对手使用其代码，主要是因为它很快就会过时：</p><p> “That source is already missing a ton of fixes and improvements we committed over the last week alone, and six months from now it will be missing major critical new features. In short: it’s old and getting older.”</p><p> “仅在上周，该资源就已经丢失了我们承诺的大量修复和改进，而从现在开始的六个月后，它将丢失主要的关键新功能。简而言之：它已经越来越老了。”</p><p> So maybe code by itself is not that valuable, and yet, software companies still have value. If the tangible aspects of the technology, the code and documentation, are not the main assets of a company, what is?</p><p> 因此，也许代码本身并不是那么有价值，但是软件公司仍然具有价值。如果技术，代码和文档的有形方面不是公司的主要资产，那是什么？</p><p>   I couldn’t really wrap my head around the previous question until I stumbled upon a wonderful article,  Programming as Theory Building, written by none other than  Turing Award winner  Peter Naur. If you’ve ever taken any formal computer science classes, you may have already heard his name: He’s the N in BNF, or Backus-Naur form, an important and widely-used notation for describing programming languages.</p><p>   在我偶然发现由图灵奖获得者彼得·纳尔（Peter Naur）撰写的精彩文章《作为理论构建的编程》之前，我无法真正回答我的问题。如果您上过任何正规的计算机科学课程，您可能已经听说过他的名字：他是BNF（或Backus-Naur形式）中的N，它是描述编程语言的一种重要且广泛使用的符号。 </p><p> In the article, Naur describes his view of what programming really is. He argues that the main activity a programmer does is building a theory or model of the problem space in their head:</p><p>在文章中，Naur描述了他对编程真正的看法。他认为程序员的主要活动是在他们脑海中建立问题空间的理论或模型：</p><p> “[…] programming properly should be regarded as an activity by which the programmers form or achieve a certain kind of insight, a theory, of the matters at hand.”</p><p> “ [[]]正确编程应该被视为一种活动，程序员可以通过该活动形成或获得对当前问题的某种见解，一种理论。”</p><p> He calls this view of programming the  “Theory Building View” and puts it in contrast to what he calls the  “Production View”, in which  “[…] programming is regarded as a production of a program and certain other texts.”</p><p> 他将这种编程观点称为“理论构建观点”，并将其与他所谓的“生产观点”形成鲜明对比，在“生产观点”中，“ […]编程被视为程序和某些其他文本的产物。”</p><p> Naur argues that the production view, while it is widespread, contradicts many things we observe empirically in software projects. In contrast, the Theory Building View allows us to explain many phenomena, such as the observation I made in this article, that the source code itself holds little to no value.  1 One of Naur’s main conclusions is that making changes to an existing program (to accommodate changing requirements) is often more costly than writing new code from scratch, at least if done by people from a different team. This is because there are intangible aspects of the model/theory in the programmer’s heads, which can’t be expressed in code and documentation:</p><p> Naur认为，尽管生产视图很普遍，但它与我们在软件项目中根据经验观察到的许多事情相矛盾。相反，“理论构建视图”使我们能够解释许多现象，例如我在本文中所做的观察，即源代码本身几乎没有价值。 1 Naur的主要结论之一是，对现有程序进行更改（以适应不断变化的需求）通常比从头编写新代码的成本更高，至少是由不同团队的人员完成的。这是因为程序员头脑中存在模型/理论的无形方面，无法在代码和文档中表达：</p><p> “A main claim of the Theory Building View of programming is that an essential part of any program, the theory of it, is something that could not be conceivably expressed, but is inextricably bound to human beings.”</p><p> “编程理论构建观的主要主张是，任何程序的本质部分，即程序理论，都是无法想象的表达，但却与人类密不可分。”</p><p> When a new team obtains the source code, they thus have to first re-build the original theory in their heads, which, Naur argues, can be more work than building their own theory from the ground up.</p><p> 当一个新的团队获得源代码时，他们必须首先重新构建头脑中的原始理论，Naur认为，这比起从头开始构建自己的理论还要做更多的工作。</p><p> Naur brings multiple examples of real life product development where teams were asked to modify or extend a program, but couldn’t do it without help from the original development team, or otherwise they would be  “destroying its power and simplicity”:</p><p> Naur带来了现实生活中的产品开发的多个示例，这些示例要求团队修改或扩展程序，但是如果没有原始开发团队的帮助，它就无法做到，否则，他们将“破坏其功能和简单性”： </p><p> “[…] the program text and its documentation has proved insufficient as a carrier of some of the most important design ideas.”</p><p>“ [...]程序文本及其文档不足以作为某些最重要的设计思想的载体。”</p><p>  “The conclusion seems inescapable that at least with certain kinds of large programs, the continued adaptation, modification, and correction of errors in them, is essentially dependent on a certain kind of knowledge possessed by a group of programmers who are closely and continuously connected with them.”</p><p>  “结论似乎不可避免，至少对于某些大型程序而言，对它们中的错误的持续适应，修改和纠正，基本上取决于与之紧密且持续联系的一组程序员所拥有的某种知识。他们。”</p><p> Since this knowledge is inherently intangible, it can’t be communicated through the code or documentation - it has to be experienced anew by each new programmer joining the team. While the previous programmers can help new team members in this task, the code itself and any written documentation is not very useful in this process. What are these intangible elements/aspects?</p><p> 由于这些知识本质上是无形的，因此无法通过代码或文档进行交流-必须由加入该团队的每位新程序员重新体验。虽然以前的程序员可以帮助新的团队成员完成此任务，但是代码本身和任何书面文档在此过程中并不是很有用。这些无形要素/方面是什么？</p><p>   According to Naur, there are three aspects that are difficult or impossible to express in any written form of code or documentation, and yet the original programmer can easily explain them:</p><p>   根据Naur所说，很难或不可能用任何书面形式的代码或文档来表达三个方面，但是原始程序员可以很容易地解释它们：</p><p> 1) The programmer knows and understands the relationship of the real world problem and the program. They can explain how the details of the problem are mapped into the code and into additional documentation: “Thus the programmer must be able to explain, for each part of the program text and for each of its overall structural characteristics, what aspect or activity of the world is matched by it.”</p><p> 1）程序员了解并了解现实世界问题与程序之间的关系。他们可以解释如何将问题的详细信息映射到代码和其他文档中：“因此，程序员必须能够针对程序文本的每个部分以及其总体结构特征来解释问题的哪些方面或活动。世界与之匹配。”</p><p> While I think it’s possible in theory to make this knowledge more tangible through documentation, doing so exhaustively would be wholly impractical. And yet, Naur notes, an exhaustive understanding of the real world problem is necessary to understand the theory of the program:</p><p> 虽然我认为从理论上讲可以通过文档使这些知识变得更切实可行，但详尽地这样做是完全不切实际的。但是，Naur指出，必须全面了解现实世界的问题才能理解程序的理论：</p><p> “By far the largest part of the world will of course lie outside the scope of the program text, being irrelevant in the context. However, the decision that a part of the world is relevant can only be made by someone who understands the whole world. This understanding must be contributed by the programmer.”</p><p> “到目前为止，世界上绝大部分地区当然不在计划文本的范围内，与上下文无关。”但是，只有一部分了解整个世界的人才能做出与世界的一部分相关的决定。这种理解必须由程序员做出贡献。” </p><p> Let me give you an example from my own experience. A few years back, I was working on a project that improved the processes of a production line in a factory. The workers there were still using paper checklists for quality assurance, making the process labor-intense and error prone. We replaced those paper checklists with a mobile app that runs on a tablet. While the app itself was fairly simple, the underlying business processes were complex - multiple different assembly lines and a variety of different machines were involved. Furthermore, the environment was changing and evolving frequently - workers often changed shifts around, the WiFi in the factory would go down or be unavailable in certain areas, machines would break down, etc. Since any downtime would incur significant costs, the app had to be prepared to handle all these situations.</p><p>让我给你一个我的经验的例子。几年前，我从事的项目是改善工厂生产线的流程。那里的工人仍在使用纸质清单进行质量保证，从而使该过程非常费力且容易出错。我们将这些纸质清单替换为可在平板电脑上运行的移动应用程序。尽管应用程序本身非常简单，但是其基础业务流程却很复杂-涉及多个不同的装配线和各种不同的机器。此外，环境在不断变化和变化-工人经常改变班次，工厂内的WiFi将会关闭或在某些区域不可用，机器将发生故障，等等。由于任何停机时间都会招致高昂的成本，因此该应用程序必须准备应对所有这些情况。</p><p> Communicating the mapping of the code and the real world, as Naur describes, would have required us to document all these processes in meticulous detail. If we had tried to, I believe the result would’ve been multiple hundred pages describing the business processes, either as a separate document or somehow annotated in the code. This would on the one hand have exploded the budget, and on the other hand would’ve had little use for any new programmers onboarded to the project. Combing through all this documentation would’ve been so time-consuming and tedious that nobody would’ve done it.</p><p> 正如Naur所描述的那样，交流代码与现实世界的映射将要求我们以细致的细节记录所有这些过程。如果我们尝试这样做，我相信结果将是数百页描述业务流程的页面，这些页面可以是单独的文档，也可以通过某种方式在代码中进行注释。一方面，这会激增预算，另一方面，对于项目的任何新程序员来说，这几乎没有用。仔细阅读所有这些文档将非常耗时且乏味，以至于没人能做到。</p><p> However, this is a fairly weak argument - just because something is tedious, it’s not impossible. So let’s take a look at the second intangible element Naur describes:</p><p> 但是，这是一个很弱的论点-仅仅因为有些乏味，这并非没有可能。因此，让我们看一下Naur描述的第二个无形元素：</p><p> 2) The programmer can explain not only how the code maps to the real world, but also  why such a mapping was chosen. This justification could be, according to Naur, for example: general design principles, quantitative estimates, and comparisons with alternatives. What’s important to note is that these decisions can’t be made only by blindly following rules. The experience and intuition of the programmer comes into play: “The final basis of the justification is and must always remain the programmer’s direct, intuitive knowledge or estimate. […] the decision that they are relevant to the situation at hand, again must in the final analysis remain a matter of the programmer’s direct knowledge.”</p><p> 2）程序员不仅可以解释代码如何映射到现实世界，还可以解释为什么选择这种映射。根据Naur的说法，这种辩解可能是：一般设计原则，定量估计以及与替代方案的比较。需要注意的重要一点是，这些决策不能仅通过盲目遵守规则来做出。程序员的经验和直觉起作用：“证明的最终基础是而且必须始终保持程序员的直接，直观的知识或估计。 […]决定它们与当前情况有关的决定，再次必须归根结底是程序员的直接知识。”</p><p> Going back to the factory example, let’s assume we would’ve spent the time to write down all the business processes as described above. Then, we would’ve had to also add explanations and reasoning for most technical decisions. For example, we could’ve explained that we included an offline mode in the app for when the WiFi in the factory goes down. On a high level this makes a lot of sense to document and we actually did exactly that. But as you go deeper into the problem, this again comes with significant cost, both in creating this documentation, as well as for any new programmers reading it.</p><p> 回到工厂示例，假设我们已经花了时间写下如上所述的所有业务流程。然后，我们还必须为大多数技术决策添加解释和推理。例如，我们可能已经解释说，当工厂中的WiFi出现故障时，我们在应用程序中包含了离线模式。从总体上讲，这很有意义，我们实际上已经做到了。但是，随着您对问题的深入了解，这在创建本文档时以及对于任何阅读此文档的新程序员中都将花费大量成本。</p><p> However, I think the third intangible aspect Naur mentions is the strongest argument for the Theory Building View:</p><p> 但是，我认为Naur提到的第三个无形方面是“理论建构”观点的最有力论据：</p><p> 3) The programmer can respond to a change request: The problem in the real world has changed somehow, now the programmer has to judge how similar the new situation/problem is to the old one. Just like in the previous point, these decisions can also not be encoded into strict rules: “Designing how a modification is best incorporated into an established program depends on the perception of the similarity of the new demand with the operational facilities already built into the program.”</p><p> 3）程序员可以响应更改请求：现实世界中的问题已经有所改变，现在程序员必须判断新情况/问题与旧情况/问题有多相似。就像在上一点中一样，这些决定也不能被编码为严格的规则：“设计如何将修改最好地结合到已建立的程序中，取决于对新需求与程序中已内置操作设施的相似性的感知。 。” </p><p> Here it becomes clear that this can’t be expressed in written documentation. It involves making decisions on how to deal with changes in the real world that couldn’t have been anticipated when the original program was written. Otherwise, they could already have been incorporated in the original design of the program.</p><p>显然，这不能在书面文档中表达。它涉及到如何应对现实环境中的变化的决策，这是编写原始程序时无法预料的。否则，它们可能已经包含在程序的原始设计中。</p><p> Going back to the factory example: At some point during live user tests, we found out that the data entered by the workers in the factory was inconsistent. After much investigation, we realized that this was due to them sometimes taking unplanned smoke breaks during their shifts. It was pretty easy for us to make minor adjustments in the app to incorporate this new requirement. However, if we hadn’t caught the data inconsistency during development, making this change for an entirely new development team taking over the code would’ve been a significant amount of work. Of course, since it was a completely unexpected requirement, it would also have been impossible to write any kind of documentation or advice on how to deal with it in advance.</p><p> 回到工厂示例：在实时用户测试的某个时候，我们发现工厂工人输入的数据不一致。经过大量调查，我们意识到这是由于他们在轮班期间有时会意外抽烟。对于我们来说，在应用程序中进行细微调整以纳入此新要求非常容易。但是，如果我们在开发过程中没有发现数据不一致的情况，那么对于一个完全负责接管代码的全新开发团队进行此更改将是一项艰巨的工作。当然，由于这是完全出乎意料的要求，因此也不可能事先编写任何类型的文档或建议以了解如何对其进行处理。</p><p> It’s important to note that Naur also says it’s possible to transfer a program’s theory between programmers, but it requires personal interaction:</p><p> 重要的是要注意，Naur还说有可能在程序员之间传递程序的理论，但这需要个人互动：</p><p> “What is required is that the new programmer has the opportunity to work in close contact with the programmers who already possess the theory, so as to be able to become familiar with the place of the program in the wider context of the relevant real world situations and so as to acquire the knowledge of how the program works and how unusual program reactions and program modifications are handled within the program theory.”</p><p> “要求的是，新程序员有机会与已经掌握该理论的程序员紧密联系，以便能够在相关的现实世界情况下更广泛地了解程序的位置。从而获得有关程序工作原理以及在程序理论中如何处理异常程序反应和程序修改的知识。”</p><p> He even compares these interactions to teaching a skill like writing, or learning a musical instrument, which requires constant personal instruction from a teacher.</p><p> 他甚至将这些互动与教授写作或学习乐器等技能进行比较，而这需要老师不断的个人指导。</p><p> Imagine an expert piano player. They could “document” in meticulous detail where exactly they put their fingers while playing. But even with the most fine grained detail, you wouldn’t be able to learn how to play the piano just by reading this documentation.</p><p> 想象一个专业的钢琴演奏家。他们可以细致地“记录”在演奏时将手指放在哪里。但是，即使具有最精细的细节，您也无法仅通过阅读本文档来学习如何弹奏钢琴。</p><p>  If we agree with Naur’s assessment of programming, what follows is that the value of a high tech company is inseparably interwoven with the development team, and the model of the problem domain in their heads. What this means, in essence:</p><p>  如果我们同意Naur对编程的评估，那么，那就是高科技公司的价值与开发团队以及问题领域的模型密不可分。从本质上讲，这意味着什么： </p><p> The main value of a software company is the mapping of source code and problem space in the developer’s heads  2.</p><p>一家软件公司的主要价值是在开发人员头脑中映射源代码和问题空间。</p><p> This conclusion has important consequences for many aspects of a software company, but especially for management, hiring and overall culture.</p><p> 这个结论对软件公司的许多方面都具有重要的意义，但对于管理，雇用和整体文化尤其重要。</p><p>  Most efforts to make software more flexible or modular, and thus programmers more replaceable are misguided. As Naur writes: “[…] much current discussion of programming seems to assume that programming is similar to industrial production, the programmer being regarded as a component of that production, a component that has to be controlled by rules of procedure and which can be replaced easily. […] At the level of industrial management these views support treating programmers as workers of fairly low responsibility, and only brief education.”</p><p>  使软件更加灵活或模块化，从而使程序员更具有可替换性的大多数努力都被误导了。正如Naur写道：“ […]当前有关编程的许多讨论似乎都假定编程类似于工业生产，程序员被视为该生产的组成部分，该组成部分必须由程序规则控制，并且可以轻松更换。 […]在工业管理方面，这些观点支持将程序员视为责任心很低的工人，并且只接受简短的教育。”</p><p> He argues that developers should be given more responsibility and regarded as permanent assets to the company.</p><p> 他认为应该给开发商更多的责任，并将其视为公司的永久资产。</p><p> If you’re in a management position, you need to realize that  development is mainly decision making, which of course only works if you’re given the necessary autonomy to make those decisions. I believe this realization is one of the  main reasons many successful companies have a better engineering culture.</p><p> 如果您是管理人员，则需要意识到发展主要是决策，当然只有在获得必要的自主权来做出决策时，这才有效。我相信这种认识是许多成功的公司拥有更好的工程文化的主要原因之一。</p><p>  Give your developers enough autonomy and decision making power. They need to be involved in decisions not just on How to build something, but also on What to build</p><p>  给您的开发人员足够的自主权和决策权。他们不仅需要参与有关如何构建事物的决策，还需要参与构建内容的决策。</p><p> Put your developers as close to the customer as possible (and as they’re comfortable with). This is the only way they can build an intuitive understanding of the real problem they need to solve, and after all, this understanding is the main value of your company.</p><p> 让您的开发人员尽可能地靠近客户（并且让他们满意）。这是他们可以直观了解需要解决的实际问题的唯一方法，毕竟，这种理解是贵公司的主要价值。 </p><p>  Don’t attempt to  measure developer productivity, since it’s an inherently unmeasurable quality. Sometimes, an afternoon of just thinking about a problem, without producing any tangible artifacts, can be the most important thing your company needs. After all,  developers spend most of their time figuring out systems.</p><p>由于这本质上是无法衡量的，因此请勿尝试衡量开发人员的生产率。有时，一下午思考问题而不产生任何实际痕迹可能是公司最重要的事情。毕竟，开发人员花费了大部分时间来确定系统。</p><p>  Retaining talent is even more important than you might think. It’s crazy that in an industry where the main value is tied up so much to individual contributors, people change jobs every two years</p><p>  留住人才比您想像的更为重要。疯狂的是，在一个主要价值与个人贡献者息息相关的行业中，人们每两年更换工作</p><p> The Theory Building View also gives us insights on how to structure onboarding processes. It helps to explain why new developers often takes a very long time until they reach full productivity</p><p> 理论构建视图还为我们提供了有关如何构建入职流程的见解。它有助于解释为什么新开发人员通常要花很长时间才能达到完全生产力</p><p> Really understanding why autonomy is important will not only help your company, but also improve your hiring processes. Your engineers will be much happier, and this will trickle down into hiring and make things much easier in the long run. It’s not an easy change to make but it’s worth it.</p><p> 真正理解自治为什么很重要，不仅会帮助您的公司，而且会改善您的招聘流程。您的工程师会更快乐，从长远来看，这将滴入招聘并简化工作。进行这项更改并非易事，但值得。</p><p> If you want to really improve your hiring and get some actionable advice, feel free to read my most popular essay on this topic:  When hiring senior engineers, you’re not buying, you’re selling</p><p> 如果您想真正改善您的招聘并获得一些可行的建议，请随时阅读我有关该主题的最受欢迎文章：招聘高级工程师时，您不会买，而是在卖 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://hiringengineersbook.com/post/autonomy">https://hiringengineersbook.com/post/autonomy</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/peter/">#peter</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/naur/">#naur</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>