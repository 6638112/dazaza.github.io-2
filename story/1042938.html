<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>半小时学习Rust </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">半小时学习Rust </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-02 15:05:20</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/99194f67e5542018f2c1c325832cade0.png"><img src="http://img2.diglog.com/img/2021/1/99194f67e5542018f2c1c325832cade0.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>为了提高编程语言的流利程度，必须阅读大量的语言，但是如果您不知道它的含义，又怎么能阅读很多呢？  在本文中，我将不着重于一个或两个概念，而是尝试尽可能多地浏览Rust片段，并解释它们所包含的关键字和符号的含义。  让x：i32; //'i32'是一个有符号的32位整数x = 42; //有i8，i16，i32，i64，i128 //也有u8，u16，u32，u64，u128（无符号）  如果您声明一个名称并在以后对其进行初始化，则编译器将阻止您在对其进行初始化之前使用它。  下划线_是一个特殊名称-或更确切地说，是＆＃34;缺少名称＆＃34;。 从根本上讲，它意味着丢弃某些东西：  //这没什么用，因为42是常数let _ = 42; //这会调用`get_thing`，但会丢弃其结果let _ = get_thing（）;  以下划线开头的名称是常规名称，只是编译器不会警告它们未被使用： </p><p>//我们最终可能会使用_x，但是我们的代码仍在开发中//我们现在只想摆脱编译器警告。 令_x = 42;  可以引入具有相同名称的单独绑定-您可以隐藏变量绑定：  令x = 13; 令x = x + 3; //在该行之后使用`x`仅表示第二个`x`，//第一个`x`不再存在。  Rust具有元组，您可以将其视为不同类型的值的固定长度集合。  执行任务时，元组可以被解构，这意味着它们被分解为各自的字段：  当然，在破坏元组时，可以使用_丢弃其中的一部分：  让x = vec！ [1、2、3、4、5、6、7、8]。 iter（）。 映射（| x | x + 3）。 折叠（0，| x，y | x + y）; </p><p>这是一个返回32位带符号整数的函数。 Thearrow指示其返回类型：  //这会先打印＆＃34; in＆＃34 ;，然后打印＆＃34; out＆＃34; fn main（）{让x =＆＃34; out＆＃34; ; {//这是一个不同的`x`，让x =＆＃34; in＆＃34; ; println！ （X ） ; } println！ （X ） ;}  令x = {令y = 1; //第一条语句让z = 2; //第二条语句y + z //这是* tail *-整个块将求值}  这就是为什么在函数末尾省略分号的原因 与返回相同，即 这些是等效的：  fn fair_dice_roll（）-＆gt; i32 {match feel_lucky {true =＆gt; 6，false => 4，}}  让a =（10，20）; a。 0分 //这是10个let amos = get_some_struct（）; amos。 昵称; //这是＆＃34; fasterthanlime＆＃34;  在此示例中，std是一个板条箱（〜一个库），cmp是一个模块（〜一个源文件），min是一个函数： </p><p>在use指令中，花括号具有另一种含义：它们是globs＆＃34;。 如果要同时导入min和max，则可以执行以下任一操作：  //这有效：使用std :: cmp :: min; 使用std :: cmp :: max; //这也可以：使用std :: cmp :: {min，max}; //这也有效！ 使用std :: {cmp :: min，cmp :: max};  让x =＆＃34; amos＆＃34; 。 len（）; //这是4个让x = str :: len（＆＃34; amos＆＃34;）; //这也是4  //`Vec`是常规结构，而不是原始类型let v = Vec :: new（）; //这是完全相同的代码，但带有`Vec`的* full *路径，让v = std :: vec :: Vec :: new（）;  令v1 = Vec2 {x：1.0，y：3.0}; 令v2 = Vec2 {y：2.0，x：4.0}; //顺序无关紧要，只有名称才重要  这就是所谓的“结构更新语法”，它只能在最后一个位置出现，并且不能跟逗号。  令v = Vec2 {x：3.0，y：6.0}; 令Vec2 {x，y} = v; // x的值现在是3.0，y的值现在是6.0 </p><p>struct Number {奇数：布尔，值：i32，} fn main（）{设一个= Number {奇数：true，值：1};设两个= Number {奇数：false，值：2}； print_number（一个）; print_number（two）;} fn print_number（n：Number）{如果让Number {奇数：true，值} = n {println！ （＆＃34;奇数：{}＆＃34 ;，值）； } if if让Number {奇数：false，值} = n {println！ （＆＃34;偶数：{}＆＃34 ;，值）； }} //打印：//奇数：1 //偶数：2</p><p>  fn print_number（n：Number）{匹配n {Number {奇数：true，值} =＆gt; println！ （＆＃34;奇数：{}＆＃34 ;，值），数字{奇数：false，值} =＆gt; println！ （＆＃34; Even number：{}＆＃34 ;, value），}} //与以前一样打印</p><p>  fn print_number（n：Number）{match n {Number {value：1，..} =＆gt; println！ （＆＃34; One＆＃34;），数字{value：2，..} =＆gt; println！ （＆＃34; Two＆＃34;），数字{value，..} =＆gt; println！ （＆＃34; {}＆＃34 ;, value），//如果最后一个臂不存在，我们将得到一个编译时错误}}</p><p>  fn print_number（n：Number）{匹配n。值{1 =＆gt; println！ （＆＃34; One＆＃34;），2 =＆gt; println！ （＆＃34; Two＆＃34;），_ =＆gt; println！ （＆＃34; {}＆＃34 ;, n.value），}}</p><p>  结构编号{奇数：布尔值，值：i32，}展示编号{fn is_strictly_positive（self）-＆gt;布尔{自我。值＆gt; 0}}</p><p>  fn main（）{let minus_two = Number {奇数：false，值：-2，}； println！ （＆＃34; positive？{}＆＃34 ;, minus_two.is_strictly_positive（））； //这会显示＆＃34;错误＆＃34;}</p><p>  fn main（）{令n =数字{奇数：true，值：17，}； n。奇=假; //错误：无法分配给`n.odd`，//因为`n`没有声明为可变的} </p><p>fn main（）{令n =数字{奇数：true，值：17，}； n =数字{奇数：false，值：22，}； //错误：无法两次分配给不可变变量`n`}</p><p>  fn main（）{let mut n = Number {奇数：true，值：17，} n。价值= 19; // 都好}</p><p>       表示数字{fn is_strictly_negative（self）->布尔{自我。值＆lt; 0}} fn main（）{令n =数字{奇数：false，值：-44}； println！ （＆＃34; {}＆＃34 ;, n.is_strictly_negative（））； //打印＆＃34; true＆＃34;}</p><p>  impl代表i32 {fn is_strictly_negative（self）->布尔{self＆lt; 0}} fn main（）{让n：i32 =-44; println！ （＆＃34; {}＆＃34 ;, n.is_strictly_negative（））； //打印＆＃34; true＆＃34;}</p><p>  //`Neg`特性用于重载一元减号运算符`-`。 impl std :: ops :: Neg for Number {类型Output = Number; fn neg（self）-> Number {Number {value：-self。值，奇数：自我。奇数，}}} fn main（）{设n =数字{奇数：真，值：987}；令m = -n; //这仅可能是因为我们实现了`Neg` println！ （＆＃34; {}＆＃34 ;, m.value）; //打印＆＃34; -987＆＃34;}</p><p> 一个impl块始终是一种类型，因此在该块内部，Selfmeans就是该类型：</p><p> impl std :: ops :: Neg for Number {type Output = Self; fn neg（self）->自我{自我{值：-自我。值，奇数：自我。奇数，}}} </p><p>有些特征是标记-它们不是说类型实现某些方法，而是说某些事情可以用类型来完成。</p><p>  fn main（）{让a：i32 = 15;令b = a; //复制a，让c = a； //`a`被再次复制}</p><p>  fn print_i32（x：i32）{println！ （＆＃34; x = {}＆＃34 ;, x）;} fn main（）{让a：i32 = 15; print_i32（a）; //复制`a` print_i32（a）; //`a`被再次复制}</p><p>  fn main（）{令n =数字{奇数：true，值：51}；令m = n; //`n`被移入`m` let o = n; //错误：使用移动值：`n`}</p><p>  fn print_number（n：Number）{println！ （＆＃34; {}数字{}＆＃34 ;，如果n.odd {＆＃34; odd＆＃34;}否则{＆＃34; even＆＃34;}，n.value）;} fn main（ ）{让n =数字{奇数：是，值：51}； print_number（n）; //`n`被移动print_number（n）; //错误：使用移动值：`n`}</p><p>  fn print_number（n：＆amp; Number）{println！ （＆＃34; {}数字{}＆＃34 ;，如果n.odd {＆＃34; odd＆＃34;}否则{＆＃34; even＆＃34;}，n.value）;} fn main（ ）{让n =数字{奇数：是，值：51}； print_number（＆amp; n）; //在调用print_number（＆amp; n）的时间内借入`n`； //`n`再次借用}</p><p> 如果一个函数采用了可变的引用，它也可以工作-但前提是我们的变量绑定也是mut。 </p><p>fn反转（n：＆amp; mut号）{n。值= -n value;} fn print_number（n：＆amp; Number）{println！ （＆＃34; {}数字{}＆＃34 ;，如果n.odd {＆＃34; odd＆＃34;}否则{＆＃34; even＆＃34;}，n.value）;} fn main（ } {//这次，'n`是可变的let mut n = Number {奇数：true，值：51}； print_number（＆amp; n）;反转（＆amp; mut n）; //`n是可变借用的-一切都是显式的print_number（＆amp; n）;}</p><p>  impl std :: clone ::克隆数字{fn clone（＆amp; self）-＆gt;自我{自我{.. *自我}}}</p><p>  fn main（）{令n =数字{奇数：true，值：51}；让mut m = n。克隆（）;米值+ = 100; print_number（＆amp; n）; print_number（＆amp; m）;}</p><p>    //注意：`Copy`要求实现`Clone`也是impl std :: clone ::克隆数字{fn clone（＆amp; self）-＆gt; Self {Self {.. * self}}} impl std :: marker ::复制数字{}</p><p>  fn main（）{令n =数字{奇数：true，值：51}；令m = n。克隆（）;令o = n。克隆（）;}</p><p>  fn main（）{令n =数字{奇数：true，值：51}；令m = n; //`m`是`n`的副本let o = n; //相同。 n既不移动也不借用。}</p><p>  ＃[derive（Clone，Copy）] struct Number {奇数：布尔值，值：i32，} //扩展为“ impl Clone for Number”和“ impl Copy for Number”块。 </p><p>它们可以具有多个类型参数，然后可以在函数的声明及其主体中使用它们，而不是具体的类型：</p><p>    fn打印＆lt; T：显示＆gt; （值：T）{println！ （＆＃34; value = {}＆＃34 ;, value）;} fn print＆lt; T：调试＆gt; （值：T）{println！ （＆＃34; value = {：？}＆＃34 ;, value）;}</p><p>    使用std :: fmt :: Debug; fn比较＆lt; ＆ （左：T，右：T）其中T：Debug + PartialEq，{println！ （＆＃34; {:?} {} {：？}＆＃34 ;，如果左边==右边{＆＃34; ==＆＃34;}否则{＆＃34;！=＆＃34 ;}，正确）;} fn main（）{比较（＆＃34; tea＆＃34 ;,＆＃34; coffee＆＃34;）; //打印：＆＃34; tea＆＃34; ！=＆＃34;咖啡＆＃34;}</p><p> 泛型函数可以被视为名称空间，其中包含具有不同具体类型的无穷函数。</p><p> 与板条箱，模块和类型相同，可以使用::浏览和导航泛型函数（导航？）。</p><p> fn main（）{使用std :: any :: type_name; println！ （＆＃34; {}＆＃34 ;, type_name ::＆lt; i32＆gt;（））； //打印＆＃34; i32＆＃34; println！ （＆＃34; {}＆＃34 ;, type_name ::＆lt;（f64，char）＆gt;（））; //打印＆＃34;（f64，char）＆＃34;}</p><p>   结构对＆ {a：T，b：T，} fn print_type_name＆lt; ＆ （_val：＆amp; T）{println！ （＆＃34; {}＆＃34 ;, std :: any :: type_name ::＆lt; T＆gt;（））;} fn main（）{让p1 = Pair {a：3，b：9};令p2 =对{a：true，b：false}; print_type_name（＆amp; p1）; //打印＆＃34; Pair＆lt; i32＆gt;＆＃34; print_type_name（＆amp; p2）; //打印＆＃34; Pair＆lt; bool＆gt;＆＃34;} </p><p>fn main（）{让mut v1 = Vec :: new（）; v1。推（1）;让mut v2 = Vec :: new（）;第2版​​。推（假）; print_type_name（＆amp; v1）; //打印＆＃34; Vec＆lt; i32＆gt;＆＃34; print_type_name（＆amp; v2）; //打印＆＃34; Vec＆lt; bool＆gt;＆＃34;}</p><p> 说到Vec，它带有一个宏，该宏或多或少地提供了＆veve字面量＆＃34 ;：</p><p> fn main（）{让v1 = vec！ [1，2，3];让v2 = vec！ [true，false，true]； print_type_name（＆amp; v1）; //打印＆＃34; Vec＆lt; i32＆gt;＆＃34; print_type_name（＆amp; v2）; //打印＆＃34; Vec＆lt; bool＆gt;＆＃34;}</p><p>      恐慌也是一个宏。如果启用了错误消息，则会猛烈停止执行，并显示错误的文件名/行号：</p><p>  有些方法也惊慌失措。例如，Option类型可以包含某些内容，也可以不包含任何内容。如果在其上调用.unwrap（），并且不包含任何内容，则会出现恐慌：</p><p> fn main（）{设o1：选项＆lt; i32＆gt; =约（128）; o1解开（）; //这很好，让o2：Option＆lt; i32＆gt; =无； o2解开（）; //这恐慌！} //输出：thread＆＃39; main＆＃39;在``src / libcore / option.rs：378：21''的``无''值上惊慌于名为``Option :: unwrap（）`''</p><p>  枚举Option＆lt; ＆ {None，Some（T），} impl＆lt; ＆选项＆lt; ＆ {fn unwrap（self）-＆gt; T {//枚举变量可以在模式中使用：match self {Self :: Some（t）=＆gt; t，Self :: None =＆gt;恐慌 ！ （＆＃34; .unwrap（）在None选项上调用＆＃34;），}}}使用self :: Option :: {None，Some}; fn main（）{设o1：选项＆lt; i32＆gt; =约（128）; o1解开（）; //这很好，让o2：Option＆lt; i32＆gt; =无； o2解开（）; //这恐慌！} //输出：thread＆＃39; main＆＃39;惊恐于＆＃39; .unwrap（）调用了None选项，src / main.rs：11：27 </p><p>fn main（）{// x不存在{让x = 42; //`x`开始现有的println！ （＆＃34; x = {}＆＃34 ;, x）; //`x`停止存在} //`x`不再存在}</p><p>  fn main（）{// x不存在{让x = 42; //`x`开始现有的let x_ref =＆amp; x; //`x_ref`开始存在-它借用`x` println！ （＆＃34; x_ref = {}＆＃34 ;, x_ref）； //`x_ref`停止存在// //`x`停止存在} //`x`不再存在}</p><p>  fn main（）{让x_ref = {让x = 42; ＆amp; x}; println！ （＆＃34; x_ref = {}＆＃34 ;, x_ref）； //错误：`x`寿命不够长}</p><p>  fn main（）{令x = 42;令x_ref1 =＆amp; x;令x_ref2 =＆amp; x;令x_ref3 =＆amp; x; println！ （＆＃34; {} {} {}＆＃34 ;, x_ref1，x_ref2，x_ref3）;}</p><p>  fn main（）{让mut x = 42;让x_ref =＆amp; x; x = 13; println！ （＆＃34; x_ref = {}＆＃34 ;, x_ref）； //错误：由于被借用，因此无法分配给x}</p><p>  fn main（）{让mut x = 42;令x_ref1 =＆amp; x;令x_ref2 =＆amp; mut x; //错误：无法借用可变的`x`，因为它也借作不可变的println！ （＆＃34; x_ref1 = {}＆＃34 ;, x_ref1）;}</p><p>  fn print（x：＆amp; i32）{//在整个调用此函数的整个过程中（从外部）借入了x。 </p><p>struct Number {value：i32，} fn number_value＆lt; ＆＃39; ＆gt; （num：＆amp; a Number）-＆gt; ＆amp; ＆＃39; i32 {＃。值} fn main（）{设n =数字{值：47};令v = number_value（＆amp; n）; //`v`借用`n`（不可变），因此：`v`不能超过`n`。 //尽管存在`v`，但是不能可变地借用，改变或移动`n`}</p><p> 当只有一个输入生存期时，不需要命名它，并且所有内容都具有相同的生存期，因此以下两个函数是等效的：</p><p> fn number_value＆lt; ＆＃39; ＆gt; （num：＆amp; a Number）-＆gt; ＆amp; ＆＃39; i32 {＃。 fn number_value（num：＆amp; Number）-＆gt; ＆amp; i32 {＃。值}</p><p>  结构NumRef＆lt; ＆＃39; ＆gt; {x：＆amp; ＆＃39; a i32，} fn main（）{让x：i32 = 99;让x_ref = NumRef {x：＆amp; x}; //`x_ref`不能超过`x`等，}</p><p>  结构NumRef＆lt; ＆＃39; ＆gt; {x：＆amp; ＆＃39; i32，} fn as_num_ref＆lt; ＆＃39; ＆gt; （x：＆amp;＆＃39; a i32）-＆gt; NumRef＆lt; ＆＃39; ＆gt; {NumRef {x：＆amp; x}} fn main（）{让x：i32 = 99;让x_ref = as_num_ref（＆amp; x）; //`x_ref`不能超过`x`等，}</p><p>  结构NumRef＆lt; ＆＃39; ＆gt; {x：＆amp; ＆＃39; i32，} fn as_num_ref（x：＆amp; i32）-＆gt; NumRef＆lt; ＆＃39; _＆gt; {NumRef {x：＆amp; x}} fn main（）{让x：i32 = 99;让x_ref = as_num_ref（＆amp; x）; //`x_ref`不能超过`x`等，}</p><p>  暗示＆＃39; ＆gt; NumRef＆lt; ＆＃39; ＆gt; {fn as_i32_ref（＆amp; a self）-＆gt; ＆amp; ＆＃39;一个i32 {self。 x}} fn main（）{让x：i32 = 99; let x_num_ref = NumRef {x：＆amp; x};让x_i32_ref = x_num_ref。 as_i32_ref（）; // ref都不能超过`x`} </p><p>struct Person {名称：＆amp; ＆＃39;静态str，} fn main（）{令p =人员{名称：＆＃34; fasterthanlime＆＃34 ;,};}</p><p>  struct Person {名称：＆amp; ＆＃39;静态str，} fn main（）{让名称=格式！ （＆＃34; fasterthan {}＆＃34 ;,＆＃34; lime＆＃34;）;设p =人员{name：＆amp; name}; //错误：“名称”的寿命不足}</p><p> 在最后一个示例中，本地名称不是静态字符串，而是字符串。它是动态分配的，将被释放。它的生存期少于整个程序（即使它恰好在主程序中）。</p><p>   结构人＆lt; ＆＃39; ＆gt; {名称：＆amp; ＆＃39; a str，} fn main（）{让名称=格式！ （＆＃34; fasterthan {}＆＃34 ;,＆＃34; lime＆＃34;）;设p =人员{name：＆amp; name}; //`p`不能超过`name`}</p><p>   struct Person {name：String，} fn main（）{let name = format！ （＆＃34; fasterthan {}＆＃34 ;,＆＃34; lime＆＃34;）;令p =人{name：name}; //`name`已移入`p`，它们的生命期不再受限。}</p><p> 说到：在结构文字中，当字段设置为具有相同名称的变量绑定时：</p><p>        fn main（）{让v = vec！ [1，2，3，4，5];令v2 =＆amp; v [2 .. 4]; println！ （＆＃34; v2 = {：？}＆＃34 ;, v2）;} //输出：// v2 = [3，4] </p><p>以上并非魔术。索引运算符（foo [index]）重载了Index和IndexMut特征。</p><p> ..语法只是范围文字。范围只是标准库中定义的一些结构。</p><p> 如果前面带有=，则它们可以是开放式的，并且它们的最右边界可以是包含性的。</p><p> fn main（）{// 0或更大的println！ （＆＃34; {：？}＆＃34 ;,（0 ..）。包含（＆amp; 100））; // true //严格小于20 println！ （＆＃34; {：？}＆＃34 ;,（.. 20）。包含（＆amp; 20））; // false // 20或小于20 println！ （＆＃34; {：？}＆＃34 ;,（.. = 20）。包含（＆amp; 20））; // true //仅3，4，5 println！ （＆＃34; {：？}＆＃34 ;,（3 .. 6）。包含（＆amp; 4））; // true}</p><p>  fn tail（s：＆amp; [u8]）-＆gt; ＆amp; [u8] {＆amp; s [1 ..]} fn main（）{令x =＆amp; [1，2，3，4，5];令y =尾（x）; println！ （＆＃34; y = {：？}＆＃34 ;, y）;}</p><p>    fn main（）{让y = {让x =＆amp; [1，2，3，4，5];尾（x）}; println！ （＆＃34; y = {：？}＆＃34 ;, y）;}</p><p>   fn main（）{让y = {让v = vec！ [1，2，3，4，5]; tail（＆amp; v）//错误：`v`寿命不长}; println！ （＆＃34; y = {：？}＆＃34 ;, y）;} </p><p>fn file_ext（name：＆amp; str）-＆gt;选项＆lt; ＆amp;力＆gt; {// //这不会创建新的字符串-它返回//参数的一部分。名称 。分割（＆＃34;。＆＃34;）。 last（）} fn main（）{让名字=＆＃34;读我。或不输入txt。＃34; ;如果让Some（ext）= file_ext（name）{println！ （＆＃34;文件扩展名：{}＆＃34 ;, ext）； } else {println！ （＆＃34;无文件扩展名＆＃34;）； }}</p><p>  fn main（）{let ext = {let name = String :: from（＆＃34; Read me。or don＆＃39; t.txt＆＃34;）; file_ext（＆amp; name）。 unwrap_or（＆＃34;＆＃34;）//错误：“名称”的寿命不足}； println！ （＆＃34;扩展名：{：？}＆＃34 ;, ext）;}</p><p>  fn main（）{让s = std :: str :: from_utf8（＆amp; [240，159，141，137]）; println！ （＆＃34; {：？}＆＃34 ;, s）; //打印：Ok（＆＃34;🍉＆＃34;）let s = std :: str :: from_utf8（＆amp; [195，40]）; println！ （＆＃34; {：？}＆＃34 ;, s）; //打印：Err（Utf8Error {valid_up_to：0，error_len：Some（1）}）}</p><p>  fn main（）{让s = std :: str :: from_utf8（＆amp; [240，159，141，137]）。解开（）; println！ （＆＃34; {：？}＆＃34 ;, s）; //打印：＆＃34;🍉＆＃34; let s = std :: str :: from_utf8（＆amp; [195，40]）。解开（）; //打印：线程＆＃39; main＆＃39;在`Err`值上惊恐地叫`Result :: unwrap（）`//：Utf8Error {valid_up_to：0，error_len：Some（1）}＆＃39 ;, // src / libcore / result。 rs：1165：5}</p><p>  fn main（）{让s = std :: str :: from_utf8（＆amp; [195，40]）。期望（＆＃34; valid utf-8＆＃34;）; //打印：线程＆＃39; main＆＃39;对有效utf-8感到惊恐：utf8Error // // {valid_up_to：0，error_len：Some（1）}＆＃39 ;, src / libcore / result.rs：1</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust">https://fasterthanli.me/articles/a-half-hour-to-learn-rust</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/学习/">#学习</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/learn/">#learn</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fn/">#fn</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1042911.html"><img src="http://img2.diglog.com/img/2021/1/thumb_7029c1ff0843b2fefa0e50c0cd7b6fc7.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1042911.html">Rust应用程序的ClickOnce </a></div><span class="my_story_list_date">2021-1-2 9:49</span></div><div class="col-sm"><div><a target="_blank" href="/story/1042872.html"><img src="http://img2.diglog.com/img/2021/1/thumb_5f838ba86b4c3d4c4b1d54ddd35f0eaa.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1042872.html">朝鲜蓟是用Rust制成的Ruby，可编译为WebAssembly </a></div><span class="my_story_list_date">2021-1-2 8:26</span></div><div class="col-sm"><div><a target="_blank" href="/story/1042751.html"><img src="http://img2.diglog.com/img/2021/1/thumb_10c030b2429f801a5aed8756bdece9d2.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1042751.html">锈1.49.0 </a></div><span class="my_story_list_date">2021-1-1 8:53</span></div><div class="col-sm"><div><a target="_blank" href="/story/1042532.html"><img src="http://img2.diglog.com/img/2020/12/thumb_ce565473a1e858289af01382da5df943.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1042532.html">FTC反托拉斯诉讼后，RentPath放弃与CoStar的收购交易 </a></div><span class="my_story_list_date">2020-12-30 19:56</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>