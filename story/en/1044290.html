<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>文件系统错误处理（2017） Filesystem Error Handling (2017)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Filesystem Error Handling (2017)<br/>文件系统错误处理（2017） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-15 21:34:35</div><div class="page_narrow text-break page_content"><p>Filesystem error handling  We’re going to reproduce some  results from papers on filesystem robustness that were written up roughly a decade ago:  Prabhakaran et al. SOSP 05 paper, which injected errors below the filesystem and  Gunawi et al. FAST 08, which looked at how often filessytems failed to check return codes of functions that can return errors.</p><p>文件系统错误处理我们将从大约十年前撰写的有关文件系统健壮性的论文中复制一些结果：Prabhakaran等。 SOSP 05论文，它在文件系统和Gunawi等人的论文下面注入了错误。 FAST 08，它检查文件系统未能检查可返回错误的函数的返回码的频率。</p><p> Prabhakaran et al. injected errors at the block device level (just underneath the filesystem) and found that  ext3,  resierfs,  ntfs, and  jfs mostly handled read errors reasonbly but  ext3,  ntfs, and  jfs mostly ignored write errors. While the paper is interesting, someone installing Linux on a system today is much more likely to use  ext4 than any of the now-dated filesystems tested by Prahbhakaran et al. We’ll try to reproduce some of the basic results from the paper on more modern filesystems like  ext4 and  btrfs, some legacy filesystems like  exfat,  ext3, and  jfs, as well as on  overlayfs.</p><p> Prabhakaran等。在块设备级别（恰好在文件系统下面）注入了错误，发现ext3，resierfs，ntfs和jfs主要处理读错误，而ext3，ntfs和jfs大多数忽略写错误。尽管这篇文章很有趣，但是与Prahbhakaran等人测试过的任何最新文件系统相比，今天在系统上安装Linux的人更可能使用ext4。我们将尝试重现本文中有关ext4和btrfs等更现代的文件系统，exfat，ext3和jfs等一些旧文件系统以及overlayfs的一些基本结果。</p><p> Gunawi et al.  found that errors weren’t checked most of the time. After we look at error injection on modern filesystems, we’ll look at how much (or little) filesystems have improved their error handling code.</p><p> Gunawi等。发现大多数时间未检查错误。在研究了现代文件系统上的错误注入之后，我们将看看有多少（或很少）文件系统改进了它们的错误处理代码。</p><p>  A cartoon view of a file read might be:  pread syscall -&gt; OS generic filesystem code -&gt; filesystem specific code -&gt; block device code -&gt; device driver -&gt; device controller -&gt; disk. Once the disk gets the request, it sends the data back up:  disk -&gt; device controller -&gt; device driver -&gt; block device code -&gt; filesystem specific code -&gt; OS generic filesystem code -&gt; pread. We’re going to look at error injection at the block device level, right below the file system.</p><p>  读取的文件的卡通视图可能是：pread syscall-＆gt; OS通用文件系统代码-＆gt;文件系统特定的代码-＆gt;阻止设备代码-＆gt;设备驱动程序-＆gt;设备控制器-＆gt;磁盘。磁盘获得请求后，它将发送数据备份：disk->设备控制器-＆gt;设备驱动程序-＆gt;阻止设备代码-＆gt;文件系统特定的代码-＆gt; OS通用文件系统代码-＆gt;前置我们将在文件系统正下方的块设备级别研究错误注入。</p><p> Let’s look at what happened when we injected errors in 2017 vs. what Prabhakaran et al. found in 2005.</p><p> 让我们看一下我们在2017年注入错误时发生的情况以及Prabhakaran等人的情况。发现于2005年。</p><p>                     Each row shows results for one filesystem.  read and  write indicating reading and writing data, respectively, where the block device returns an error indicating that the operation failed.  silent indicates a read failure (incorrect data) where the block device didn’t indicate an error. This could happen if there’s disk corruption, a transient read failure, or a transient write failure silently caused bad data to be written.  file indicates that the operation was done on a file opened with  open and  mmap indicates that the test was done on a file mapped with  mmap.  ignore (red) indicates that the error was ignored,  prop (yellow) indicates that the error was propagated and that the  pread or  pwrite syscall returned an error code, and  fix (green) indicates that the error was corrected. No errors were corrected. Grey entries indicate configurations that weren’t tested.</p><p>                     每行显示一个文件系统的结果。读取和写入分别表示读取和写入数据，其中块设备返回指示操作失败的错误。 Silent表示读取失败（数据不正确），其中块设备未指示错误。如果磁盘损坏，瞬时读取失败或瞬时写入失败默默地导致不良数据被写入，则可能会发生这种情况。文件表示对打开为打开的文件进行了操作，而mmap表示对映射为mmap的文件进行了测试。 ignore（红色）表示已忽略该错误，prop（黄色）表示该错误已传播，并且pread或pwrite syscall返回了错误代码，而fix（绿色）表示已纠正该错误。没有错误得到纠正。灰色条目表示未经测试的配置。</p><p> From the table, we can see that, in 2005,  ext3 and  jfs ignored write errors even when the block device indicated that the write failed and that things have improved, and that any filesystem you’re likely to use will correctly tell you that a write failed.  jfs hasn’t improved, but  jfs is now rarely used outside of legacy installations.</p><p> 从表中可以看到，在2005年，即使​​块设备指示写入失败并且情况有所改善，并且可能使用的任何文件系统都会正确告诉您，ext3和jfs忽略了写入错误。写失败。 jfs尚未改进，但是jfs现在很少在旧式安装之外使用。 </p><p> No tested filesystem other than  btrfs handled silent failures correctly. The other filesystems tested neither duplicate nor checksum data, making it impossible for them to detect silent failures.  zfs would probably also handle silent failures correctly but wasn’t tested.  apfs, despite post-dating  btrfs and  zfs, made the explicit decision to not checksum data and silently fail on silent block device errors. We’ll discuss this more later.</p><p>除btrfs之外，没有经过测试的文件系统可以正确处理静默故障。其他文件系统未测试重复数据或校验和数据，因此它们无法检测到静默故障。 zfs可能还可以正确处理静默故障，但未经测试。尽管对btrfs和zfs进行了约会，但apfs做出了明确的决定，即不校验和数据，并且在出现静默块设备错误时静默失败。我们将在以后再讨论。</p><p> In all cases tested where errors were propagated, file reads and writes returned  EIO from  pread or  pwrite, respectively;  mmap reads and writes caused the process to receive a  SIGBUS signal.</p><p> 在传播错误的所有测试情况下，文件读取和写入分别从pread或pwrite返回EIO； mmap的读取和写入导致进程接收到SIGBUS信号。</p><p> The 2017 tests above used an 8k file where the first block that contained file data either returned an error at the block device level or was corrupted, depending on the test. The table below tests the same thing, but with a 445 byte file instead of an 8k file. The choice of 445 was arbitrary.</p><p> 上面的2017测试使用了8k文件，其中第一个包含文件数据的块在块设备级别返回了错误或已损坏，具体取决于测试。下表测试了相同的内容，但是使用445字节文件而不是8k文件。 445的选择是任意的。</p><p>               In the small file test table, all the results are the same, except for  btrfs, which returns correct data in every case tested. What’s happening here is that the filesystem was created on a rotational disk and, by default,  btrfs duplicates filesystem metadata on rotational disks (it can be configured to do so on SSDs, but that’s not the default). Since the file was tiny,  btrfs packed the file into the metadata and the file was duplicated along with the metadata, allowing the filesystem to fix the error when one block either returned bad data or reported a failure.</p><p>               在小型文件测试表中，除btrfs以外，所有结果均相同，而btrfs在每种情况下均返回正确的数据。这里发生的是文件系统是在旋转磁盘上创建的，并且默认情况下，btrfs在旋转磁盘上复制文件系统元数据（可以配置为在SSD上这样做，但这不是默认设置）。由于文件很小，因此btrfs将文件打包到元数据中，并且该文件与元数据一起复制，从而使文件系统可以在一个块返回错误数据或报告故障时修复错误。</p><p>  Overlayfs allows one file system to be “overlaid” on another.  As explained in the initial commit, one use case might be to put an (upper) read-write directory tree on top of a (lower) read-only directory tree, where all modifications go to the upper, writable layer.</p><p>  Overlayfs允许将一个文件系统“覆盖”在另一个文件系统上。如最初提交中所述，一种用例可能是将（上部）读写目录树放在（下部）只读目录树的顶部，所有修改都移至上部可写层。</p><p> Although not listed on the tables, we also tested every filesystem other than  fat as the lower filesystem with overlay fs (ext4 was the upper filesystem for all tests). Every filessytem tested showed the same results when used as the bottom layer in  overlay as when used alone.  fat wasn’t tested because mounting  fat resulted in a  filesystem not supported error.</p><p> 尽管未在表中列出，但我们也测试了除fat以外的每个文件系统，将它们作为具有覆盖fs的较低文件系统（ext4是所有测试的较高文件系统）。当用作覆盖层的底层时，测试的每个文件系统都显示与单独使用时相同的结果。尚未测试fat，因为安装fat会导致文件系统不支持的错误。</p><p>  btrfs doesn’t, by default, duplicate metadata on SSDs because the developers believe that redundancy wouldn’t provide protection against errors on SSD (which is the same reason  apfs doesn’t have redundancy). SSDs do a kind of write coalescing, which is likely to cause writes which happen consecutively to fall into the same block. If that block has a total failure, the redundant copies would all be lost, so redundancy doesn’t provide as much protection against failure as it would on a rotational drive.</p><p>  默认情况下，btrfs不会在SSD上复制元数据，因为开发人员认为冗余不会为防止SSD上的错误提供保护（这与apfs没有冗余的原因相同）。 SSD执行某种写入合并，这很可能导致连续发生的写入落入同一块中。如果该块完全失败，则冗余副本将全部丢失，因此冗余无法提供与旋转驱动器一样多的故障保护。 </p><p> I’m not sure that this means that redundancy wouldn’t help -- Individual flash cells degrade with operation and lose charge as they age. SSDs have built-in  wear-leveling and  error-correction that’s designed to reduce the probability that a block returns bad data, but over time, some blocks will develop so many errors that the error-correction won’t be able to fix the error and the block will return bad data. In that case, a read should return some bad bits along with mostly good bits. AFAICT, the publicly available data on SSD error rates seems to line up with this view.</p><p>我不确定这是否意味着冗余将无济于事-各个闪存单元会随着运行而降级，并随着它们的老化而失去电荷。 SSD具有内置的损耗均衡和纠错功能，旨在降低块返回不良数据的可能性，但是随着时间的流逝，某些块会产生大量错误，因此纠错将无法修复错误。并且该块将返回错误数据。在这种情况下，读操作应返回一些不良位以及大多数不良位。 AFAICT的关于SSD错误率的公开数据似乎与此观点一致。</p><p>  Relatedly, it appears that   apfs doesn’t checksum data because “[apfs] engineers contend that Apple devices basically don’t return bogus data”. Publicly available studies on SSD reliability have not found that there’s a model that doesn’t sometimes return bad data. It’s a common conception that SSDs are less likely to return bad data than rotational disks, but when Google studied this across their drives, they found:</p><p>  相关地，似乎apfs不会校验和数据，因为“ [apfs]工程师认为Apple设备基本上不会返回假数据”。关于SSD可靠性的公开研究尚未发现，有一种模型有时不会返回不良数据。通常的观念是，与旋转磁盘相比，固态硬盘返回坏数据的可能性较小，但是当Google在其驱动器上进行研究时，他们发现：</p><p> The annual replacement rates of hard disk drives have previously been reported to be 2-9% [19,20], which is high compared to the 4-10% of flash drives we see being replaced in a 4 year period. However, flash drives are less attractive when it comes to their error rates. More than 20% of flash drives develop uncorrectable errors in a four year period, 30-80% develop bad blocks and 2-7% of them develop bad chips. In comparison, previous work [1] on HDDs reports that only 3.5% of disks in a large population developed bad sectors in a 32 months period – a low number when taking into account that the number of sectors on a hard disk is orders of magnitudes larger than the number of either blocks or chips on a solid state drive, and that sectors are smaller than blocks, so a failure is less severe.</p><p> 以前，硬盘驱动器的年更换率为2-9％[19,20]，与我们在四年内看到的闪存驱动器的4-10％相比，这个数字很高。但是，就错误率而言，闪存驱动器吸引力不大。在四年的时间内，超过20％的闪存驱动器会产生无法纠正的错误，30-80％的驱动器会产生坏块，而其中2-7％的驱动器会产生坏芯片。相比之下，以前有关HDD的工作[1]报告说，在大量硬盘中，只有3.5％的磁盘在32个月内出现了坏扇区–考虑到硬盘上的扇区数量是几个数量级，这个数字很小。大于固态驱动器上的块或芯片的数量，并且扇区小于块，因此故障的严重性就较小。</p><p> While there is one sense in which SSDs are more reliable than rotational disks, there’s also a sense in which they appear to be less reliable. It’s not impossible that Apple uses some kind of custom firmware on its drive that devotes more bits to error correction than you can get in publicly available disks, but even if that’s the case, you might plug a non-apple drive into your apple computer and want some kind of protection against data corruption.</p><p> 从某种意义上说，SSD比旋转磁盘更可靠，但从某种意义上说，它们似乎不那么可靠。 Apple在驱动器上使用某种自定义固件来进行纠错比在公共磁盘上投入更多的比特并不是不可能，但是即使是这种情况，您也可以将非Apple驱动器插入Apple计算机并想要某种防止数据损坏的保护措施。</p><p>  Now that we’ve reproduced some tests from Prabhakaran et al., we’re going to move on to  Gunawi et al.. Since the paper is fairly involved, we’re just going to look at one small part of the paper, the part where they examined three function calls,  filemap_fdatawait,  filemap_fdatawrite, and  sync_blockdev to see how often errors weren’t checked for these functions.</p><p>  现在，我们已经复制了Prabhakaran等人的一些测试，我们将继续研究Gunawi等人。由于本文涉及的内容非常丰富，因此我们只看一下本文的一小部分，即在该部分中，他们检查了三个函数调用，分别是filemap_fdatawait，filemap_fdatawrite和sync_blockdev，以查看不检查这些函数的错误的频率。</p><p>  As discussed in Section 3.1, a function could return more than one error code at the same time, and checking only one of them suffices. However, if we know that a certain function only returns a single error code and yet the caller does not save the return value properly, then we would know that such call is really a flaw. To find real flaws in the file system code, we examined three important functions that we know only return single error codes: sync_blockdev, filemap_fdatawrite, and filemap_fdatawait. A file system that does not check the returned error codes from these functions would obviously let failures go unnoticed in the upper layers.</p><p>  如第3.1节所述，一个函数可以同时返回多个错误代码，并且仅检查其中一个就足够了。但是，如果我们知道某个函数只返回一个错误代码，而调用者却没有正确保存返回值，那么我们就会知道这样的调用确实是一个缺陷。为了发现文件系统代码中的真正缺陷，我们检查了三个我们仅知道会返回单个错误代码的重要函数：sync_blockdev，filemap_fdatawrite和filemap_fdatawait。如果文件系统不检查从这些函数返回的错误代码，则显然会使上层未注意到故障。</p><p> Ignoring errors from these functions appears to have fairly serious consequences. The documentation for  filemap_fdatawait says:</p><p> 忽略这些功能中的错误似乎会带来相当严重的后果。 filemap_fdatawait的文档说： </p><p> filemap_fdatawait — wait for all under-writeback pages to complete...Walk the list of under-writeback pages of the given address space and wait for all of them. Check error status of the address space and return it.Since the error status of the address space is cleared by this function, callers are responsible for checking the return value and handling and/or reporting the error.</p><p>filemap_fdatawait —等待所有欠写回页面完成...步行给定地址空间的欠写回页面列表，然后等待所有它们。检查地址空间的错误状态并返回它。由于此功能清除了地址空间的错误状态，因此调用者负责检查返回值以及处理和/或报告错误。</p><p>  Write out and wait upon all the dirty data associated with a block device via its mapping. Does not take the superblock lock.</p><p>  写出并等待通过块映射与块设备关联的所有脏数据。不采用超级块锁定。</p><p> In both of these cases, it appears that ignoring the error code could mean that data would fail to get written to disk without notifying the writer that the data wasn’t actually written?</p><p> 在这两种情况下，忽略错误代码似乎都意味着数据将无法写入磁盘而没有通知写入者该数据不是实际写入的？</p><p> Let’s look at how often calls to these functions didn’t completely ignore the error code:</p><p> 让我们看看对这些函数的调用没有完全忽略错误代码的频率：</p><p>  This table is for all code in linux under  fs. Each row shows data for calls of one function. For each year, the leftmost cell shows the number of calls that do something with the return value over the total number of calls. The cell to the right shows the percentage of calls that do something with the return value. “Do something” is used very loosely here -- branching on the return value and then failing to handle the error in either branch, returning the return value and having the caller fail to handle the return value, as well as saving the return value and then ignoring it are all considered doing something for the purposes of this table.</p><p>  该表适用于Linux下fs下的所有代码。每行显示一个函数的调用数据。对于每年，最左边的单元格显示的是在返回的总次数中使用返回值执行某项操作的呼叫数。右边的单元格显示使用返回值执行操作的呼叫百分比。 “做某事”在这里非常宽松-分支返回值，然后在任何一个分支中均无法处理错误，返回返回值并使调用者无法处理返回值，以及保存返回值和然后忽略此表，则认为所有操作都在做。</p><p>   Although  cifs_sign_smb returned an error code, it was never checked before being overwritten by  smb_send, which counted as being used for our purposes even though the error wasn’t handled.</p><p>   尽管cifs_sign_smb返回了错误代码，但从未被检查过，然后被smb_send覆盖，即使未处理该错误，该代码仍被视为用于我们的目的。</p><p> Overall, the table appears to show that many more errors are handled now than were handled in 2008 when Gunawi et al. did their analysis, but it’s hard to say what this means from looking at the raw numbers because it might be ok for some errors not to be handled and different lines of code are executed with different probabilities.</p><p> 总体而言，该表似乎表明，现在处理的错误比2008年Gunawi等提出的错误要多得多。进行了分析，但是很难看清原始数字的含义，因为可以解决一些错误并且以不同的概率执行不同的代码行是可以的。 </p><p>  Filesystem error handling seems to have improved. Reporting an error on a  pwrite if the block device reports an error is perhaps the most basic error propagation a robust filesystem should do; few filesystems reported that error correctly in 2005. Today, most filesystems will correctly report an error when the simplest possible error condition that doesn’t involve the entire drive being dead occurs if there are no complicating factors.</p><p>文件系统错误处理似乎有所改善。如果块设备报告错误，则在pwrite上报告错误，这可能是健壮的文件系统应该执行的最基本的错误传播；很少有文件系统在2005年正确地报告了该错误。今天，如果没有复杂的因素，那么当最简单的错误情况（不涉及整个驱动器死机）发生时，大多数文件系统将正确地报告错误。</p><p> Most filesystems don’t have checksums for data and leave error detection and correction up to userspace software. When I talk to server-side devs at big companies, their answer is usually something like “who cares? All of our file accesses go through a library that checksums things anyway and redundancy across machines and datacenters takes care of failures, so we only need error detection and not correction”. While that’s true for developers at certain big companies, there’s a lot of software out there that isn’t written robustly and just assumes that filesystems and disks don’t have errors.</p><p> 大多数文件系统都没有数据校验和，而错误检测和纠正则留给用户空间软件进行。当我与大公司的服务器端开发人员交谈时，他们的回答通常是“谁在乎？我们所有的文件访问都经过一个库，该库无论如何都会对所有事物进行校验和，并且跨机器和数据中心的冗余可以解决故障，因此我们只需要错误检测而无需纠正。”尽管某些大公司的开发人员确实如此，但其中有很多软件编写得不够好，只是假设文件系统和磁盘没有错误。</p><p> This was a joint project with Wesley Aptekar-Cassels; the vast majority of the work for the project was done while pair programming at  RC. We also got a lot  of help from Kate Murphy. Both Wesley (w.aptekar@gmail.com) and Kate (hello@kate.io) are looking for work. They’re great and I highly recommend talking to them if you’re hiring!</p><p> 这是与Wesley Aptekar-Cassels的联合项目；该项目的绝大部分工作是在RC进行结对编程时完成的。凯特·墨菲（Kate Murphy）也提供了很多帮助。卫斯理（w.aptekar@gmail.com）和凯特（hello@kate.io）都在找工作。他们很棒，如果您正在招聘，我强烈建议与他们交谈！</p><p>  A fair amount of effort has been applied to get error handling right. But C makes it very easy to get things wrong, even when you apply a fair amount effort and even apply extra tooling. One example of this in the code is the  submit_one_bio function. If you look at the definition, you can see that it’s annotated with  __must_check, which will cause a compiler warning when the result is ignored. But if you look at calls of  submit_one_bio, you’ll see that its callers aren’t annotated and can ignore errors. If you dig around enough you’ll find one path of error propagation that looks like:</p><p>  为了获得正确的错误处理，已经进行了大量的工作。但是，即使您付出了相当大的努力，甚至使用了额外的工具，使用C都很容易出错。代码中的一个示例是Submit_one_bio函数。如果看一下定义，您会发现它用__must_check进行了注释，当忽略结果时，它将引起编译器警告。但是，如果您查看submit_one_bio的调用，您会发现其调用者没有注释，可以忽略错误。如果深入研究，您会发现一条错误传播路径，如下所示：</p><p>  Nine levels removed from  submit_one_bio, we see our old friend, `filemap_fdatawrite, which we know often doesn’t get checked for errors.</p><p>  从commit_one_bio中删除了9个级别，我们看到了我们的老朋友`filemap_fdatawrite，我们知道通常不会检查错误。</p><p> There&#39;s a very old debate over how to prevent things like this from accidentally happening. One school of thought, which I&#39;ll call the Uncle Bob (UB) school believes that  we can&#39;t fix these kinds of issues with tools or processes and simply need to be better programmers in order to avoid bugs. You&#39;ll often hear people of the UB school say things like, &#34;you can&#39;t get rid of all bugs with better tools (or processes)&#34;. In his famous and well-regarded talk,  Simple Made Easy, Rich Hickey says</p><p> 关于如何防止此类意外事件的争论非常古老。我称之为鲍勃叔叔（UB）学派的一所思想流派认为，我们无法用工具或流程解决这类问题，仅需要成为更好的程序员来避免错误。您会经常听到UB学校的人说类似的事情，“您无法使用更好的工具（或过程）摆脱所有错误”。 Rich Hickey在他著名且备受好评的演讲中说：</p><p> It got written. Yes. What&#39;s a more interesting fact about it? It passed the type checker.</p><p> 它写了。是。关于它的更有趣的事实是什么？它通过了类型检查器。 </p><p>    It passed all the tests. Okay. So now what do you do? Right? I think we&#39;re in this world I&#39;d like to call guardrail programming. Right? It&#39;s really sad. We&#39;re like: I can make change because I have tests. Who does that? Who drives their car around banging against the guardrail saying, &#34;Whoa! I&#39;m glad I&#39;ve got these guardrails because I&#39;d never make it to the show on time.&#34;</p><p>它通过了所有测试。好的。那么，现在您该怎么办？对？我想我们在这个世界上想打电话给护栏编程。对？真的很伤心。我们就像：我可以进行更改，因为我有测试。是谁啊谁开着车撞在护栏上说：哇！我很高兴获得了这些护栏，因为我从来没有准时参加演出。</p><p> If you watch the talk, Rich uses &#34;simplicity&#34; the way Uncle Bob uses &#34;discipline&#34;. They way these statements are used, they&#39;re roughly equivalent to Ken Thompson saying &#34; Bugs are bugs. You write code with bugs because you do&#34;. The UB school throws tools and processes under the bus, saying that it&#39;s unsafe to rely solely on tools or processes.</p><p> 如果您观看谈话，Rich会使用＆＃34; simplicity＆＃34; Bob叔叔使用＆＃34;纪律＆＃34;的方式。他们使用这些陈述的方式，大致相当于Ken Thompson所说的＆＃34;错误就是错误。您编写带有错误的代码是因为这样做。 UB学校在总线下扔了工具和流程，说仅仅依靠工具或流程是不安全的。</p><p> Rich&#39;s rhetorical trick is brilliant -- I&#39;ve heard that line quoted tens of times since the talk to argue against tests or tools or types. But, like guardrails, most tools and processes aren&#39;t about eliminating all bugs, they&#39;re about reducing the severity or probability of bugs. If we look at this particular function call, we can see that a static analysis tool failed to find this bug. Does that mean that we should give up on static analysis tools? A static analysis tool could look for all calls of  submit_one_bio and show you the cases where the error is propogated up N levels only to be dropped. Gunawi et al. did exactly that and found  a lot of bugs. A person basically can&#39;t do the same thing without tooling. They could try, but people are lucky if they get 95% accuracy when manually digging through things like this. The sheer volume of code guarantees that a human doing this by hand would make mistakes.</p><p> 里奇的修辞手法非常出色-自从谈论反对测试，工具或类型的讨论以来，我听说那行引用了数十次。但是，就像护栏一样，大多数工具和流程并不是要消除所有错误，而是要降低错误的严重性或可能性。如果我们看一下这个特定的函数调用，我们可以看到静态分析工具未能找到该错误。这是否意味着我们应该放弃静态分析工具？静态分析工具可以查找所有commit_one_bio调用，并向您显示将错误传播到N个级别而仅将其删除的情况。 Gunawi等。确实做到了，发现了很多错误。没有工具，一个人基本上不可能做同样的事情。他们可以尝试，但如果人们在手动进行此类操作时获得95％的准确度，他们将很幸运。庞大的代码量保证了人工操作会出错。</p><p> Even better than a static analysis tool would be a language that makes it harder to accidentally forget about checking for an error. One of the issues here is that it&#39;s sometimes valid to drop an error. There are a number of places where there&#39;s no interace that allows an error to get propogated out of the filesystem, making it correct to drop the error, modulo changing the interface. In the current situation, as an outsider reading the code, if you look at a bunch of calls that drop errors, it&#39;s very hard to say, for all of them, which of those is a bug and which of those is correct. If the default is that we have a kind of guardrail that says &#34;this error must be checked&#34;, people can still incorrectly ignore errors, but you at least get an annotation that the omission was on purpose. For example, if you&#39;re forced to specifically write code that indicates that you&#39;re ignoring an error, and in code that&#39;s inteded to be robust, like filesystem code, code that drops an error on purpose is relatively likely to be accompanied by a comment explaining why the error was dropped.</p><p> 甚至比静态分析工具更好的语言是一种语言，它使人们更容易意外忘记检查错误。这里的问题之一是删除错误有时是有效的。在很多地方，没有接口可以使错误从文件系统中传播出去，从而可以正确地删除错误，对接口进行模更改。在当前情况下，作为局外人阅读代码，如果您查看一堆掉落错误的调用，那么对于所有错误来说，很难说出哪个是错误，哪个是错误。正确。如果默认情况是我们有一种说“必须检查此错误”的护栏，那么人们仍然可以错误地忽略错误，但是您至少会得到一个注释，表示故意遗漏了。例如，如果您被迫专门编写表明您忽略错误的代码，并且在文件系统代码等本来要健壮的代码中，故意丢弃错误的代码相对有可能附有解释错误原因的注释。</p><p>  After all, it would be nice if we knew if modern filesystems could do basic tasks correctly. Filesystem developers probably know this stuff, but since I don&#39;t  follow LKML, I had no idea whether or not things had improved since 2005 until we ran the experiment.</p><p>  毕竟，如果我们知道现代文件系统是否可以正确完成基本任务，那就太好了。文件系统开发人员可能知道这些知识，但是由于我不遵循LKML，因此在进行实验之前，我不知道自2005年以来情况是否有所改善。</p><p> The papers we looked at here came out of Andrea and Remzi Arpaci-Dusseau&#39;s research lab. Remzi has a talk where he mentioned that grad students don&#39;t want to reproduce and update old work. That&#39;s entirely reasonable, given the incentives they face. And I don&#39;t mean to pick on academia here -- this work came out of academia, not industry. It&#39;s possible this kind of work simply wouldn&#39;t have happened if not for the academic incentive system.</p><p> 我们在这里查看的论文来自Andrea和Remzi Arpaci-Dusseau的研究实验室。 Remzi在一次演讲中提到，研究生不希望复制和更新旧作品。考虑到他们面临的激励，这是完全合理的。我不是要在这里选择学术界-这项工作来自学术界，而不是行业。如果没有学术奖励制度，这种工作可能根本不会发生。</p><p> In general, it seems to be quite difficult to fund work on correctness. There are a fair number of papers on new ways to find bugs, but that&#39;s relatively little work on applying existing techniques to existing code. In academia, that seems to be hard to get a good publication out of, in the open source world, that seems to be less interesting to people than writing new code. That&#39;s also entirely reasonable -- people should work on what they want, and even if they enjoy working on correctness, that&#39;s probably not a great career decision in general. I was at the  RC career fair the other night and my badge said I was interested in testing. The first person who chatted me up opened with &#34;do you work in QA?&#34;. Back when I worked in hardware, that wouldn&#39;t have been a red flag, but in software, &#34;QA&#34; is code for a low-skill, tedious, and poorly paid job. Much of industry considers testing and QA to be an afterthought. As a result, open source projects that companies rely on are often  woefully underfunded. Google funds some great work (like afl-fuzz), but that&#39;s the exception and not the rule, even within Google, and most companies don&#39;t fund any open source work. The work in this post was done by a few people who are intentionally temporarily unemployed, which isn&#39;t really a scalable model.</p><p> 通常，为正确性工作提供资金似乎非常困难。关于发现错误的新方法的论文很多，但是将现有技术应用于现有代码的工作相对较少。在学术界，在开源世界中很难找到一个好的出版物，这对人们来说似乎比编写新代码有趣。那也是完全合理的-人们应该按照自己想要的去工作，即使他们喜欢正确性，总体上这也不是一个伟大的职业决定。那天晚上我参加了RC招聘会，徽章上写着我对测试感兴趣。与我聊天的第一个人以＆＃34;开始从事质量检查工作吗？＆＃34;。回到我在硬件上工作时，这并不是一个危险的信号，但是在软件中，＆Q34＆QA＆＃34;是低技能，乏味且薪水低的工作的代码。许多行业认为测试和质量检查是事后的想法。结果，公司所依赖的开放源代码项目常常资金不足。 Google资助了一些出色的工作（例如afl-fuzz），但这是一个例外，而不是常规，即使在Google内部也是如此，而且大多数公司不资助任何开源工作。这篇文章中的工作是由一些有意暂时失业的人完成的，这实际上不是可扩展的模型。 </p><p> Occasionally, you&#39;ll see someone spend a lot of effort on immproving correctness, but that&#39;s usually done as a massive amount of free labor. Kyle Kingsbury might be the canonical example of this -- my understanding is that he worked on the  Jepsen distributed systems testing tool on nights and weekends for years before turning that into a consulting business. It&#39;s great that he did that -- he showed that almost every open source distributed system had serious data loss or corruption bugs. I think that&#39;s great, but stories about heoric effort like that always worry me because heroism doesn&#39;t scale. If Kyle hadn&#39;t come along, would most of the bugs that he and his tool found still plague open source distributed systems today? That&#39;s a scary thought.</p><p>有时，您会看到有人在提高正确性上花费了很多心血，但这通常是大量的自由劳动。凯尔·金斯伯里（Kyle Kingsbury）可能是一个典型的例子-我的理解是，他在晚上和周末从事Jepsen分布式系统测试工具的工作了多年，然后才将其转变为咨询业务。他做到了，真是太好了-他表明几乎每个开源分布式系统都存在严重的数据丢失或损坏错误。我认为这很不错，但是关于英雄式努力的故事总是让我感到担忧，因为英雄主义无法扩展。如果凯尔（Kyle）没有出现，他和他的工具发现的大多数错误是否还会困扰当今的开源分布式系统？那是一个可怕的想法。</p><p> If I knew how to fund more work on correctness, I&#39;d try to convince you that we should switch to this new model, but I don&#39;t know of a funding model that works. I&#39;ve set up a  patreon (donation account), but it would be quite extraordinary if that was sufficient to actually fund a signifcant amount of work. If you look at how much programmers make off of donations, if I made two order of magnitude less tha</p><p> 如果我知道如何为正确性上的更多工作提供资金，我会试图说服您我们应该改用这种新模型，但是我不知道可行的资金模型。我已经建立了一个patreon（捐赠帐户），但是如果这足以实际资助大量工作，那将是非常不寻常的。如果你看看程序员从捐赠中赚了多少钱，如果我减少了两个数量级，</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://danluu.com/filesystem-errors/">https://danluu.com/filesystem-errors/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/文件系统/">#文件系统</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/error/">#error</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/错误/">#错误</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>