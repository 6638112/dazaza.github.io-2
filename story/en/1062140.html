<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>验证= TCB / PB减少 Verification = TCB/PB Reduction</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Verification = TCB/PB Reduction<br/>验证= TCB / PB减少 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-12 18:08:18</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/7cf484ceeae6bc7fc2161eddc603cd15.jpg"><img src="http://img2.diglog.com/img/2021/5/7cf484ceeae6bc7fc2161eddc603cd15.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In high-school maths, we are introduced to the idea of a  proof — the word “proof” is etymologically related to the word “probe”. In a proof, we reason from first principles (aka  axioms), why a certain assertion (aka  theorem) holds true. Said differently, we  verify the theorem, and  the  proof represents the verification process.</p><p>在高中数学中，我们被引入了证明的概念 - “证明”这个词与“探针”一词的词语相关。在证明中，我们从第一个原则（AKA公理）的原因，为什么某种断言（AKA定理）保持真实。如有不同，我们验证定理，证明代表验证过程。</p><p> The axioms and the proof need a language in which they are represented — at a minimum, this language involves a syntax and a set of  proof rules governing that syntax. This mathematical rule-based verification is also called  formal verification, to distinguish it from the colloquial use of the word verification which may just involve human inspection.</p><p> 该语言的原理和证据需要一种语言 - 至少是该语言涉及语法和一组管理该语法的证明规则。基于数学规则的验证也称为正式验证，以区分其从口语使用中可能只是涉及人类检查的验证。</p><p> The theorem being verified is often broken up into two parts: (1) the implementation, and (2) a specification that is supposed to hold for that implementation. Here is an example of an implementation, a specification, the axioms that we assume, and the proof system that can be used to complete the proof.</p><p> 正在验证的定理通常被分为两部分：（1）实施，（2）所谓的规范，该规范应该适用于该实施。以下是我们假设的一个示例，规格，我们假设的公理系统，以及可用于完成证明的证明系统。</p><p>    The proof author can choose an abstraction level for the axioms and the proof rules, to trade-off between proof simplicity and the level of rigour. For example, the author may choose to consider the commutativity of natural number addition as an axiom, and perhaps prove it separately elsewhere. Alternatively, the author may choose to restrict herself to lower-level axioms only, to potentially obtain more succinct and elegant proofs.</p><p>    证明作者可以选择公理和证明规则的抽象级别，以便在证明简单和严格水平之间进行权衡。例如，作者可以选择考虑作为公理的自然数量的换向，也许在其他地方分开证明它。或者，作者可以选择仅将自己限制到较低级别的公理，以潜在地获得更加简洁和优雅的证明。</p><p> Similarly, the author may choose to assume the validity of mathematical induction over natural numbers (proof rule) even though that may be derivable from more general proof rules such as Noetherian induction.</p><p> 类似地，作者可以选择假设数学归纳的有效性，即使可以从诸如Noetherian诱导的更常规证明规则中衍生来源。</p><p> From a pure theoretical standpoint, it should not matter which (abstraction level of) axioms and proof rules you pick. However, from a computer systems point of view, this does have an effect on your confidence in the verification effort as we discuss below (TL;DR higher abstraction levels slightly increase the size of specifications and proof rules, thus potentially increasing the probability of a bug escaping the verification process).</p><p> 从纯粹的理论上的角度来看，你不应该重要（抽象水平）你选择的公理和证明规则。然而，从计算机系统的角度来看，这确实对您对验证工作的信心产生了影响，因为我们讨论了以下（TL;更高的抽象级别略微增加规格和证明规则的大小，因此可能增加了概率错误逃避验证过程）。</p><p>  size_t strlen( char  const* str) {  char* ptr;  ulong *longword_ptr;  ulong longword, himagic, lomagic;  for (ptr = str; (( ulong)ptr &amp;  7) !=  0; ++ptr)  if (*ptr ==  ‘\0’)  return ptr - str; longword_ptr = ( ulong*)ptr; himagic =  0x8080808080808080L; lomagic =  0x0101010101010101L;  for (;;) { longword = *longword_ptr;  if ((longword - lomagic) &amp; ~longword &amp; himagic) {  char *cp = ( char*)(longword_ptr -  1);  if (cp[ 0] ==  0)  return cp - str;  if (cp[ 1] ==  0)  return cp - str +  1;  if (cp[ 2] ==  0)  return cp - str +  2;  if (cp[ 3] ==  0)  return cp - str +  3;  if (cp[ 4] ==  0)  return cp - str +  4;  if (cp[ 5] ==  0)  return cp - str +  5;  if (cp[ 6] ==  0)  return cp - str +  6;  if (cp[ 7] ==  0)  return cp - str +  7;} } }</p><p>  size_t strlen（char const * str）{char * ptr; ulong * longword_ptr; ulong longword，himagic，lomagic; for（ptr = str;（（unong）ptr＆amp; 7）！= 0; ++ PTR）如果（* ptr =='\ 0'）返回ptr-str; longword_ptr =（Ulong *）PTR; himagic = 0x8080808080808080l; Lomagic = 0x0101010101010101L; for（;;）{longword = * longword_ptr; if（（longword  -  lomagic）＆amp;〜longword＆amp; himagic）{char * cp =（char *）（longword_ptr  -  1）; if（cp [0] == 0）返回cp  -  str; if（cp [1] == 0）返回cp  -  str + 1; if（cp [2] == 0）返回cp  -  str + 2; if（cp [3] == 0）返回cp  -  str + 3; if（cp [4] == 0）返回cp  -  str + 4; if（cp [5] == 0）返回cp  -  str + 5; if（cp [6] == 0）返回cp  -  str + 6; if（cp [7] == 0）返回cp  -  str + 7;}}} </p><p> In software, we are usually interested in proving properties of a computer program. The program will have its own syntax, depending on the programming language (PL) in which it has been developed. The syntax of the computer program can be different from the syntax that is used for the specification, the axioms and the proof. In the text below, we show four different ways to write the specification for the C library’s  strlen() function; for each specification method, we also provide the required axioms and proof system.</p><p>在软件中，我们通常对证明计算机程序的属性感兴趣。该程序将有自己的语法，具体取决于它已经开发的编程语言（PL）。计算机程序的语法可以与用于规范，公理和证明的语法不同。在下文中，我们显示了四种不同的方法来编写C库的strlen（）函数的规范;对于每个规格方法，我们还提供所需的公理和证明系统。</p><p>      Quantifier-free logic with bitvector and array theories. Proof rules for the   operator, as shown below</p><p>      具有BitVector和Array理论的无量值逻辑。操作员的证明规则，如下所示</p><p> The proof rules for the   operator are shown as inference rules below. If you are not an expert in reading this notation, don’t bother — basically these are a set of rules that try and resolve the value of the   operator depending on the context in which it occurs. The mechanical checker can use these inference rules as input to decide the validity of a proof step.</p><p> 操作员的证明规则如下所示。如果您不是读取此表示法的专家，则不会打扰 - 基本上这些是一组尝试解决操作员的规则，具体取决于它发生的上下文。机械检查器可以使用这些推理规则作为输入来决定证明步骤的有效性。</p><p>         In these inference rules,  Ctx represents the context under which this evaluation is performed,  Heap represents the memory array,  addr b and  addr e represent the bitvectors representing addresses used to index into the heap.  L represents a (lambda) function that takes a byte and returns either true or false. Intuitively, the   operator returns the first index (relative to  addr b) of the byte (starting at  addr b and before  addr e) which evaluates  L to true. The sentinel value of  -1 is used if none of the bytes between  addr b and  addr e evaluate  L to true. For example, the first inference rule (base case) states that if  addr b and  addr e are equal (i.e., there are no bytes in the range), then   evaluates to the sentinel value  -1 (irrespective of  Heap and  L). The   operator represents bitvector addition with wrap-around semantics.</p><p>         在这些推理规则中，CTX表示执行此评估的上下文，堆代表存储器阵列，Addr B和Addr E表示表示用于索引到堆的地址的BitVectors。 l表示一个（lambda）函数，它需要一个字节并返回true或false。直观地，操作员将返回字节的第一个索引（相对于ADDR B）（在Addr B和Addr E之前启动），其评估l为true。如果ADDR B和ADDR E之间没有评估L为TRUE，则使用-1的Sentinel值。例如，第一推断规则（基本情况）指出，如果Addr B和Addr E相等（即，范围内没有字节），则评估到Sentinel值-1（无论堆和l）。运算符代表与环绕语义的BitVector添加。</p><p> Notice that the  addr e argument in our theorem relating  strlen to   is zero, indicating that we are interested in finding the first null character between  str and the maximum address value  addr max in the memory address space (recall that  addr max 1=0).</p><p> 请注意，我们定论中的Addr E参数关联strlen为零，指示我们有兴趣在内存地址空间中找到str和最大地址值addr max之间的第一个空字符（调用该addr max 1 = 0）。</p><p>   size_t strlenNaive( char const* s) {  char const* p = s;  for (p = s; *p; p++);  return p - s;}</p><p>   size_t strlennaive（char const * s）{char const * p = s; for（p = s; * p; p ++）;返回p  -  s;}</p><p> In this method of specification, both  strlenNaive and  strlen are specified in the same syntax (the syntax of the C programming language). However, the specification program ( strlenNaive) is significantly simpler and smaller than the implementation ( strlen).</p><p> 在这种规范方法中，STRLENNAVE和STRLEN都以相同的语法（C编程语言的语法）指定。然而，规范程序（StrennaIve）明显更简单，而不是实现（strlen）。 </p><p>    Inductive string :  Set := | EmptyString : string | String :  ascii -&gt; string -&gt; string Fixpoint strlenCoq (strCoq :  string) :  nat :=  match s  with |  EmptyString =&gt; 0 |  String c s&#39; =&gt;  S (length s&#39;)  end.</p><p>归纳字符串：SET：= |空字符串：字符串|字符串：ASCII  - ＆gt;弦 - ＆gt;字符串FixPoint StrlencoQ（strcoq：string）：nat：=匹配s |空心队=＆gt; 0 |字符串C s＆＃39; =＆gt; S（长度S＆＃39;）结束。</p><p> Here, a different syntax (Coq) is used for the specification program. Using a higher-level Coq syntax has the benefit that a higher level syntax does not allow several unsafe behaviours, such as memory errors, that are possible in the C syntax (discussed in more detail in  Adam Chlipala’s blog post). On the other hand, proofs with respect to the Coq specification now require the prover to relate the data structures between two different representations — e.g.,  str in C is a character array that needs to be related to  strCoq that is a user-specified abstract data type.</p><p> 这里，不同的语法（COQ）用于规范程序。使用更高级别的COQ语法具有更高级别的语法不允许诸如C语法中可能的多个不安全行为（例如在Adam Chlipala博客文章中讨论的内存错误）的益处。另一方面，关于COQ规范的证据现在要求递送递送两个不同表示之间的数据结构 - 例如，C中的STR是需要与STRCOQ相关的字符阵列，该字符数组是用户指定的抽象数据类型。</p><p> Quantifier-free logic with bitvector and array theories. CoInduction and Bisimulation. Support for relational predicates across data structures in C and Coq</p><p> 具有BitVector和Array理论的无量值逻辑。掺入和分发。支持C和COQ中数据结构的关系谓词</p><p>  A proof, or a verification process, is incorrect if it concludes that a theorem is provably valid even when it was not.</p><p>  如果它得出结论，即使没有，证明或验证过程是不正确的。</p><p> Irrespective of the method of specification and proof, the verification process can be incorrect for one of the following reasons:</p><p> 无论规范和证明方法如何，验证过程都可能不正确，原因之一：</p><p> Incoherent Proof Steps: If any step in the proof does not follow from the existing theorems/axioms/proof rules, then we have an incorrect proof. The common solution to guard against this possibility is to have a mechanical  proof checker, codified as a computer program, that can ascertain that all the steps in your proof are valid.   However, if the proof checker has bugs or oversights, then you may admit an incorrect proof.</p><p> 不连贯的证明步骤：如果证明中的任何步骤都没有从现有定理/公理/证据规则中遵循，那么我们的证据不正确。防范这种可能性的常见解决方案是有机械证明检查器，被称为计算机程序，可以确定证明的所有步骤都有效。但是，如果证明检查器有错误或疏忽，那么您可能会承认证据不正确。</p><p> Incorrect Axioms: If the axioms were incorrect, then this can corrupt the entire proof effort. In the context of verification of computer systems, the semantics of a programming language form the set of axioms for example. Further, the  specification itself is a part of the axioms, e.g., if the simpler  strlenNaive function has a bug, then we would admit the same bug in the  strlen implementation as well.   It is important for the axioms to be either small (so that they are manually verifiable) or rigorously tested. For example, the  strlenNaive function is small enough to develop confidence through manual inspection alone. On the other hand, the C language semantics are much larger and hard to read manually to develop confidence. Fortunately, C language semantics involve a single codebase that is used for verification and testing across tens of thousands of codebases, and so such wide testing and production use provides confidence in its correctness. For example, it is possible to test the logical encodings of the C semantics by checking that the outputs of the logical encodings are identical to the outputs produced through C compilations on a physical computer.</p><p> 不正确的公理：如果公理是不正确的，那么这可能会破坏整个证明工作。在验证计算机系统的上下文中，例如，编程语言的语义形成了一组公理。此外，规范本身是公理的一部分，例如，如果更简单的strnenaive函数有一个错误，那么我们也会承认strlen实现中的相同错误。重要的是要么是小（使它们是手动验证的）或严格地测试。例如，Strennaive函数足够小，可以通过单独手动检查来发展信心。另一方面，C语言语言的语言语言很大，难以手动读取以发展信心。幸运的是，C语言语言涉及单个代码库，用于验证和测试成千上万的CodeBases，因此这种广泛的测试和生产使用提供了对其正确性的信心。例如，可以通过检查逻辑编码的输出与通过物理计算机上的C编译产生的输出相同的输出来测试C语义的逻辑编码。 </p><p> Incorrect Proof Rules: If any of the proof rules is unsound (buggy), then the proof steps can become unsound, which in turn results in an incorrect proof.  In our example, most proof rules are based on standard quantifier-free or first-order logic for bitvectors and arrays. These proof rules have undergone several code reviews, extensive testing, and are in production use by thousands of users — and so we can be reasonably confident of their correctness.  There is a slightly higher likelihood for the proof rules to be unsound for custom proof rules added for custom axiomatic operators, such as   in our example. However, even so, these custom rules are typically much simpler than the implementations that they verify (because they do not need to be optimized) and further they have wider use and testing (e.g.,   could be used for several search-based algorithms, and is not limited to  strlen).</p><p>证明规则不正确：如果任何证明规则都是非疑问（越野车），则校对步骤可能会变得不健全，这反过来导致证明不正确。在我们的示例中，大多数证明规则基于BitVectors和阵列的标准量化或一阶逻辑。这些证明规则经过了多种代码审查，广泛的测试，并在成千上万的用户使用中使用，因此我们可以合适地对其正确性充满信心。对于为自定义公理运算符添加的定制规则，诸如示例中添加的定制规则，有一个略高的概率。然而，即便如此，这些自定义的规则通常比实施更简单，他们确认（因为他们并不需要优化做），并进一步他们有更广泛的应用和测试（例如，可用于多种基于搜索的算法，并不限于Strlen）。</p><p>  We have already discussed that the proof can be incorrect. If you have read this interesting blog post on  the Piano Test by John Regehr, you now know that you do not want to be sitting under that piano.</p><p>  我们已经讨论过，证明可能不正确。如果您阅读了John Regehr的钢琴测试上的这个有趣的博客帖子，您现在知道您不想坐在那个钢琴下。</p><p> Then,  what does it mean for a software program to be formally verified, if it does not guarantee the absence of bugs?</p><p> 那么，如果不保证没有错误的情况，那么软件程序是什么意思的，如果不保证错误？</p><p> The value of a formal verification effort is that it  reduces your Trusted Computing Base/Probability of a Bug, or  TCB/PB. In our  strlen example, if the implementation has been formally verified (using any of the four specification methods), then we know that for there to be a bug in the implementation, there must be a bug either in the specification (which is much smaller than the implementation) or there must be a bug in the logical encoding of the C programming language semantics (which have been heavily tested) or there must be a bug in the proof rules (also heavily tested) or there must be a bug in the proof checker (also heavily tested). The formal verification process adds value if the chances of bugs in any of these subsystems is lower than the chance of a bug in your original implementation.</p><p> 正式验证工作的价值是它降低了您的可信计算基础/错误的计算基础/概率，或TCB / PB。在我们的strlen的例子，如果实现已经正式验证（使用任意四种规格的方法），那么我们知道，那里是在执行中的错误，必须有规范或者错误（这是小得多不是实现），或者必须有C编程语言的语义（已严格测试的逻辑编码错误），或者必须有一个错误的证据规则（也大量测试）或存在必须在一个错误校对检查器（也严重测试）。如果这些子系统中的任何错误的机会低于原始实现中错误的机会，则正式验证过程增加了值。</p><p> It is worth emphasizing that a “reduction” in the TCB is not necessarily a quantifiable reduction, e.g., it often cannot be measured by SLOC (source lines of code) alone. For some components of the proof, such as the specification, it makes sense to quantify the TCB reduction through SLOC. But for other components, such as axioms, proof rules, and proof checkers, we are not relying on SLOC reduction but on the fact that these are infrastructural components that have been heavily tested and are often in heavy production use. Thus TCB reduction is not enough to capture the value of the verification effort, and so we also need to quantify the reduction in the bug probability (PB).</p><p> 值得强调的是，TCB中的“减少”不一定是可量化的减少，例如，它通常不能单独通过SLOC（代码源线）来衡量。对于证明的某些组件，例如规范，通过SLOC量化TCB减少是有意义的。但对于其他组件，如公理，证明规则和证明跳棋，我们不依靠SLOC减少，但这样的事实，这些都是已经经过大量测试，而且往往重生产中使用的基础设施组件。因此，TCB减少不足以捕获验证工作的价值，因此我们还需要量化错误概率（PB）的减少。</p><p> Further, even if any of these infrastructural verification components have a corner-case bug, it is very unlikely that the bug manifests itself in a way that it causes an incorrect proof to go through. For example, it is much more likely for my  strlen implementation to have a memory error, than the possibility of a  memory error in the proof checker that causes the verification of  strlen to incorrectly succeed. At worst, a corner-case bug in the verification tools would cause the verification process to end abruptly, not cause a wrong proof to go through (with a very high probability).</p><p> 此外，即使这些基础架构验证组件中的任何一个都有一个角落案例错误，该错误也不太可能以它导致错误的证据方式表现出来。例如，我的STRLEN实现更有可能具有内存错误，而不是证明检查器中的内存错误的可能性，导致strlen验证到错误地成功。在最糟糕的是，验证工具中的一个角落案例错误会导致验证过程突然结束，不会导致错误的证据（具有很高的概率）。</p><p>  In practice, formal verification is very useful because it is able to catch several corner-case bugs. For  mission-critical applications, such as those found in defence, aerospace, and automobile sectors, the formal verification of software reduces the probability of errors by orders of magnitude and  prevents catastrophes (e.g.,  Boeing).</p><p>  在实践中，正式验证非常有用，因为它能够捕获几个角色案例错误。对于任务关键的应用，例如防御，航空航天和汽车领域的关键应用，软件的正式验证通过数量级来降低误差的可能性，并防止灾难（例如，波音）。 </p><p> The speed at which implementations evolve is significantly faster than the pace at which the verification infrastructure needs to be modified/adapted — and so the  presence of a verification harness provides the much needed confidence-of-correctness even in the presence of continuous code modifications. Such verification infrastructure allows organizations to  save testing/QA costs.</p><p>实现的速度发展比验证基础设施需要修改/调整的步伐更快 - 因此即使在连续代码修改的情况下也提供了验证线束的存在提供了众多所需的正确性。此类验证基础架构允许组织节省测试/ QA成本。</p><p> Security properties are usually better suited for verification than testing. Researchers have found serious bugs in rigorously tested compilers and libraries — most such  corner-case bugs are very difficult to catch through testing and much easier to catch through verification tools. If you look through our  bugs-found page for examples of bugs found by our verification tool, you will find that the most common bugs involve corner cases like pointer aliasing, buffer/integer overflows, overflows during type-conversions, etc. Verification tools have unique advantages over traditional testing methods in identifying such hidden errors and security loopholes.</p><p> 安全性属性通常更适合验证而不是测试。研究人员在严格测试的编译器和库中发现了严重的错误 - 大多数此类角色案例错误很难通过测试，并且更容易通过验证工具捕获。如果您通过我们的验证工具找到的错误示例查看了错误的页面，您会发现最常见的错误涉及像指针别名，缓冲区/整数溢出等角色函数，在类型转换期间溢出等等。验证工具具有在识别此类隐藏错误和安全漏洞的传统测试方法方面具有独特的优势。</p><p> Machine-readable proofs serve as executable documents and help an engineering team in the development and maintenance of their software over time.</p><p> 机器可读证明用作可执行文件，并帮助工程团队随着时间的推移在开发和维护其软件方面。</p><p> It is my humble prediction that it is only a matter of time before verified software becomes the norm.</p><p> 我谦卑的预测是验证软件成为常态之前只是时间问题。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.compiler.ai/2021/05/06/verification-is-tcbpb-reduction/">https://blog.compiler.ai/2021/05/06/verification-is-tcbpb-reduction/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/tcb/">#tcb</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/证明/">#证明</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>