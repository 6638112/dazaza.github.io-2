<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我从TypeScript切换到ReScript I Switched from TypeScript to ReScript</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">I Switched from TypeScript to ReScript<br/>我从TypeScript切换到ReScript </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-20 20:30:42</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/33f3abed609ffe63aa7c1003f3979d47.jpeg"><img src="http://img2.diglog.com/img/2021/1/33f3abed609ffe63aa7c1003f3979d47.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This is not evangelism of ReScript or a one-to-one comparison with TypeScript. I love TypeScript. I decided to rewrite a small TypeScript+React+Jest side project into ReScript.</p><p>这不是ReScript的福音，也不是与TypeScript的一对一比较。我喜欢TypeScript。我决定将一个小的TypeScript + React + Jest辅助项目重写为ReScript。</p><p> ReScript is not new. In a way it’s as old as JavaScript itself. ReScript is a rebranding of ReasonML ( Facebook) and BuckleScript ( Bloomberg), which wrap  OCaml on both ends. The former is an interface of the OCaml syntax, while the latter makes sure to compile the AST into JavaScript. ReasonML was created by Jordan Walke, the creator of React.  ReasonML still exists as a parallel project to ReScript, with a slightly different syntax and mission.</p><p> ReScript不是新的。在某种程度上，它和JavaScript本身一样古老。 ReScript是ReasonML（Facebook）和BuckleScript（Bloomberg）的更名，它们的两端都包装了OCaml。前者是OCaml语法的接口，而后者则确保将AST编译为JavaScript。 ReasonML由React的创建者Jordan Walke创建。 ReasonML仍作为ReScript的并行项目存在，但语法和任务略有不同。</p><p>  ReScript is not just a rebranding: it’s a ReasonML which freed itself of the yoke of the OCaml ecosystem. By doing so, it forfeited compilation to native code and OCaml library interop, but gained a freer syntax which further resembles JavaScript to embrace its developers, eager for better tools.</p><p>  ReScript不仅是品牌重塑，它还是一个ReasonML，使自己摆脱了OCaml生态系统的束缚。这样，它就放弃了对本机代码和OCaml库互操作的编译，但是获得了一种更自由的语法，该语法进一步类似于JavaScript，以拥抱其开发人员，渴望使用更好的工具。</p><p>  My first attempt was to just install ReScript on my project, start the watcher, rename an easy file into  .res and be guided by the errors. I immediately learned that refactoring into ReScript is not “breadth-first” but “depth-first.” Simply renaming the file extension won’t work, as the compiler stops completely at type errors.</p><p>  我的第一次尝试是将ReScript安装在我的项目上，启动观察程序，将简单文件重命名为.res，并根据错误进行引导。我立即了解到，重构为ReScript不是“广度优先”，而是“深度优先”。简单地重命名文件扩展名将不起作用，因为编译器会在出现类型错误时完全停止。</p><p> In TypeScript one can gradually assign types and interfaces to dynamic types, while tagging some as  unknown or  any. Depth-first means that you start with one small function, or one small React component, and write it properly. If all the types are right — and with mathematical precision— your code will compile into JavaScript.</p><p> 在TypeScript中，可以将类型和接口逐渐分配给动态类型，同时将某些类型标记为未知或任意类型。深度优先意味着您从一个小功能或一个小React组件开始，并正确编写它。如果所有类型都是正确的-并且具有数学精度-您的代码将编译为JavaScript。</p><p> While TypeScript often transpiles into unreadable code, it’s good practice to keep an open tab on the auto-generated  js file from ReScript. You’ll be pleasantly surprised by the speed of transpilation, the conciseness and readability of the code, and the performance of such code. If the ReScript code compiled, it means its types are safe and sound, so it can optimize away all the noise.</p><p> 虽然TypeScript通常会转换为无法读取的代码，但最好的做法是在由ReScript自动生成的js文件上保留打开的标签。编译速度，代码的简洁性和可读性以及此类代码的性能都会给您带来惊喜。如果编译了ReScript代码，则表明其类型安全无害，因此可以消除所有噪音。</p><p> The only exception I saw to readability and performance of the generated JavaScript was in curried functions. All functions in ReScript are curried by default, and some of them generate code which imports a Currying library. This didn’t happen often, and currying can be disabled.</p><p> 我看到的关于生成的JavaScript的可读性和性能的唯一例外是咖喱函数。默认情况下，ReScript中的所有函数都是经过咖喱处理的，其中一些函数会生成导入Currying库的代码。这种情况并不经常发生，可以禁用currying。 </p><p> But what about TypeScript? Inter-operation with JavaScript code is trivial, but importing and exporting types from TypeScript (or Flow) can be more complex, and it creates two sources of truth: one for ReScript types and another for TypeScript.</p><p>但是TypeScript呢？与JavaScript代码的互操作是微不足道的，但是从TypeScript（或Flow）导入和导出类型可能更加复杂，并且它创建了两个事实来源：一个用于ReScript类型，另一个用于TypeScript。</p><p> GenType, described below, auto-generates a typed  tsx file from your ReScript code which you can import into other modules. This helped for exporting ReScript types, but it’s not possible to import TypeScript ones. The automation of type conversions  eased the problem of the two sources of truth.</p><p> 如下所述，GenType会从ReScript代码中自动生成类型化的tsx文件，您可以将其导入其他模块。这有助于导出ReScript类型，但无法导入TypeScript类型。类型转换的自动化缓解了两个事实来源的问题。</p><p> Furthermore, the generated ts code uses CommonJs  require syntax, which break when using native ECMAScript module support. I also had to tweak my  tsc to not transpile the auto-generated  tsx into a fourth (!) source file:</p><p> 此外，生成的ts代码使用CommonJs require语法，该语法在使用本机ECMAScript模块支持时会中断。我还必须调整tsc，以免将自动生成的tsx转换为第四个（！）源文件：</p><p> .gen.tsx auto-generated by GenType, which import the compiled JavaScript code and re-export it with proper types. Also add to your  .gitignore.</p><p> .gen.tsx由GenType自动生成，该文件将导入已编译的JavaScript代码，然后使用适当的类型将其重新导出。还要添加到您的.gitignore中。</p><p> I first rewrote my algorithms, since they didn’t have any third-party imports to inter-operate with, and the import syntax was daunting for me at first. Some teams go for a  data-first strategy, or a UI-first one (as Facebook did in 2017 for Messenger.com,  rewriting 50% of the codebase).</p><p> 我首先重新编写了算法，因为它们没有任何可相互操作的第三方导入，并且导入语法起初对我来说是艰巨的。一些团队追求数据优先策略或UI优先策略（就像Facebook在2017年为Messenger.com所做的那样，重写了50％的代码库）。</p><p>  ReScript is part of the  statically typed functional programming language family, which means it’s not compiling. Just kidding, it means it uses the Hindley-Milner type algorithm, which deduces types with 100% certainty and can prove it mathematically as long as your variables are immutable (and a few other language design choices). TypeScript on the other hand tries to do it’s best at finding a common type for all your usages.</p><p>  ReScript是静态类型的功能编程语言家族的一部分，这意味着它没有编译。只是开个玩笑，这意味着它使用Hindley-Milner类型算法，该算法以100％的确定性推导类型，并且只要您的变量是不变的（以及其他一些语言设计选择），就可以在数学上证明它。另一方面，TypeScript会尽力为所有用法找到通用类型。</p><p> This might blow your mind as a TypeScript user, but the following ReScript function is fully statically typed:</p><p> 作为TypeScript用户，这可能会让您大吃一惊，但是以下ReScript函数是完全静态键入的： </p><p>  ReScript knows with provable certainty that  a and  b are both  int and that the function returns an  int. This is because the  + operator only works on two  int and returns an  int . To concatenate two strings you’d use  ++ and for two floats use  +.. To combine two different types you need to convert either of them. Also, no semicolons.</p><p>ReScript可以肯定地知道a和b都是int，并且该函数返回int。这是因为+运算符仅对两个int起作用，并返回int。要连接两个字符串，请使用++，对于两个浮点数，请使用+.。要组合两种不同的类型，您需要将它们中的任何一个都转换。另外，没有分号。</p><p> If you’re like me and like to type your code as you prototype, you can do so as you’d expect:</p><p> 如果您像我一样，并且喜欢在原型制作过程中键入代码，则可以按照您的期望进行操作：</p><p>    Notice how I didn’t specify any module exports but the resulting code did. This shows how everything in the module/file is exported by default. The JavaScript function itself is not type safe, so importing it in a JavaScript module and using it there won’t have all the advantages of ReScript.</p><p>    请注意，我没有指定任何模块导出，但是结果代码却指定了。这显示了默认情况下如何导出模块/文件中的所有内容。 JavaScript函数本身并不安全，因此将其导入JavaScript模块中并在其中使用将不会具有ReScript的所有优点。</p><p>   To interoperate with TypeScript with proper type information you’ll use third-party  genType. Add it as a devDependency and annotate the module export you want to generate with  @genType (in previous versions you’d surround annotations with square brackets).</p><p>   要使用适当的类型信息与TypeScript进行互操作，您将使用第三方genType。将其添加为devDependency，并使用@genType注释要生成的模块导出（在以前的版本中，注释使用方括号括起来）。</p><p>  This will result in the following TypeScript. Notice how the generated TypeScript imports the generated JavaScript  MyModule.bs.js file:</p><p>  这将导致以下TypeScript。请注意，生成的TypeScript如何导入生成的JavaScript MyModule.bs.js文件：</p><p>  GenType generates a one-line re-export of your generated  .bs.js file, with proper TypeScript typing. From this example you’ll notice two more things:</p><p>  GenType使用正确的TypeScript类型生成生成的.bs.js文件的单行重新导出。在此示例中，您还会注意到两件事：</p><p>     There is only one type which does need a type declaration, which is the  record type. A type declaration will look like this and produces no JavaScript code:</p><p>     只有一种类型需要类型声明，即记录类型。类型声明将如下所示，并且不产生任何JavaScript代码： </p><p>  Types must begin with a lowercase! If we prepend it with  @genType, the generated TypeScript will look like this:</p><p>类型必须以小写开头！如果我们在其前面加上@genType，则生成的TypeScript将如下所示：</p><p>  If you’re wincing at the lower-cased type breaking all your conventions you can rename the type on conversion with  @genType.as(&#34;Student&#34;). This will add another line of code below the previous one:</p><p>  如果您想破坏所有约定的小写字母类型，可以在转换时使用@ genType.as（＆＃34; Student＆＃34;）重命名该类型。这将在上一个代码下面添加另一行代码：</p><p>  Also it includes a  tslint ignore line, which I hope they switch soon to  eslint as the former is deprecated.</p><p>  它还包括一条tslint忽略行，我希望他们在弃用前者后尽快切换到eslint。</p><p> These are record types, not ReScript  objects (don’t misuse the  string type on them). As soon you type something like  foo.age ReScript will know that  foo is of type  student. In case there’s another record with and  age field, it will infer it’s the last one declared. In that case you might want to explicitly annotate the type.</p><p> 这些是记录类型，而不是ReScript对象（请不要滥用它们上的字符串类型）。键入foo.age之类的内容后，ReScript就会知道foo是Student类型的。如果还有另一个“年龄”字段记录，它将推断它是最后声明的记录。在这种情况下，您可能需要显式注释类型。</p><p> In the case you don’t want that much ceremony, you can use the  object type and index it with a string:  student[&#34;age&#34;]; then you don’t need to declare a type.</p><p> 如果您不需要那么多的仪式，则可以使用对象类型并用字符串将其编入索引：student [＆＃34; age＆＃34;];那么您无需声明类型。</p><p> Furthermore you can use  student as a variable name, so  student.age is a valid expression, TypeScript would scream at something like this. Variables (that is, bindings) and Types live in a separate namespace, so a  student of type  student an be written as  student: student.</p><p> 此外，您可以使用Student作为变量名，因此student.age是有效的表达式，TypeScript会发出类似这样的消息。变量（即绑定）和类型位于单独的命名空间中，因此，将类型为Student的学生写为student：学生。</p><p>  Record types have “ nominal typing” similar to Java or C#, as opposed to TypeScript’s “ structural typing.” This is why interfaces are so important in TypeScript, and are used much more than Types. TypeScript doesn’t really care about “ what you are”, it cares about “ how you look.”</p><p>  记录类型具有类似于Java或C＃的“名义类型”，而不是TypeScript的“结构类型”。这就是为什么接口在TypeScript中如此重要，并且比Types使用更多的原因。 TypeScript并不真正在乎“您是什么”，而是在乎“您的外观”。 </p><p> For instance, if there’s another type, say,  teacher with the same fields of a  student, you cannot assign a  student to somewhere expecting a  teacher:</p><p>例如，如果存在另一种类型，例如与学生具有相同领域的老师，则无法将学生分配到需要老师的地方：</p><p> // defined first type  student = {  age: int,  name: string } // defined last type  teacher = {  age: int,  name: string } // t is a teacher let t = {  age: 35,  name: &#34;Ronen&#34; } let s:  student = t // Error!</p><p> //定义的第一个学生类型= {年龄：整数，名称：字符串} //定义的最后一个类型教师= {年龄：整数，名称：字符串} // t是一个老师，让t = {年龄：35，名称：＆＃ 34; Ronen＆＃34; } s：student = t //错误！</p><p>  We&#39;ve found a bug for you! //... This has type:  teacher Somewhere wanted:  student FAILED: cannot make progress due to previous errors. &gt;&gt;&gt;&gt; Finish compiling(exit: 1)</p><p>  我们为您找到了一个错误！ // ...类型：教师某个地方想要：学生失败：由于先前的错误，无法取得进展。 ＆gt;＆gt;＆gt;完成编译（退出：1）</p><p> Unlike TypeScript’s  tsc compiler,  bsb won’t begrudgingly continue its transpilation work into working JavaScript. It will stop with a non-zero exit code, and you have to fix the issue in order to make any progress.</p><p> 与TypeScript的tsc编译器不同，bsb不会轻易将其转译工作转换为可运行的JavaScript。它将以非零的退出代码停止，您必须修复该问题才能取得任何进展。</p><p>  One of the features I most like in modern TypeScript (or future JavaScript) are the optionals. They make working with nullable types easy and concise:</p><p>  我最喜欢现代TypeScript（或将来的JavaScript）中的功能之一是可选功能。它们使使用空值类型的工作变得简单而简洁：</p><p>  something will be the content of  baz if it reached that far, or be  &#34;default&#34;.</p><p>  如果baz达到了那么远，它将是内容，或者是＆＃34; default＆＃34;。</p><p> There are no  null or  undefined in ReScript. But we can work with nullable values using the Variant  option. But how can we get the elegance of the above TypeScript code? I tried to answer this question but, we can’t, currently. Not enough sugar.</p><p> ReScript中没有null或undefined。但是我们可以使用Variant选项处理可为空的值。但是，如何才能获得上述TypeScript代码的优雅呢？我试图回答这个问题，但目前还不能。没有足够的糖。 </p><p> As with other functional languages, we can use a myriad of interesting library functions. Some of  Belt utility functions are:</p><p>与其他功能语言一样，我们可以使用许多有趣的库函数。 Belt实用程序的一些功能是：</p><p> Belt.Option.Map will execute a function on the optional value if it exists, or return  None.</p><p> Belt.Option.Map将在可选值（如果存在）上执行一个函数，或者返回None。</p><p>  let baz = switch foo {  | Some({ bar: Some({ baz: baz })}) =&gt; baz  | None =&gt; None }</p><p>  让baz =切换foo {| Some（{bar：Some（{baz：baz}）}）=＆gt; baz |无=＆gt;没有 }</p><p> There isn’t yet a sugared syntax for optionals; the optional operators are very new to TypeScript as well.</p><p> 可选语法尚不完善。可选运算符对于TypeScript也是非常新的。</p><p> The important quality of pattern matching is that the compiler will complain if there’s any case — doesn’t matter how deeply nested — you haven’t addressed. It’s best practice for most cases.</p><p> 模式匹配的重要素质在于，如果您没有解决任何问题，无论嵌套的深度如何，编译器都会抱怨。在大多数情况下，这是最佳做法。</p><p>      Previous versions used a triangle operator  |&gt;. The difference is in where to shove the data: as the first parameter, as the arrow does, or as the last parameter, as the deprecated triangle does.  More about this.</p><p>      以前的版本使用三角形运算符|＆gt;。区别在于将数据推送到何处：作为第一个参数（如箭头所示），或作为最后一个参数（如已弃用的三角形一样）。有关此的更多信息。</p><p> Notice that in the case of a one-parameter function we don’t write the  unit, that is  (). This is a common beginner’s mistake. In the case of multiple parameters, the value gets passed as the first one and the other parameters begin with the second one.</p><p> 注意，对于单参数函数，我们不写单位，即（）。这是一个常见的初学者的错误。在有多个参数的情况下，该值作为第一个参数传递，而其他参数以第二个参数开头。 </p><p> This is especially important in a functional language, since we lose some of the elegance of calling methods in objects.</p><p>这在函数式语言中尤其重要，因为我们失去了对象调用方法的某些优雅之处。</p><p>       As a newcomer I try to find a use for it anywhere I can, which can lead to the bad practice of rewriting code around it to impress my coworkers. To use it on JavaScript libraries you’ll have to  write the correct bindings for them. This is one thing I’d like to see in JavaScript.  Here are a few stage-1 proposals.</p><p>       作为一个新手，我会尝试在任何可能的地方找到它的用法，这可能会导致错误的做法，那就是围绕它重写代码以打动我的同事。要在JavaScript库上使用它，您必须为其编写正确的绑定。这是我想在JavaScript中看到的一件事。以下是第一阶段的一些建议。</p><p> By the way, if you’re not using  Fira Code then you’re missing out on a lot of the pipe’s aesthetics.</p><p> 顺便说一句，如果您不使用Fira Code，那么您会错过很多管道的美感。</p><p>  This was very frustrating for me. I love using modern  async and  await syntax in my code, which ReScript didn’t implement yet. I had to go back into thinking about  then and  resolve, which made simple code look complex.</p><p>  这让我非常沮丧。我喜欢在代码中使用现代的async和await语法，而ReScript尚未实现。我不得不重新考虑然后再解决，这使简单的代码看起来很复杂。</p><p>  const  getName = async (id: number): Promise&lt;string&gt; =&gt; {  const user = await  fetchUser(id);  return user.name; }</p><p>  const getName = async（id：number）：Promise＆lt; string＆gt; =＆gt; {const user = await fetchUser（id）;返回user.name; }</p><p>   Now consider  then to be a function in the  Js.Promises module instead of a method, which accepts  fetchUser(id) as its last parameter, and you can write it like this:</p><p>   现在，将其视为Js.Promises模块中的函数，而不是将fetchUser（id）作为其最后一个参数的方法，您可以这样编写它：</p><p>  Typed as  Js.Promise.t&lt;string&gt;, and with arrow pipe syntax for readability, the above function can be written as:</p><p>  键入为Js.Promise.t＆lt; string＆gt ;，并具有箭头管道语法以提高可读性，以上函数可以写为： </p><p>  The Promise library still uses the old convention of passing the data as the last argument, so in order to use the newer arrow pipe, an underscore has to be placed in the proper location.</p><p>Promise库仍然使用传递数据作为最后一个参数的旧约定，因此，为了使用较新的箭头管道，必须在适当的位置放置下划线。</p><p>  The ReScript team  promised (no pun intended) to implement a Promise API revamp with their own  async and  await.</p><p>  ReScript团队承诺（并非双关语）使用自己的异步和等待功能来实现Promise API改造。</p><p>  If you’re writing only in ReScript you don’t need to bother with imports or exports, and this is done under the hood. Every file is a module and everything in it is exported. If you only want specific things exported you do so with an interface file. To import JavaScript modules however, the syntax can get complicated.</p><p>  如果您仅使用ReScript编写，则无需理会导入或导出，这是在后台进行的。每个文件都是一个模块，其中的所有内容都将导出。如果只希望导出特定内容，则可以使用接口文件来导出。但是，要导入JavaScript模块，语法可能会变得复杂。</p><p>      For ReasonReact this became particularly tiresome, as I had to define inline modules for each React Component, and reexport the default export as the “make” function, paying attention to named parameters such as “children.” Here I imported the Container from  react-bootstrap and used it in ReasonReact:</p><p>      对于ReasonReact来说，这变得特别麻烦，因为我必须为每个React Component定义内联模块，然后将默认导出重新导出为“ make”函数，并注意诸如“ children”之类的命名参数。在这里，我从react-bootstrap导入了Container，并在ReasonReact中使用了它：</p><p> module Container = {  @bs.module(&#34;react-bootstrap/Container&#34;)  @react.component  external make: (~children: React.element) =&gt; React.element = &#34;default&#34; } @react.component let make = () =&gt; &lt;Container&gt; ...</p><p> 模块容器= {@ bs.module（＆＃34; react-bootstrap / Container＆＃34;）@ react.component外部make：（〜children：React.element）=＆gt; React.element =＆＃34;默认＆＃34; } @ react.component让make =（）=＆gt; ＆lt;容器＆gt; ...</p><p>   For this case I can get the bindings from  redex, and add it as a dependency both to my  package.json and my  bsconfig.json. I can then import it with  open ReactBootstrap at the top of my file. This is similar to  DefinitelyTyped, where you can find high-quality type definitions for TypeScript.</p><p>   对于这种情况，我可以从redex获取绑定，并将其作为依赖项添加到package.json和bsconfig.json中。然后，我可以使用文件顶部的打开ReactBootstrap导入它。这类似于DefinitelyTyped，在其中您可以找到TypeScript的高质量类型定义。</p><p> For this case however I ran into an error, as the package I needed was not updated to the latest version. I had to fork it and  manually update it to  react-jsx version 3.</p><p> 但是对于这种情况，我遇到了一个错误，因为我需要的软件包没有更新到最新版本。我不得不将其分叉并手动将其更新为react-jsx版本3。 </p><p>  You can’t import a type from TypeScript and use it in ReScript, you have to re-declare it. However, you can link the type you created to the original TypeScript one for correct inter-operation. Here’s an example with Node.js’  fs module:</p><p>您无法从TypeScript导入类型并在ReScript中使用它，必须重新声明它。但是，您可以将创建的类型链接到原始TypeScript，以实现正确的互操作。这是Node.js的fs模块的示例：</p><p>  Notice that I passed a  tuple to  import, not an argument list. This will link my type  dirent to  fs.Dirent, and will generate the following TypeScript:</p><p>  请注意，我传递了要导入的元组，而不是参数列表。这会将我的类型dirent链接到fs.Dirent，并将生成以下TypeScript：</p><p>  You can declare the entire type, in case you need to use its properties, or leave it as is.</p><p>  您可以声明整个类型，以防您需要使用其属性，也可以保持不变。</p><p> Because of the syntax overhead of TypeScript-ReScript inter-operation, I recommend doing it as little as possible, using each language in separate areas of your app.</p><p> 由于TypeScript-ReScript互操作的语法开销，我建议尽可能少地使用每种语言，在应用程序的不同区域中使用它。</p><p>   ReasonML (now ReScript) was created by Jordan Walke, the creator of React. Reason+React pushes the React philosophy further by utilizing the language syntax and features for ReactJS’s programming patterns.</p><p>   ReasonML（现为ReScript）由React的创建者Jordan Walke创建。 Reason + React通过利用ReactJS编程模式的语言语法和功能进一步推动了React理念。</p><p> ReasonReact provides smooth JS interop and uses built-in language features to integrate into UI framework patterns left unaddressed by ReactJS, such as routing and data management. Using them feels like “ just using Reason.”</p><p> ReasonReact提供流畅的JS互操作，并使用内置的语言功能集成到ReactJS未解决的UI框架模式中，例如路由和数据管理。使用它们的感觉就像“只使用理性”。</p><p>     If you want to use the old syntax, just change the file extension to  .re instead of  .res.</p><p>     如果要使用旧语法，只需将文件扩展名更改为.re而不是.res。 </p><p> ReasonReact is stricter than ReactJS, mainly in its use of types (e.g., strings need to be used with  React.string()in JSX. Other than this, the  React.useState returns a proper  tuple instead of an array, the way it was originally intended. Finally, React Components are rendered through a  make function, and prepended with  @react.component (I added  @genType as well for TypeScript generation):</p><p>ReasonReact比ReactJS更严格，主要是在类型的使用上（例如，字符串需要与JSX中的React.string（）一起使用。除此之外，React.useState返回一个正确的元组而不是数组，就像以前那样）最后，React Components通过make函数呈现，并以@ react.component开头（我也为TypeScript生成添加了@genType）：</p><p>      In case we don’t want GenType for TypeScript generation, we just import  Demo.bs instead.</p><p>      如果我们不希望GenType用于TypeScript生成，我们只需导入Demo.bs。</p><p>  In order to write tests in ReScript, and thus test your code directly, you can use  bs-jest, which provides ReScript bindings to Jest. If you prefer, you can also use the slightly less mature  bs-mocha. You can also test the generated JavaScript or TypeScript files with no extra configuration.</p><p>  为了用ReScript编写测试，从而直接测试代码，可以使用bs-jest，它提供了到Jest的ReScript绑定。如果您愿意，也可以使用稍微不太成熟的bs-mocha。您也可以在不进行额外配置的情况下测试生成的JavaScript或TypeScript文件。</p><p> Since ReScript is in the JavaScript ecosystem it makes little sense to create specialized testing tools for ReScript, and the direction seems to be in developing bindings for JavaScript testing tools.</p><p> 由于ReScript位于JavaScript生态系统中，因此为ReScript创建专门的测试工具几乎没有意义，其方向似乎是为JavaScript测试工具开发绑定。</p><p> With bs-jest, you have to name you can’t name your file  foo.spec.res, only with a valid module name, such as  foo_spec.res. Jest will run on the compiled folder, by default inside  lib/js. Also, assertions are not executed immediately, but instead returned by the function and run at the end of the suite. It’s a functional way to thing about tests. Consequently, you can only write one assertion per test, which is best practice anyway.</p><p> 使用bs-jest，您必须命名，而不能使用有效的模块名称（例如foo_spec.res）来命名文件foo.spec.res。 Jest将在默认情况下在lib / js中的已编译文件夹中运行。同样，断言不会立即执行，而是由函数返回并在套件末尾运行。这是测试的一种实用方式。因此，每个测试只能编写一个断言，这是最佳做法。</p><p>  ReScript devs did well on prioritizing the  plugin for VSCode, which works really well. With the ReScript’s watcher running, you’ll see your Type errors underlined in red, with a descriptive bubble on hover. You also get type hints, formatting, and jumps to definitions. There’s also official support for  Vim (both plain Vim and Coc Language Server) and  Sublime.</p><p>  ReScript开发人员在确定VSCode插件的优先级方面做得很好，效果很好。在运行ReScript的观察程序后，您会看到类型错误用红色下划线标出，并在悬停时带有描述性气泡。您还将获得类型提示，格式设置并跳转到定​​义。还对Vim（纯Vim和Coc语言服务器）和Sublime提供了官方支持。</p><p>   A few times in my coding career I had to work with small communities, and I always loved it. I developed smart-contracts in  Solidity, some database queries in the functional language  Q, and Roku channels in  BrightScript. You end up working with Slack/Discord/Gitter open and code together with the few others going through your similar problems. You don’t even bother checking StackOverflow for answers.</p><p>   在编码生涯中，有几次我不得不与小型社区合作，而我一直很喜欢它。我使用Solidity开发了智能合约，使用功能语言Q开发了一些数据库查询，并使用BrightScript开发了Roku通道。您最终会在Slack / Discord / Gitter打开的情况下工作，并与其他几个经历类似问题的人员一起进行编码。您甚至不必费心检查StackOverflow寻找答案。 </p><p> This forces you to read and reread the official documentation and examples, as you don’t want to look like dumb in the chatroom. Also, you’re part of a community maintained by real people, where you can always contribute something interesting, and even shape its development.</p><p>由于您不想在聊天室中显得笨拙，因此这迫使您阅读和重新阅读官方文档和示例。此外，您是一个由真正的人维护的社区的一部分，在这里，您总是可以贡献出一些有趣的东西，甚至可以决定它的发展。</p><p> Not all communities are alike, of course. I personally found the ReasonML/ReScript community to be welcoming. ReScript has an  official forum where you can communicate asynchronously and with a permanent paper record you can search. The core team consists of a  handful of developers with public Twitter accounts, and there’s an  official blog. I found however that the community hangs around in the  ReasonML’s Discord server, in an unofficial ReScript room.</p><p> 当然，并非所有社区都一样。我个人发现ReasonML / ReScript社区很受欢迎。 ReScript有一个官方论坛，您可以在其中进行异步通信，并可以搜索永久的纸质记录。核心团队由少数具有公开Twitter帐户的开发人员组成，并且有一个官方博客。但是，我发现社区在一个非正式的ReScript会议室中的ReasonML Discord服务器中闲逛。</p><p> Finally, there’s  ReasonTown, “a podcast about the ReasonML language and the community that makes it good,”  ReasonConf’s YouTube channel, and  Redex, to find bindings for your libraries.</p><p> 最后，ReasonConf的YouTube频道和Redex提供了ReasonTown，“有关ReasonML语言及其完善社区的播客”，以查找库的绑定。</p><p>  The switch is not easy; a refactor of an existing app is even more difficult given its fatal stop on the first issue. This will certainly hinder its adoption. Popular transpilers, such as TypeScript, SCSS, or CoffeeScript garnered adoption by its ease. Just copy-paste your code — or rename your file — and you’re done.</p><p>  切换并不容易。考虑到它在第一个问题上的致命威胁，对现有应用程序的重构甚至更加困难。这肯定会阻碍其采用。诸如TypeScript，SCSS或CoffeeScript之类的流行编译器很容易获得采用。只需复制粘贴代码（或重命名文件）即可，操作就完成了。</p><p> This is different. ReScript, as with other statically typed functional languages, aims at changing the way code is approached at a fundamental level. I believe we’ll see a greater adoption of functional programming in the future, eventually becoming the default for some industries. This is due to the mathematical approach to types, formal verification of a program’s correctness, and given immutability: less moving pieces and mental mapping.</p><p> 这是不同的。与其他静态类型的功能语言一样，ReScript旨在从根本上改变代码的处理方式。我相信将来我们会看到功能编程的更多采用，最终将成为某些行业的默认功能。这是由于对类型的数学方法，对程序正确性的形式验证以及给定的不变性：较少的移动部分和思维导图。</p><p> We’re already at the first stage of adopting a “functional style” in the ecosystem with  map,  filter,  reduce functions in JavaScript. ReScript represent the next — hybrid stage — of a properly functional language from the ML family which compiles to the industry’s standard JavaScript.</p><p> 我们已经处于在生态系统中采用“功能样式”以及通过JavaScript进行地图，过滤，归约功能的第一步。 ReScript代表了ML系列中一种功能正常的语言的下一个混合阶段，该语言已编译为行业标准的JavaScript。</p><p> Functional programming at its core takes itself seriously. It’s mathematical, formal, and doesn’t comply with hacks. It aspires to deals with truths, not processes. Writing a «functional style» in JavaScript only whets one’s appetite for more, as the language brings one’s good intentions down, not up. ReScript, while frustrating, might be the precision tool for a more civilized future in the ecosystem.</p><p> 函数式编程的核心是认真对待自己。这是数学上的，形式上的，并且不符合骇客行为。它渴望处理真理，而不是过程。用JavaScript编写“功能样式”只会激发人们的胃口，因为该语言会使人的良好意愿降低，而不是提高。 ReScript虽然令人沮丧，但它可能是生态系统中更加文明的未来的精确工具。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://medium.com/att-israel/how-i-switched-from-typescript-to-rescript-637aa5ef8d3">https://medium.com/att-israel/how-i-switched-from-typescript-to-rescript-637aa5ef8d3</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/切换/">#切换</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>