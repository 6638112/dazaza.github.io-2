<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>编程的小乐趣 The Small Pleasures of Programming</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Small Pleasures of Programming<br/>编程的小乐趣 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-15 14:36:42</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/e2c3ef9f2206b46549fe36b994c3c36a.png"><img src="http://img2.diglog.com/img/2020/12/e2c3ef9f2206b46549fe36b994c3c36a.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>One of the little secrets of computer programming is that it is actually quite a bit of fun. You discover little intellectual puzzles to wrestle with and solve on your way to building something bigger. And then instead of throwing away the puzzle solution like Saturday’s completed Sudoku, you get to tuck it into your app and keep it around in your bag of tricks.</p><p>计算机编程的小秘密之一是，它实际上很有趣。您会发现一些智力难题，难以解决，并在构建更大项目的途中得以解决。然后，您不必扔掉像星期六完成的Sudoku这样的难题解决方案，而可以将其塞入您的应用程序中，并随身携带各种技巧。</p><p>  The  app I am working   on, for a variety of reasons, occasionally needs to be able to take a census block ID — a 15 character string — and map it to the ID of the voting district that includes it — a 9–12 character string. The census department publishes this information and makes it freely available on their website. We imported this information and stored it in probably the simplest JSON/JavaScript representation you could imagine — just an object with block IDs as the keys and voting district ID as the values. The processing that needed to do the mapping would load the JSON file and then just use the object to do the mapping from key to value.</p><p>  由于各种原因，我正在开发的应用有时需要能够获取一个人口普查区ID（一个15字符串），并将其映射到包含它的投票区的ID（一个9-12字符串）。 。人口普查部门发布此信息，并在其网站上免费提供。我们导入了此信息，并将其存储在您可能想到的最简单的JSON / JavaScript表示中—只是一个以块ID为键，而投票区ID为值的对象。进行映射所需的处理将加载JSON文件，然后仅使用该对象进行从键到值的映射。</p><p> These files are stored by state, so to pick the worst case, Texas has almost one million census blocks and this structure is almost 30 megabytes when stored on disk. In memory it expands to 50 MB. JSON (JavaScript Object Notation — a way to take a JavaScript object and pass it as a string or store it in a file) can be pretty wordy so sometimes it can get smaller when imported but in this case the file is mostly just strings so actually expands once it is parsed and stored into memory.</p><p> 这些文件是按州存储的，因此，最糟糕的情况是，德克萨斯州拥有将近一百万个人口普查块，当存储在磁盘上时，这种结构将近30兆字节。在内存中，它可以扩展到50 MB。 JSON（JavaScript对象表示法-一种获取JavaScript对象并将其作为字符串传递或存储在文件中的方法）可能非常罗word，因此有时在导入时它会变小，但在这种情况下，文件大多只是字符串，因此实际上解析并存储到内存后会扩展。</p><p> The processing that required this mapping ability previously had to load a number of even bigger files, so despite its girth, it wasn’t quite on the list of top issues. But as is common, some other changes and improvements suddenly made the download and processing costs associated with this mapping table something we cared about.</p><p> 以前，需要这种映射功能的处理过程必须加载许多甚至更大的文件，因此尽管有很多问题，但它并不是最重要的问题。但是通常，其他一些更改和改进突然使我们关心的与此映射表相关的下载和处理成本。</p><p> Now again looking at Texas, that 30 MB JSON file was actually only 4 MB when compressed which is how it was stored and transmitted. Compression is a good quick way to get some intuition about what the “real” information content of some block of data is. The compressed form might not be in the best form for processing, but it does give you a sense of how much redundancy there is in the data. In this case, there is a  ton of redundancy. That redundancy is pretty obvious when you think about the content. Each voting district is made up of about 65 census blocks, so each value (the 9 to 12 character voting district ID) is repeated on average 65 times. The block IDs are actually in a very structured form where the first 2 characters are the state ID (so are the same for all values in a file organized by state), the next 3 characters are county ID, then census tract, census block group and then finally the individual block number.</p><p> 现在再来看一下Texas，那个30 MB的JSON文件在压缩时实际上只有4 MB，这就是它的存储和传输方式。压缩是一种快速直观的方法，可让您直观了解某些数据块的“实际”信息内容。压缩形式可能不是最佳处理形式，但是它确实使您了解数据中有多少冗余。在这种情况下，会有大量的冗余。考虑内容时，这种冗余非常明显。每个投票区大约由65个人口普查区组成，因此每个值（9到12个字符的投票区ID）平均重复65次。区块ID实际上采用结构化的形式，其中前2个字符是州ID（对于按州组织的文件中的所有值来说都是相同的），接下来的3个字符是县ID，然后是人口普查区，人口普查区块组最后是单个块号。</p><p> Given all this redundancy, it seemed likely to me that we could come up with a much denser data structure that could be stored, transmitted, loaded and used directly in this dense representation without having to blow it up in memory. I’ve recently become a fan in my JavaScript programming when needing to speed something up or reduce memory usage (often the same thing) of identifying where the naïve JavaScript data representation is unnecessarily bloated and instead using a compact binary representation. Maybe it’s my C/C++ roots.</p><p> 考虑到所有这些冗余，在我看来，我们可能想出了一个更密集的数据结构，可以在这种密集表示形式中直接存储，传输，加载和使用它，而不必将其消耗在内存中。最近，我需要提高速度或减少内存使用量（通常是同一件事），从而确定不必要的JavaScript数据表示形式在哪里膨胀，而改为使用紧凑的二进制表示形式，因此成为我的JavaScript编程迷。也许是我的C / C ++根源。</p><p> In this case, I had two areas to focus on: how to store the values and how to store the keys. Since I knew the values were duplicated on average 65 times, a trivial solution would be just to keep a copy of all unique strings and store a reference to the unique string rather than the literal string (compilers and languages often do this automatically internally for some parts of your program). I thought I could do a little better since the values also have a ton of internal redundancy — many values share the same first part and then many values have the same last few distinguishing characters. A simple solution was just to break the strings into two pieces (dynamically) and find the splits that minimized the string storage. This is essentially an approximation of what a general compression algorithm does (find common shared sequences and then reference them compactly).</p><p> 在这种情况下，我要重点关注两个方面：如何存储值和如何存储键。因为我知道这些值平均重复了65次，所以一个简单的解决方案是保留所有唯一字符串的副本，并存储对唯一字符串的引用，而不是文字字符串（编译器和语言通常会在内部自动对某些字符串进行复制）程序的一部分）。我认为我可以做得更好，因为这些值还具有大量的内部冗余-许多值共享相同的第一部分，然后许多值具有相同的后几个区别字符。一个简单的解决方案是（动态地）将字符串分成两部分，并找到将字符串存储量最小化的拆分。这本质上是通用压缩算法所做的近似（查找公用共享序列，然后紧凑地引用它们）。 </p><p> For the keys, when you have a large amount of redundancy in your key space, a  trie is a good choice. Coding this up was mostly about designing how to pack it into a single block of data, using offsets from the start of the buffer rather than pointers to walk through the data structure. As is typical when you start playing around with memory in tricky ways, this took a bit of testing and debugging to get working.</p><p>对于密钥，当密钥空间中有大量冗余时，trie是一个不错的选择。编写代码主要是关于设计如何将其打包为单个数据块，使用从缓冲区开始的偏移量而不是指针来遍历数据结构。通常，当您开始以棘手的方式使用内存时，需要进行一些测试和调试才能开始工作。</p><p> I was pretty happy with the final results. That Texas file ended up as a compact buffer of 2.7 MB that could be directly loaded into memory as a single block and used without further transformation. It compressed to less than 1 MB for storage and transmission (which argued that there was even more room for improvement in my solution). But I already had a 20X improvement in memory use and significant improvements in storage and transmission so I stopped there.</p><p> 我对最终结果感到非常满意。该得克萨斯文件最终以2.7 MB的紧凑型缓冲区结尾，可以直接作为单个块加载到内存中，而无需进一步转换即可使用。用于存储和传输的压缩到不到1 MB（这表明我的解决方案还有更大的改进空间）。但是我在内存使用方面已经有了20倍的改进，在存储和传输方面也有了显着的改进，所以我就此止步。</p><p> This was a fun little problem. It was well-isolated and easily described so I didn’t have to spend a ton of time on gnarly integration and complex testing and deployment issues. I was able to use intuitions from a lifetime of programming and also required some careful bit fiddling to get right. And then it actually worked and solved the problem.</p><p> 这是一个有趣的小问题。它被很好地隔离并且易于描述，因此我不必花大量时间在陈旧的集成以及复杂的测试和部署问题上。我能够使用一生编程中的直觉，并且还需要一些谨慎的摆弄才能正确。然后它实际上起作用并解决了问题。</p><p> I will say that the general problem of “compact dictionaries” (which this was a special case of) is such a well-studied problem that I felt a little guilty writing something from scratch. Surely there was something I could grab off the shelf? A search didn’t find anything so I had the advantage of being retired; I could suppress the guilt and just have fun solving the problem.</p><p> 我要说的是，“紧凑型字典”的一般问题（这是特例）是一个经过充分研究的问题，我从头开始写东西有点内lt。当然有什么我可以抢购的东西吗？搜索没有找到任何东西，所以我有退休的优势。我可以抑制内感，并乐于解决问题。</p><p> My second example is a little different. In this case, it was the fun of learning something new and then putting it to effective use.</p><p> 我的第二个示例有些不同。在这种情况下，有趣的是学习新知识然后将其有效利用。</p><p> I was trying to solve a trio of problems that turned out to be related in a surprising way. The core of our app loads and displays voting district shapes. Voting districts are created from the underlying census block shapes. The memory required to store and process these shapes ends up having a big influence on our overall performance.</p><p> 我试图解决三个问题，但结果却令人惊讶。我们应用程序的核心加载并显示投票区形状。投票区是根据基本的人口普查区形状创建的。存储和处理这些形状所需的内存最终会对我们的整体性能产生重大影响。</p><p> The most basic way of improving performance is to take the high resolution shapes provided by the census department and simplify them by removing points. This helps everywhere (in memory use and in every stage of processing) so is the obvious thing to focus on. The extra points either make no visual difference when displayed on a computer screen or make no effective difference because they don’t change how the user interacts with the application. The underlying census shapes need to distinguish whether a single house is in one census block or another, but for our purposes an approximation of that works just fine since none of our other data (census and elections) is available at that resolution.</p><p> 提高性能的最基本方法是采用人口普查部门提供的高分辨率形状，并通过删除点来简化形状。这对任何地方（在内存使用和处理的每个阶段）都有帮助，因此显而易见的是重点。这些额外的点在计算机屏幕上显示时不会产生视觉差异，也不会产生有效的改变，因为它们不会改变用户与应用程序的交互方式。基本的人口普查形状需要区分一所房子是在一个人口普查区中还是在另一个人口普查区中，但是出于我们的目的，由于在该分辨率下没有其他数据（人口普查和选举），因此近似估算效果很好。 </p><p>  The second problem is how to combine a set of shapes into a single shape or more generally “polygon union”. The core place we had this problem is taking a set of voting district shapes and combining them into a single congressional (or state legislative) shape. Polygon union is a well-studied problem in computer graphics, but the general solution is both memory and processing intensive and when we integrated an open-source solution into our app, it was a significant load on the interactive performance of the application. I had to build a complex asynchronous work-slicing mechanism on top of it to prevent it from locking up our app for seconds at a time.</p><p>第二个问题是如何将一组形状组合成单个形状，或更笼统地说是“多边形并集”。我们遇到这个问题的核心地方是采用一组投票区形状，并将它们组合成一个国会（或州立法）形状。多边形联合是计算机图形学中一个经过充分研究的问题，但是一般的解决方案既占用内存，又需要大量处理，并且当我们将开源解决方案集成到我们的应用程序中时，这对应用程序的交互性能造成了很大的负担。我必须在它之上构建一个复杂的异步工作切片机制，以防止它一次锁定我们的应用几秒钟。</p><p> The third problem was how to determine if two shapes are contiguous. This is core to how we analyze a redistricting plan. In our application, this happens “offline” to produce a contiguity graph. It did not need to be especially fast but had originally been solved with a set of tools that were separated from our core tool set so we had motivation to try to unify this.</p><p> 第三个问题是如何确定两个形状是否连续。这是我们分析重新划分计划的核心。在我们的应用程序中，这发生在“脱机”状态以产生连续性图。它并不需要特别快，但是最初是通过与我们的核心工具集分离的一组工具解决的，因此我们有动力尝试统一这一工具。</p><p> There are a lot of simplification algorithms to choose from, but the additional challenge in our case is we have a set of shapes that we are drawing together on a surface. The shapes cover the surface and when you simplify, you can run into two related issues if you make different simplification decisions for two shapes that lie next to each other. Making different decisions happens easily because one shape may have a single continuous line while there might be multiple shapes on the other side that border that line. Maintaining the integrity of those smaller shapes means keeping more points, while the larger shape can simplify and remove those points. When you make different simplification decisions, you end up either leaving holes in the map when you draw adjacent shapes, or you have overlapping shapes and this causes visual anomalies when you fill shapes with partial opacity (because the overlapping areas are drawn twice and appear darker).</p><p> 有很多简化算法可供选择，但是在我们的案例中，另一个挑战是我们要在表面上绘制一组形状。这些形状覆盖表面，并且在简化时，如果对彼此相邻的两个形状做出不同的简化决策，则会遇到两个相关问题。容易做出不同的决策，因为一个形状可能只有一条连续线，而另一边可能有多个形状接壤该线。保持那些较小形状的完整性意味着保留更多的点，而较大形状可以简化和删除这些点。当您做出不同的简化决策时，最终可能会在绘制相邻形状时在地图上留下孔，或者形状重叠，这会在您用部分不透明度填充形状时导致视觉异常（因为重叠区域被绘制了两次并显得更暗） ）。</p><p> The gaps also cause problems when you want to combine shapes (the polygon union problem I mentioned above) because you end up generating shapes with lots of little anomalous holes that aren’t actually in the real data. These both make the processing more expensive as well as introducing visual and analytic anomalies.</p><p> 当您要组合形状时，间隙也会引起问题（我在上面提到了多边形并集问题），因为最终生成的形状带有很多小的异常孔，这些孔实际上不在实际数据中。这些都使处理更加昂贵，并且引入了视觉和分析异常。</p><p> In researching this, I came across the  TopoJSON libraries written by  Mike Bostock. Mike is quite well-known in the visualization community, formerly doing innovative work at the New York Times and the co-author of an important open-source visualization library,  d3.js. Investigating this is where I got to learn something new.</p><p> 在研究中，我遇到了Mike Bostock编写的TopoJSON库。 Mike在可视化社区中非常有名，他以前在《纽约时报》从事创新工作，并且是重要的开源可视化库d3.js的合著者。调查这是我必须学习新知识的地方。</p><p> The TopoJSON libraries take a different approach to the problems I was facing. The core insight is that when you have a set of shapes like the outlines of the US states or the voting districts of a state, these shapes actually have the important characteristic of dividing up the surface — they don’t overlap and they fully cover the part of the surface you care about. You really have a  topology (hence the package’s name) and the polygons share the line segments or  arcs of this topology.</p><p> TopoJSON库对我面临的问题采取了不同的方法。核心见解是，当您拥有一组形状（例如美国各州的轮廓或一个州的投票区）时，这些形状实际上具有划分表面的重要特征-它们不会重叠，并且可以完全覆盖表面您关心的部分表面。您确实有一个拓扑（因此具有包装名称），并且多边形共享此拓扑的线段或弧线。</p><p> The core insight is that instead of thinking of your data as a set of shapes, you really have this set of topological arcs that divide up your surface. This ends up being key to the processing that follows. This is so cool!</p><p> 核心见解是，您实际上没有将这组拓扑圆弧划分为表面，而不是将数据视为一组形状。这最终成为后续处理的关键。太酷了！ </p><p> This pattern of breakthrough recurs often. You have some general problem that is “theoretically hard” but by identifying a key insight you can solve a different, simpler problem in a way that cuts through the complexity with much better performance.</p><p>这种突破的模式经常发生。您有一些“理论上很难”解决的一般问题，但是通过确定关键的见解，您可以通过降低复杂性和更好的性能的方式来解决另一个更简单的问题。</p><p> The first stage of processing is to take your polygons and split them into arcs broken at the points where the polygons intersect. Then you eliminate duplicate arcs by identifying all polygons that share an arc and have them reference the same arc.</p><p> 处理的第一步是获取多边形并将其分割为在多边形相交的点处断开的弧。然后，通过标识共享弧并让它们引用相同弧的所有多边形来消除重复弧。</p><p> With this representation — each polygon is described as a set drawn from a shared collection of arcs — the key challenges I described above become straightforward.</p><p> 通过这种表示方式-每个多边形被描述为从共享的弧形集合中绘制的集合-我上面描述的关键挑战变得简单明了。</p><p> Now when you simplify, you simplify at the granularity of these shared arcs. This automatically guarantees that two polygons that share an edge make the same simplification decisions on both sides of the edge. That edge is specified by the shared simplified arc.</p><p> 现在，当您简化时，就可以简化这些共享弧的粒度。这将自动保证共享一条边的两个多边形在边的两边都做出相同的简化决策。该边由共享的简化弧指定。</p><p> The union problem becomes even easier. Given a collection of polygons described as a set of arcs, you simply remove any arcs that are referenced by more than one polygon. The arcs that remain describe the boundary of the merged shape (there are a few subtleties to deal with disjoint shapes and holes when reconstructing the final shape).</p><p> 工会问题变得更加容易。给定一组描述为一组弧的多边形，您只需删除由多个多边形引用的所有弧。剩下的弧形描述了合并形状的边界（在重建最终形状时，存在一些细微之处，可以处理不相交的形状和孔）。</p><p> The contiguity problem is also trivial in this representation — two shapes are contiguous if they share an arc.</p><p> 连续性问题在这个表示中也很简单-如果两个形状共享一条弧，则它们是连续的。</p><p> The other thing I found remarkable was that all this functionality (and other features I’ve skipped over) was implemented in a few hundred lines of code. A very neat piece of work. I’m more familiar with codebases like Microsoft Office where you might have 100’s of thousands of lines of code just dealing with copy/paste (which to be fair, really is a semantically complex problem — let me tell you about copy and paste in HTML tables some time).</p><p> 我发现与众不同的另一件事是，所有这些功能（以及我已跳过的其他功能）都是在几百行代码中实现的。一件非常整齐的工作。我更熟悉Microsoft Office这样的代码库，在其中您可能只有100几千行代码来处理复制/粘贴（公平地说，这确实是一个语义复杂的问题-让我告诉您有关HTML复制和粘贴的信息表一段时间）。 </p><p> I got a chance to dive deeper into this bit of code because things didn’t quite “just work”. I personally find it difficult to read and understand a piece of code if I am not digging in to try to fix a bug or extend it in some way. I just don’t have the persistence to give it the attention it requires if I’m not trying to achieve some explicit goal.</p><p>我有机会更深入地研究这段代码，因为事情并非完全“可行”。我个人发现，如果我不去尝试修复错误或以某种方式扩展它，则很难阅读和理解一段代码。如果我不尝试实现一些明确的目标，我只是没有足够的毅力去给予它所需的关注。</p><p> In this case, there were a few issues that needed to be addressed before we could make use of it in our app so I got a much deeper appreciation for the work as well as the additional satisfaction of solving the problems I encountered along the way.</p><p> 在这种情况下，我们需要先解决一些问题，然后才能在应用程序中使用它，因此我对工作非常满意，并且对解决我在此过程中遇到的问题也感到更加满意。</p><p> The challenges with simplification were basically the converse of simplifying at the granularity of polygons. The same simplification decision is made for two polygons that share an edge, but inconsistent decisions could be made for separate edges of the  same polygon. The result would be a polygon that crosses over on itself. This typically only happened for narrow twisting shapes, for example a census block that had been drawn to cover the path of a river or stream. Unfortunately, the result of these self-crossing polygons was exactly the sort of visual and processing anomalies I was trying to avoid in the first place!</p><p> 简化的挑战基本上是在多边形的粒度上进行简化的相反过程。对于共享一条边的两个多边形，可以做出相同的简化决策，但是对于同一多边形的不同边，可以做出不一致的决策。结果将是一个交叉的多边形。这通常仅发生在狭窄的扭曲形状上，例如绘制为覆盖河流或溪流路径的人口普查区。不幸的是，这些自相交多边形的结果恰好是我最初要避免的视觉和处理异常！</p><p> This gave me an opportunity to dive deeper into how simplification worked inside TopoJSON. The library treats simplification as a two step process. The first step is a configurable process that computes a  weight for each point, most commonly by computing the area of a triangle formed by that point with its adjacent points. You can think of the area of that triangle as measuring the importance of that point in showing the true path of the line. The second stage is to specify some weight limit and remove points that fall below it (but always keeping the key points that mark the points of polygon intersection).</p><p> 这使我有机会更深入地研究TopoJSON内的简化工作。该库将简化视为两个步骤。第一步是可配置的过程，该过程可计算每个点的权重，最常见的方法是计算该点及其相邻点形成的三角形的面积。您可以将三角形的面积视为衡量该点在显示线的真实路径时的重要性。第二阶段是指定一些权重限制并删除落在该权重限制以下的点（但始终保留标记多边形相交点的关键点）。</p><p> The approach I took was an iterative one. I knew that if I kept  all the points, I clearly would have a set of well-formed shapes. So, I would run the simplification process, identify the mal-formed shapes and step-wise artificially increase the “weight” of the points along the arcs that were referenced by those degenerate polygons. This was both possible and reasonably efficient because the weights were explicitly exposed as an output of the first stage of the simplification process. At the start, I wasn’t certain this would result in sufficient simplification, but in practice it ended up working very well. The fact that the library had exposed this intermediate stage rather than treating the whole process as a black box made this reasonably straight-forward.</p><p> 我采用的方法是一种迭代方法。我知道，如果我保留所有要点，显然我将拥有一组格式良好的形状。因此，我将进行简化过程，确定格式不正确的形状，并逐步人工增加这些退化多边形所引用的圆弧上的点的“权重”。这既可行又合理有效，因为权重被明确公开为简化过程第一阶段的输出。起初，我不确定这是否会带来足够的简化，但实际上，最终效果很好。图书馆暴露了这个中间阶段，而不是将整个过程视为一个黑匣子，这一事实使得这一点很简单。</p><p> The development process had a few twist and turns. I would process tens of millions of shapes covering the US and a few hundred would end up giving me trouble. What was it about these shapes? So I would journey to a spot along the Boston Harbor where a mostly rectangular shape had a long thin finger covering a wharf. Or a set of shapes in Colorado carefully drawn by a geographer to cover a narrow winding stream. To Minnesota, which uses far more shapes than you might expect, carefully drawn around all its bodies of water. Land of ten thousand lakes. I got to pursue a general bug with the TopoJSON merge algorithm when dealing with polygons with self-touching holes (think of a figure eight). Why does it only happen a few dozen times in the whole US? And then I see a set of holes — a string of pearls — carefully drawn around a line of islands in the middle of a river.</p><p> 开发过程有些曲折。我要加工成千上万种覆盖美国的形状，最后有数百种会给我带来麻烦。这些形状是什么？因此，我将沿着波士顿港到达一个地点，那里是一个大体矩形的手指，细长的手指遮住了码头。或由地理学家精心绘制的科罗拉多州的一组形状，以覆盖狭窄的蜿蜒溪流。对于明尼苏达州，该州使用的形状远远超出您的预期，并在其所有水域上仔细绘制。万湖之乡。在处理具有自触孔的多边形时（请参见图八），我必须使用TopoJSON合并算法来解决一般错误。为什么在整个美国只发生几十次？然后，我看到一组孔-一串珍珠-小心地在河中央的一系列岛屿周围绘制。</p><p> The second problem was that the representation TopoJSON used for points and line sequences was consistent with other JavaScript packages and formats for geographical processing (essentially a point was represented by a two element array and a line sequence was represented as an array of points) but was horribly memory inefficient. A C programmer thinks of an array as perhaps the simplest and most compact of data structures, but JavaScript treats arrays as a special form of a general object or hash table, just with special string keys of the form “0”, “1”, etc. The upshot is that the simple point / line sequence representation used a ton of memory and actually dominated our memory usage. This was true despite the fact that TopoJSON starts off with a big win of almost 50% over formats organized by polygon by only encoding the points on a shared edge once.</p><p> 第二个问题是用于点和线序列的TopoJSON表示与用于地理处理的其他JavaScript包和格式一致（本质上，一个点由两个元素数组表示，而一个线序列表示为点数组），但是可怕的内存效率低下。 AC程序员认为数组可能是最简单，最紧凑的数据结构，但是JavaScript会将数组视为通用对象或哈希表的一种特殊形式，只是使用特殊字符串键，其形式为“ 0”，“ 1”等结果是，简单的点/线序列表示使用了大量的内存，实际上占据了我们的内存使用量。尽管事实如此，尽管TopoJSON仅通过一次在共享边上编码点，就比多边形组织的格式赢得了将近50％的巨大胜利，这是事实。 </p><p> I had previously come up with a packed representation that essentially stored all the points for a complex set of shapes in one binary buffer that gave me two orders of magnitude improvement in memory usage (I love JavaScript but it was just shocking to me how bad the naïve representation was). I was looking to see if I could apply the same improvement to the TopoJSON package.</p><p>我以前曾想过一个压缩的表示形式，该表示形式实际上将一组复杂形状的所有点存储在一个二进制缓冲区中，这使我的内存使用率提高了两个数量级（我喜欢JavaScript，但这让我震惊了，天真的代表是）。我一直在寻找是否可以对TopoJSON包应用相同的改进。</p><p> Here was where the small overall size of the package (in lines of code) as well as its clean design really helped. I was able to integrate the packed format with just a few dozen additional lines of code (and the existing code needed to only change in a couple places). Even better, the core processing I needed to do using the TopoJSON library, merge, could be done directly from the packed representation. The previous approach had kept the polygons packed but had needed to unpack the coordinates in order to pass them through to the library we were using for polygon union.</p><p> 这是小巧的包装（按代码行）的总体尺寸以及其简洁的设计所起到的作用。我能够将打包格式与另外几十行代码集成在一起（而现有代码只需在几个地方进行更改）。甚至更好的是，我需要使用TopoJSON库进行的核心处理，合并可以直接从打包表示形式进行。先前的方法保留了多边形的包装，但是需要解开坐标才能将其传递到我们用于多边形联合的库中。</p><p> When finally integrated, the completed work reduced our apps memory usage by 100’s of megabytes and essentially eliminated as an issue the most compute and memory intensive part of our interactive application. And along the way I got to learn about an interesting technology and explore some of the oddities of US geography. What fun!</p><p> 最终集成完成后，完成的工作将我们的应用程序的内存使用量减少了100兆字节，并且从根本上消除了交互式应用程序中计算和内存密集度最高的问题。在此过程中，我学习了一种有趣的技术，并探索了美国地理的一些奇特之处。真有趣！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://medium.com/@terrycrowley/small-pleasures-of-programming-ae4f50dde67a">https://medium.com/@terrycrowley/small-pleasures-of-programming-ae4f50dde67a</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pleasures/">#pleasures</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/形状/">#形状</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>