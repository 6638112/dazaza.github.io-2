<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Libdispatch出了什么问题What Went Wrong with the Libdispatch</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">What Went Wrong with the Libdispatch<br/>Libdispatch出了什么问题</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-24 06:56:48</div><div class="page_narrow text-break page_content"><p>Back in the mid 2000s processors performance started to plateau and chip makers like Intel told the world that the time of ever increasing the CPU clock speed was not going to be enough. They would not be able to meet Moore&#39;s law that way anymore but they had another way: to pack more cores onto the same chip. There was a catch of course, developers would need to update their software if they wanted to be able to take advantage of these many cores. Back then some believed that in 10 years time consumer machines with 80 cores (or even more) would be common. Fast-forward to today&#39;s 2020 and most consumer machines have about 4 cores and pro machines have about 8 to 12 cores. Something must have gone wrong along the way. Spoiler: multithreading is hard.</p><p>早在2000年代中期，处理器性能就开始达到平稳状态，像英特尔这样的芯片制造商告诉世界，不断提高CPU时钟速度的时间还不够。他们将无法再以这种方式满足摩尔定律，但他们有另一种方式：将更多的内核封装到同一芯片上。当然有很多问题，如果开发人员希望能够利用这些许多内核，就需要更新其软件。当时有人认为，具有80核（甚至更多核）的消费类计算机将在10年内普及。快进到今天的2020年，大多数消费类计算机具有约4个内核，而专业计算机具有约8至12个内核。在此过程中一定出了点问题。剧透：多线程很难。</p><p>  Apple responded in 2008 with the announcement of Mac OS X 10.6 Snow Leopard (considered by some to be the best Mac OS version ever released) which included the libdispatch (a.k.a. Grand Central Dispatch). I was there at WWDC 2008 when it was announced and we were all ecstatic, it was probably the most exciting WWDC I&#39;ve attended (I would attend 5 other times after that). The libdispatch and the new inline block syntax were nothing short of amazing and offered the promise to finally easily access the power of multicore machines. Multicore machines have been available for a long time before that (dual processors really) but it was mainly used by pro apps such as Photoshop. In the 2000-2008 era, developers would generally only start multithreading their app when they had to, for example because a piece of work was long-running and would block the user-events run loop of the app for too long (causing the infamous spinning beach ball to appear).</p><p>  苹果公司在2008年做出了回应，宣布推出Mac OS X 10.6 Snow Leopard（有人认为这是有史以来最好的Mac OS版本），其中包括libdispatch（又名Grand Central Dispatch）。当我宣布WWDC 2008时，我在那儿，我们都很欣喜若狂，这可能是我参加过的最激动人心的WWDC（此后我将再参加5次）。 libdispatch和新的内联块语法令人惊叹，它们有望最终轻松地访问多核计算机的功能。在此之前，多核计算机已经使用了很长时间（实际上是双处理器），但是它主要由Photoshop等专业应用程序使用。在2000-2008时代，开发人员通常只在需要时才开始对应用程序进行多线程处理，例如，因为一项工作需要长时间运行，并且可能会阻塞应用程序的用户事件运行循环太长时间（导致臭名昭著）旋转沙滩球出现）。</p><p> Apple demonstrated the libdispatch and the promise seemed great, they introduced the notion of serial queues and told us that we should stop thinking in term of threads and start thinking in term of queues. We would submit various program tasks to be executed serially or concurrently and the libdispatch would do the rest, automatically scaling based on the available hardware. Queues were cheap, we could have a lot of them. I actually remember very vividly a Q&amp;A at the end of one of the WWDC sessions, a developer got to the mic and asked how many queues we could have in a program, how cheap were they really? The Apple engineer on stage answered that most of the queue size was basically the debug label that the developer would pass to it at creation time. We could have thousands of them without a problem.</p><p> 苹果公司展示了libdispatch，它的承诺似乎很棒，他们介绍了串行队列的概念，并告诉我们应该停止考虑线程，而开始考虑队列。我们将提交各种程序任务以串行或并发执行，而libdispatch将完成其余工作，并根据可用硬件自动缩放。队列很便宜，我们可以有很多。实际上，我非常清楚地记得在WWDC的一次会议结束时进行的问答，一位开发人员来到麦克风旁，问我们程序中可以有多少个队列，它们的真正价格是多少？舞台上的苹果工程师回答说，大多数队列大小基本上是开发人员在创建时传递给它的调试标签。我们可以毫无问题地拥有成千上万个。</p><p> How would serial queues help us with concurrency? Well various program components would have their own private queue which would be used to ensure thread-safety (locks would not even be needed anymore) and those components would be concurrent between themselves. They told us these were &#34;islands of serialization in a sea of concurrency&#34;.</p><p> 串行队列将如何帮助我们进行并发？那么，各种程序组件将具有自己的专用队列，该专用队列将用于确保线程安全（甚至不再需要锁定），并且这些组件之间将是并发的。他们告诉我们，这是“并发海洋中的序列化之岛”。</p><p>  The future was multithreading and we had to use the libdispatch to get there. So we did.</p><p>  未来是多线程，我们不得不使用libdispatch到达那里。我们做到了。</p><p> Then the problems started. We ran into thread explosion which was really surprising because we were told that the libdispatch would automatically scale based on the available hardware so we expected the number of threads to more or less match the number of cores in the machine. A younger me in 2010  asked for help on the libdispatch mailing-list and the response from Apple at the time was to  remove synchronization points and  go async all the way.</p><p> 然后问题开始了。我们遇到了线程爆炸问题，这真是令人惊讶，因为我们被告知libdispatch将根据可用硬件自动扩展，因此我们期望线程数或多或少地与计算机中的内核数相匹配。 2010年，一个年纪较小的我在libdispatch邮件列表上寻求帮助，当时Apple的回应是删除同步点并一直保持异步。</p><p> As we went down that rabbit hole, things got progressively worse. Async functions have the bad habit of contaminating other functions: because a function can&#39;t call another async function and return a result without being async itself, entire chain calls had to be turned async. We started to have many async functions that actually made no sense being async, they were not executing long-running background tasks and they were not inherently async (like for example network requests are). We had to deal with the complexity of heavy callback designs which made everything harder to read. More worryingly async made our program a lot more unpredictable and hard to reason about: because every time we dispatched async we released the execution context until the work item completed, it was now possible for the program to execute new calls in an interleaved fashion in the middle of our methods. This led to all sort of very subtle and hard to debug ordering bugs. Worse, they were really hard to fix too and caused countless days of debugging, implementation tricks and hair pulling. Worse of all, we eventually realized we had terrible performance problems, turns out it&#39;s really wasteful to async small tasks and constantly dispatch on many queues. Which is a bit insane because the whole reason we started doing all this in the first place was to get better performance out of the cores, but we were actually doing worse off. Despite our most sincere efforts and actually having an extremely async program, we could still easily see between 30 and 60 threads running on a 4-cores machine during normal operation.</p><p> 当我们钻进那个兔子洞时，情况逐渐恶化。异步函数有污染其他函数的坏习惯：因为一个函数不能调用另一个异步函数并在不自身异步的情况下返回结果，因此整个链调用必须变为异步。我们开始拥有许多异步功能，这些功能实际上对异步没有任何意义，它们没有执行长时间运行的后台任务，并且它们本身并不是异步的（例如网络请求）。我们不得不处理繁重的回调设计的复杂性，这使得所有内容都难以阅读。更为令人担忧的是，异步使我们的程序变得更加不可预测且难以推理：因为每次我们分派异步时，我们都会释放执行上下文，直到工作项完成为止，现在该程序可以以交错方式执行新的调用了，我们方法的中间这导致了各种非常微妙且难以调试的订购错误。更糟糕的是，它们确实也很难修复，并导致了数天的调试，实施技巧和拖延。更糟糕的是，我们最终意识到我们遇到了可怕的性能问题，事实证明异步小型任务并不断地在许多队列上调度确实是浪费。这有点疯狂，因为我们一开始就做所有这些事情的全部原因是为了从内核中获得更好的性能，但是实际上我们的情况更糟。尽管我们付出了最大的努力，并且实际上拥有一个非常异步的程序，但在正常运行期间，我们仍然可以轻松地看到4核计算机上正在运行30至60个线程。</p><p> Turns out Apple engineers are developers just like us and met the exact same problems that we did. In Mac OS X 10.7 Lion they introduced the Security Transforms, a brand new async API to perform security operations (hashing, encryption, etc...). We were using it to decrypt files and it caused thread explosion in our program. It turns out that every security transform is backed by its own private queue causing way too many threads to be spawned. The API is now abandoned in favor of synchronous libraries such as CommonCrypto and the new CryptoKit.</p><p>事实证明，苹果工程师是像我们一样的开发人员，并且遇到了与我们完全相同的问题。在Mac OS X 10.7 Lion中，他们引入了安全转换（Security Transforms），这是一种用于执行安全操作（哈希，加密等）的全新异步API。我们使用它解密文件，并在程序中引起线程爆炸。事实证明，每个安全转换都由其自己的专用队列支持，从而导致产生太多线程。现在已放弃了该API，而倾向于使用诸如CommonCrypto和新的CryptoKit之类的同步库。</p><p> An Apple engineer also  revealed that a lot of the perf wins in iOS 12 were from daemons going single-threaded. Which means multithreaded code was written, maintained and shipped for a number of years in the OS itself until the engineers eventually realized that it was not working so well. The same engineer also  recommended to &#34;strongly consider not writing async/concurrent code&#34;. Yep, I know the feeling.</p><p> 一位苹果工程师还透露，iOS 12的许多性能优势都来自单线程守护进程。这意味着多线程代码已在OS本身中编写，维护和交付了很多年，直到工程师最终意识到它不能很好地工作。该工程师还建议“强烈考虑不编写异步/并发代码”。是的，我知道这种感觉。</p><p>  I was half-joking on twitter that everything was better back when we had to use  +[NSThread detachNewThreadSelector...] to do multithreading. This is not really true of course, the libdispatch has useful features and I do use it (with care). The reason I said that is that back then the upfront cost of doing multithreading was higher for the programmer (things like starting new threads, communicating across threads, etc...). The consequence was that developers would stop and think hard about whether it made sense to create threads, they would carefully think about their program design. The libdispatch kind of made it too easy, developers started dispatching left and right without really thinking anymore about what was actually going on in their software and hardware, it pushed developers away from careful design.</p><p>  我在推特上开玩笑说，当我们不得不使用+ [NSThread detachNewThreadSelector ...]进行多线程处理时，一切都会变得更好。当然，这不是真的，libdispatch具有有用的功能，我确实小心使用了它。我之所以这么说，是因为那时候程序员进行多线程的前期成本较高（诸如启动新线程，跨线程通信等）。结果是，开发人员将停止并认真思考创建线程是否有意义，他们将仔细考虑其程序设计。 libdispatch的实现太简单了，开发人员开始左右调度，而不必再真正考虑他们的软件和硬件中实际发生了什么，这使开发人员远离精心设计。</p><p>  It was not before 2017 that I eventually stumbled on a discussion ( page 1,  page 2) on the Swift mailing-list. Pierre Habouzit, the libdispatch maintainer at Apple at the time, attempted to explain to the Swift compiler engineers things I wish Apple had told us many years before (and to be fair Apple started backtracking and explained some of it in recent WWDC sessions but it didn&#39;t hit me at the time like this discussion did). I collected all the information I could find and published it  here (go read that now if you haven&#39;t already). It turns out the solution was to carefully think of queues a lot more like if they were threads and to use async sparingly. For some reason Apple never updated the libdispatch API to make it harder to misuse and never updated the documentation to explain all this.</p><p>  直到2017年之前，我终于偶然发现了Swift邮件列表上的讨论（第1页，第2页）。当时苹果公司的libdispatch维护者Pierre Habouzit试图向Swift编译器工程师解释我希望苹果多年以前告诉我们的事情（公平地说，苹果公司开始回溯并在最近的WWDC会议上进行了解释，但它没有像这次讨论那样打我。）我收集了所有可以找到的信息并将其发布在这里（如果您尚未阅读，请立即阅读）。事实证明，解决方案是仔细考虑队列，就像它们是线程一样，并谨慎使用异步。由于某种原因，Apple从未更新过libdispatch API以使其更易于滥用，也从未更新过文档来解释所有这一切。</p><p> I applied the recommendations and it took some time but it was great. A lot of the code that never really needed to be async in the first place went back to being synchronous and it made all the difference. Things got much simpler, I could remove a ton of code that was just there to protect against the out-of-order interleaved calls that I mentioned earlier. Things were now async only when it actually made sense (like backgrounding long-running tasks or doing network requests). The program was more predictable and easier to read and reason about. The number of threads went down to a reasonable amount. It was faster too, a lot faster (this program received and handled various system events from a kernel extension so a lot of things were going on there).</p><p> 我应用了建议，花了一些时间，但是很棒。许多本来不需要真正异步的代码又回到了同步，这一切都与众不同。事情变得简单得多，我可以删除大量的代码，以防止前面提到的无序交错调用。现在，只有在真正有意义的情况下，事情才是异步的（例如，将长期运行的任务置入后台或执行网络请求）。该程序更具可预测性，更易于阅读和推理。线程数下降到合理的数量。它也更快，更快（该程序从内核扩展接收并处理了各种系统事件，因此很多事情都在进行）。</p><p> It is now obvious that the original intent of the libdispatch failed. Developers do need to think hard about multithreading and need to carefully consider their program design. Every other OS and languages have tried their own variant of the libdispatch and from what I have read they all failed to some extent. It seems that multithreading is a hard problem after all that resists being made easy.</p><p> 现在很明显，libdispatch的原始意图失败了。开发人员确实需要认真考虑多线程，并且需要仔细考虑他们的程序设计。其他所有操作系统和语言都尝试了自己的libdispatch变体，从我阅读的内容来看，它们都在某种程度上失败了。毕竟，多线程是一个很难解决的难题。</p><p>  Now I&#39;m a bit worried because I see all those shiny new things that Apple is planning to add into the Swift language and I wonder what might happen this time.</p><p>  现在我有点担心，因为我看到Apple计划将所有闪亮的新事物添加到Swift语言中，我不知道这次会发生什么。</p><p> An &#34;actor&#34; is a new type of class which has its own internal private queue onto which its functions execute to ensure thread-safety, an actor&#39;s exposed functions can only be async. How does that help concurrency you may ask? Well you see, you can have many actors in your program and they execute concurrently between themselves, they are islands of serialization in a sea of concurrency. Now I don&#39;t know about you but to me it seems a hell of a lot like what we did all these years ago and that failed miserably. I&#39;m not even sure actors can be made right because this very idea of using async everywhere to protect shared state is very problematic. If there is one thing that this whole story told me it is that async should be used with extreme caution and only when it really makes sense (and protecting shared state isn&#39;t one of those things). If you see an async interface and can&#39;t understand why it needs to be async then it probably shouldn&#39;t. I know there are discussions about suspending the actor&#39;s internal queue while awaiting in order to avoid the interleaved calls issue but to me this is a clear indication that the whole idea is misguided (I&#39;ve been there already, we&#39;ve done that, this is an unfortunate trick that makes deadlocks possible). As for the rest (async/await, structured concurrency) it&#39;s probably ok but lowers the cost of writing async code even more which is good if we want people to write more async code.</p><p>“ actor”是一种新型的类，它具有自己的内部专用队列，在其内部执行其函数以确保线程安全，而actor的公开函数只能是异步的。您可能会问这如何帮助并发？好了，您看到了，您的程序中可以有许多参与者，它们之间可以同时执行，它们是并发海洋中的序列化孤岛。现在我不认识你，但对我来说，这似乎像我们几年前所做的那样，真是太惨了。我什至不能确定参与者是否正确，因为在各处使用异步来保护共享状态的想法非常有问题。如果整个故事都告诉我一件事，那就是应该非常谨慎地使用异步，并且仅在真正有意义的情况下使用（并且保护共享状态不是其中之一）。如果您看到一个异步接口并且不明白为什么它需要异步，那么可能就不需要。我知道有人在讨论如何在等待时暂停参与者的内部队列，以避免出现交错呼叫的问题，但是对我来说，这清楚地表明，整个想法都被误导了（我已经去过那里，我们已经这样做了，是使死锁成为可能的不幸技巧。至于其余的（异步/等待，结构化并发），可能还可以，但是可以进一步降低编写异步代码的成本，如果我们希望人们编写更多的异步代码，那么这很好。</p><p> The most alarming thing to me is the long-lasting impact that the libdispatch has on our entire software ecosystem. 12 years after the introduction of the libdispatch I still see it being misused almost everywhere I look. I still see people tweeting and writing blog posts recommending practices that are now known to be problematic. I still see async code that shouldn&#39;t be and programs spawning way too many threads. I don&#39;t think this is ever going away. Now is probably the time to be extra-careful because of the long-lasting impact these APIs have on our software (including operating systems). Once things like actors are out, they are going to be used and there will be no stopping it. We should certainly wonder about the long-term impact and consequences.</p><p> 对我来说，最令人担忧的是libdispatch对我们整个软件生态系统的长期影响。 libdispatch引入12年后，我仍然看到它几乎在我所看到的任何地方都被滥用。我仍然看到人们在推特上写博客文章，推荐目前已知有问题的做法。我仍然看到不应该的异步代码，程序产生太多线程。我认为这不会消失。现在可能是时候格外小心了，因为这些API对我们的软件（包括操作系统）产生了长期影响。一旦像演员这样的事情出现了，它们将被使用，并且将不会停止。我们当然应该对长期影响和后果感到奇怪。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://tclementdev.com/posts/what_went_wrong_with_the_libdispatch.html">https://tclementdev.com/posts/what_went_wrong_with_the_libdispatch.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/wrong/">#wrong</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>