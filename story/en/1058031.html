<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>一个新的命令行界面的曙光 The Dawn of a New Command Line Interface</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Dawn of a New Command Line Interface<br/>一个新的命令行界面的曙光 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-13 19:06:33</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/b7b24441a494f9c0417ff07075406c1a.png"><img src="http://img2.diglog.com/img/2021/4/b7b24441a494f9c0417ff07075406c1a.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>disclaimer: this is a technical post aimed at developers being somewhat aware of the problem space. There will be a concluding ‘the day of…’ post aimed at end users where some of the benefits will be demonstrated in a stronger light.</p><p>免责声明：这是一个技术帖子，旨在开发人员有点了解问题空间。将有一个结论的“......”帖子的旨在最终用户，其中一些福利将以更强大的光明证明。</p><p> A few months back, I wrote a lighter  post about an ongoing effort towards reshaping the venerable Linux/BSD CLI to be free of the legacy cruft that comes with having to deal with the emulation of old terminal protocols, stressing the point that these protocols make the CLI less efficient, and hard to work with from both a user- and a developer- perspective. In this post, we’ll recap some of the problems, go through the pending solution, update with the current progress and targets, and see what’s left to do.</p><p> 几个月后，我写了一个打火机帖子，关于重塑古老的Linux / BSD CLI的持续努力，不受旧终端协议的仿真的遗留CRUFT，强调这些协议所做的一点CLI效率较低，难以从用户和开发者角度工作。在这篇文章中，我们将重新回顾一些问题，通过待处理的解决方案，使用当前的进度和目标更新，并查看已剩下的操作。</p><p>  Split between terminal emulator and command line shell breaks desktop integration – Visual partitions such as windows, borders and popups are simulated with characters that are unwanted in copy-paste operations and fail to integration with an outer desktop shell (if any).</p><p>  终端仿真器和命令行shell之间的拆分中断桌面集成 - 诸如Windows，边框和弹出窗口之类的视觉分区，使用副本粘贴操作中不需要的字符进行模拟，并且无法与外部桌面壳（如果有的话）集成。</p><p> Code/data confusion – both the terminal emulator and text-oriented user interfaces (TUIs) tries to separate content from metadata using a large assortment of encoding schemes, all being prone to errors, abuse, difficult to parse and ridden with legacy.</p><p> 代码/数据混淆 - 终端仿真器和面向文本的用户界面（TUIS）都尝试使用大型各种编码方案的元数据分离内容，所有这些方案都容易出错，滥用，难以解析和乘坐遗产。</p><p> Uncertain capabilities/feature-set – basic things like color depth, palette, character encoding schemes and so on are all probed through a broken mishmash of environment variables, capability databases and the actual support varies with the terminal emulator that is being used.</p><p> 不确定的功能/功能集 - 诸如颜色深度，调色板，字符编码方案等的基本内容都是通过破碎的环境变量的破碎的MishMash探测，能力数据库和实际支持随着所使用的终端仿真器而异。</p><p> Confusion between user-input and data – programs can’t reliably distinguish between interactive (keyboard) input, pasted/”IPC” input and other forms of data entry.</p><p> 用户输入和数据之间的困惑 - 程序无法可靠地区分交互式（键盘）输入，粘贴/“IPC”输入和其他形式的数据输入。</p><p> Lack of synchronisation. This makes it impossible for the terminal emulator to know when it is supposed to draw, and signal propagation contributes to making resize operations slow.</p><p> 缺乏同步。这使得终端仿真器无法知道何时应该绘制，并且信号传播有助于使调整大小操作慢。 </p><p> This just scratches the surface and don’t go into related issues when it comes to user-interaction, consistency, and it ignores the entire problem space of system interaction when it comes to tty devices, input modes, virtual terminal switching and so on.</p><p>这只是在涉及用户交互，一致性，一致性时划伤表面并不会进入相关问题，并且当涉及到TTY设备时，输入模式，虚拟终端交换等时，忽略系统交互的整个问题空间。</p><p> If you consider the entire feature-set of all protocols that are already around and in use, you get a very “ Cronenberg“- take on a display server and I, at least, find the eerie similarities between terminal emulators and the insect typewriters from  Naked Lunch both amusing, tragic and frightening at the same time; the basic features one would expect are there, along with some very unwanted ones, but pieced together in an outright disgusting way. If we also include related libraries and tools like  curses and  turbo vision we get a clunky version of a regular point and click UI toolkit. Even though the scope is arguably more narrow and well-defined, these libraries are conceptually not far away from the likes of Qt, GTK and Electron. Study unicode and it shouldn’t be hard to see that ‘text’ is mostly graphics, the largest difference by far is the smallest atom, and the biggest state-space explosion comes from saying ‘pixel’ instead of cell.</p><p> 如果您考虑过的所有协议的所有功能集，您可以获得一个非常“Cronenberg” - 至少在显示服务器上，至少找到终端仿真器和昆虫打字机之间的令人毛骨悚然的相似之处赤裸午餐同时有趣，悲惨和恐惧;一个人期望的基本特征在那里，以及一些非常不需要的，但以一种直接的恶心方式拼凑在一起。如果我们还包含相关的库和工具，如诅咒和turbo vision，我们会获得常规点的笨重版本，然后单击UI工具包。尽管范围可以说是更狭隘和明确的定义，但这些库在概念上与QT，GTK和电子的相似之处不远。研究Unicode，不应该很难看到“文本”大多是图形，到目前为止的最大差异是最小的原子，最大的状态空间爆炸来自称为“像素”而不是单元格。</p><p> So the first question is, why even bother to do anything at all within this spectrum instead of just maintaining the status quo? One may argue that we can, after all, write good CLI/TUIs using QT running on Xorg today, no change needed – it’s just not the path people typically take; maybe it’s the paradigm of favouring mouse or touch oriented user interaction that is “at fault” here, along with favouring style and aesthetics over substance. One counterpoint is that the infrastructure needed to support the toolkit+display server approach is morbidly obese into the millions of lines of code, when the problem space should be solvable within the tens-of-thousands, but “so what, we have teraflops and gigabytes to spare!”. Ok, how about the individual investment of writing software? accommodating for disabilities? attack surface? mobility and mutability of produced output? efficiency for a (trained) operator? or when said infrastructure isn’t available? the list goes on.</p><p> 所以第一个问题是，为什么甚至烦扰在这个频谱中做任何事情，而不是保持状态quo？毕竟，我们可以争辩说，我们可以在今天使用Qt在Xorg上运行Qt，无需改变 - 这不是人们通常采取的道路;也许它是有利于鼠标或触摸导向的用户互动的范式，即在此处“在故障”中，随着物质的偏好风格和美学。一个对立面是支持Toolkit +显示服务器方法所需的基础设施是肥胖的肥胖进入数百万的代码时，当问题空间应该在数千岁内可解决，但“所以，我们有Teraflops和teraflops千兆字节备用！“。好的，写作软件的个人投资怎么样？适合残疾？攻击表面？产生输出的移动性和可变性？ （培训）运营商的效率？或者当所述基础架构不可用？列表继续。</p><p> There is arguably a rift here between those that prefer the ‘shove it in a browser’ or flashy UIs that animate and morph as you interact, and those that prefer staring into a text editor. It seems to me that the former category gets all the fancy new toys, while the latter mutters on about insurmountable levels of legacy. What I personally want is many more “one- purpose” TUIs and for them to be much easier to develop. They need to be simpler, more consistent, obvious to use, and more configurable. That’s nice and dreamy, but how are “we” supposed to get there?</p><p> 在那些喜欢'在浏览器中的浏览器中推送它'或flashy的UI之间的人之间可以说，随着您的互动，以及更喜欢盯着文本编辑器的浏览器的uis。在我看来，前面的类别得到了所有奇特的新玩具，而后者嘀咕着关于不可逾越的遗产水平。我个人想要的是更多的“单一目的”，以及他们更容易发展。他们需要更简单，更一致，明显使用，更可配置。这很好，梦幻般的，但“我们”应该如何到达那里？</p><p> First, lets consider some of the relevant components of the Arcan project as a whole, as the proposed solution reconfigures these in a very specific way. The following picture shows the span of current components:</p><p> 首先，让我们考虑一下Arcan项目的一些相关组件，因为所提出的解决方案以一种非常具体的方式重新配置这些。以下图片显示了当前组件的跨度：</p><p> This time around, we’re only interested in the parts marked  SHMIF,  Terminal and  TUI. Everything else can be ignored.  SHMIF is the structural glue/client IPC.  TUI is a developer facing API built on top of SHMIF but with actual guarantees of being a forward/backwards compatible API. Terminal is a vtXXX terminal emulator/state machine built using a modified and extended version of libtsm.</p><p> 这一次，我们只对Shmif，终端和Tui的零件感兴趣。其他一切都可以忽略。 Shmif是结构胶水/客户端IPC。 TUI是一个面向SHMIF的API的开发人员，但实际保证是前进/向后兼容API。终端是使用修改和扩展版本的Libtsm构建的VTXXX终端仿真器/状态机。</p><p>   From this, we take the  frameserver(ipc)– block and we put it into its own  shmif-server library. We take the  platform block and split out into its own,  libarcan-abc. Terminal is extended to be able to use these two APIs along with optional Lua/whatever bindings for the TUI API so that the higher level shell CLI logic with all its string processing ickiness can be written in something that isn’t C. This opens the door for two configurations.  Starting with the more complex one, we get this figure:</p><p>   由此，我们采取框架（IPC） - 块，我们将其放入自己的SHMIF-Server库中。我们采取平台块并分成自己的LibArcan-ABC。终端扩展到能够将这两个API与TUI API的可选LUA /任何绑定一起使用，使得具有其所有字符串处理ickines的更高级别的shell CLI逻辑可以写入不是C.这打开了门两种配置。从更复杂的开始，我们得到这个数字： </p><p>  Here, Arcan is used as the main display server or hooked up to render using another one (there are implementations of the platform layer for both low-level and high-level system integration). The running ‘appl’ acts as the window manger (which can practically be a trivial one that just works as fullscreen or the alt+fN VT switching style with only a few lines of code) and it may spawn one or many of the  afsrv_terminal. These can be run in ‘compatibility mode’ where the emulator state machine is activated and it acts just like xterm and friends.</p><p>在这里，Arcan用作主显示服务器，或者用另一个连接到渲染（有用于低级和高级系统集成的平台层的实现）。运行的'Appl'充当窗户管理器（实际上可以是一个琐碎的，只需用作普通屏幕或Alt + Fn VT交换样式，只有几行代码，它可能会产生一个或许多AFSRV_TERMINAL。这些可以在“兼容模式”中运行，其中仿真器状态机被激活，它就像Xterm和朋友一样。</p><p>   In this mode, the terminal works directly with the platform layer to  drive displays and sample input. It can even perform this role directly at boot if need be. An interesting property of shmif here is the support for different connection modes (which I’ll elaborate on in another post) where you can both interactively  migrate and  delegate connection primitives. This means that you can switch between these two configurations at runtime, without data loss – even have the individual clients survive and reconnect in the event of a display server crash.</p><p>   在此模式下，终端直接使用平台层来驱动显示和示例输入。如果需要，它甚至可以直接在启动时执行此角色。 Shmif的一个有趣的属性在这里是对不同连接模式的支持（我会在另一个帖子中详细说明），您可以在那里交互迁移和委派连接基元。这意味着您可以在运行时在这两个配置之间切换，而不数据丢失 - 甚至可以在显示服务器崩溃的情况下生存并重新连接。</p><p> No matter the configuration,  you (the ghost behind the shell) get access to all the  features in shmif and can decide which ones that should be used and which ones that should be rejected.  You are in control over the routing via the choice in shell (and the appl- for the complex version). Recall that the prime target now is local text-oriented, command line interfaces – not changing or tampering with the awk | sed | grep | … flow, that’s an entirely different beast. In contrast to curses and similar solutions, this approach also avoids tampering with  stdin,  stdout,  stderr or  argv, because  connection primitives and invocation arguments are inherited or passed via env. This should mean that retrofitting existing tools can be done without much in terms of ifdef hell or breaking existing code.</p><p> 无论配置，您（shell后面的幽灵）都可以访问SHMIF中的所有功能，并可以决定哪些应该使用哪些应该被拒绝。您可以通过shell（以及复杂版本的应用程序）中的选择来控制路由。回想一下，Prime目标现在是当地的面向文本，命令行接口 - 没有改变或篡改awk | SED | grep | ......流动，这是一个完全不同的野兽。与诅咒和类似的解决方案相比，这种方法还避免使用STDIN，STDOUT，STDERR或ARGV来篡改，因为连接基元和调用参数是通过ENV的继承或传递的。这应该意味着可以在IFDEF地狱或破坏现有代码方面没有多大地完成现有工具。</p><p> Anyhow, most of this is not just vapours from some hallucinogenic vision but has, in fact, already been implemented and been in testing for quite some time. What is currently being worked on now and for the near future is improving the quality in some of the existing stages and adding:</p><p> 无论如何，大多数情况都不只是来自一些致幻视觉的蒸气，而且事实上已经过了一段时间已经实施并在测试中进行了测试。目前正在进行的内容以及不久的将来正在提高一些现有阶段的质量和添加：</p><p> Double buffering on the virtual cell screen level to add support for sub-cell “smooth” scrolling, text shaping, BiDi, and non-monospace, properly kerned, text rendering.</p><p> 虚拟单元屏幕级别的双重缓冲以增加对子单元格“平滑”滚动，文本整形，BIDI和非操作区的支持，正确攻击，文本呈现。</p><p> API and structures for designating regions (alt-screen mode) or lines (normal mode) for custom input, particularly mixing/composing contents from other tui clients or frameservers.</p><p> 用于指定定制输入的区域（ALT-SCHEE模式）或线条（正常模式）的API和结构，特别是从其他TUI客户端或帧群维护者混合/编写内容。</p><p>    Shmif-server-proxy tool that can convert to-/from- a network or pipe-passed ‘line format’ (protocol) to enable networking support and test high latency/packet loss behavior.</p><p>    Shmif-server-proxy工具，可以转换为-/ from-a网络或管道传递的'行格式'（协议），以实现网络支持和测试高延迟/数据包丢失行为。 </p><p> Should all these steps succeed, the last ‘nail in the coffin’ will be to provide an alternative platform output target that undoes all this work and outputs into a VT100 compliant mess again – all for the sake of backwards compatibility. That part is comparably trivial as it is the end result of ‘composition’ (merge all layers), it is the premature composition that is (primarily) at fault here as information is irreversibly lost. It is just made worse in this case as the feature scope of the output side (desktop computer instead of dumb terminal) and the capability of the input side (clients) mismatch because of the communication language.</p><p>如果所有这些步骤都成功，最后的“棺材中的钉子”将是提供一个替代平台输出目标，可以撤消所有这项工作并再次输出到符合VT100的副本 - 所有这些都是为了向后兼容。 该部分与“组成”的最终结果（合并所有层），那部分是相对的，它是（主要）在这里（主要）在这里发生故障，因为信息不可逆转地丢失。 在这种情况下，它刚刚使得输出侧（台式计算机代替哑终端）的特征范围以及由于通信语言而不匹配的输入侧（客户端）的功能。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://arcan-fe.com/2017/07/12/the-dawn-of-a-new-command-line-interface/">https://arcan-fe.com/2017/07/12/the-dawn-of-a-new-command-line-interface/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/界面/">#界面</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/command/">#command</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>