<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>GNU Autotools面临的优势，劣势，机会和威胁 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">GNU Autotools面临的优势，劣势，机会和威胁 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-29 07:08:39</div><div class="page_narrow text-break page_content"><p>多年来，我一直是GNU项目的贡献者，尤其是GCC和GNU libc。最近，我领导了自2012年以来第一版Autoconf的发布（Autoconf 2.70的发布公告）。有关背景和上下文，请参阅我的Changeset Consulting同事Sumana Harihareswara撰写的LWN文章。</p><p> Autoconf八年来未发布版本是一个更深层次问题的征兆。许多GNU项目，包括Autotools的所有其他组件（Automake，Libtool，Gnulib等）及其依赖的软件（GNU M4，GNU Make等），贡献者的热情和用户都在稳步下降。过去十年的基础。我将自己纳入下降的狂热人群中；如果我没有得到报酬，我将不会做导致Autoconf 2.70发行的工作。 （我想对项目资助者表示感谢：彭博社，基思·波斯蒂克和FSF的GNU工具链基金。）</p><p> 由于贡献者热情的下降，自动工具的状态特别糟糕。 Autoconf 2.70版本的准备工作几乎是预期时间的两倍。在2020年7月至2020年12月之间，我发布了5个beta版本，并合并了157个补丁，其中大多数修正了错误。在不止一次的情况下，我被问到为什么要麻烦我-Autoconf（以及其他暗示的工具）完全过时了吗？为什么每个人都不能切换到新的东西，例如CMake或Meson？ （有关示例，请参见Sumana的LWN文章中的评论。）</p><p> 我个人认为Autotools并不是过时的，甚至比某些替代品都难以使用，但这是一个公平的问题。 Autotools的开发应该继续吗？如果要继续下去，我们需要找到有时间和意愿（也许还有资金）来稳定维护他们的人，而不是每八年发布六个月的冲刺。我们还需要适当的路线图，以说明在何处进行进一步开发这些项目。作为关于是否应该继续进行项目以及应该制定路线图的对话的起点，我受到Sumana正在进行的有关开源项目管理的书（可从她的网站上获得示例章节）的启发，以写出优点和缺点，机会和Autotools的威胁分析。</p><p> 此清单可以帮助我们找出如何利用Autotools的强大优势来把握新机遇，以及在何处进行投资以防范威胁并弥补当前的弱点。</p><p>   总结：作为数十年来类别领导者，Autotools受益于其体系结构方法，互操作性，边缘案例覆盖范围，标准遵循性，用户信任度和现有安装基础。</p><p> Autoconf的基于功能的方法可实现代码的可移植性，其扩展性优于系统怪癖列表。 </p><p>Autotools具有30多年的嵌入式知识，涉及C程序的可移植性陷阱以及Unix（以及程度较小的Windows等）上的基于shell的构建脚本的知识，包括其他同类配置工具均不支持的Unix变体。</p><p>  Autoconf和Automake支持以多种语言编写的软件比某些竞争性的构建系统更好（但请参见下文）。</p><p>  与竞争工具生产的Tarball版本相比，Autotools生产的Tarball版本具有更少的构建依赖关系。</p><p> Autotools生产的Tarball版本具有可预测的，标准化的（从字面上讲，这是GNU编码标准的关键方面）界面，用于设置构建时选项，构建，测试和安装它们。</p><p> Automake极力尝试生成可与任何Make实现一起使用的Makefile，而不仅仅是GNU make，甚至不只是（GNU或BSD）make。</p><p>  由于它们是GNU项目，因此用户可以确信Autotools是并且将始终是免费软件。</p><p> 相关地，用户可以相信，架构决策不受特定大型公司的需求驱动。 </p><p>拥有庞大的安装基础，而切换到竞争的构建系统是很多工作。</p><p>  总结：Autoconf的核心功能是解决1990年代/ 2000年代初（Unix战争期间）主要从事C语言工作的软件开发人员遇到的问题。从那时起，系统编程接口变得更加标准化，而shell环境的bug更少了。今天，新代码的开发人员在查看现有的配置脚本和文档时，无法轻松确定Autoconf知道哪些可移植陷阱仍与它们有关。同样，旧程序的维护人员很难知道仍然需要进行哪些现有的可移植性检查。与其他Autotools的协调不力使问题更加复杂。</p><p>  Autoconf（以及其余的Autotools）是用四种古老而困难的编程语言编写的：Bourne shell，Make，Perl和M4的可移植子集。竞争的构建系统倾向于使用更新，更符合人体工程学的语言，这不仅使他们更容易完成工作，而且使他们更容易吸引新的开发人员。</p><p>  支持的语言集没有特别的理由。不支持几种新的和越来越流行的编译代码语言（例如，Swift和Rust），而支持Erlang之类的奇怪功能。</p><p> 30年来关于便携陷阱的嵌入式知识中的大部分已过时。没有系统的政策来确定何时某些问题过时而不再需要担心。</p><p> 对较新平台，C标准版本等的支持要弱于对较旧版本的支持。</p><p> Autoconf的可扩展性是非系统的；这些第三方宏中的许多宏都可以发挥作用，并且会在核心开发中造成尴尬的兼容性约束。与现有的configure.acs相同。 </p><p>第三方宏的代码质量差异很大。不良的第三方宏不能很好地反映Autoconf的正确性。</p><p> Autoconf随附的一些辅助工具无法正常工作；最重要的是，自动更新（应该对configure.ac进行补丁以使其符合当前Autoconf的建议）非常有限且不可靠，因此最好完全不进行更新。</p><p>  由于文书要求和人们认为缺乏执行层领导，GNU项目地位不鼓励新的贡献者。</p><p> 没有持续的集成，也没有代码审查的文化。测试套件存在，但不够全面（同时它们非常慢）。</p><p> 错误，功能请求和提交的补丁不会得到系统地跟踪。 （这部分取决于FSF / GNU基础架构的改进，这些改进会无限期地延迟。）</p><p> 有发行破坏兼容性的历史，因此人们不愿升级。同时，Linux发行版积极地希望对其所提供的所有产品进行强制升级，以确保体系结构支持，从而导致上游/下游摩擦。</p><p>  直接从其VCS检出项构建基于Autotools的项目通常比从tarball版本进行构建要困难得多，并且可能涉及跟踪并安装许多非常规工具。 </p><p>Autotools依赖于其他未被主动维护的GNU软件，最重要的是GNU M4，并在较小程度上依赖于GNU Make。</p><p> 即使工具之间紧密耦合，Autotools之间的协调性仍然很弱。某些代码库的存在完全是为了与工具链中的其他工具实现互操作性，从而导致维护者和审阅者职责重叠，代码审阅缓慢以及版权分配过程不便成倍增加，并造成混乱和丢球。例如，通过在源存储库之间复制文件，在Autoconf，Automake和/或Gnulib之间共享代码。这些文件的更改非常不便。缺乏协调也使工具维护者更难以弃用旧功能，或使接口解耦以使事情更容易扩展。维护者不会相互协商政策以提供帮助。例如，Autoconf很难知道何时可以安全地删除Automake的旧版本所依赖的内部错误，并且某些shell命令（例如aclocal）与一个软件包一起分发，但抽象地属于另一个软件包。</p><p> Autotools之间的分工以及第三方宏的来源是临时的并且不清楚。 （哪个宏应该是Autoconf适当的一部分？哪些应该是Gnulib的一部分？哪些应该是Autoconf宏存档的一部分？哪些应该与Automake一起提供？autoreconf应该知道如何运行哪些工具？等等。）</p><p>  与其他竞争对手不同，Automake仅适用于Make，不适用于较新的构建驱动程序（例如Ninja）。</p><p> 因为Automake尝试生成可与任何Make实现一起使用的Makefile，所以它生成的Makefile比利用GNU和/或BSD扩展的情况要复杂和缓慢得多。</p><p> 众所周知，Libtool缓慢，脆弱且难以修改（甚至比Autoconf本身还差）。这部分归因于技术债务，部分归因于维护对完全过时的平台（例如AIX的旧版本）的支持。</p><p> Libtool对管理Linux发行版积极不同意的共享库的正确方法持意见，这迫使他们在软件包构建过程中相互混淆其代码。 </p><p>Libtool的替代品都未能获得人们的关注，这主要是因为Automake仅支持使用Libtool或确切的替代产品来构建共享库。</p><p>  由于其可扩展的体系结构，安装基础以及用户信任的源泉，Autotools可以对这些行业变化做出反应，从而刺激使用，投资和开发人员贡献的增加。</p><p> 新一代的系统编程语言（Go，Rust，D，Swift（？），Dart（？）等引起了人们对系统编程的新兴趣，这可能会为构建良好处理它们的构建系统创造机会，尤其是在处理多语言的情况下项目进展顺利（见下文）。</p><p> 由于ARM和RISC-V CPU以及基于这些芯片的小型设备（太小而无法编译自己的代码）的普及，交叉编译正受到新的欢迎。</p><p> 整个自由软件生态系统将受益于传统软件分发模型之间的协调（具有稳定接口的编译代码，以固定间隔定期发布为tarball，在任何给定计算机上安装一次并依赖于共享库和/或二进制文件）而较新的版本则直接取决于VCS检出并捆绑以下所述的所有模型。 Autotools贡献者拥有丰富的经验和知识来领导这项工作。</p><p>  这些威胁可能导致Autotools开发人员的贡献，资金和动力进一步下降。</p><p> 只要您在项目中仅使用一种语言，即可随即使用的构建系统所附带的编程语言的心态就会越来越多。 （这些系统通常根本无法处理多语种项目，因此，对于很好地处理多语种项目的第三方系统来说，这是一个机会。） </p><p>从VCS检出（也许不是在特定标签处）而不是通过tarball来构建软件的偏好越来越高。  由Node.js，Ruby等发起的软件分发模型的关注度不断提高，其中每个应用程序都捆绑了其所有依赖项。 尽管这特别被Linux发行维护人员认为是一个非常糟糕的主意（因为这使查找和修补错误的依赖关系变得更加困难），并且使最终用户更难以修改软件（因为过时的依赖关系可能会 与他们自己的文档（描述最新版本）说的非常不同），对于上游开发人员而言，它要方便得多。 竞争的构建系统比Autoconf更好地处理了该模型。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.owlfolio.org/development/autoconf-swot/">https://www.owlfolio.org/development/autoconf-swot/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/autotools/">#autotools</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/autoconf/">#autoconf</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>