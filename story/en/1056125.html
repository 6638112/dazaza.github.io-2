<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在缓存失效：为什么它很难？ On Cache Invalidation: Why Is It Hard?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">On Cache Invalidation: Why Is It Hard?<br/>在缓存失效：为什么它很难？ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-04 23:52:18</div><div class="page_narrow text-break page_content"><p>Many people must have heard this quote (by Phil Karlton) many times:  There are only two hard things in Computer Science: cache invalidation and naming thing. Two days ago, Nick Tierney mentioned it again in his post “ Naming Things”. Since he said he was not sure what cache invalidation meant, and I have a tiny bit experience here, I want to write this short post to explain why cache invalidation is hard from my experience.</p><p>许多人必须听到这句话（菲尔卡尔顿）多次：计算机科学只有两个艰难的东西：缓存失效和命名的东西。两天前，尼克泰尔尼再次在他的帖子“命名事物”中提到了它。由于他说他不确定缓存失效意味着什么，而且在这里有一个微小的体验，我想写这个短篇大论来解释为什么缓存失效来自我的经验。</p><p>  First of all, the main purpose of caching is speed. The basic idea is simple: if you know you are going to compute the same thing, you may just load the result saved from the previous run, and skip the computing this time. There are two keywords here: “the same thing”, and “the saved result”. The latter means you are essentially trading (more) storage space for (less) time. That is the price to pay for caching, and also an important fact to be aware of when you use caching (i.e., caching is definitely not free, and sometimes the price can be fairly high).</p><p>  首先，缓存的主要目的是速度。基本思想很简单：如果你知道你要计算同样的事情，你可能只是加载从上一个运行中保存的结果，并这次跳过计算。这里有两个关键字：“同样的事情”和“已保存的结果”。后者意味着您基本上是交易（更多）存储空间（更少）时间。这是支付缓存支付的价格，也是在使用缓存时要注意的重要事实（即，缓存绝对不是免费的，有时价格可能相当高）​​。</p><p> The tricky thing is “the same thing”. How do you know that you are computing the same thing? That is all “cache invalidation” is about. When things become different, you have to invalidate the cache, and do the (presumably time-consuming) computing again.</p><p> 棘手的事情是“同样的事情”。你怎么知道你正在计算同样的事情？这就是所有“缓存失效”就是关于。当事情变得不同时，您必须使缓存失效，并再次执行（大概耗时）计算。</p><p>  Implementing caching without considering the invalidation is often simple enough. Here is a simple example of turning a normal function to a function that supports caching:</p><p>  在不考虑失效的情况下实现缓存通常很简单。以下是将正常功能转到支持缓存的函数的一个简单示例：</p><p> greet = function(person) { switch(person, Nick = { # fast and smart Sys.sleep(3); &#39;Hello!&#39; }, Yihui = { # slow and shy Sys.sleep(15); &#39;你好！&#39; } )}</p><p> 问候=函数（人）{switch（person，nick = {＃fast smart sys.sleep（3）;＆＃39;您好！＆＃39;}，yihui = {＃慢速和害羞的sys.sleep（15） ;＆＃39;你好！＆＃39;}）}</p><p> I used  Sys.sleep() only to pretend the function was time-consuming. In the  greet() function, Nick is fast and will say “Hello”, and Yihui is slow, speaking Chinese. If we have to call this function many times, there is no need to wait if we can save what Nick and Yihui say. We will need a database to store their words, and keys to retrieve the results.</p><p> 我使用sys.sleep（）只是假装函数是耗时的。在问候（）函数中，尼克很快，会说“你好”，y辉很慢，说中文。如果我们必须多次调用这个函数，如果我们可以保存尼克和yihui说什么，无需等待。我们需要一个数据库来存储他们的单词，以及键来检索结果。</p><p> greet_cache = local({ # a caching database (in-memory only; could be on disk, too) database = list() function(person) { res = database[[person]] # if found in database, just return the cached result if (person %in% names(database)) return(res) # not found? compute and save it res = greet(person) database[[person]] &lt;&lt;- res # note the double arrow here res }})</p><p> hold_cache = local（{＃仅限缓存数据库（仅限内存）database = list（）函数（person）{res = database [person]]＃如果在数据库中找到，只需返回缓存结果（人物％在％名称（数据库））返回（res）＃未找到？计算和保存它res = break（person）数据库[​​[person]]＆lt;＆lt;＆lt;  -  res＃注意双箭头这里} }） </p><p> The first time you run this function, it will be slow, but for the second time, it will be instant.</p><p>第一次运行此功能时，它将很慢，但第二次，它将是即时的。</p><p>  The toy example shows the basic idea of implementing caching: turn your input into a key, use this key to retrieve the output in a cache database if it exists, otherwise do the computing and save the output to the database with the key.</p><p>  玩具示例显示了实现缓存的基本思想：将输入转换为键，如果存在，请使用此键在缓存数据库中检索输出，否则将计算和将输出保存到数据库中的键。</p><p>  Of course, toy examples often cannot represent the reality. If Nick goes to Japan, he may speak Japanese. When Yihui is in the US, he should speak English. We need to update the cache database in these cases (invalidating the previously saved results).</p><p>  当然，玩具例子通常不能代表现实。如果尼克去日本，他可能会说日语。当yihui在美国时，他应该说英语。我们需要在这些情况下更新缓存数据库（使先前保存的结果无效）。</p><p> Now let me talk about a real example in  knitr’s caching, which should sound similar to the case of Nick being in Japan (or Yihui in US). For those who care about technical details,  knitr caches results using  these lines of code and invalidate the cache  here.</p><p> 现在让我谈谈KNITR的缓存中的一个真实例子，这应该听起来与日本的尼克（或美国yihui）的情况相似。对于那些关心技术细节的人，KnitR缓存使用这些代码行并使缓存无效。</p><p> The basic idea of  knitr’s idea is that if you did not modify a code chunk (e.g., did not modify chunk options or the code), the result will be loaded from the previous run. The key of a code chunk is pretty much an MD5 hash (via  digest::digest()) of the chunk options and the chunk content (code). Whenever you modify chunk options or the code, the hash will change, and the cache will be invalidated.</p><p> Knitr的基本思想是，如果您没有修改代码块（例如，没有修改块选项或代码），则将从上一个运行加载结果。代码块的键是块选项和块内容（代码）的MD5哈希（VIA DIGEST :: DIGEST（））。每当修改块选项或代码时，哈希将会更改，缓存将无效。</p><p>  I have heard unhappy users curse  knitr’s caching. Some thought it was too sensitive, and some thought it was dumb. For example, when you add a space in an R comment in your code chunk, should  knitr invalidate the cache? Modifying a comment certainly won’t affect the computing at all (but the text output may change if you show the code in the output via  echo = TRUE), but the MD5 hash will change.  1</p><p>  我听说过不开心的用户诅咒剑的缓存。有些人认为它太敏感了，有些人认为这是愚蠢的。例如，当您在代码块中添加一个注释中的空格时，是否应对缓存无效吗？修改评论肯定不会影响所有计算（但如果您通过Echo = True显示输出中的代码，则可能会更改文本输出），但MD5散列将改变。 1</p><p> Then an example to explain why people thought  knitr’s caching was dumb: if you read an external CSV file in a code chunk,  knitr does not know whether you have modified the data file. If you happen to have updated the data file,  knitr won’t re-read it by default if you didn’t modify chunk options or the code. The cache key does not depend on the external file. In this case, you have to explicitly associate the cache with the external file, e.g.,  2</p><p> 然后一个例子来解释为什么人们认为knitr的缓存是愚蠢的：如果你在代码块中读取外部CSV文件，knitr不知道您是否已修改数据文件。如果您碰巧更新了数据文件，则如果您没有修改块选项或代码，则knitt不会重新读取它。缓存密钥不依赖于外部文件。在这种情况下，您必须将缓存与外部文件显式关联，例如，2 </p><p>  Since the chunk option  cache.extra is associated with the CSV file, cache will be invalidated when the file is changed (because the cache key will be different).</p><p>由于块选项Cache.Extra与CSV文件关联，因此在更改文件时缓存将无效（因为缓存键将不同）。</p><p> Another example is one code chunk using a variable created from a previous code chunk. When the variable is updated in the previous chunk, this chunk’s cache should be invalidated, too. This leads to the topic of the dependency structure of code chunks, which can be complicated, but there are some helper functions such as  knitr::dep_prev() and  knitr::dep_auto() to make it a little easier.</p><p> 另一个例子是使用从上一个代码块创建的变量的一个代码块。当变量在上一个块中更新时，此块的缓存也应该无效。这导致代码块的依赖关系的主题，这可能是复杂的，但有一些辅助函数，如knitr :: dep_prev（）和knitt :: dep_auto（），使其更容易。</p><p> When a code chunk is extremely time-consuming,  knitr should be more conservative (not to invalidate the expensive cache unless there have been critical changes). When a code chunk is only moderately slow (e.g., 10 or 20 seconds), the caching probably should be more sensitive.</p><p> 当代码块非常耗时时，knitr应该更保守（除非存在严重变化，否则不要使昂贵的缓存无效）。当代码块仅适度慢慢（例如，10或20秒）时，缓存可能应该更敏感。</p><p> The tricky thing is, it is hard to find the balance. Either direction can offend users.</p><p> 棘手的事情是，很难找到平衡。任何一个方向都可以冒犯用户。</p><p>  I said above that the obvious price to pay for caching is storage (either in memory or on disk). However, to make caching work perfectly for you, there is a hidden cost. That is, the cost to understand caching. This is similar to a situation in our daily life: we may spend a lot of time and energy to save some money. We can only see the money we saved, but ignore the cost of time and emotion. If you don’t analyze the two costs, the money you saved may not really be worthwhile.</p><p>  我上面说的是，支付缓存的明显价格是存储（在内存或磁盘上）。但是，为了让您对您的缓存工作，存在隐藏的成本。也就是说，了解缓存的成本。这类似于我们日常生活中的情况：我们可能会花费大量的时间和精力来挽救一些钱。我们只能看到我们保存的钱，但忽略了时间和情感的成本。如果您没有分析两种成本，那么您挽救的金额可能并不值得。</p><p> If you don’t fully understand how caching works and the conditions for its invalidation, caching could be too sensitive or dumb, and may not serve you well. Some users may be able to quick understand it, and some may not. If you want to speed, you’d better know the traffic rules first, otherwise you may be pulled over.</p><p> 如果您不完全了解缓存的工作和无效的条件，缓存可能太敏感或愚蠢，并且可能不适合您。有些用户可能能够快速理解它，有些用户可能不会。如果您想要速度，您可以先更好地了解交通规则，否则可能会被拉出。</p><p> The full documentation of  knitr’s caching is in the  knitr book “ Dynamic Documents with R and knitr (2nd ed)“. If you don’t have this book, there is  a page on  knitr’s website that contains more information.</p><p> KNITR的缓存的完整文档是KNITR书籍“带有R和KNITR（2nd）的动态文件”。如果您没有本书，则KNITR的网站上有一个页面包含更多信息。 </p><p> I don’t know what was on Phil Karlton’s mind when he said those words, but the above is my experience about caching. The ultimate suggestion I often give to users is that if you feel  knitr’s caching is too complicated, it is totally fine to use a much simpler caching mechanism like this:</p><p>当他说这些话时，我不知道是菲尔卡尔顿的思想，但以上是我对缓存的经验。我经常给用户的最终建议是，如果你觉得Knitt的缓存太复杂，它完全可以使用这样更简单的缓存机制：</p><p> if (file.exists(&#39;results.rds&#39;)) { res = readRDS(&#39;results.rds&#39;)} else { res = compute_it() # a time-consuming function saveRDS(res, &#39;results.rds&#39;)}</p><p> if（file.exists（＆＃39;结果.rds＆＃39;））{res = readrds（＆＃39;结果.rds＆＃39;）} else {res = compute_it（）＃耗时的函数saverds（ Res，＆＃39;结果.rds＆＃39;）}</p><p> In this case, you clearly understand how your caching works. The one and only way to invalidate the cache is to delete  results.rds, which is no longer hard at all. If you prefer this mechanism,  you may consider using  xfun::cache_rds().</p><p> 在这种情况下，您清楚地了解您的缓存工作原理。无效缓存的唯一方法是删除结果。它根本不再硬。如果您更喜欢此机制，您可以考虑使用Xfun :: cache_rds（）。</p><p> Actually you can use the chunk option  cache.comments = FALSE to prevent cache invalidation when only comments were changed in a code chunk. This can be useful when  echo = FALSE.  ↩</p><p> 实际上，您可以使用chunk选项cache.comments = false，以防止缓存失效，只有在代码块中仅更改注释时。 echo = false时，这可能是有用的。 ↩</p><p> You could also use  file.mtime() instead of  tools::md5sum() if you want the cache to depend on the modification time of the CSV file.  ↩</p><p> 如果您希望缓存依赖于CSV文件的修改时间，您还可以使用File.mtime（）而不是工具:: md5sum（）。 ↩ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://yihui.org/en/2018/06/cache-invalidation/">https://yihui.org/en/2018/06/cache-invalidation/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/缓存/">#缓存</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>