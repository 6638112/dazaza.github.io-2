<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Ruby 3.0和新的FiberScheduler接口 Ruby 3.0 and the new FiberScheduler interface</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Ruby 3.0 and the new FiberScheduler interface<br/>Ruby 3.0和新的FiberScheduler接口 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-30 02:47:48</div><div class="page_narrow text-break page_content"><p>A few days ago on Christmas day 2020, Matz released Ruby 3.0. Like every year, a host of interesting new features was included with the new version. Most articles I have read so far focus more on the new ways to introduce type hints and the  Ractor system but for me the most interesting addition was the introduction of the  Fiber::SchedulerInterface class. It allows for (but does not yet implement) more advanced event loop based schedulers for non-blocking I/O in Ruby. Several advanced techniques already exist for this in Ruby, from event loop frameworks like  EventMachine and  Async to releasing the GVL in C extensions, but this new interface is more exciting to me because it makes it much easier to accidentally do the right thing.</p><p>几天前，在2020年圣诞节那天，Matz发布了Ruby 3.0。像每年一样，新版本中包含许多有趣的新功能。到目前为止，我阅读的大多数文章都将更多的精力放在引入类型提示和Ractor系统的新方法上，但对我而言，最有趣的添加是Fiber :: SchedulerInterface类的引入。它允许（但尚未实现）更高级的基于事件循环的调度程序，用于Ruby中的非阻塞I / O。从EventMachine和Async之类的事件循环框架到C扩展发布GVL，Ruby中已经存在一些先进的技术，但是这个新接口对我来说更令人兴奋，因为它使意外地做正确的事情变得容易得多。</p><p> In this post I’ll go over the way the scheduler interface works in “normal” Ruby, and how to access it from within MRI C extensions. We’ll also have a look at the drawbacks of the current interface, because nothing is perfect.</p><p> 在本文中，我将介绍调度程序接口在“常规” Ruby中的工作方式，以及如何从MRI C扩展中访问它。我们还将看看当前界面的缺点，因为没有什么是完美的。</p><p>  In MRI Ruby, a   Fiber is a primitive for implementing light weight cooperative concurrency. They are somewhat like traditional  threads in that they take a block and run it concurrently with other fibers, but they live with many fibers “inside” a thread. This means that at most one fiber per thread can run at a time, but because they use very little memory it is feasible to create hundreds of thousands of fibers without problems. If you have very computationally intensive tasks for your fibers, this does not bring any benefits since dividing the work into many small parts does not help if you don’t have enough capacity for it in the first place. However, many Ruby processes spend much of their time waiting on I/O, such as waiting for the responses of API and database calls or waiting to read more of a HTTP request from a network socket. This is the use case where fibers shine.</p><p>  在MRI Ruby中，光纤是用于实现轻量级协作并发的原语。它们在某种程度上类似于传统线程，它们占用一个块并与其他光纤同时运行，但它们在线程“内部”存在许多光纤。这意味着每个线程一次最多只能运行一根光纤，但是由于它们使用的内存很少，因此可以毫无问题地创建成千上万的光纤。如果您的光纤需要执行大量计算任务，那么这不会带来任何好处，因为如果一开始的工作量不足，将工作分成许多小部分将无济于事。但是，许多Ruby进程花费大量时间等待I / O，例如等待API和数据库调用的响应，或者等待从网络套接字读取更多HTTP请求。这是纤维发亮的用例。</p><p> More “traditional” systems manage all this waiting around by allocating a separate operating system (OS) thread for every separate request, then make blocking system calls for reading from and writing to sockets and files. This works well up to a point, but an OS thread is relatively expensive to create and they require a context switch to the OS whenever another thread needs to run. This leads to a lot of overhead. Fibers can leverage the facilities for non-blocking and asynchronous I/O that modern operating systems provide to skip a lot of this overhead. They do this by calling   yield whenever they realize they will not be able to make progress, giving the floor to another fiber. Some examples might be when  Kernel#sleep is called or whenever a  read() or  write() syscall returns the   EWOULDBLOCK or  EAGAIN error codes. The missing link in this story is the new fiber scheduler, which is the code that a fiber yields  to. The scheduler is responsible for maintaining a inventory of blocked fibers and  resume-ing those fibers when the reason why they were blocked disappears. For example, if a fiber was blocked because it called  sleep(10), then after 10 seconds it should be resumed again. If the fiber was blocked because no data was available on the socket it wanted to read from, it should be resumed as soon as data arrives.</p><p> 更多的“传统”系统通过为每个单独的请求分配一个单独的操作系统（OS）线程来管理所有这些等待，然后进行阻止系统调用以读取和写入套接字和文件。这一点可以很好地工作，但是创建OS线程的成本相对较高，并且每当需要运行另一个线程时，它们都需要将上下文切换到OS。这导致很多开销。光纤可以利用现代操作系统提供的用于非阻塞和异步I / O的设施来跳过很多此类开销。当他们意识到自己将无法取得进展时，他们通过召集收益来做到这一点，这让另一根光纤陷入了困境。例如，当调用Kernel＃sleep时，或者每当read（）或write（）系统调用返回EWOULDBLOCK或EAGAIN错误代码时。这个故事中缺少的链接是新的光纤调度程序，它是光纤产生的代码。调度程序负责维护阻塞光纤的库存，并在阻塞光纤的原因消失时恢复这些光纤。例如，如果某条光纤因为调用sleep（10）而被阻塞，那么10秒钟后应重新恢复。如果光纤因要读取的套接字上没有可用数据而阻塞，则应在数据到达后立即恢复。</p><p> The scheduler is allowed to any mechanism to achieve this, but in practice there are a couple of good options:</p><p> 调度程序可以采用任何机制来实现此目的，但实际上有两个不错的选择：</p><p> On almost all Linux systems,  epoll() is the go-to mechanism for watching large numbers of sockets to see if new data is available. It can also manage sleeps with the  timerFD mechanism.</p><p> 在几乎所有的Linux系统上，epoll（）是监视大量套接字以查看是否有新数据可用的机制。它还可以使用timerFD机制管理睡眠。</p><p> On very modern Linux systems (kernel version 5.4 and beyond), the  io_uring API is available. This API makes it not only possible to monitor sockets and manage sleeps, but also to offload the read and write calls themselves to the OS instead of offloading just the waiting for availability.</p><p> 在非常现代的Linux系统（内核版本5.4及更高版本）上，可以使用io_uring API。通过此API，不仅可以监视套接字和管理睡眠，还可以将读取和写入调用本身转移到OS，而不是仅转移等待可用性。 </p><p> On Windows systems, IO Completion Ports can be used in much the same way as the  io_uring API.</p><p>在Windows系统上，可以使用与io_uring API几乎相同的方式来使用IO完成端口。</p><p> On BSD systems and derivatives like MacOS, the  kqueue() system call is used insted of  epoll(). I’m not aware of an async I/O API being developed for these systems yet, but would be happy if someone can correct me on that.</p><p> 在BSD系统和类似MacOS的派生工具上，kqueue（）系统调用用于安装epoll（）。我还不知道正在为这些系统开发异步I / O API，但是如果有人可以对此进行纠正，我将非常高兴。</p><p> Choosing between these possible mechanisms and managing the conversion between Ruby objects and what the OS demands is the task of the scheduler. Since fibers are thread-local and cannot move between threads, so is the scheduler. It would theoretically be possible to have an  epoll() based scheduler for one thread and an  io_uring based one for another, but in practice the scheduler would probably be provided by a separate gem and automatically choose the most performant interface available for the current OS.</p><p> 在这些可能的机制之间进行选择，以及管理Ruby对象之间的转换以及OS所需要的是调度程序的任务。由于光纤是线程本地的，并且无法在线程之间移动，因此调度程序也是如此。从理论上讲，可能有一个线程基于epoll（）的调度程序，而另一个线程基于io_uring的调度程序，但实际上，调度程序可能由单独的gem提供，并自动为当前OS选择性能最高的接口。</p><p> To make the integration seamless for Ruby developers, in Ruby 3.0 and onwards all relevant standard library methods have been patched to  yield to the scheduler whenever they encounter a situation where they will block the current fiber. These methods include, at the time of writing,  Kernel.sleep,  IO#wait_readable,  IO#wait_writable,  IO#read,  IO#write and other related methods (e.g.  IO#puts,  IO#gets),  Thread#join,  ConditionVariable#wait,  Queue#pop,  SizedQueue#push. This yielding to the scheduler only happens when a scheduler has actually been defined for the thread with  Fiber.set_scheduler. The real power of this becomes apparent when you realize that this means  any method in any gem that eventually calls  IO#read or  IO#write can make use of the scheduler, whether that gem has been written with the scheduler in mind or not. This immediately makes many gems like database drivers and network libraries scheduler-aware, as long as they don’t use C extensions too heavily. Even if they do, not all is lost. We’ll look at integrating C extensions with the scheduler later.</p><p> 为了使集成对于Ruby开发人员而言是无缝的，在Ruby 3.0及更高版本中，所有相关的标准库方法都已进行了修补，以便在遇到阻塞当前光纤的情况时，可以将其生成给调度程序。这些方法在撰写本文时包括Kernel.sleep，IO＃wait_read，IO＃wait_writable，IO＃read，IO＃write和其他相关方法（例如IO＃puts，IO＃gets），Thread＃join，ConditionVariable＃等待，Queue＃pop，SizedQueue＃push。仅当已使用Fiber.set_scheduler为线程实际定义了调度程序时，才产生调度程序的结果。当您意识到这意味着任何gem中的任何最终调用IO＃read或IO＃write的方法都可以使用调度程序时，无论该gem是否已在考虑调度程序的情况下编写，此方法的真正作用就显而易见。只要它们不需要过多使用C扩展，就可以立即使许多宝石如数据库驱动程序和网络库调度程序。即使他们这样做，也不会全部丢失。稍后我们将介绍如何将C扩展与调度程序集成在一起。</p><p>   start =  Time.now     Thread.new  do  # in this thread, we&#39;ll have non-blocking fibers    Fiber.set_scheduler  Scheduler.new      %w[ 2.6 2.7 3.0 ].each  do |version|    Fiber.schedule  do  # Runs block of code in a separate Fiber   t =  Time.now    # Instead of blocking while the response will be ready, the Fiber    # will invoke scheduler to add itself to the list of waiting fibers    # and transfer control to other fibers    Net:: HTTP.get( &#39;rubyreferences.github.io&#39;,  &#34;/rubychanges/ #{version } .html&#34;)   puts  &#39;%s: finished in %.3f&#39; % [version,  Time.now - t]    end    end   end.join  # At the  END  of the thread code, Scheduler will be called to dispatch    # all waiting fibers in a non-blocking manner    puts  &#39;Total: finished in %.3f&#39; % ( Time.now - start)   # Prints:   # 2.6: finished in 0.139   # 2.7: finished in 0.141   # 3.0: finished in 0.143   # Total: finished in 0.146</p><p>   start = Time.now Thread.new do＃在此线程中，我们将具有非阻塞光纤Fiber.set_scheduler Scheduler.new％w [2.6 2.7 3.0]。 Fiber.schedule do＃在单独的Fiber中运行代码块t = Time.now＃Fiber＃会调用调度程序将自身添加到等待的光纤列表中，而不是在响应准备就绪时进行阻塞，并将控制权转移给其他Fibre Net :: HTTP.get（＆＃39; ruby​​references.github.io＆＃39 ;,＆＃34; / ruby​​changes /＃{version} .html＆＃34;）放％s：以％结尾。 3f＆＃39; ％[version，Time.now-t] end end end.join＃在线程代码的末尾，将调度Scheduler以非阻塞的方式调度所有等待的光纤，以总计％的形式完成。 .3f＆＃39; ％（Time.now-start）＃打印：＃2.6：完成于0.139＃2.7：完成于0.141＃3.0：完成于0.143＃总计：完成于0.146</p><p> This example sets the scheduler for the new thread to a new instance of some  Scheduler class and then uses  Fiber.schedule to send off three HTTP requests that fetch the release notes for several recent Ruby versions. We can see in the output that the total time taken is only a few milliseconds longer than the slowest response, indicating that all three HTTP requests were performed in parallel.</p><p> 本示例将新线程的调度程序设置为某些Scheduler类的新实例，然后使用Fiber.schedule发送三个HTTP请求，以获取多个最新Ruby版本的发行说明。从输出中我们可以看到，所花费的总时间仅比最慢的响应长几毫秒，这表明所有三个HTTP请求都是并行执行的。</p><p> How does this work, given that we can see none of the methods mentioned above being used in the example? Well,  Net::HTTP.get uses  IO#write and  IO#read in its implementation, so while a request is in flight and waiting for a response, its fiber will  yield back to the scheduler to let other fibers do work. Since the actual CPU work here is very low, many fibers can be run on the same scheduler without them getting in each other’s way too much.</p><p> 假设我们在示例中没有使用上面提到的任何方法，该工作如何进行？好的，Net :: HTTP.get在其实现中使用IO＃write和IO＃read，因此，当请求在传输中并等待响应时，其光纤将退回给调度程序，以让其他光纤工作。由于此处的实际CPU工作量非常低，因此许多光纤可以在同一调度程序上运行，而又不会造成彼此过多的干扰。 </p><p>  Having functions like  IO#read and  Kernel.sleep automatically using the Fiber scheduler is all well and good, but many useful Ruby gems use C extensions to drop the GVL, perform operations “underneath” the Ruby garbage collector or just for plain speed of execution of computationally expensive operations. These C extensions will typically not use the Ruby methods for writing to and reading from file descriptors, so if they wish to use an existing fiber scheduler to efficiently use non-blocking I/O they have to call it themselves. Luckily, this is not hard!</p><p>使用Fiber调度程序自动具有IO＃read和Kernel.sleep之类的功能很好，但是许多有用的Ruby gem使用C扩展来删除GVL，在Ruby垃圾收集器“下方”执行操作，或者只是为了提高执行速度计算上昂贵的操作。这些C扩展通常不会使用Ruby方法来读写文件描述符，因此，如果它们希望使用现有的光纤调度程序来有效地使用非阻塞I / O，则必须自己调用它。幸运的是，这并不难！</p><p> A (very) quick recap of C extensions for MRI: a Ruby object is represented in C by a  VALUE struct that contains all the relevant information about the object. A few “standard” values like  true,  false and  nil and some others have been predefined and are available to test against as  Qnil,  Qtrue, etc. Ruby methods can be called either directly in C (if the Ruby method itself was defined in C) or with the  rb_funcall() C function.</p><p> MRI C扩展的（非常）快速概述：Ruby对象在C中由VALUE结构表示，该VALUE结构包含有关该对象的所有相关信息。预先定义了一些“标准”值，例如true，false和nil以及其他一些值，可以将它们测试为Qnil，Qtrue等。Ruby方法可以直接在C中调用（如果Ruby方法本身是在C中定义的） ）或使用rb_funcall（）C函数。</p><p> Using the scheduler is obviously only possible if it has been defined for the current thread with  Fiber#set_scheduler. To check if this is the case in a C extension, we can use the  rb_scheduler_current() C function, which will return a  VALUE containing either the current scheduler or  Qnil if it hasn’t been set. If the scheduler is set, it is possible to call with one of the available functions that are defined in  scheduler.c in the main folder of the Ruby repo. Finally as a complete example, let’s look at how the  Ruby standard library implements this pattern:</p><p> 显然，只有在使用Fiber＃set_scheduler为当前线程定义了调度程序后，才能使用调度程序。要检查C扩展名是否属于这种情况，我们可以使用rb_scheduler_current（）C函数，该函数将返回一个包含当前调度程序或Qnil的VALUE（如果尚未设置）。如果设置了调度程序，则可以使用Ruby存储库主文件夹中scheduler.c中定义的可用函数之一进行调用。最后，作为一个完整的示例，让我们看看Ruby标准库如何实现此模式：</p><p> int rb_io_wait_readable( int f)  {   VALUE scheduler = rb_scheduler_current();    if (scheduler != Qnil) {    return RTEST(   rb_scheduler_io_wait_readable(scheduler, rb_io_from_fd(f))   );   }      // rest of function for if no scheduler was defined  }</p><p> int rb_io_wait_read（int f）{值调度程序= rb_scheduler_current（）; if（scheduler！= Qnil）{返回RTEST（rb_scheduler_io_wait_read（scheduler，rb_io_from_fd（f）））; } //如果未定义调度程序，则其余功能}</p><p> This snippet also demonstrates how to get a Ruby  IO object out of a file descriptor: with  rb_io_from_fd().</p><p> 此代码段还演示了如何使用rb_io_from_fd（）从文件描述符中获取Ruby IO对象。</p><p>  The current implementation does still have some drawbacks. For one, fibers are thread-local and cannot be moved between threads (yet). (For the purposes of this paragraph, you can also read “Ractor” wherever I wrote “thread”.) This means that any system that wants to scale beyond a single thread will have to run multiple threads, each with their own scheduler. If there is an imbalance between the duration of the fiber tasks, it is possible that some threads will have run through their entire work queue and be idle while other threads still have a surplus of work. This would limit the throughput of the system since not all resources are properly utilized. Languags like Haskell and Go solve this issue by “work stealing”, where threads without any work to do can “steal” work from the run queues of other schedulers. This issue can be worked around somewhat by having a global  Queue (or intermediate “pipe” Ractor) that distributes work items, but this only works for coarser items like entire HTTP requests or background jobs. Once a request or background job has been started on a certain thread it will stay there forever.</p><p>  当前的实现方式仍然存在一些缺陷。例如，光纤是线程局部的，不能在线程之间移动。 （出于本段的目的，无论我在何处编写“线程”，您都可以阅读“ Ractor”。）这意味着任何要扩展到单个线程之外的系统都必须运行多个线程，每个线程都有自己的调度程序。如果光纤任务的持续时间之间存在不平衡，则某些线程可能会在其整个工作队列中运行并处于空闲状态，而其他线程仍然有多余的工作。由于并非所有资源都得到适当利用，这将限制系统的吞吐量。诸如Haskell和Go这样的Languags通过“窃取工作”来解决此问题，无需执行任何工作的线程就可以从其他调度程序的运行队列中“窃取”工作。通过使用全局队列（或中间“管道” Ractor）来分配工作项，可以在某种程度上解决此问题，但这仅适用于较粗的项目，例如整个HTTP请求或后台作业。一旦在某个线程上启动了请求或后台作业，它将永远存在。</p><p> Another drawback (for POSIX systems only) is that “non-blocking” I/O can actually still block sometimes! While you can set any file descriptor to non-blocking mode, only those file descriptors that represent sockets and pipes will ever return EWOULDBLOCK. A file descriptor representing an actual file on a filesystem will never return EWOULDBLOCK, even if the file is on a network filesystem on the other side of the world and will very much block. This is more a POSIX problem and not unique to Ruby, but is still something to watch out for. The fiber scheduler C interface file does provide for  asynchronous read and write operations which could be backed by “real” asynchronous I/O operations like  io_uring on Linux or IO Completion Ports on Windows. However those functions are as of yet undocumented, so it is unclear if and how they are meant to be used. There are also many more syscalls that can block (such as  unlink()-ing a file on a slow filesystem) that are not yet covered by the available asynchronous operations.</p><p> 另一个缺点（仅适用于POSIX系统）是“非阻塞” I / O实际上有时仍会阻塞！虽然可以将任何文件描述符设置为非阻塞模式，但是只有那些表示套接字和管道的文件描述符才会返回EWOULDBLOCK。代表文件系统上实际文件的文件描述符将永远不会返回EWOULDBLOCK，即使该文件位于世界另一端的网络文件系统上并且也会阻塞很大。这更多是一个POSIX问题，并非Ruby独有，但仍需提防。光纤调度程序C接口文件确实提供了异步读写操作，这些操作可以由“真正的”异步I / O操作（例如Linux上的io_uring或Windows上的IO完成端口）支持。但是这些功能尚未记录，因此尚不清楚是否以及如何使用它们。还有更多的系统调用可能尚未被可用的异步操作覆盖（例如，对慢速文件系统上的文件进行unlink（）锁定）。 </p><p> Finally, the main drawback of the fiber scheduling mechanisms is that at the time of writing (end of Dec 2020) no production-ready fiber schedulers have been released yet! I am aware of the   evt library but could not get it to install, although that might be because the  liburing library on my machine is broken at the moment due to work on another project involving it. Some people on Reddit were also speculating that a scheduler based on the  async framework might be in the works, but no news seems to be available as of yet. Lastly, there is a toy scheduler based on  IO.select available in the test suite of MRI but it seems to be broken as it can try to resume fibers that have already finished. The current unavailability of a good scheduler also means that at the moment we cannot have a default scheduler already initialised on program startup, it must be imported from a gem and activated with  Fiber#set_scheduler.</p><p>最后，光纤调度机制的主要缺点是，在撰写本文时（2020年12月结束），尚未发布可用于生产的光纤调度器！我知道evt库，但无法安装它，尽管那可能是因为由于涉及该项目的另一个项目而导致我的计算机上的库现在被破坏了。 Reddit上的一些人还推测基于异步框架的调度程序可能正在开发中，但到目前为止似乎尚无消息。最后，在MRI测试套件中有一个基于IO.select的玩具调度程序，但是它似乎已损坏，因为它可以尝试恢复已经完成的纤维。良好的调度程序当前不可用，这也意味着目前我们还不能在程序启动时初始化默认调度程序，因此必须从gem导入默认调度程序，并使用Fiber＃set_scheduler对其进行激活。</p><p> ERRATA: I was corrected in the Reddit comments by /u/ioquatix, the creator of the  async series of gems and initiator of the FiberScheduler interface in MRI. It turns out that  async already includes  a functional, production-grade scheduler that can be used as soon as today.</p><p> 勘误表：/ u / ioquatix在Reddit注释中对我进行了更正，/ u / ioquatix是宝石异步系列的创建者，也是MRI中FiberScheduler接口的发起者。事实证明，异步已经包括一个功能强大的生产级调度程序，该调度程序可在今天立即使用。</p><p>  I think the interface for fiber schedulers is extremely interesting. It enables highly scalable IO-bound systems in Ruby, while still providing developers with a nice programming model free of callbacks and async/await style “colored” functions. You simply write your fiber code in the usual straightforward way and the scheduler will manage all your fibers in an efficient manner, parking them somewhere out of the way when they block and retrieving them as soon as they can resume again. A very Ruby-like approach, designed to keep programmers happy.</p><p>  我认为光纤调度程序的接口非常有趣。它在Ruby中启用了高度可扩展的IO绑定系统，同时仍为开发人员提供了一个不错的编程模型，其中没有回调和异步/等待样式的“彩色”函数。您只需以通常简单明了的方式编写光纤代码，调度程序将以高效的方式管理您的所有光纤，在它们阻塞时将它们停放在某个地方，并在它们可以再次恢复时立即进行检索。一种非常类似于Ruby的方法，旨在使程序员满意。</p><p> In this first iterations there are still several properties of the system that could be improved upon, such as “work stealing” of fibers between threads and/or Ractors, the addition of a default scheduler, and expansion of the available asynchronous operations. The available documentation is also not very thorough yet. Still, as these systems get used more widely, we will see most of the issues shake out. It will be interesting to see how Ruby evolves!</p><p> 在第一个迭代中，系统的一些属性仍可以改进，例如线程和/或Ractor之间的光纤“窃取工作”，添加默认调度程序以及扩展可用的异步操作。可用的文档还不是很完整。尽管如此，随着这些系统的广泛使用，我们将看到大多数问题都消失了。看看Ruby是如何发展的将会很有趣！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://www.wjwh.eu/posts/2020-12-28-ruby-fiber-scheduler-c-extension.html">http://www.wjwh.eu/posts/2020-12-28-ruby-fiber-scheduler-c-extension.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ruby/">#ruby</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/调度/">#调度</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>