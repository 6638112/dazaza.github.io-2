<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>SCons并不慢</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">SCons并不慢</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-09-20 03:30:26</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/9/f6424bd250735f3a5add866375a3a035.png"><img src="http://img2.diglog.com/img/2020/9/f6424bd250735f3a5add866375a3a035.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>在互联网上四处看看，可以找到很多地方，人们抱怨SCons速度慢得可怕，以至于(对他们)无法使用。其中最突出的似乎是埃里克·梅尔斯基(Eric Melski)的一系列博客文章：</p><p>那么什么是真的呢？SCon在大型构建上速度慢吗？这到底是什么时候发生的，为什么呢？</p><p>为了可能回答其中一些问题，我开始了自己的调查。这意味着在各种条件下运行大量SCons构建，并记录和评估结果。</p><p>在我的第一部分调查中，我集中精力打破了SCons&#39；任务负责人会表现出二次时间复杂性行为的神话。我的基本方法是将给定基准项目的C/CPP文件数量增加一倍，然后比较分析输出。我认为一个设计糟糕的任务主管会导致任务部分的运行时间大大增加。</p><p>以下讨论的所有结果都可以作为HG(Mercurial)repo从http://www.bitbucket.org/dirkbaechle/scons_testresults.下载。在不同的文件夹中，您可以找到原始结果数据和用于运行示例的脚本。注意readme.rst或overview.rst文件，它们包含一些有关事物如何工作以及单个子目录包含哪些内容的附加信息。</p><p>此外，我创建了一个单独的SCons测试套件，可从http://www.bitbucket.org/dirkbaechle/scons_testsuite.获得。它包括几个真实的项目、控制脚本，以及用于运行所有计时和概要分析的支持sstest包。</p><p>本节介绍在单核上运行时SCons线性缩放行为的结果。我的意思是：&#34；当源文件的数量在每一步增加一倍时会发生什么？</p><p>对于本节中的所有测试和加速比较，我使用以下计算机设置</p><p>这是Eric Melski在比较SCons和make时使用的原始脚本。我另外下载了SConsv1.2.0的稳定版本并安装了它，只是为了确保我尽可能接近他的设置。</p><p>可以在scons_testresult存储库的scons120_vs_make文件夹中找到完整的结果集。</p><p>为了进行更好的比较，下面是Eric Melski First(通过pastebin发布的)的原始结果数据。</p><p>我将我自己的一系列构建作为&#34；Clean build&#34；(从头开始)、&#34；update&#34；和&#34；Impline-deps-untified update&#34；运行(仅对于SCON，使用命令行选项--max-drift=1--impline-deps-untified)。在这样做的同时，项目大小从2,500到16500个C文件不等。</p><p>测量的时间并不像声称的那样显示出戏剧性的二次增长。您肯定会注意到X轴的缩放方式不同。这是因为如果我的机器不开始交换内存，我无法达到更高数量的C文件。在最多16500个C文件的情况下，SCON需要大约1 GB的内存才能进行干净的构建，并且还会运行更新。我总共2 GB的其余部分都被操作系统拿走了，这让我想知道埃里克·梅尔斯基是如何获得这么多文件的。通过让机器自由更换吗？这将解释构建时间的增加，从他的数据中大约20000个C文件开始。</p><p>另一件事是，如果可以看到整个过程的二次型行为，我希望至少有一个模块或函数表现出O(n**2)行为或更糟的行为。我的意思是，如果发现了一个设计缺陷，它不应该影响整个程序/框架，而是只影响其中的一部分，比如一个模块或单个函数。然后，此错误将随文件数量呈指数增长，并拖累SCons的整体性能。</p><p>因此，我使用cProfile.py对两个项目大小d(8500个文件)和e(16500个文件)进行了完整的性能分析运行。您将在repo中找到完整的结果，其中包含所有的计时、内存消耗和pstats文件。以下是更新运行的性能分析结果：</p><p>这对于每个函数中的运行时间百分比没有显示出任何显著的差异或增加。</p><p>正如我后来的实验所显示的那样(参见下面的继续分析一节)，文件的数量仍然太少，无法产生实际效果并产生清晰可见的凹凸不平的效果。</p><p>将旧的v1.2.0与最新的v2.3.0版本(参见scons_testresult repo中的scons230_vs_make/genscons文件夹)进行比较，并未显示出运行时行为上的任何重大差异(请参阅scons_testresult repo中的scons230_vs_make/genscons文件夹)。因此，对于其余的测试，我决定从最新开发切换到当前版本。</p><p>我选择了SCons主干的修订版0c9c8aff8f46。这意味着我们谈论的是稳定的2.3.0版本，以及2.3.1版本的一些额外补丁(就在替换文档工具链之后)。</p><p>这是诺埃尔·洛皮斯(Noel Llopis)在他的“追求表演”(Quest For Performance)系列中使用的脚本。我从网站上下载了它，并禁用了除SCons和Make之外的所有其他竞争对手。</p><p>项目大小分别为5,000、10000、12500和15000个cpp文件。所有结果都可以在scons230_vs_make/questfperf/run_Original文件夹中找到。</p><p>然后，我使用相同数量的源文件运行来自WENDBUILD基准测试的示例脚本。</p><p>至于Melski系列，这两个额外的基准测试都没有显示出严格的二次缩放(我仍在调查一个干净构建的奇妙构建结果中的钩子从何而来)。然而，make和scons的时代差异相当大。</p><p>主要原因是源文件实际上是空的，因此编译器没有任何事情可做。因此，显示的时间提供了有关每个构建系统所需的管理开销的线索。但是如果我编译大约10000个cpp文件，我肯定不会期望2到3分钟的构建时间。</p><p>我尝试通过添加一些实际在执行任务的函数并在某种程度上使用STL来进行更真实的比较：</p><p>/Header：/#ifndef class_0_h_#定义class_0_h_#include&lt；string&gt；#include&lt；Vector&gt；class class_0{public：class_0()；~class_0()；class_0(const class_0&amp；elem)；class_0&amp；Operator=(const class_0&amp；elem)；void addData(const std：：string&amp；value)；void clear()；私有：std：：Vector&lt；std：：string&gt；Data；}；#endif/来源：/#include&#34；class_0.h&#34；&lt；其他几个包括&gt；使用命名空间std；class_0：：class_0(){}class_0：：~class_0(){}class_0：：class_0(const class_0&amp；elem){data=elem。Data；}class_0&amp；class_0：：Operator=(const class_0&amp；elem){if(&amp；elem==this){return*this；}data=elem。Data；return*this；}void class_0：：clear(){data。Clear()；}void class_0：：addData(常量字符串&amp；值){数据。PUSH_BACK(值)；}。</p><p>有了这些打了补丁的类，我又运行了另一个系列，用于性能探索和奇妙构建基准测试。</p><p>。完整的结果集可以分别在scons230_vs_make/questfperf和scons230_vs_make/waldbuild的run_patching文件夹中找到。</p><p>这些图显示了当构建步骤有一些实际负载时，make和SCons时间如何收敛。</p><p>幸运的是，我可以在一周内使用两台不同的多核机器。因此，我抓住机会，编写了一些脚本，并在启用了并行&#34；-j&34；选项的情况下运行了完整系列的SCons/make构建。我的目标是找出SCons在并行构建时是否存在任何可伸缩性问题。</p><p>您可以在scons230_vs_make/parallel文件夹及其子目录中找到所有结果和加速比图表。请阅读自述文件/overview.rst文件以获得更好的概述。</p><p>大体上，结果表明SCons和make的并行加速比相当，下面是两个示例图。第一个是在四核计算机上运行的，左侧显示了对性能的追求结果，右侧显示了加速的奇妙构建结果：(#34；Quest for Performance&#34；Quest for Performance&#34；Quest Response for Performance&#34；Quest Effedup)：</p><p>我在octa核心机器上重复了相同的实验，但是线程数在1到12之间(同样，图&#34；WENDBUILD&#34；图在右边)：</p><p>作为这些图表背后实际情况的一个例子，这里是OCTA核心系统上的WellBuild基准测试从-j1到-j12的完整单次运行数组：</p><p>到目前为止，我们已经看到SCons的表现并没有那么糟糕，我的意思是，它的规模似乎相当不错。对我来说，这表明我们的任务负责人做得很好(尽管大家都这么认为)，而且我们的源代码中没有更普遍的问题，即二次或更高的复杂性会造成严重破坏。不过，更新时间可能会稍短一些，这就提出了一些问题。</p><p>有什么需要改进的地方吗？我在互联网上搜索，收集了一些使用SCons作为构建系统的开源项目。添加了上面的基准测试，我编译了一个小型测试套件，用于计时和分析不同的修订。这使得更容易辨别代码更改是否真的提高了性能，以及在哪些部分提高了性能。</p><p>Http://www.bitbucket.org/dirkbaechle/scons_testsuiteIf如果您有足够的兴趣尝试一下，请查阅顶层文件夹中的Readme.rst文件以了解其工作原理。</p><p>免责声明：它目前不是处处运行，而是专门为我自己的Ubuntu Linux机器量身定做的。因此，如果您试图自己开始这些示例，请准备好遇到一些陷阱。您可能需要调整控制脚本，甚至需要为软件包本身打补丁……包括作为先决条件安装特殊软件包。</p><p>通过这个测试套件，我描述了上面提到的SConsv2.3.0的0c9c8aff8f46修订版，以便有一些数字可供参考。我不会详细介绍所有不同的性能分析和结果图表，您只需自己查看testResults/default文件夹即可。</p><p>通常，SCons的运行时间分布在许多不同的模块和函数上，因此很难确定适合优化的单个位置。然而，通过循环修补源代码和重新运行测试，我发现了两个地方，在我看来，有两个地方在错误的事情上花费了大量时间。至少这是我们可以腾出几个周期的地方，特别是对于具有大量C/CPP文件的大型项目：</p><p>默认C/CPP构建器中的程序、对象和库的前缀和后缀被设置为变量。例如src/engine/scons/tool/__init__.py，ll中的Program Builder。196，使用：</p><p>这意味着每次建立相应的目标时，它们都必须被替换。</p><p>与此有点相关的是我们在指定C/CPP源文件时提供的灵活性。通过添加用于文件后缀的不同扫描仪的大列表，</p><p>CSuffiches=[&#34；.C&#34；，&#34；.C&#34；，&#34；.cxx&#34；，&#34；.c++&#34；，&#34；.cc&#34；，&#34；.h&#34；，&#34；.h&#34；，&#34；.hxx&#34；，&#34；.hpp&#34；，&#34；.hpp&#34；，&#34；.hh&#34；，&#34；.f&#34；，&#34；.fpp&#34；，&#34；.fpp&#34；，&#34；.m&#34；，&#34；.mm&#34；，&#34；.S&#34；，&#34；.spp&#34；，&#34；.SPP&#34；，&#34；.sx&#34；]。</p><p>，src/engine/scons/tool/__init__.py，ll.。64，我们必须对照它们检查我们遇到的每个源文件。当用户知道他只有CPP文件要处理时，根本不需要检查FORTRAN...所以我的改进想法是：</p><p>以同样的方式，将可能的源文件后缀的数量限制为可自定义的扩展名，如&#34；.cpp&#34；。这些观察结果导致了另一个名为&#34；fast cpp&#34；的外部工具的开发。它列在工具索引中，可以加载到正常的C/CPP构建环境之上。</p><p>但要注意警告：它仍处于非常实验性的状态，可能还没有准备好进行生产工作！</p><p>下图显示了使用fast cpp工具针对make更新SCons的时间：</p><p>快速cpp构建器的所有结果和脚本都可以在文件夹scons_testresult/scons230_trace/fast cpp中找到。</p><p>Http://blog.melski.net/2013/12/11/update-scons-is-still-really-slow/，I最终能够在一台内存为8 GB的更大的机器上重现他的结果。下面的图表都基于基准测试的简化版本，其中实际的编译器和链接器调用被&#34；echo&#34；命令替换。这意味着程序和基准的运行时间更快，同时仍显示相同的基本行为。</p><p>我检查了两个Python解释器，因为我在Internet上发现了一些通知，说明PyPy不会遇到与CPython相同的内存重新分配问题。事实证明，这在一定程度上是正确的，而且PyPy的运行时增加明显较少……但它仍然存在。</p><p>Https://mail.python.org/pipermail//portland/2011-August/001132.html，，并尝试禁用垃圾收集器以执行完整的SCon运行。但这并没有任何帮助，反而使运行时变得更糟……。</p><p>正如Eric在分析过程中发现的那样，SCons会花费大量时间在与系统调用相关的方法上，比如waitpid和fork。因此，我开始仔细观察内部结构，用strace追踪整个运行过程。结果(参见scons_testresult存储库中的scons230_trace/strace和strace_orig_logs文件夹)似乎暗示CPython内存分配的realloc或内核中的Futex管理存在问题。在比较strace记录的单个系统调用的运行时间时，mremap和set_Robust_list两个方法在构建期间线性地增加了它们的运行时间(同时内存使用量增加)。</p><p>下图显示了两个单独的编译命令(第一个、第二个)在所需的syscall次数上的累计时间差异。虽然第一个图表是在构建开始时(在前十个目标内)捕获的，但第二个评估接近尾声：</p><p>它显示了在整个项目的构建过程中，单个编译所需的时间是如何增加的。因此，我修补了SCons源代码，这样就不会产生shell/进程，而只会通过在Python中直接访问目标文件来创建它们。</p><p>#HG变更集补丁#parent d53323337b3accbe3b88280fd0597580a1b5e894 diff-r d53323337b3a-r 1fc40f790145 src/engine/scons/Action.py-a/src/engine/scons/Action.py Sun Jan 05 13：27：10 2014+0100+b/src/engine/scons/Action.py清华1月09 09：16：10 2014+0100@@-801，17+801，22@source=ecutor.get_all_source()cmd_list(忽略，无提示)=self.process(target，list(rfile，source))，env，+b/src/engine/scons/Action.py清华1月09：16：10 2014+0100@@-801，17+801，22@source=ecutor.get_all_source()cmd_list(目标，列表(rfile，source))，env，+b/src/engine/scons/Action.py。Executor)+for t in target：+tf=open(str(T)，&#34；W&#34；)+tf.write(&#34；\n&#34；)+tf.close()+#使用len()筛选出长度为零的任何&#34；命令&#34；。-对于过滤器中的cmd_line(len，cmd_list)：-#退出我们正在使用的解释器的命令行。-cmd_line=ESCAPE_LIST(cmd_line，ESCUE)-result=spawn(shell，ESCRINE，cmd_line[0]，cmd_line，ENV)-如果不是，则忽略并结果：-msg=&#34；error%s&#34；%result-return SCons.Errors.BuildError(errstr=msg，-status=result，-action=self，-command=cmd_line)+#for cmd_line in filter(len，cmd_list)：+##转义我们正在使用的解释器的命令行。+#cmd_line=ESCAPE_LIST(cmd_line，ESCUE)+#result=spawn(shell，ESCRY，cmd_line[0]，cmd_line，ENV)+#如果不这样做，忽略和结果：+#msg=&#34；%result+#return SCons.Errors.BuildError(errstr=msg，+#status=result，+#action=self，+#command=cmd_line)return 0 def get_presig(self，target，source，env，Executor=NONE)：</p><p>然后，我再次运行了完整的基准测试，结果如下(同样，CPython位于左侧，PyPy位于右侧)：</p><p>与上面的结果相比，这些曲线清楚地显示了通过产卵shell并等待进程完成而带来的大量开销。SCons本身(查找/处理任务、跟踪构建签名、扫描隐式依赖项)的伸缩性似乎很好。</p><p>受Trevor Highland和他在http://blog.melski.net/2013/12/11/update-scons-is-still-really-slow/，中的评论的启发，我编写了这个小Python脚本，它可以快速连续地生成单个进程。通过同时分配越来越多的内存，单个进程调用的运行时似乎会增长。</p><p>Import os import sys perc=&#39；%&#39；def main()：Cycle=25000 append=True if len(sys.。Argv)&gt；1：Cycle=int(sys.。Argv[1])if len(sys.。Argv)&gt；2：APPEND=FALSE PRINT&#34；STARTING%d CLOCES m_LIST=[]cnt=0 for i in xrange(Cycle)：cnt+=1 args=[&#39；ECHO&#39；，&#39；%d/%d(%.2f%s)&#39；%(cnt，Cycle，Float(Cnt)*100.0/Float(Cycle)，perc)]os。Spawnvpe(os.。P_WAIT、args[0]、args、os。环境)签名=&#39；A&#39；*20000，如果附加：M_LIST。追加(签名)打印&#34；完成。&#34；如果__名称__==&#34；__Main__&#34；：Main()。</p><p>然后，我将其重写为一个C程序，再次尝试模仿SCons重复构建目标，然后在内存中收集构建信息的基本过程：</p><p>#include&lt；stdio.h&gt；#include&lt；stdlib.h&gt；#include&lt；unistd.h&gt；#include&lt；string.h&gt；#DEFINE MAXCYCLES 32000#DEFINE SIGLEN 20000 INT Main(int argc，char**argv){int cnt=0；int Cycle=MAXCYCLES；char ECHO_ARG[100]；PID_t CHILD_PID；INT CHILD_STATUS；IF(argc&gt；1){cycles=argi(v[1])；IF(Cycle&gt；MAXCYCLES){Cycle=MAXCYCLES；printf(&#34；Warning：将周期数设置为内部最大值%d！&#34；，MAXCYCLES)；}}printf(&#34；开始%d个周期...。\n&#34；，Cycle)；char*m_list[MAXCYCLES]；对于(；cnt&lt；Cycle；++cnt){spintf(ECHO_ARG，&#34；%d/%d(%.2f%%)&#34；，cnt，Cycle，((双)cnt)*100.0/((双)周期))；printf(&#34；%s\n&#34；，ECHO_ARG)；CHILD_PID=fork()；If(Child_pid==0){/*这是由子进程完成的。*/execlp(&#34；ECHO&#34；，ECHO_ARG，NULL)；/*如果execvp返回，则一定是失败了。*/printf(&#34；未知命令\n&#34；)；exit(0)；}Else{/*这由父级运行。等待孩子终止妊娠。*/WHILE(WAIT(&amp；CHILD_STATUS)！=CHILD_PID)；}m_LIST[cnt]=malloc(SIGLEN*sizeof(Char))；strcpy(m_list[cnt]，echo_arg)；}printf(&#34；完成。\n&#34；)；}。</p><p>在我的机器上，后一个C程序的运行时间(使用/usr/bin/time测量)为：</p><p>周期|运行时间-2000年|0：01.694000|0：04.048000|0：10.7216000|0：32.5132000|1：46.85</p><p>因此，虽然每一步的周期数(产生的进程)都会翻倍，但运行时间并不随之线性扩展。</p><p>我在kernel-dev邮件列表和glibc-help上询问了这个问题。内核列表没有提供任何答案(事后看来，这是一个错误的论坛)，但一些glibc用户在以下帖子中提供了非常有用的建议和见解：</p><p>非常感谢茨维坦·米科夫(Tzvetan Mikov)，他自愿在代码中找到了Fork做坏事的地方：</p><p>这发生在内核中：fork()需要复制父进程的所有页表条目，因此根据定义，它的成本与地址空间的大小成正比。我不认为这有什么神秘之处，除非我遗漏了什么(我很可能遗漏了)--它需要为每4K页的地址空间做一些工作。您可以检查内核源代码中的内核/fork.c：dup_mmap()和mm/ememy.c：copy_page_range()(例如，在http://lxr.free-electrons.com/source/kernel/fork.c)&#34；同时，Jason Kenny(英特尔，巴黎)周围的部件团队报告也遇到了类似的性能问题：</p><p>Http://two.pairlist.net/pipermail/scons-dev/2014-April/001263.htmlThey写了一个包装纸。</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/SCons/scons/wiki/WhySconsIsNotSlow">https://github.com/SCons/scons/wiki/WhySconsIsNotSlow</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/scons/">#scons</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>