<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>让我们构建一个全文搜索引擎</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">让我们构建一个全文搜索引擎</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-08-05 00:52:01</div><div class="page_narrow text-break page_content"><p>全文搜索是人们在不知不觉中每天使用的工具之一。如果您曾经在谷歌上搜索过覆盖报告，或者试图在电子商务网站上查找室内无线摄像头，那么您使用的是某种全文搜索。</p><p>全文搜索(FTS)是一种在文档集合中搜索文本的技术。文档可以指网页、报纸文章、电子邮件消息或任何结构化文本。</p><p>今天，我们将构建我们自己的FTS引擎。到本文结束时，我们将能够在不到1毫秒的时间内搜索数百万个文档。我们将从简单的搜索查询(如)开始，给出所有包含单词cat；的文档，然后我们将扩展引擎以支持更复杂的布尔查询。</p><p>最著名的FTS引擎是Lucene(以及构建在其之上的Elasticsearch和Solr)。</p><p>在我们开始编写代码之前，您可能会问，我们不能只使用grep吗？或者使用一个循环来检查是否每个文档都包含单词“我正在寻找？”。是的，我们可以。然而，这并不总是最好的主意。</p><p>我们要搜索英文维基百科摘要的一部分。最新的转储可以在dumps.wikimedia.org上找到。截至今天，解压缩后的文件大小为913MB。XML文件包含600K多个文档。</p><p>&lt；title&gt；维基百科：Kit-Cat Klock&lt；/Title&gt；&lt；url&gt；https://en.wikipedia.org/wiki/Kit-Cat_Klock&lt；/url&gt；&lt；抽象&gt；Kit-Cat Klock是一个装饰艺术的新奇挂钟，形状像一只咧嘴笑的猫，卡通的眼睛随着它的摆尾随时间旋转。&lt；/摘要&gt；</p><p>首先，我们需要从转储中加载所有文档。内置的编码/XML包非常方便：</p><p>Import(&#34；coding/xml&#34；&#34；os&#34；)类型文档结构{标题字符串`xml：&#34；title&#34；`URL字符串`xml：&#34；url&#34；`文本字符串`xml：&#34；摘要&#34；`ID int}func loadDocuments(路径字符串)([]document，error){f，err：=os。如果err！=nil{return nil，err}延迟f，则打开(路径)。Close()dec：=xml。NewDecoder(F)dump：=struct{Documents[]document`xml：&#34；doc&#34；`}{}if err：=dec。解码(&amp；dump)；err！=nil{return nil，err}docs：=dump。I：=范围文档{docs[i]的文档。Id=i}退回单据，空}。</p><p>每个加载的文档都分配了一个唯一的标识符，为了简单起见，第一个加载的文档分配ID=0，第二个分配ID=1，依此类推。</p><p>现在我们已经将所有文档加载到内存中，我们可以尝试查找关于猫的文档。首先，让&#39；循环遍历所有文档并检查它们是否包含子字符串cat：</p><p>函数搜索(docs[]document，术语字符串)[]document{var r[]document for_，doc：=range docs{if string。包含(文档。Text，term){r=追加(r，doc)}}返回r}。</p><p>在我的笔记本电脑上，搜索阶段耗时103ms--不算太差。如果你从输出中抽查几个文档，你可能会注意到，该函数与caterpillar和类别相匹配，但与Cat的大写字母C不匹配。这不完全是我要找的。</p><p>在单词边界而不是子字符串上匹配(因此caterpillar和Communication不匹配)。</p><p>一种快速浮现并允许实现这两个需求的解决方案是正则表达式。</p><p>\B匹配单词边界(一边是单词字符，另一边不是单词字符的位置)</p><p>函数搜索(docs[]document，词汇字符串)[]document{re：=regexp。MustCompile(`(？i)\b`+Term+`\b`)//不要在生产中这样做，这会带来安全风险。学期需要清理一下。Var r[]document for_，doc：=范围文档{如果是。MatchString(文档。Text){r=追加(r，doc)}}返回r}。</p><p>啊，搜索花了两秒钟多的时间。如您所见，即使有600K的文档，事情也开始变慢。虽然这种方法很容易实现，但它没有很好的伸缩性。随着数据集变得越来越大，我们需要扫描越来越多的文档。该算法的时间复杂度是线性的--需要扫描的文档数量等于文档总数。如果我们有600万个文档，而不是600K，搜索将需要20秒。我们需要做得更好。</p><p>为了使搜索查询更快，我们将对文本进行预处理，并提前建立索引。</p><p>FTS的核心是一种称为倒排索引的数据结构，倒排索引将文档中的每个单词与包含该单词的文档相关联。</p><p>文档={1：&#34；玻璃盘上的甜甜圈&#34；，2：&#34；只有甜甜圈&#34；，3：&#34；听鼓机&#34；，}index={&#34；a&#34；：[1]，&#34；甜甜圈&#34；：[1，2]，&#34；on&#34；：[1]，&#34；玻璃&#34；：[1]，&#34；板材&#34；：[1]，&#34；仅&#34；：[2]，&#34；&#34；：[2，3]，&#34；收听&#34；：[3]，&#34；至&#34；：[3]，&#34；鼓&#34；：[3]，&#34；机器&#34；：[3]，}。</p><p>下面是倒排索引的真实示例。书中术语引用页码的索引：</p><p>在开始构建索引之前，我们需要将原始文本分解成适合索引和搜索的单词(标记)列表。</p><p>标记器是文本分析的第一步。它的工作是将文本转换为令牌列表。我们的实现在单词边界上拆分文本并删除标点符号：</p><p>函数标记化(文本字符串)[]string{返回字符串。FieldsFunc(text，func(R Rune)bool{//拆分不是字母或数字的任何字符。回来！Unicode。IsLetter(R)&amp；&amp；！Unicode。IsNumber(R)})}。</p><p>将玻璃盘上的甜甜圈标记化(&gt；tokenize(&gt；tokenize))。仅限甜甜圈。&#34；)[&#34；A&#34；，&#34；甜甜圈&#34；，&#34；上&#34；，&#34；，&#34；玻璃&#34；，&#34；盘子&#34；，&#34；仅&#34；，&#34；甜甜圈&#34；，&#34；]。</p><p>在大多数情况下，仅将文本转换为令牌列表是不够的。为了使文本更容易索引和搜索，我们需要进行额外的规范化。</p><p>为了使搜索不区分大小写，小写过滤器将令牌转换为小写。猫、猫和猫被规范化为猫。稍后，当我们查询索引时，我们也会将搜索词小写。这将使搜索词CAT与文本Cat匹配。</p><p>Func lowercaseFilter(tokens[]string)[]string{r：=make([]string，len(Tokens))for i，Token：=Range Tokens{r[i]=string。Tolower(Token)}返回r}。</p><p>&gt；lowercaseFilter([]string{&#34；A&#34；，&#34；甜甜圈&#34；，&#34；上的&#34；，&#34；，&#34；玻璃&#34；，&#34；盘子&#34；，&#34；仅&#34；，&#34；&#34；，&#34；甜甜圈&#34；})[&#34；a&#34；，&#34；甜甜圈&#34；，&#34；上的&#34；，&#34；，&#34；玻璃&#34；，&#34；板&#34；，&#34；仅&#34；，&#34；上的&#34；，&#34；甜甜圈&#34；]。</p><p>几乎所有的英文文本都包含像a、i、the或be这样的常用单词。这样的话被称为“停用词”。我们将删除它们，因为几乎所有文档都会匹配停用字词。</p><p>没有官方的停用词列表。让我们按照OEC排名排除前10名。您可以随时添加更多内容：</p><p>Var stopwords=map[string]struct{}{//我希望Go有内置的集合。&#34；a&#34；：{}，&#34；和&#34；：{}，&#34；为&#34；：{}，&#34；具有&#34；：{}，&#34；i&#34；：{}，&#34；位于&#34；：{}，&#34；中：{}，&#34；那个&#34；：{}，&#34；&#34；：{}，&#34；到&#34；：{}，}func stopwordFilter(tokens[]string)[]string{r：=make([]string，0，len(Tokens))for_，Token：=Range Tokens{if_，ok：=stopwords[Token]；！确定{r=追加(r，Token)}}返回r}。</p><p>&gt；stopwordFilter([]string{&#34；a&#34；，&#34；甜甜圈&#34；，&#34；上的&#34；，&#34；，&#34；玻璃&#34；，&#34；盘&#34；，&#34；仅&#34；，&#34；甜甜圈&#34；})[&#34；甜甜圈&#34；})[&#34；甜甜圈&#34；})[&#34；甜甜圈&#34；，&#34；在&#34；，&#34；玻璃&#34；，&#34；盘子&#34；，&#34；上仅&#34；，&#34；甜甜圈&#34；]。</p><p>由于语法规则的原因，文档可能包含同一单词的不同形式。模版将单词缩减为其基本形式。例如，垂钓、捕捞和捕捞可能会被简化为基型(茎)鱼。</p><p>实现词干分析器不是一件微不足道的任务，这篇文章中没有涉及到这一点。我们将选择现有模块之一：</p><p>为i导入Snowball Eng&#34；github.com/kljensen/snowball/english&#34；Func stemmerFilter(Tokens[]String)[]String{r：=Make([]String，len(Tokens)，Token：=范围令牌{r[i]=Snowball Eng。STEM(TOKEN，FALSE)}返回r}。</p><p>词干并不总是有效的单词。例如，一些干枝可能会将航空公司减少到航空公司。</p><p>Func Analyze(文本字符串)[]string{tokens：=tokenize(文本)tokens=lowercaseFilter(Tokens)tokens=stopwordFilter(Tokens)tokens=stemmerFilter(Tokens)返回令牌}。</p><p>&gt；分析(玻璃盘上的甜甜圈。仅限甜甜圈。&#34；)[&#34；甜甜圈&#34；，&#34；上&#34；，&#34；，&#34；盘子&#34；，&#34；仅&#34；，&#34；甜甜圈&#34；]</p><p>回到倒排索引。它将文档中的每个单词映射到文档ID。内置映射是存储映射的理想候选。映射中的键是令牌(字符串)，值是文档ID列表：</p><p>构建索引包括分析文档并将其ID添加到地图中：</p><p>函数(idx索引)add(docs[]document){for_，doc：=范围文档{for_，Token：=范围分析(doc.。Text){ids：=idx[Token]if ids！=nil&amp；&amp；ids[len(Ids)-1]==doc。ID{//不要添加同一ID两次。CONTINUE}IDX[TOKEN]=APPEND(ID，doc.。Id)}func main(){idx：=make(Index)idx。在玻璃盘上添加([]文档{{ID：1，text：&#34；一个甜甜圈。只有甜甜圈。&#34；})IDX。添加([]文档{{ID：2，text：&#34；Donut is a Donut&#34；}})fmt。Println(IDX)}。</p><p>它起作用了!。映射中的每个令牌都引用包含该令牌的文档的ID：</p><p>要查询索引，我们将应用用于索引的相同标记器和筛选器：</p><p>函数(idx索引)search(文本字符串)[][]int{var r[][]int for_，TOKEN：=范围分析(文本){IF ID，ok：=IDX[TOKEN]；ok{r=append(r，id)}}返回r}。</p><p>&gt；idx。搜索(&#34；小野猫&#34；)[[24,173,303，...]，[98,173,765，...]，[[24，51,173，...]]。</p><p>最后，我们可以找到所有提到猫的文件。搜索600K文档只用了不到1毫秒(18微秒)！</p><p>利用倒排索引，搜索查询的时间复杂度与搜索标记的数量成线性关系。在上面的示例查询中，除了分析输入文本之外，Search只需要执行三次地图查找。</p><p>上一节中的查询返回每个令牌的独立文档列表。当我们在搜索框中键入Small Wildcat时，通常会发现同时包含Small、Wild和CAT的结果列表。下一步是计算列表之间的集合交集。这样，我们将获得与所有令牌匹配的文档列表。</p><p>幸运的是，倒排索引中的ID是按升序插入的。由于ID是排序的，所以可以在线性时间内计算两个列表之间的交集。交集函数同时迭代两个列表，并收集两个列表中都存在的ID：</p><p>函数交集(a[]int，b[]int)[]int{maxLen：=len(A)if len(B)&gt；maxLen{maxLen=len(B)}r：=make([]int，0，maxLen)var i，j int for i&lt；len(A)&amp；&amp；j&lt；len(B){if a[i]&lt；B[j]{i++}Else if a[i]&gt；b[j]{j++}Else{r=append(r，a[i])i++j++}}返回r}。</p><p>更新的搜索分析给定的查询文本，查找令牌，并计算ID列表之间的集合交集：</p><p>函数(idx索引)search(文本字符串)[]int{var r[]int for_，TOKEN：=范围分析(文本){IF ID，ok：=IDX[TOKEN]；OK{IF r==nil{r=IDS}ELSE{r=交集(r，ID)}}ELSE{//TOKEN不存在。返回nil}}返回r}。</p><p>维基百科转储只包含两个同时匹配Small、Wild和cat的文档：</p><p>&gt；idx。搜索(#34；小野猫)130764野猫是一个物种复合体，由两个小野猫物种组成，欧洲野猫(Felis Silvestris)和非洲野猫(F.。利比卡)。131692猫科动物是一个包含两个亚洲小型野生猫科动物的属，即亚洲金猫(C.。Temminckii)和海湾猫。</p><p>顺便说一下，这是我第一次听说Catopuma，这是其中之一：</p><p>我们刚刚建立了一个全文搜索引擎。尽管它很简单，但它可以为更高级的项目奠定坚实的基础。</p><p>我没有提到很多可以显著提高性能并使引擎更加用户友好的东西。以下是一些进一步改进的想法：</p><p>尝试使用内存和CPU高效的数据格式来存储文档ID集。看看咆哮的位图。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://artem.krylysov.com/blog/2020/07/28/lets-build-a-full-text-search-engine/">https://artem.krylysov.com/blog/2020/07/28/lets-build-a-full-text-search-engine/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/全文/">#全文</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/full/">#full</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文档/">#文档</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>