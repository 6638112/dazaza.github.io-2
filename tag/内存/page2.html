<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#内存</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#内存</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1029373.html">关于学校的按需寻呼，他们不会告诉你什么？™</a></div><div class="item_title_en"><a target="_blank" href="https://offlinemark.com/2020/10/14/demand-paging/">What they donâ€™t tell you about demand paging in school</a><span>(offlinemark.com)</span></div><span class="my_story_list_date">2020-10-17 10:6</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1029373.html"><img src="http://img2.diglog.com/img/2020/10/thumb_9854fc37c69b2457fc46b68960629e34.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">这篇文章详细介绍了我使用Linux虚拟内存子系统的经历，以及我发现了一种创造性的方法，通过在内核而不是在用户空间积累内存来嘲弄OOM(内存不足)杀手。
一个可爱的被OOM杀手杀死的方式，同时看起来占用很少的内存(非常适合聚会)。
像往常一样，故事从我询问有关实现细节的问题开始。这一次，是关于Linux内核的请求分页实......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/不会/">#不会</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/demand/">#demand</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1028949.html">从内存中窃取未加密的SSH代理密钥(2014)</a></div><div class="item_title_en"><a target="_blank" href="https://blog.netspi.com/stealing-unencrypted-ssh-agent-keys-from-memory/">Stealing unencrypted SSH-agent keys from memory (2014)</a><span>(blog.netspi.com)</span></div><span class="my_story_list_date">2020-10-15 10:45</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1028949.html"><img src="http://img2.diglog.com/img/2020/10/thumb_88fa04aeeb654e035c0473fba57113e3.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">如果您曾经使用SSH密钥管理过多台机器，那么您很有可能使用过SSH-agent。此工具旨在将SSH密钥保存在内存中，以便用户不必每次都键入他们的密码短语。但是，这可能会造成一些安全风险。以根用户身份运行的用户可能具有从内存中提取解密的SSH密钥并重新构建它的能力。
由于需要超级用户访问权限，此攻击可能看起来无用。例如......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ssh/">#ssh</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1028316.html">我试图减少Pylint内存使用量</a></div><div class="item_title_en"><a target="_blank" href="https://rtpg.co/2020/10/12/pylint-usage.html">I Tried to Reduce Pylint Memory Usage</a><span>(rtpg.co)</span></div><span class="my_story_list_date">2020-10-12 22:28</span><div class="my_story_list_item_desc">通过工作，我必须处理相当大的代码库，并在我们的持续集成过程中在其上运行Pylint。它总是有点慢，但最近我也注意到它消耗了大量内存，如果我们试图过多地并行运行，就会导致OOM失败。
这是我如何处理这两个问题的日志，作为将来我在Python中进行其他分析工作时的参考。
从入口点(pylint/__main__.py)查......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/减少/">#减少</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pylint/">#pylint</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1028267.html">AWS将其自己的ARM CPU默认用于ElastiCache内存数据存储服务</a></div><div class="item_title_en"><a target="_blank" href="https://www.theregister.com/2020/10/12/aws_makes_graviton2_default_for_elasticache/">AWS makes its own Arm CPUs default for ElastiCache in-memory data store service</a><span>(www.theregister.com)</span></div><span class="my_story_list_date">2020-10-12 21:38</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1028267.html"><img src="http://img2.diglog.com/img/2020/10/thumb_40e601088cc96ad25fccc2c0e443fd4d.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">亚马逊网络服务已经将其自制的ARM驱动的Graviton2 CPU作为其ElastiCache服务的默认处理器。
ElastiCache是AWS的内存中数据存储即服务，允许用户在亚马逊云中创建Redis或memcached实现。
早在2019年12月，AWS就对Graviton2上的ElastiCache感到非常兴奋......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/arm/">#arm</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/aws/">#aws</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1027916.html">内存安全“卷曲”，实现更安全的互联网</a></div><div class="item_title_en"><a target="_blank" href="https://daniel.haxx.se/blog/2020/10/09/rust-in-curl-with-hyper/">Memory safe ‘curl’ for a more secure internet</a><span>(daniel.haxx.se)</span></div><span class="my_story_list_date">2020-10-11 15:33</span><div class="my_story_list_item_desc">TLDR：已经开始让Hyper在用于HTTP的cURL中作为后端工作。
CURL和它的数据传输核心libcurl都是用C语言编写的。C语言以内存不安全而臭名昭著，很容易搞砸，从而意外地导致安全问题。
同时，C编译器得到了非常广泛的使用和使用，您可以为几乎所有的操作系统和CPU编译C程序。C程序可以比用几乎任何其他编程......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/安全/">#安全</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/safe/">#safe</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/curl/">#curl</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1027353.html">谷歌推出Pixel 4a 5G，6.2英寸显示屏，6 GB内存，128 GB存储空间，高通765G芯片组，18W USB-C快速充电，售价499美元</a></div><div class="item_title_en"><a target="_blank" href="https://9to5google.com/2020/09/30/pixel-4a-5g-launch/">Google unveils Pixel 4a 5G with a 6.2" display, 6GB of RAM, 128GB storage, Qualcomm's 765G chipset, and 18W USB-C fast charging for $499</a><span>(9to5google.com)</span></div><span class="my_story_list_date">2020-10-1 3:28</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1027353.html"><img src="http://img2.diglog.com/img/2020/10/thumb_5698ca4339ea6a8467348b431cb8229b.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">在经历了猜测、泄密、花絮和谣言之后，谷歌现在已经在网上的“Launch Night In”主题演讲中正式发布了Pixel 4a 5G。
从技术上讲，这款价格适中的手机仍然是Pixel 4a系列的一部分，尽管它是与旗舰Pixel 5一起发布的。考虑到这一点，它以跨越这两个价位的规格弥合了Pixel 4a和Pixel 5......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/5g/">#5g</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/芯片/">#芯片</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/google/">#google</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1024784.html">Mmap()写入时复制技巧：减少数组副本的内存使用量</a></div><div class="item_title_en"><a target="_blank" href="https://pythonspeed.com/articles/reduce-memory-array-copies/">The mmap() copy-on-write trick: reducing memory usage of array copies</a><span>(pythonspeed.com)</span></div><span class="my_story_list_date">2020-9-18 14:12</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1024784.html"><img src="http://img2.diglog.com/img/2020/9/thumb_41b739e6fcf7ccc7b25fba1d52942df1.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">假设您有一个阵列，您需要创建一些副本并修改这些副本。通常，内存使用量会随着副本的数量而增加：如果您的原始阵列是1 GB的RAM，那么每个副本将占用1 GB的RAM。
但通常情况下，您只更改了阵列的一小部分，理想情况下，内存开销只是您更改的那部分副本。
事实证明，有一个操作系统工具可以实现这一点：mmap()的写入时复......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/写入/">#写入</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/copy/">#copy</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1024660.html">无虚拟内存的软件内存管理的成本</a></div><div class="item_title_en"><a target="_blank" href="https://arxiv.org/abs/2009.06789">The Cost of Software-Based Memory Management Without Virtual Memory</a><span>(arxiv.org)</span></div><span class="my_story_list_date">2020-9-18 3:10</span><div class="my_story_list_item_desc">下载PDF摘要：虚拟内存已经成为超过三年的标准硬件特性。以增加硬件复杂性为代价，它简化了软件，并承诺在托管进程之间实现强大的隔离。然而，在现代计算系统中，虚拟内存的成本已经显著增加。对于大内存工作负载、虚拟化环境、数据中心计算和带有多个DMA设备的芯片，虚拟内存可能会降低性能并提高功耗。因此，我们将探讨在不依赖硬件支......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/虚拟内存/">#虚拟内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/硬件/">#硬件</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1024441.html">比较两个内存分配器不是那么简单的任务</a></div><div class="item_title_en"><a target="_blank" href="https://blog.janestreet.com/memory-allocator-showdown/">The not-so-simple task of comparing two memory allocators</a><span>(blog.janestreet.com)</span></div><span class="my_story_list_date">2020-9-17 5:54</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1024441.html"><img src="http://img2.diglog.com/img/2020/9/thumb_e6caa00f94c9f81d1681e5771659369e.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">从4.10版本开始，OCaml除了现有的默认内存分配器(Next-Fit Allocator)之外，还提供了一个新的最佳内存分配器。在JaneStreet，我们看到改用newallocator后有了很大的改善。
这篇文章不是关于新的分配器是如何工作的。对于这一点，最好的来源是它的作者的一次演讲中的这些笔记。
相反，这......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/task/">#task</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1023285.html">谷歌发布了Android 11 Go Edition，它支持2 GB内存的手机，高于之前的1.5 GB，并表示启动应用程序的速度比Android Go 10快20%</a></div><div class="item_title_en"><a target="_blank" href="https://www.engadget.com/google-android-go-11-smartphones-2gb-memory-160009415.html">Google unveils Android 11 Go Edition, which supports phones with 2GB of RAM, up from 1.5GB before, and says it can launch apps 20% faster than Android Go 10</a><span>(www.engadget.com)</span></div><span class="my_story_list_date">2020-9-11 21:49</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1023285.html"><img src="http://img2.diglog.com/img/2020/9/thumb_0a7400aa0987e296a504e02317fd7129.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">现在Android 11已经下降，谷歌推出了Android 11 Go Edition，目的是加快入门级智能手机的速度。许多变化都是为了利用现代经济型设备上改进的功能，如更大的屏幕、双摄像头、更大的RAM和额外的存储空间。
根据谷歌的说法，该操作系统现在支持2 GB的RAM(之前为1.5 GB)，为用户提供了额外的2......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/android/">#android</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/发布/">#发布</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1023114.html">.NET内存性能分析</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/Maoni0/mem-doc/blob/master/doc/.NETMemoryPerformanceAnalysis.md">.NET Memory Performance Analysis</a><span>(github.com)</span></div><span class="my_story_list_date">2020-9-10 7:45</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1023114.html"><img src="http://img2.diglog.com/img/2020/9/thumb_bd043b2f03488bb96533bee0c04d1b3c.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">知道什么时候该担心它，如果你需要担心该怎么做。
本文档旨在帮助使用.NET开发应用程序的人员如何考虑内存性能分析，并在需要时找到执行此类分析的正确方法。在此上下文中，.NET包括.NET Framework和.NET Core。为了在垃圾收集器和框架的其余部分获得最新的内存改进，我强烈建议您使用.NET Core(如......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gc/">#gc</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1022493.html">美光披露GDDR6X细节：内存的未来，还是专有的DRAM？</a></div><div class="item_title_en"><a target="_blank" href="https://www.tomshardware.com/uk/news/micron-reveals-gddr6x-details-the-future-of-memory-or-a-proprietary-dram">Micron Reveals GDDR6X Details: The Future of Memory, or a Proprietary DRAM?</a><span>(www.tomshardware.com)</span></div><span class="my_story_list_date">2020-9-7 10:55</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1022493.html"><img src="http://img2.diglog.com/img/2020/9/thumb_b03e710a28ae6d2961561d9a6fb53f06.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">在上周的虚拟简报会上，美光科技分享了英伟达GeForce RTX 30系列显卡使用的最新GDDR6X SGRAM的更多细节。该公司透露，它已经试验了十多年的使新型存储器成为可能的技术，并表示GDDR6X SGRAM还没有被JEDEC标准化。目前，只有NVIDIA使用GDDR6X内存，但美光希望这种情况会随着时间的推移......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/reveals/">#reveals</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gddr6x/">#gddr6x</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1022352.html">AES Finder-在运行的进程内存中查找AES密钥的实用程序</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/MantechUser/aes-finder">AES Finder – the utility to find AES keys in running process memory</a><span>(github.com)</span></div><span class="my_story_list_date">2020-9-6 22:14</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1022352.html"><img src="http://img2.diglog.com/img/2020/9/thumb_a2ed1a9c66e86ef5f13f67370d60db6c.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">在运行的进程内存中查找AES密钥的实用程序。适用于128、192和256位密钥。
现在您可以看到在您最喜欢的应用程序中使用了哪种AES密钥！
C：\&gt；aes-finder.exe putty.exe搜索PID 2180...[0016C904]找到aes-256加密密钥：00010203040506070809......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/aes/">#aes</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/找到/">#找到</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1022258.html">IBM Power10核心的内存区网络</a></div><div class="item_title_en"><a target="_blank" href="https://www.nextplatform.com/2020/09/03/the-memory-area-network-at-the-heart-of-ibms-power10/">The Memory Area Network at the Heart of IBM’s Power10</a><span>(www.nextplatform.com)</span></div><span class="my_story_list_date">2020-9-5 21:20</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1022258.html"><img src="http://img2.diglog.com/img/2020/9/thumb_a2cda9dd281b94b45f116e9e4b6652ca.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">当我们分析IBM第二季度的财务状况时，考虑到蓝色巨人将在大约一年后推出的“Cirrus”Power10系统所拥有的选择，我们做了一个思考实验，如果IBM再次开始相信大型钢铁机器，那将意味着什么，除了需要用一些有趣的东西填充空白页之外，什么都不是，只是需要用一些有趣的东西来填充一张空白的页面，当我们分析IBM第二季度的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/power10/">#power10</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/area/">#area</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1022118.html">编写高效的Vulkan渲染器</a></div><div class="item_title_en"><a target="_blank" href="https://zeux.io/2020/02/27/writing-an-efficient-vulkan-renderer/">Writing an Efficient Vulkan Renderer</a><span>(zeux.io)</span></div><span class="my_story_list_date">2020-9-4 23:5</span><div class="my_story_list_item_desc">2018年，我为GPU Zen 2图书撰写了一篇文章《编写高效的Vulkan渲染器》，并于2019年出版。在本文中，我试图聚合尽可能多的关于Vulkan性能的信息-而不是试图集中在一个特定的方面或应用程序，而是试图涵盖广泛的主题，让读者了解不同API在实际硬件上的行为，并为每个需要解决的问题提供一系列选项。
在发表这......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/vulkan/">#vulkan</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/efficient/">#efficient</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021099.html">我们用存储类内存替换了固态硬盘。以下是我们了解到的情况</a></div><div class="item_title_en"><a target="_blank" href="https://engineering.mongodb.com/post/we-replaced-an-ssd-with-storage-class-memory-here-is-what-we-learned">We Replaced an SSD with Storage Class Memory. Here Is What We Learned</a><span>(engineering.mongodb.com)</span></div><span class="my_story_list_date">2020-8-29 14:4</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1021099.html"><img src="http://img.diglog.com/img/2020/8/thumb_acbf005225bb769e4fe1a757f81c4864.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">2019年4月2日，英特尔Optane永久内存成为第一款商用的存储类内存(SCM)产品。与SSD一样，该内存是持久的，并且与DRAM一样，它位于内存总线上。早在商业发布之前，系统架构师就在思考SCM如何准确地适应存储层次结构，现在是执行具体测量的机会了。我们想要回答的一个问题是，位于内存总线上的存储设备是否可以提供比......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/硬盘/">#硬盘</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/固态硬盘/">#固态硬盘</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/替换/">#替换</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ssd/">#ssd</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1020402.html">漏洞利用开发的现状：第1部分</a></div><div class="item_title_en"><a target="_blank" href="https://www.crowdstrike.com/blog/state-of-exploit-development-part-1/">The Current State of Exploit Development: Part 1</a><span>(www.crowdstrike.com)</span></div><span class="my_story_list_date">2020-8-26 19:36</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1020402.html"><img src="http://img.diglog.com/img/2020/8/thumb_2e540190fec5f7f1acad5376da6aa592.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">历史上，内存腐败利用一直是优秀红色团队成员工具包中最强大的附件之一。它们允许攻击者在不依赖任何用户交互的情况下执行有效负载，为攻击性安全工程师和对手带来了轻松的胜利。
对于防御者来说，幸运的是，但对于研究人员和对手来说，不幸的是，这些类型的利用变得越来越难以执行，这在很大程度上要归功于我们每天使用的系统中直接实施的广......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/漏洞/">#漏洞</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/开发/">#开发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/利用/">#利用</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/state/">#state</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1019850.html">RPCS3 Inside Look：深入研究硬件和性能扩展</a></div><div class="item_title_en"><a target="_blank" href="https://rpcs3.net/blog/2020/08/21/hardware-performance-scaling/">RPCS3 Inside Look: A Deep-Dive into Hardware and Performance Scaling</a><span>(rpcs3.net)</span></div><span class="my_story_list_date">2020-8-23 6:35</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1019850.html"><img src="http://img.diglog.com/img/2020/8/thumb_6e50ece1e013bbf8a20058f0e1782492.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">嘿大家好！今天我们将讨论一些与您在进度报告中习惯的内容略有不同的内容。我们将深入讨论某些硬件和软件配置如何显著影响您在RPCS3中的性能。
有几个方面可能会使RPCS3的性能达不到应有的水平，内存速度就是其中之一。在我们的示例中，RPCS3将以几种方式强调内存性能：
单元仿真：SPU通过DMA访问主存储器。这是一次仅......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/硬件/">#硬件</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/深入研究/">#深入研究</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/deep/">#deep</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1019612.html">了解Haskell中的内存碎片</a></div><div class="item_title_en"><a target="_blank" href="https://www.well-typed.com/blog/2020/08/memory-fragmentation/">Understanding Memory Fragmentation in Haskell</a><span>(www.well-typed.com)</span></div><span class="my_story_list_date">2020-8-22 0:58</span><div class="my_story_list_item_desc">最近我为Hasura做了一些工作，调查了GraphQL-Engine中一些奇怪的内存行为。在测量内存使用情况时，我们可以询问操作系统(OS)我们的进程使用了多少内存，但是我们也可以使用GHC运行时系统(RTS)的堆分析器。在运行GraphQL-Engine基准之后，操作系统报告的服务器内存使用率远远高于GHC的堆分析......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/了解/">#了解</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/memory/">#memory</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1017930.html">句柄是更好的指针(2018年)</a></div><div class="item_title_en"><a target="_blank" href="https://floooh.github.com/2018/06/17/handles-vs-pointers.html">Handles Are the Better Pointers (2018)</a><span>(floooh.github.com)</span></div><span class="my_story_list_date">2020-8-13 21:1</span><div class="my_story_list_item_desc">2018年11月28日：我在结尾处添加了一个小更新，介绍如何使用每个插槽生成计数器防止“处理冲突”
…。其中我稍微谈了一下最近我是如何在C和C++中进行动态内存管理的，它基本上是用“索引句柄”取代了原始指针和智能指针。
在我上一篇博客文章中，我提到了免指针和免分配编程，但是跳过了细节。这就是下面这篇博文的主题。
这一......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/句柄/">#句柄</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/handles/">#handles</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1017409.html">16位MS-DOS内存模型回顾</a></div><div class="item_title_en"><a target="_blank" href="https://devblogs.microsoft.com/oldnewthing/20200728-00/?p=104012">A look back at memory models in 16-bit MS-DOS</a><span>(devblogs.microsoft.com)</span></div><span class="my_story_list_date">2020-8-11 3:47</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1017409.html"><img src="http://img.diglog.com/img/2020/8/thumb_d5ac22b6724f715986d70f6c316f3742.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">在MS-DOS和16位Windows编程中，您必须处理内存模型。这个术语不是指处理器体系结构内存模型(处理器如何与内存交互)，而是指程序如何在内部组织自身。操作系统本身对应用程序内存模型一无所知；它只是讨论程序如何处理不同类型的代码和数据的一种便捷方式。
内存模型的术语来自C编译器，因为这会通知编译器要生成哪种类型的......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ms/">#ms</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指针/">#指针</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1017327.html">围棋中的分布式内存数据结构。可嵌入或独立的服务</a></div><div class="item_title_en"><a target="_blank" href="https://github.com/buraksezer/olric/releases/tag/v0.3.0-beta.1#=">Distributed in-memory data structures in Go. Embeddable or independent service</a><span>(github.com)</span></div><span class="my_story_list_date">2020-8-10 21:16</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1017327.html"><img src="http://img.diglog.com/img/2020/8/thumb_586e0defe0ce03e4f6eb1ed969fd929d.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">分布式缓存和内存中的键/值数据存储。它既可以作为嵌入式围棋库使用，也可以作为独立于语言的服务使用。
使用Olric，您可以跨计算机群集即时创建快速、可扩展的共享RAM池。</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1015934.html">在数据中心“隐藏”网络延迟以实现快速内存</a></div><div class="item_title_en"><a target="_blank" href="https://news.engin.umich.edu/2020/07/hiding-network-latency-for-fast-memory-in-data-centers/">“Hiding” network latency for fast memory in data centers</a><span>(news.engin.umich.edu)</span></div><span class="my_story_list_date">2020-8-4 0:37</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1015934.html"><img src="http://img.diglog.com/img/2020/8/thumb_4027801a27d9001d8b49466bb1e412e6.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">一种名为Leap的新系统在USENIX ATC‘20上获得了最佳论文奖，因为它在数据中心网络上产生了与本地机器相当的远程内存访问速度。
在大型计算机集群中的应用程序之间共享服务器内存仍然是云和高性能计算社区的主要目标。通过快速联网技术，整个中心服务器机架上可用的内存可以像管理单一资源一样由调度员进行管理，从而大大提高......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/隐藏/">#隐藏</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/network/">#network</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1015398.html">HVMI(虚拟机管理程序内存自检)简介</a></div><div class="item_title_en"><a target="_blank" href="https://hvmi.github.io/blog/introspection/2020/07/30/introduction.html">A Gentle Introduction to HVMI (Hypervisor Memory Introspection)</a><span>(hvmi.github.io)</span></div><span class="my_story_list_date">2020-7-31 19:53</span><div class="my_story_list_item_desc">虚拟机管理程序内存自省(HVMI)已经存在很长一段时间了，并且有几个开源项目以某种方式利用了虚拟机自省(VMI)。通常，现有项目侧重于调试或跟踪来宾VM的执行。在这篇博客文章中，我们介绍了一种略微不同的内存自省方法：来宾VM的实时保护。我们讲述了我们的HVMI引擎背后的动机，它是如何构思的，它是如何随着时间的推移而演......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/虚拟机/">#虚拟机</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/hvmi/">#hvmi</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1015092.html">三星公布第二季度销售额约445亿美元，同比下降5.6%，但营业利润约68亿美元，同比增长23.5%，原因是对内存芯片的需求增加</a></div><div class="item_title_en"><a target="_blank" href="https://www.zdnet.com/article/samsung-q2-profits-strong-thanks-to-memory/">Samsung reports Q2 earnings with sales of ~$44.5B, down 5.6% YoY, but an operating profit of ~$6.8B, up 23.5% YoY, as demand for memory chips increased</a><span>(www.zdnet.com)</span></div><span class="my_story_list_date">2020-7-30 10:16</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1015092.html"><img src="http://img.diglog.com/img/2020/7/thumb_8032faff566c06033707ae6a643402a8.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">三星电子(Samsung Electronics)周四表示，该公司公布2020年第二季度营业利润为8.15万亿韩元，销售额为53万亿韩元。
与去年同期相比，分别上升了23.5%和下降了5.6%。
该公司的半导体业务以5.43万亿韩元贡献了营业利润的最大份额。
三星表示，由于新冠肺炎疫情的影响，数据中心和个人电脑对内存......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/芯片/">#芯片</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/同比/">#同比</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/reports/">#reports</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/需求/">#需求</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1013973.html">Windows 286</a></div><div class="item_title_en"><a target="_blank" href="https://winworldpc.com/product/windows-20/windows-286">Windows 286</a><span>(winworldpc.com)</span></div><span class="my_story_list_date">2020-7-24 23:11</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1013973.html"><img src="http://img.diglog.com/img/2020/7/thumb_55279394690e0ef1abb5e6ba4ee351a2.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">Windows2与Windows1.x相比的变化主要是视觉上的改进。Windows2增加了重叠窗口、菜单键盘快捷键、VGA支持以及其他受IBM标准影响的用户界面更改。Windows2是最后一个支持软盘安装并可作为应用程序运行时使用的版本。更高版本的Windows2增加了对286高内存的支持，并在386VDM中运行应用......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1013532.html">华硕推出6.59英寸ROG Phone 3，显示屏144 Hz，内存高达16 GB，支持5G的骁龙865+将于9月在美国发布</a></div><div class="item_title_en"><a target="_blank" href="https://www.theverge.com/2020/7/22/21332716/asus-rog-phone-3-gaming-snapdragon-865-plus-5g-airtriggers-oled-ram?scrolla=5eb6d68b7fedc32c19ef33b4">Asus unveils 6.59" ROG Phone 3 with a 144Hz display, up to 16GB of RAM, and Snapdragon 865+ with 5G support, launching in the US in September</a><span>(www.theverge.com)</span></div><span class="my_story_list_date">2020-7-23 0:23</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1013532.html"><img src="http://img.diglog.com/img/2020/7/thumb_a62034c792885ebdb92c90066005ea96.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">华硕新的ROG phone3的目标是成为智能手机的顶峰，如果你对游戏和拥有最快的规格是认真的话。该设备采用6.59英寸OLED HDR色彩校准屏幕，刷新率高达144 Hz，响应时间为1ms。它由支持5G的骁龙865 Plus芯片组驱动，最高可配置16 GB的LPDDR5 RAM和512 GB的UFS 3.1 ROM存......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/5g/">#5g</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/发布/">#发布</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ram/">#ram</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1013315.html">安全恢复共享内存</a></div><div class="item_title_en"><a target="_blank" href="https://hacks.mozilla.org/2020/07/safely-reviving-shared-memory/">Safely Reviving Shared Memory</a><span>(hacks.mozilla.org)</span></div><span class="my_story_list_date">2020-7-22 1:0</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1013315.html"><img src="http://img.diglog.com/img/2020/7/thumb_491e865d86f43ebe214a7933370f816e.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">在Mozilla，我们希望Web能够运行高性能的应用程序，这样用户和内容作者就可以选择Web平台的安全性、代理性和开放性。许多高性能应用程序的一个基本低级构建块是共享内存多线程。这就是为什么在2016年向JavaScript和WebAssembly交付共享内存是如此令人兴奋的原因。这在线程之间提供了极快的通信。
然而......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/恢复/">#恢复</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/reviving/">#reviving</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/共享内存/">#共享内存</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1012969.html">英特尔限制主流主板的内存速度</a></div><div class="item_title_en"><a target="_blank" href="https://www.youtube.com/watch?v=Skry6cKyz50">Intel limits memory speeds in mainstream motherboads</a><span>(www.youtube.com)</span></div><span class="my_story_list_date">2020-7-20 12:40</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1012969.html"><img src="http://img.diglog.com/img/2020/7/thumb_bd0ab016b931c12656dc9efb288246e5.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">访问https://www.squarespace.com/LTT并使用优惠码LTT9折，感谢热灰熊赞助今天的节目！购买保暖灰熊导管..。</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/英特尔/">#英特尔</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/主板/">#主板</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/limits/">#limits</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/https/">#https</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1012335.html">对象过多：减少Python实例的内存开销</a></div><div class="item_title_en"><a target="_blank" href="https://pythonspeed.com/articles/python-object-memory/">Too many objects: Reducing memory overhead from Python instances</a><span>(pythonspeed.com)</span></div><span class="my_story_list_date">2020-7-17 0:42</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1012335.html"><img src="http://img.diglog.com/img/2020/7/thumb_0246ad23b833bbcfd8c809c620eb2291.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">每次在Python中创建类的实例时，都会消耗一些内存-包括实际上可能比您关心的数据更大的开销。创建一百万个对象，开销是原来的一百万倍。
而且这种开销可能会累积起来，要么会阻止您运行程序，要么会增加您在硬件配置上的花费。
那么让我们来看看这个开销到底有多大(预告：它很大！)。以及你能做些什么。
在Python中，普通类......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/python/">#python</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/内存/">#内存</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/减少/">#减少</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/reducing/">#reducing</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/对象/">#对象</a></button></div></div></div><div id="my_pager"><ul class="pagination justify-content-center"><li class="page-item"><a class="page-link" href="/tag/内存/">0</a></li><li class="page-item"><a class="page-link" href="/tag/内存/page1.html">1</a></li><li class="page-item active"><a class="page-link" href="/tag/内存/page2.html">2</a></li><li class="page-item"><a class="page-link" href="/tag/内存/page3.html">3</a></li><li class="page-item"><a class="page-link" href="/tag/内存/page4.html">4</a></li></ul></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>