<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>逆向工程我的圣诞树 Reverse Engineering my Christmas Tree</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Reverse Engineering my Christmas Tree<br/>逆向工程我的圣诞树 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-29 21:34:11</div><div class="page_narrow text-break page_content"><p>Over the course of the last year and a half, I’ve been doing some self-directedlearning on how radios work. I’ve gone from a very basic understanding ofwireless communications (there’s usually some sort of antenna, I guess?) allthe way through the process of learning about and implementing a set oflibraries to modulate and demodulate data using my now formidable stash of SDRs.I’ve been implementing all of the RF processing code from first principals andpurely based on other primitives I’ve written myself to prove to myself that Iunderstand each concept before moving on.</p><p>在过去一年半的时间里，我一直在做一些关于无线电工作方式的自我指导的学习。我从对无线通信的最基本的理解（我猜通常是某种天线？）一直到学习和实现一组库来使用我现在强大的SDR来调制和解调数据的过程。我一直是根据第一原理实施所有RF处理代码的，并且纯粹是基于其他原语，我已经写了我自己，向自己证明我在继续之前理解每个概念。</p><p> I figured that there was a fun “capstone” to be done here - the blind reverseengineering and implementation of the protocol my cheep Amazon power switchuses to turn on and off my Christmas Tree. All the work described in this postwas done over the course of a few hours thanks to help during the demodulationfrom  Tom Bereknyei and hlieberman.</p><p> 我认为这里有一个有趣的“顶峰”-盲目的反向工程和协议的实现（我廉价的Amazon电源开关用于打开和关闭圣诞树）。感谢汤姆·贝雷克内伊（Tom Bereknyei）和赫里伯曼（hlieberman）在解调过程中的帮助，这篇文章中描述的所有工作已经完成了几个小时。</p><p>  When I first got my switch, I checked it for any FCC markings in order to lookup the FCC filings to determine the operational frequency of the device, andmaybe some other information such as declared modulation or maybe even partnumbers and/or diagrams. However, beyond a few regulatory stickers, there wereno FCC ids or other distinguishing IDs on the device. Worse yet, it appeared tobe a whitelabeled version of another product, so searching Google for theproduct name was very unhelpful.</p><p>  当我第一次获得开关时，我检查了它是否有FCC标记，以便查找FCC文件来确定设备的工作频率，也许还可以找到一些其他信息，例如声明的调制方式，甚至零件号和/或图表。但是，除了一些法规标签外，设备上没有FCC ID或其他可区分的ID。更糟糕的是，它似乎是另一种产品的白标版本，因此在Google上搜索该产品名称非常无助。</p><p> Since operation of this device is unlicensed, I figured I’d start looking inthe ISM band. The most common band used that I’ve seen is the band startingat  433.05MHz up to  434.79MHz. I fired up my trusty waterfall tuned to acenter frequency of  433.92MHz (since it’s right in the middle of the band, andit let me see far enough up and down the band to spot the remote) and presseda few buttons. Imagine my surprise when I realize the operational frequency ofthis device is  433.920MHz, exactly dead center. Weird, but lucky!</p><p> 由于此设备的操作未经许可，因此我认为我将开始关注ISM频段。我见过的最常见的频段是从433.05MHz到434.79MHz的频段。我启动了可信任的瀑布，将其调整为433.92MHz的中心频率（因为它正好位于频段的中间，它让我在频段的上下都可以看到足够远的距离，以便发现遥控器）并按下了几个按钮。当我意识到该设备的工作频率为433.920MHz（恰好是死点）时，我会感到惊讶。很奇怪，但是很幸运！</p><p>  After taking a capture, I started to look at understanding what the modulationtype of the signal was, and how I may go about demodulating it.Using  inspectrum, I was able to clearlysee the signal in the capture, and it immediately stuck out to my eye to beencoded using OOK / ASK.</p><p>  进行捕获后，我开始着眼于了解信号的调制类型以及如何对其进行解调。使用inspectrum，我能够清楚地看到捕获中的信号，并立即将其突出显示使用OOK / ASK进行编码。</p><p>  Next, I started to measure the smallest pulse, and see if I could infer thesymbols per second, and try to decode it by hand. These types of signals aregenerally pretty easy to decode by eye.</p><p>  接下来，我开始测量最小的脉冲，看看是否可以每秒推断出符号，然后尝试手动解码。这些类型的信号通常很容易用肉眼解码。</p><p>  This wound up giving me symbol rate of 2.2 Ksym/s, which is a lot faster than Iexpected. While I was working by hand,  Tomdemodulated a few messages in Python, and noticed that if you grouped the bitsinto groups of 4, you either had a  1000 or a  1110 – which caused me torealize this was encoded using something I saw documented elsewhere, where the0 is a “short” pulse, and a 1 is a “long” pulse, not unlike morse code, butwhere each symbol takes up a fixed length of time (monospace morse code?).Working on that assumption, I changed my inspectrum symbol width, anddemodulated a few more by hand. This wound up demodulating nicely (and thepreamble / clock sync could be represented as repeating  0s, which is handy!)and gave us a symbol rate of 612(ish) symbols per second – a lot closer towhat I was expecting.</p><p>  这给了我2.2 Ksym / s的符号率，这比我预期的要快得多。在我手工工作时，汤姆用Python解调了一些消息，并注意到，如果将bitinto分成4组，则可能有1000或1110，这使我意识到这是使用我在其他地方记录的内容编码的不同于摩尔斯电码，the0是一个“短”脉冲，而数字1是一个“长”脉冲，但是每个符号占用固定的时间长度（等距莫尔斯电码？）。宽度，并用手将其解调。这样可以很好地进行解调（并且前同步码/时钟同步可以表示为重复的0，这很方便！），并为我们提供了每秒612（ish）个符号的符号率，与我的预期相差很多。 </p><p>  If we take the code for ‘on’ in the inspectrum capture above and demodulateit by hand, we get  0000000000110101100100010 (treat a short pulse as a 0, anda long pulse as a 1). If you’re interested in following along at home, click onthe inspectrum image, and write down the bits you see, and compare it to whatI have!</p><p>如果我们在上面的检查区捕获中采用“打开”的代码并手动进行解调，则会得到0000000000110101100100010（将短脉冲处理为0，将长脉冲处理为1）。如果您有兴趣在家中跟随，请单击检查图像，并写下您看到的内容，然后将其与我所拥有的进行比较！</p><p> Right, so it looks like from what we can tell so far that the packet lookssomething like this:</p><p> 是的，从目前为止我们可以看出，数据包看起来像这样：</p><p>  Next, I took a capture of all the button presses and demodulated them by hand,and put them into a table to try and understand the format of the messages:</p><p>  接下来，我捕获了所有按钮按下的信息，并手工对其进行了解调，然后将它们放入表格中以尝试了解消息的格式：</p><p>  Great! So, this is enough to attempt to control the tree with, I think – so Iwrote a simple modulator. My approach was to use the fact that I can break downa single symbol into 4 “sub-symbol” components – which is to say, go back torepresenting a  1 as  1110, and a  0 as  1000. This let me allocate IQspace for the symbol, break the bit into 4 symbols, and if that symbol is 1,write out values from a carrier wave ( cos in the  real values, and  sin inthe  imaginary values) to the buffer. Now that I can go from bits to IQ data,I can transmit that IQ data using my PlutoSDR or HackRF and try and control mytree. I gave it a try, and the tree blinked off!</p><p>  大！因此，我认为这足以尝试用它来控制树，因此编写了一个简单的调制器。我的方法是利用我可以将一个符号分解为4个“子符号”组成部分的事实–也就是说，回到将1表示为1110，将0表示为1000。这使我可以为该符号分配IQspace ，将其分成4个符号，如果该符号为1，则将载波中的值（实际值中的cos和虚部值中的sin）写入缓冲区。现在，我可以将比特数据转换为IQ数据了，现在可以使用PlutoSDR或HackRF传输IQ数据并尝试控制mytree。我试了一下，树眨了眨眼！</p><p>  But wait – that’s not enough for me – I know I can’t just demodulate bits andtry and replay the bits forever – there’s stuff like addresses and keys andstuff, and I want to get a second one of these working. Let’s take a look atthe bits to see if we spot anything fun &amp; interesting.</p><p>  但是，等等-这对我来说还不够-我知道我不能永远解调比特并尝试并永久重放比特-诸如地址，密钥和填充之类的东西，我想让其中的第二个起作用。让我们来看看这些位，看看我们是否发现任何有趣的东西。有趣。</p><p> At first glance, a few things jumped out at me as being&amp;mldr weird? First isthat the preamble is 10 bits long (fine, let’s move along - maybe itjust needs 8 in a row and there’s two to ensure clocks sync?). Next is thatthe messages are not all the same length. I double (and triple!) checkedthe messages, and it’s true, the messages are not all the same length. Addingan extra bit at the end didn’t break anything, but I wonder if that’s just dueto the implementation rather than the protocol.</p><p> 乍一看，有些事情让我感到奇怪吗？首先是前同步码是10位长（很好，让我们继续前进-也许恰好需要连续8位，而有2位可以确保时钟同步？）。其次是消息长度不一样。我检查了一下邮件（是三遍！），的确如此，邮件的长度不尽相同。最后增加一点点都没有破坏任何东西，但是我想知道这是否仅是由于实现而不是协议。</p><p> But, good news, it looks like we have a stable prefix to the messages from theremote – must be my device’s address! The stable 6 bits that jump out rightaway are  110101. Something seems weird, though, 6 bits is a bit awkward, evenfor a bit limited embedded device. Why 6? But hey, wait, we had 10 bits in thepreamble, what if we have an 8 bit address – meaning my device is  00110101,and the preamble is 8  0 symbols! Those are numbers that someone working onan 8 bit aligned platform would pick! To test this, I added a  0 to thepreamble to see if the message starts at the first  1, or if it requires allthe bits to be fully decoded, and lo and behold, the tree did not turn on oroff. This would seem to me to confirm that the 0s are part of the address,and I can assume we have two 8 bit aligned bytes in the prefix of the message.</p><p> 但是，好消息是，我们似乎有一个固定的前缀来发送来自远程的消息-必须是我设备的地址！立刻跳出来的稳定的6位是110101。尽管有些限制，但对于某些有限的嵌入式设备来说，有些奇怪的事情还是显得有些奇怪。为什么是6？但是，嘿，等等，我们的前导中有10位，如果我们有8位地址，那意味着我的设备是00110101，而前导是8 0个符号！这些是在8位对齐平台上工作的人会选择的数字！为了测试这一点，我在序言中添加了0，以查看消息是否从前1开始，或者它是否要求所有位都被完全解码，并且瞧，树没有打开或关闭。在我看来，这似乎是为了确认0是地址的一部分，并且我可以假设我们在消息的前缀中有两个8位对齐的字节。 </p><p>  Now, when we go through the 9-10 bits of “stuff”, we see all sorts of weirdbits floating all over the place. The first 4 bits look like it’s either 1001 or  0001, but other than that, there’s a lot of chaos. This is wherethings get really squishy. I needed more information to try and figure this out,but no matter how many times I sent a command it was always the same bits (so,no counters), and things feel very opaque still.</p><p>现在，当我们经历9到10位的“内容”时，我们看到各种各样的怪异的东西到处漂浮。前4位看起来是1001或0001，但除此之外，还有很多混乱。这是真的很糊涂的地方。我需要更多信息来尝试解决此问题，但是无论我发送了多少次命令，它始终是相同的位（因此，没有计数器），并且感觉仍然很不透明。</p><p> The only way I was going to make any progress is to get another switch and seehow the messages from the remote change. Off to Amazon I went, and orderedanother switch from the same page, and eagerly waited its arrival.</p><p> 我要取得任何进展的唯一方法是获得另一个开关，并查看远程消息如何更改。我去了亚马逊，并命令从同一页面进行另一次切换，并热切地等待它的到来。</p><p>  The second switch showed up, and I hurriedly unboxed the kit, put batteriesinto the remote, and fired up my SDR to take a capture. After I captured thefirst button (“Off”), my heart sunk as I saw my lights connected toSwitch #1 flicker off. Apparently the new switch and the old switch have thesame exact address. To be sure, I demodulated the messages as before, andcame out with the exact same bit pattern. This is a setback and letdown – Iwas hoping to independently control my switches, but it also means I got noadditional information about the address or button format.</p><p>  第二个开关出现了，我急忙拆开工具箱的包装，将电池放入遥控器中，并发射了我的SDR进行捕获。按下第一个按钮（“关”）后，当我看到连接到＃1开关的灯闪烁时，我的心沉没了。显然，新交换机和旧交换机具有相同的确切地址。可以肯定的是，我像以前一样对消息进行了解调，并以完全相同的位模式显示出来。这是一个挫折和失望–我希望独立控制我的开关，但这也意味着我没有关于地址或按钮格式的其他信息。</p><p> The upside to all of this, though, is that because the switches are controlledby either remote, I only needed one remote, so why not pull it apart and see ifI can figure out what components it’s using to transmit, and find anydatasheets I can. The PCB was super simple, and I wound up finding a “WL116SC”IC on the PCB.</p><p> 但是，所有这些操作的好处是，由于开关是由任何一个远程控制的，所以我只需要一个远程，那么为什么不将其拆开，看看我是否能弄清楚它用来传输什么组件，并找到我能找到的任何数据表。 PCB非常简单，我最终在PCB上找到了“ WL116SC” IC。</p><p>  After some googling, I found a single lone datasheet,entirely in Chinese. Thankfully, Google Translate seems to have worked wellenough on technical words, and I was able to put together at least a little bitof understanding based on the documentation that was made available. I took afew screenshots below - I put the google translated text above the hanzi. Fromthat sheet, we can see we got the basics of the “1” and “0” symbol encodingright (I was halfway expecting the bits to be flipped), and a huge find by wayof a description of the bits in the message!</p><p>  谷歌搜索后，我发现了一个单独的中文数据表。值得庆幸的是，Google Translate在技术用语方面似乎做得很好，并且我可以根据提供的文档至少收集了一点理解。我在下面截取了一些屏幕截图-我将Google翻译的文字放在了汉字上方。从那张纸上，我们可以看到我们对“ 1”和“ 0”符号的编码有了正确的理解（我中途期望比特被翻转），并且通过对消息中的比特进行描述而获得了巨大的发现！</p><p>  It’s a bummer that we missed the clock sync / preamble pulse before the datamessage, but that’s OK somehow. It also turns out that 8 or 10 bit series of of“0&#34;s wasn’t clock sync at all - it was part of the address! Since it also turnsout that all devices made by this manufacturer have the hardcoded address of []byte{0x00, 0x35}, that means that the vast majority of bits sent are alwaysgoing to be the same for any button press on any remote made by this vendor.Seems like a waste of bits to me, but hey, what do I know.</p><p>  令人遗憾的是，我们错过了数据消息之前的时钟同步/前同步脉冲，但这在某种程度上是可以的。事实证明，“ 0＃34; s”的8或10位序列完全没有时钟同步-它是地址的一部分！由于还证明该制造商制造的所有设备的硬编码地址均为[] byte {0x00，0x35}，因此，对于由此制造的任何遥控器上的任何按钮按下，发送的绝大多数位总是相同的供应商。对我来说似乎有点浪费，但是，嘿，我知道些什么。</p><p> Additionally, this also tells us the trailing zeros are not part of the dataencoding scheme, which is progress!</p><p> 此外，这还告诉我们尾随零不是数据编码方案的一部分，这是进步！ </p><p>  Now, working on the assumptions validated by the datasheet, here’s the updatedlist of scancodes we’ve found:</p><p>现在，根据数据表验证的假设，这是我们发现的扫描代码的更新列表：</p><p>  Interestingly, I think the “Dim” keys may have a confirmation that we havea good demod – the codes on the bottom are missing the most significantbit, and when I look back at the scancode table in the datasheet, they make aninteresting pattern – the bottom two rows, right and left side values matchup! If you take a look, Dim 100% is “S1”, Dim 75% is “S19”, Dim 50% is “S8”,and Dim 25% is “S20”. Cool!</p><p>  有趣的是，我认为“ Dim”键可以确认我们的演示良好-底部的代码缺少最高有效位，当我回顾数据表中的scancode表时，它们会形成一个有趣的模式-底部两行，右侧和左侧的值匹配！如果看一看，Dim 100％是“ S1”，Dim 75％是“ S19”，Dim 50％是“ S8”，Dim 25％是“ S20”。凉！</p><p> Since none of the other codes line up, I am willing to bet the most significantbit is a “Combo” indicator, and not part of the button (leaving 7 bits for thekeycode).</p><p> 由于没有其他代码排队，因此我敢打赌，最高有效位是“组合”指示器，而不是按钮的一部分（为键代码保留7位）。</p><p>  And even more interestingly, one of our scancodes (“Off”, which is 0x94) shows up justbelow this table, in the examples.</p><p>  更有趣的是，在示例中，我们的扫描代码之一（“ Off”，即0x94）显示在此表的正下方。</p><p>  Over all, I think this tells us we have the right bits to look at fordetermining the scan code! Great news there!</p><p>  总的来说，我认为这告诉我们我们有正确的判断力来确定扫描代码！好消息！</p><p>  So, armed with this knowledge, I was able to refactor my code to match thetimings and understanding outlined by the datasheet and ensure things still work.The switch itself has a high degree of tolerance, so being wildly off frequencyor a wildly wrong symbol rate may actually still work. It’s hard to know ifthis is more or less correct, but matching documentation seems like a more stablefoundation if nothing else.</p><p>  因此，有了这些知识，我就能够重构我的代码以匹配数据表中概述的时机和理解，并确保一切仍然正常。仍然有效。很难知道这是否正确，但是如果没有其他要求，匹配的文档似乎更稳定。</p><p> This code has been really reliable, and tends to work just as well as theremote from what I’ve been able to determine. I’ve been using incredibly lowpower to avoid any interference, and it’s been very robust - a testament to theengineering that went into the outlet hardware, even though it cost less thanof a lot of other switches! I have a lot of respect for the folks who builtthis device - it’s incredibly simple, reliable and my guess is this thing willkeep working even in some fairly harsh RF environments.</p><p> 这段代码确实可靠，并且在无法确定的情况下也能正常工作。我一直在使用非常低的功率来避免任何干扰，而且它非常坚固-证明了插座硬件的工程设计，尽管它的成本比许多其他开关要低！我对制造此设备的人表示敬意-它非常简单，可靠，而且我猜想即使在某些相当恶劣的RF环境中，该设备也能正常工作。 </p><p> The only downside is the fact the manufacturer used the same address for alltheir devices, rather than programming a unique address for each outlet andremote when the underlying WL116SC chip supports it. I’m sure this was done toavoid complexity in assembly (e.g. pairing the remote and outlet, and having tokeep those two items together during assembly), but it’s still a bummer. I tookapart the switch to see if I could dump an EEPROM and change the address inROM, but the entire thing was potted in waterproof epoxy, which is a very nicefeature if this was ever used outdoors. Not good news for tinkering, though!</p><p>唯一的缺点是制造商在所有设备上使用了相同的地址，而不是为每个插座编程一个唯一的地址，并在底层WL116SC芯片支持时为其远程编程。我敢肯定，这样做是为了避免组装的复杂性（例如，将遥控器和插座配对，并在组装过程中将这两项保持在一起），但这仍然很麻烦。我看了一下交换机，看看是否可以转储EEPROM并在ROM中更改地址，但是整个设备都用防水环氧树脂灌封，如果在户外使用，这是一个很好的功能。不过，这不是一个好消息！</p><p>  At this point, even though I understand the protocol enough to control thedevice, it still feels like I hit a dead end in my understanding. I’m not ableto figure out how exactly the scancodes are implemented, and break them downinto more specific parts. They are stable and based on the physical wiring ofthe remote, so I think I’m going to leave it a magic number. I have what I waslooking for, and these magic constants appear to be the right one to use, evenif I did understand how to create the codes itself.</p><p>  在这一点上，即使我足够了解该协议来控制该设备，但仍然感觉我陷入了僵局。我无法弄清楚扫描代码是如何实现的，并将其分解为更具体的部分。它们是稳定的，并基于遥控器的物理布线，因此我想给它一个神奇的数字。我已经在寻找什么了，即使我确实知道如何创建代码，这些魔术常数似乎也是可以使用的正确常数。</p><p> This does leave us with a few bits we never resolved, which I’ll memorializebelow just to be sure I don’t forget about them.</p><p> 这确实给我们留下了一些我们从未解决过的问题，为确保我不会忘记它们，我将在下面对此加以纪念。</p><p> Question #1: According to the datasheet there should be a preamble. Why doI not see one leading the first message?</p><p> 问题1：根据数据表，应该有一个序言。为什么我看不到第一个消息的开头？</p><p> My hunch is that the trailing “0” at the end of the payload is actually justthe preamble for the next message (always rendering the first messageinvalid?). This would let us claim there’s an engineering reason why we areignoring the weird bit, and also explain away something from the documentation.It’s just weird that it wouldn’t be present on the first message.</p><p> 我的直觉是，有效负载末尾的结尾“ 0”实际上只是下一条消息的序言（总是使第一条消息无效？）。这可以让我们声称我们出于工程原因而忽略了这些奇怪的地方，并从文档中解释了一些内容。这很奇怪，它不会出现在第一条消息中。</p><p> This theory is mostly confirmed by measuring the timing and comparing it to thedatasheet, but it’s not  exactly in line with the datasheet timings either(specifically, it’s off by 200µs, which is kinda a lot for a system using 400µstimings). I think I could go either way on the last “0” being the preamble forthe next message. It could be that the first message is technically invalid, orit could also be that this was not implemented or actively disabled by thevendor for this specific application / device. It’s really hard to knowwithout getting the source code for the WL116SC chip in this specific remoteor the source in the outlet itself.</p><p> 可以通过测量时序并将其与数据表进行比较来证实这一理论，但它也不完全符合数据表时序（具体而言，相差200µs，对于使用400µstimings的系统来说，这是很多东西）。我认为我可以在最后一个“ 0”上选择任一种方式作为下一条消息的序言。第一条消息可能在技术上是无效的，也可能是供应商未针对此特定应用程序/设备实施或未主动禁用此消息。很难知道没有在此特定遥控器中获得WL116SC芯片的源代码，也无法在插座本身中获得源代码。</p><p>  I still have no idea why there sometimes 8 bits (for instance, “On”) andother times there are 9 bits (for instance, “Off”) in the 8 bit keycodefield.</p><p>  我仍然不知道为什么有时8位键码字段中有时会有8位（例如“ On”），而有时又有9位（例如“ Off”）。 </p><p> I spent some time playing with the “trailing” zeros, when I try and send an“Off” with the most significant 8 bits (without the least significant / last9th bit, which is a “0”), it does not turn the tree off. If I send an “On” with9 bits (an additional 0 after the least significant bit), it does work,but both “On” and “Off” work when I send 10, 11 or 12 bits padded with trailingzeros. I suspect my outlet will ignore data after the switch is “done” readingbits regardless of trailing zeros. The docs tell me there should only be 8 bits,but it won’t work unless I send 9 bits for some commands. There’s somethingfishy going on here, and the datasheet isn’t exactly right either way.</p><p>我花了一些时间处理“尾随”零，当我尝试发送具有最高有效8位（无最低有效/ last9th位，即“ 0”）的“关”时，它不会转动树关。如果我发送一个带有9位的“开”（最低有效位后再加一个0），它确实起作用，但是当我发送带有尾随零填充的10、11或12位时，“开”和“关”都起作用。我怀疑开关“完成”读取位后，无论尾随零如何，我的插座都会忽略数据。文档告诉我应该只有8位，但是除非我为某些命令发送9位，否则它将无法工作。这里有些混乱，数据表也不是完全正确的。</p><p>  This one drove me  nuts. I’ve spent countless hours on trying to figure thisout, including emailing the company that makes the WL116SC (they’re reallynice!), and even though they were super kind and generous with documentationand example source, I’m still having a hard time lining up their documentationand examples with what I see from my remote. I think the manufacturer of myremote and switch has modified the protocol enough to where there’s actuallysomething different going on here. Bummer.</p><p>  这个让我发疯。我花了无数时间来尝试解决这个问题，包括向制造WL116SC的公司发送电子邮件（真是太好了！），尽管它们非常友好，慷慨地提供了文档和示例源，但我仍然很难将他们的文档和示例与我从遥控器上看到的内容对齐。我认为myremote和switch的制造商已经对协议进行了足够的修改，以适应实际发生的变化。笨蛋</p><p> I wound up in my place of last resort – asking friends over Signal to try andsee if they could find a pattern, as well as makingmultiple pleas to the twittersphere, to no avail (but thank you to Ben Hilburn, devnulling, Andreas Bombe and  Larmefor your repiles, help and advice!)</p><p> 我选择了最后的解决方法–让Signal上的朋友尝试看看他们是否可以找到一个模式，并对Twitter圈进行多次请愿，但无济于事（但要感谢Ben Hilburn，devnulling，Andreas Bombe和Larmefor您的答复，帮助和建议！）</p><p> I still don’t understand how they assemble the scan code – for instance,if you merely add, you won’t know if a key press of  0x05 is  0x03 +  0x02or if it’s  0x01 +  0x04. On the other hand, treating it as two 4-bitintegers won’t work for  0x10 to  0x15 (since they need 5 bits torepresent). It’s also likely the most significant bit is a combo indicator,which only leaves 7 bits for the actual keypress data. Stuffing 10 bits of datainto 7 bits is likely resulting in some really intricate bit work.On a last ditch whim, I tried to XOR the math into working, but some initialbrute forcing to make the math work given the provided examples did not resultin anything. It could be a bitpacked field that I don’t understand, but I don’tthink I can make progress on that without inside knowledge and much more work.</p><p> 我仍然不了解它们如何组装扫描代码-例如，如果仅添加，您将不知道0x05的按键是0x03 + 0x02还是0x01 + 0x04。另一方面，将其视为两个4位整数对于0x10到​​0x15不起作用（因为它们需要5位才能表示）。最高有效位也可能是组合指示符，它仅保留7位用于实际按键数据。将10位数据填充到7位中可能会导致某些真正复杂的位工作。最后一阵奇想，我尝试对数学进行XOR运算，但是鉴于所提供的示例并没有任何结果，因此我进行了一些初步的强制使数学运算起作用。这可能是一个我不太了解的领域，但是我认为如果没有内部知识和更多工作，我就无法在这方面取得进展。</p><p>   If anyone has thoughts on how these codes work, I’d love to hear about it! Sendme an email or a tweet or something - I’m a bit stumped.</p><p>   如果有人对这些代码的工作方式有任何想法，我很想听听！向我发送电子邮件或推文之类的东西-我有些困惑。</p><p> There’s some trick here that is being used to encode the combo key in a waythat is decodeable. If it’s actually not decodeable (which is a realpossibility!), this may act as a unique button combo “hash” which allows thereceiver to not actually determine which keys are pressed, but have a unique“button” that gets sent when a combo is used. I’m not sure I know enough tohave a theory as to which it may be.</p><p> 这里有一些技巧，用于以可解码的方式对组合键进行编码。如果它实际上是不可解码的（这是现实的可能性！），则它可以充当唯一的按钮组合“哈希”，这使接收者实际上无法确定按下了哪些键，但是有一个唯一的“按钮”，当组合键被按下时会发送该按钮。用过的。我不确定我是否了解足够的理论。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://kc3nwj.com/christmas/">https://kc3nwj.com/christmas/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/逆向工程/">#逆向工程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/工程/">#工程</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>