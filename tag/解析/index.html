<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>#解析</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1>#解析</h1><div class="row"><div class="col-lg-8 col-12"><div id="list"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1066392.html">对文本协议的案例 </a></div><div class="item_title_en"><a target="_blank" href="https://unmdplyr-new.bearblog.dev/a-case-against-text-protocols/">A case against text protocols</a><span>(unmdplyr-new.bearblog.dev)</span></div><span class="my_story_list_date">2021-6-17 14:12</span><div class="my_story_list_item_desc">人机交互与计算机计算机交互非常不同。对于与计算机进行通信的人，在文本shell或使用点击模型的图形用户界面上的英语命令很大。但是，一旦结束，当两个或更多计算机必须交互时，文本协议可能并不是所有有帮助的。然而，基于文本的计算机到计算机协议非常常见，并且甚至在它的地方常见的地方似乎普遍无处不在。
 以下是您＆＃39; l......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/协议/">#协议</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/text/">#text</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1062897.html">parsix：解析不验证 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/parsix/parsix">Parsix: Parse Don't Validate</a><span>(github.com)</span></div><span class="my_story_list_date">2021-5-16 0:42</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1062897.html"><img src="http://img2.diglog.com/img/2021/5/thumb_945d6789e2d9643f2da320e8f0a62c11.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">为确保输入的高级解析为右侧，满足业务逻辑所需的所有约束。
 它受到亚历克西斯国王的工作的强烈启发;解析，Don＆＃39; t验证＆＃34;我们建议您读它即使您不熟悉Haskell。
  任何非琐碎程序始终需要验证外部输入。在Kotlin Ecosystem IT＆＃39; s往往是将Stream化为对象的混合，然后验......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/parsix/">#parsix</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parse/">#parse</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1062887.html">用于通过SQLite的CSV绘制可视化的第一PWA </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/lana-k/sqliteviz">Offline-First PWA for Plotly Visualization of CSV via SQLite</a><span>(github.com)</span></div><span class="my_story_list_date">2021-5-15 23:53</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1062887.html"><img src="http://img2.diglog.com/img/2021/5/thumb_44cff8d82fb9dfd022bb0dda267ec473.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">SQLiteVIZ是一个单页离线 - 首先pwa，用于全客户端可视化SQLite数据库或CSV文件。  运行对SQLite数据库的SQL查询，并根据结果集创建绘图图表  它基于Vue.js中的反应图表编辑器，SQL.js和Vue-Codemirror之上。 CSV解析用爸爸解析进行。 </div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/sqlite/">#sqlite</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/可视化/">#可视化</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pwa/">#pwa</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1060206.html">解析protobuf在2 + gb / s：我如何学会爱尾呼叫 </a></div><div class="item_title_en"><a target="_blank" href="https://blog.reverberate.org/2021/04/21/musttail-efficient-interpreters.html">Parsing Protobuf at 2+GB/S: How I Learned to Love Tail Calls in C</a><span>(blog.reverberate.org)</span></div><span class="my_story_list_date">2021-4-26 10:57</span><div class="my_story_list_item_desc">一个令人兴奋的功能，刚刚登陆克兰贩运者的主要分支机构。使用[[clang :: musttail]]或__Attribute __（（musttail））语句属性，您现在可以在C，C ++和Objective-C中获得保证标准呼叫。
 虽然尾部呼叫通常与功能性编程风格相关联，但iam纯粹对它们的性能原因感兴趣。事实证......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/learned/">#learned</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1055439.html">NPM NetMask中的IPv4解析缺陷可能会影响270,000个应用程序 </a></div><div class="item_title_en"><a target="_blank" href="https://securityledger.com/2021/03/critical-flaws-found-in-widely-used-netmask-open-source-library">IPv4 Parsing Flaw In NPM Netmask Could Affect 270,000 Apps</a><span>(securityledger.com)</span></div><span class="my_story_list_date">2021-4-1 20:25</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1055439.html"><img src="http://img2.diglog.com/img/2021/4/thumb_51170aa475ec000804ecc5f0db60a592.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">根据星期一发布的报告，分析了广泛使用的开源组件的安全研究人员发现了遗漏遗漏攻击攻击的安全漏洞。
 五个研究人员集团发现了网络掩码中的安全漏洞，这是一个用于惊人的270,000个软件项目的开源库。根据该报告，缺陷将门打开到广泛的恶意攻击，使攻击者能够将恶意代码渡过受保护的网络，或者虹吸敏感数据。
  在缺陷使能的攻击中......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parsing/">#parsing</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/地址/">#地址</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1052644.html">C ++如何解析函数调用 </a></div><div class="item_title_en"><a target="_blank" href="https://preshing.com/20210315/how-cpp-resolves-a-function-call/">How C++ Resolves a Function Call</a><span>(preshing.com)</span></div><span class="my_story_list_date">2021-3-16 10:44</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1052644.html"><img src="http://img2.diglog.com/img/2021/3/thumb_84862d0d9e7c47e8e9f1531b3f2513ee.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">c是一种简单的语言。您只允许使用每个名称的函数。另一方面，C ++为您提供更大的灵活性：
    我喜欢这些c ++功能。使用这些功能，您可以使str1 + str2返回两个字符串的串联。您可以有一对2D点，另一对3D点，并过载点（A，B）以与任一类型一起使用。您可以拥有一堆类似数组类的类，并编写一个与所有的单个排序......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/resolves/">#resolves</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/模板/">#模板</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1050142.html">由于sscanf，解析可能意外地变成平方 </a></div><div class="item_title_en"><a target="_blank" href="https://github.com/biojppm/rapidyaml/issues/40">Parsing can become accidentally quadratic because of sscanf</a><span>(github.com)</span></div><span class="my_story_list_date">2021-3-1 22:40</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1050142.html"><img src="http://img2.diglog.com/img/2021/3/thumb_91862a492d8f31d759646572babf44c3.jpeg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">但是无论如何，ryml必须支持C ++ 11以及包括C ++ 11在内的所有内容，因此我们在此标准中无权求助。 您可能已经研究了这些c4 :: atof（）函数，并查看了它们为保证边界而必须执行的歌舞。 现在，它看起来就像glibc的sscanf（）正在寻找不存在的终止零字符，因此它失败了（并且可能会产生一个后端读取......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/读取/">#读取</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1046809.html">每秒千兆字节解析的数量 </a></div><div class="item_title_en"><a target="_blank" href="https://lemire.me/blog/2021/01/29/number-parsing-at-a-gigabyte-per-second/">Number Parsing at a Gigabyte per Second</a><span>(lemire.me)</span></div><span class="my_story_list_date">2021-1-30 6:25</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1046809.html"><img src="http://img2.diglog.com/img/2021/1/thumb_c72a4bdf84c77ccc3eff0558d5edc17a.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">计算机通常依赖于二进制浮点数。大多数情况下，它们跨越64位或32位。许多编程语言将它们称为double和float。 JavaScript默认情况下使用64位二进制浮点数字类型表示其所有数字。
 人类通常以十进制表示数字，例如0.1或1e-1。因此，许多系统使用ASCII文本以十进制表示形式存储数字。该软件必须从二进......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parsing/">#parsing</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/标准/">#标准</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1044309.html">置换解析器，不验证 </a></div><div class="item_title_en"><a target="_blank" href="https://juliu.is/permutate-parsers/">Permutate Parsers, Don't Validate</a><span>(juliu.is)</span></div><span class="my_story_list_date">2021-1-15 22:27</span><div class="my_story_list_item_desc">一段时间以来，“解析，不验证”一直是我最喜欢的编程文章之一。这篇文章的主旨是，当以类型驱动的方式编写时，您的贪婪口号应该是：
  可以通过查看两个非常相似的函数来解释解析和验证之间的核心区别：
 parseInt ::字符串-＆gt;也许Int parseInt str = Text.Read.readMaybe s......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/置换/">#置换</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parsers/">#parsers</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1037054.html">将所有维基百科解析为离线百科全书</a></div><div class="item_title_en"><a target="_blank" href="https://daveshap.github.io/DavidShapiroBlog/automation/2020/11/15/parsing-all-wikipedia.html">Parsing All of Wikipedia to an Offline Encyclopedia</a><span>(daveshap.github.io)</span></div><span class="my_story_list_date">2020-11-29 5:22</span><div class="my_story_list_item_desc">当我遇到\ u2013这样的转义unicode文字时，很快就变得棘手。他们无处不在。
 因此，我又写了两个函数来尝试解决方括号中的内容。这些是链接，引用和图片之类的东西。由于我需要纯文本的Wikipedia，因此我真的只需要将其全部删除。
 def remove_double_curly（text）：而True：be......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/wikipedia/">#wikipedia</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/text/">#text</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1035321.html">Packrat解析和解析表达式文法页</a></div><div class="item_title_en"><a target="_blank" href="https://bford.info/packrat/">The Packrat Parsing and Parsing Expression Grammars Page</a><span>(bford.info)</span></div><span class="my_story_list_date">2020-11-16 4:10</span><div class="my_story_list_item_desc">Scala中的Packrat解析(PDF)。项目报告，Manohar Jonnalagedda，EPFL，2009年1月。</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parsing/">#parsing</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1031776.html">PICA解析：将PackRAT解析重新定义为动态编程算法</a></div><div class="item_title_en"><a target="_blank" href="https://arxiv.org/abs/2005.06444">Pika parsing: reformulating packrat parsing as a dynamic programming algorithm</a><span>(arxiv.org)</span></div><span class="my_story_list_date">2020-10-29 2:43</span><div class="my_story_list_item_desc">下载PDF摘要：递归下降解析器是由一组相互递归的函数构建的，其中每个函数直接实现语法的一个非终结符。PackRAT解析器使用记忆来降低递归下降解析的时间复杂度，从输入长度的指数下降到线性。递归下降解析器非常容易编写，但存在两个重要问题：(I)左递归语法导致解析器陷入无限递归；(Ii)出现语法错误后，很难或不可能以最佳......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/算法/">#算法</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parsing/">#parsing</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1031292.html">“解析算法”完整课程现已开课</a></div><div class="item_title_en"><a target="_blank" href="http://dmitrysoshnikov.com/courses/parsing-algorithms/">“Parsing Algorithms” full course is now available</a><span>(dmitrysoshnikov.com)</span></div><span class="my_story_list_date">2020-10-27 1:47</span><div class="my_story_list_item_desc">对学习和教育感兴趣的软件工程师。有时会撰写关于编程语言理论、编译器和ECMAScript主题的博客。</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/算法/">#算法</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/教育/">#教育</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1030636.html">Played解析事务数据</a></div><div class="item_title_en"><a target="_blank" href="https://blog.plaid.com/how-plaid-parses-transaction-data/">Plaid Parses Transaction Data</a><span>(blog.plaid.com)</span></div><span class="my_story_list_date">2020-10-23 2:56</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1030636.html"><img src="http://img2.diglog.com/img/2020/10/thumb_ce433d97af5491e8cde5ea4d7fcc1a9d.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">在Play，我们将金融账户与应用程序联系起来，消除了我们的客户与金融机构建立个人连接的需要，并标准化了跨多个账户使用的数据。这意味着开发者可以专注于创造创新的产品和服务。
我们面临的最有趣的挑战之一是前面提到的数据标准化或标准化：我们如何简化数千种不同格式的数据，以便以数千种不同的方式使用，我们为什么要这样做？
“为......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parses/">#parses</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/模型/">#模型</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1030323.html">Lezer解析器系统</a></div><div class="item_title_en"><a target="_blank" href="https://lezer.codemirror.net/">The Lezer Parser System</a><span>(lezer.codemirror.net)</span></div><span class="my_story_list_date">2020-10-22 3:37</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1030323.html"><img src="http://img2.diglog.com/img/2020/10/thumb_32b692da469ef4a807a74bc16141af46.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">60多年来，结构化文本的解析问题一直在抵制“一刀切”的解决方案。Lezer也不是这样的解决方案，但它是一个非常不错的解析器生成器，特别适合在代码编辑器中使用。
Lezer(荷兰语中的读取器，发音类似于“LASSER”)提供了一个解析器生成器，该生成器输出JavaScript模块，可以加载这些模块将代码解析到非抽象语法......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/解析器/">#解析器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parser/">#parser</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1028536.html">Racket：用33行解析命题逻辑</a></div><div class="item_title_en"><a target="_blank" href="https://micahcantor.xyz/blog/logic-racket-parser">Racket: Parsing propositional logic in 33 lines</a><span>(micahcantor.xyz)</span></div><span class="my_story_list_date">2020-10-14 0:32</span><div class="my_story_list_item_desc">我最近开始对两个看似完全不同的东西感兴趣：方案/球拍和符号逻辑，所以我决定把这两个结合到一个小项目中，以获得一些乐趣。这场联姻实际上没有看起来那么奇怪，因为由于Sracket专注于元编程，所以它有非常健壮的词法分析和解析工具。在这篇文章中，我们将回顾一些实现简单解析器的策略，这些策略的概念可以很容易地扩展到解析其他东......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parsing/">#parsing</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语法/">#语法</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1025187.html">对等名称解析协议(2009，Microsoft。哇)</a></div><div class="item_title_en"><a target="_blank" href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-vista/bb726971(v=technet.10)">Peer Name Resolution Protocol (2009, Microsoft. Wow)</a><span>(docs.microsoft.com)</span></div><span class="my_story_list_date">2020-9-21 0:48</span><div class="my_story_list_item_desc">简介PNRP云对等名称和PNRP ID PNRP名称解析扩展使用多级缓存的对等名称解析PNRP名称发布PNRP缓存初始化在应用程序开发摘要中使用PNRP相关链接。
在对等环境中，对等方依靠名称解析系统从名称或其他类型的标识符中相互解析对方的网络位置(地址、协议和端口)。由于域名系统(DNS)中的瞬时连接和缺陷，对等名......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/microsoft/">#microsoft</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pnrp/">#pnrp</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1024320.html">挑战LR解析</a></div><div class="item_title_en"><a target="_blank" href="https://rust-analyzer.github.io/blog/2020/09/16/challeging-LR-parsing.html">Challenging LR Parsing</a><span>(rust-analyzer.github.io)</span></div><span class="my_story_list_date">2020-9-17 0:50</span><div class="my_story_list_item_desc">这篇文章是对哪种解析方法的直接回应？如果你还没有读过那篇文章，现在就做吧 - 这是对现代解析技术领域的最好的短期调查。我同意这样的结论，如果你想“正确”地进行解析， - LR解析是可行的。几年前我也是这么想的：现代解析器生成器。
但是，这里需要注意的是，锈蚀分析器使用的是手工编写的递归下降/PRATT解析器，原因之一......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/lr/">#lr</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1024186.html">哪种解析方法？</a></div><div class="item_title_en"><a target="_blank" href="https://tratt.net/laurie/blog/entries/which_parsing_approach.html">Which Parsing Approach?</a><span>(tratt.net)</span></div><span class="my_story_list_date">2020-9-16 22:46</span><div class="my_story_list_item_desc">劳伦斯·特拉特：哪种解析方法？</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parsing/">#parsing</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021269.html">MARPA将解析任何可以用BNF编写的内容</a></div><div class="item_title_en"><a target="_blank" href="http://savage.net.au/Marpa.html">Marpa will parse anything that can be written in BNF</a><span>(savage.net.au)</span></div><span class="my_story_list_date">2020-8-30 16:50</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1021269.html"><img src="http://img.diglog.com/img/2020/8/thumb_42848e46331dd51dc2cf4fab0689aa48.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">作者Jeffrey Kegler对MARPA的概述：MARPA是一种解析算法。它是新的，但在很大程度上是基于Jay Earley，Joop Leo，JohnAycock和R.Nigel Horspool的先前工作。Marpa旨在取代并远远超越递归下降和Yacc解析器家族。它在线性时间内解析：o递归下降解析的所有语法类......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parse/">#parse</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1021188.html">解析：时间线(2014)</a></div><div class="item_title_en"><a target="_blank" href="http://blogs.perl.org/users/jeffrey_kegler/2014/09/parsing-a-timeline.html">Parsing: A Timeline (2014)</a><span>(blogs.perl.org)</span></div><span class="my_story_list_date">2020-8-30 3:6</span><div class="my_story_list_item_desc">1960年：ALGOL 60规范问世。它第一次指定了块结构语言。ALGOL委员会很清楚，没有人知道如何解析这样的语言。但他们相信，如果他们指定一种块结构语言，就会发明一种解析器。尽管这种方法有风险，但它是值得的.。
1961年：奈德·艾伦斯出版了他的ALGOL解析器。事实上，Irons解析器是第一个用印刷体描述的任何......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/时间/">#时间</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parsing/">#parsing</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1010085.html">从字符串解析始发地城市和目的地城市</a></div><div class="item_title_en"><a target="_blank" href="https://stackoverflow.com/questions/59956670/parsing-city-of-origin-destination-city-from-a-string">Parsing city of origin and destination city from a string</a><span>(stackoverflow.com)</span></div><span class="my_story_list_date">2020-7-6 16:29</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1010085.html"><img src="http://img.diglog.com/img/2020/7/thumb_ff0287210796737fd34a6056d629fa7a.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">我有一个熊猫数据框，其中一列是带有特定旅行详细信息的一串字符串。我的目标是解析每个字符串以提取始发地城市和目的地城市(我最终希望有两个新列，标题分别为&#39；Origin&39；和&#39；Destination&39；)。
从纽约到意大利威尼斯的阿提哈德航空公司从布鲁塞尔到曼谷的往返航班，从洛杉矶到墨西哥瓜达拉哈......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/city/">#city</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/城市/">#城市</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/1010008.html">LEZER：一个面向CodeMirror的增量式解析系统</a></div><div class="item_title_en"><a target="_blank" href="https://lezer.codemirror.net/">Lezer: An incremental parsing system for CodeMirror</a><span>(lezer.codemirror.net)</span></div><span class="my_story_list_date">2020-7-6 4:53</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/1010008.html"><img src="http://img.diglog.com/img/2020/7/thumb_32b692da469ef4a807a74bc16141af46.png" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">60多年来，结构化文本的解析问题一直在抵制“一刀切”的解决方案。Lezer也不是这样的解决方案，但它是一个非常不错的解析器生成器，特别适合在代码编辑器中使用。
Lezer(荷兰语中的读取器，发音类似于“LASSER”)提供了一个解析器生成器，该生成器输出JavaScript模块，可以加载这些模块将代码解析到非抽象语法......</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button></div></div><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded clearfix"><div class="item_title"><a target="_blank" href="/story/technology_internet_158163.html">[组图]微软Xbox 360全身动作感应系统Natal解析</a></div><span class="my_story_list_date">2009-6-9 19:31</span><div class="float-md-right my_story_img_thumb"><a target="_blank" href="/story/technology_internet_158163.html"><img src="http://img.diglog.com/img/2009/6/thumb_c64c219fee8849b78b2c7dcf7f45a8b7.jpg" class="img-fluid my_story_img_thumb" onerror="this.style.display='none'"></a></div><div class="my_story_list_item_desc">上周在美国洛杉矶举行的E3 2009游戏展上，微软发布了Xbox 360游戏机的全身动作感应系统——Natal。有了这项技术的帮助，玩家今后无须使用游戏控制器，只用身体语言便可玩游戏。微软还宣称，Natal可以识别各种情感，已给玩家、开发人员甚至像史蒂芬&#183；斯皮尔伯格这样的大导演留下了深刻印象。</div><div class="my_item_tag_container"><button type="button" class="btn btn-light my_tag"><a href="/tag/xbox/">#xbox</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/360/">#360</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/natal/">#natal</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/全身动作感应系统/">#全身动作感应系统</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button></div></div></div></div><div class="col-lg-4 col-0"><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/warning/">#warning</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/ai/">#ai</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/学习/">#学习</a></button></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>