<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>来自因子团队的TDD TDD from the Factorio Team</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">TDD from the Factorio Team<br/>来自因子团队的TDD </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-18 19:39:35</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/20f7cc581ee120e937806f5a83f1cd3d.png"><img src="http://img2.diglog.com/img/2021/6/20f7cc581ee120e937806f5a83f1cd3d.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>We obviously have a lot to talk about when it comes to the game changes we recently did, or plan to do, but we don&#39;t want to share any of it yet.</p><p>我们显然有很多谈论，我们最近谈到了游戏更改，或者计划做，但我们不想分享任何一个。</p><p>  Yet, there is currently a topic very relevant to us and we can share it without revealing any specific changes to the game. Today&#39;s post will be quite technical and related to programming, so if you just came for the game news, you can safely skip this one.</p><p>  然而，目前对我们来说非常相关的话题，我们可以没有透露任何具体修改游戏分享。今天＆＃39; S Post将是非常技术性的，与编程相关，所以如果您刚刚来到游戏新闻，您可以安全地跳过这一点。</p><p>    Now that there are only developers here, I can share my new discovery of Uncle Bob and his  really nice explanation of some of the fundamental principles related to programming project management, and more. If you have 8.5 free hours on your hands, I propose you watch it, as there will be some references to what he mentions later on.</p><p>    现在，只有开发人员在这里，我可以分享我对鲍勃叔叔的新发现以及他对一些与编程项目管理相关的一些基本原则的非常好的解释，以及更多。如果你手上有8.5个免费的时间，我就会提出你看它，因为会有一些引用他在以后的提到。</p><p>  My general thought was, that we maintain the quality of the code to be quite high, and we have a reasonably good work methodology. But we were the victims of selective blindness in many places actually. It is interesting, how some pieces code were just good from start and stayed pretty good throughout all the years, even when it was expanded a lot... and some of the code just deteriorated heavily.</p><p>  我的一般思想是，我们保持代码的质量非常高，我们有一个合理的工作方法。但我们实际上是许多地方的选择性盲目的受害者。有趣的是，一些碎片代码在始于开始，在整个年份都非常好，即使它扩大了很多......而一些代码才会变得巨大恶化。</p><p>    What is a wax foundation and how is it related to programming you might ask? My grandfather was a very enthusiastic bee-keeper. My childhood was spent in our garden, where you had to be careful where you step, where you sit down, and you could never leave anything sweet just laying around, because you would find a big pile of bees on top of it quite soon. I had to help him and learn about the bees from time to time, which I honestly hated, because I knew that I will never have any bees of my own. But he was right about one thing, everything you learn will be useful to you in one way or another.</p><p>    什么是蜡基金会，与您可能会问的编程有关如何？我的祖父是一个非常热情的蜜蜂守护者。我的童年在我们的花园里度过，在那里你必须小心你在哪里，你坐下的地方，你永远不会留下任何甜蜜的东西，因为你会很快找到一大块蜜蜂。我不得不帮助他并不时了解蜜蜂，我真诚地讨厌，因为我知道我永远不会拥有自己的蜜蜂。但他对了一件事，你学到的一切都会以某种方式对你有用。</p><p>  One of the jobs you do around bees, is that when the honey is taken away from the bees, you put the wax foundation in the hive, which looks like this:</p><p>  一个你身边的蜜蜂，作业的是，蜂蜜是由蜜蜂带走的时候，你把蜂巢蜡的基础上，它看起来像这样：</p><p>    Its primary function is that the bees build their tiles evenly and quite fast, as it is just natural to follow the optimised structure that is already there. And this is exactly what happens with code that has a good and expandable design from the start.</p><p>    它的主要功能是蜜蜂均匀地建立瓷砖，并且遵循已经存在的优化结构是自然的。这正是从一开始就具有良好和可扩展设计的代码发生的事情。 </p><p>  On the other hand, there is code that either had a lazy original design, or it was never expected to grow so much in complexity, and each of the changes were just a small addition to the mess. Eventually we got used to the idea that this part of the code is just hell, and that making small changes is annoying. This implies that we just don&#39;t like this part of the code, and we want to spend as little time as possible working with it. And the result is that the problem is slowly spiralling out of control.</p><p>另一方面，有一个代码有一个懒惰的原创设计，或者从未预料到复杂性中的复杂性，并且每个变化都只是乱七八糟的一个少量补充。最终我们已经习惯了这一部分代码的想法只是地狱，而且制作小的变化很烦人。这意味着我们只是＆＃39; t就像代码的这一部分，我们希望尽可能少的时间与它一起工作。结果是，问题正在缓慢循环失控。</p><p>  When I took the  Uncle Bob glasses and started looking around, I quickly identified several problematic places like this. It is not a coincidence, that these places were eating away an disproportionately large amount of the dev time, not only because making changes is hard, but because they are full of regression bugs and generally are a never-ending source of problems.</p><p>  当我拿走叔叔鲍勃眼镜并开始环顾四周时，我很快就确定了这样的几个有问题的地方。这不是一件巧合，这些地方正在消除一个不成比例的大量开发时间，不仅是因为改变很难，而且因为它们充满了回归错误，并且通常是永无止境的问题来源。</p><p>  This is the beautiful thing about having a company that isn&#39;t on the stock market. Imagine you have a company that goes slower and slower every quarter, and then you confront the shareholders with the statement, that the way to solve it, is to do absolutely no new features for a quarter or two, refactor the code, learn new methodologies etc. I doubt that the shareholders would allow that. Luckily, we don&#39;t have any shareholders, and we understand the vital importance of this investment in the long run. Not only in the project, but also in our skill and knowledge, so we do better next time.</p><p>  这是拥有一家公司的美丽事物，该公司在股票市场上and＃39; t。想象一下，你有一家公司每季度慢慢慢，然后你对股东面对陈述，即解决它的方式，是为四分之一或两个，重构代码做出绝对没有新功能，学习新方法等等。怀疑股东将允许这一点。幸运的是，我们没有任何股东，我们了解这项投资的重要意义。不仅在项目中，而且还在我们的技能和知识中，所以我们下次做得更好。</p><p>      It would look pretty reasonable if there was the same amount of people working from start to finish, but it is not. It was just me at the very start, and now there are 9 programmers. It could be explained by the game getting bigger and growing a lot of interconnected mechanics, which is harder to maintain. Or it could also mean that the density of the code improved so much. Both of these are not enough explain why having more programmers doesn&#39;t result in faster development.</p><p>      如果有相同数量的人从开始完成工作，那么它看起来很合理，但它不是。这只是我的开始，现在有9个程序员。它可以通过游戏来解释越来越多的互联机制，这更难以维持。或者它也可能意味着代码的密度提高了如此大。这两个都没有足够的解释为什么有更多程序员并导致更快的开发。</p><p>  This indicates that the problems Uncle Bob describes are relevant to us, and the solution is actually to improve the way we develop rather than just scaling the amount of people. Once we have a nice clean foundation, then hiring new programmers and getting them up to speed with the code will be much faster.</p><p>  这表明鲍勃叔叔描述了与我们相关的问题，解决方案实际上是改善我们发展的方式，而不是仅缩放人数。一旦我们有一个漂亮的干净基础，那么招聘新程序员并让他们加快代码即可更快。</p><p>  Let me now explain a few typical examples of the problems we had, and how we proceeded to fix them:</p><p>  现在让我解释我们所拥有的问题的一些典型例子，以及我们如何修复它们：</p><p>    We wrote a lot about the GUI (for example  FFF-216) and how we iteratively raised the bar of what we find acceptable both from both the user and programmer perspective. The common takeaways from the FFF and from the coding was, that we always underestimated how complicated GUI logic/styles/layouting etc. can become. This implies that improving the way the GUI is written has large potential gains.</p><p>    我们对GUI进行了很多关于GUI（例如FFF-216）以及我们如何从用户和程序员的角度来看，我们如何迭代地提出了我们发现的栏。来自FFF和编码的共同外带是，我们总是低估了复杂的GUI逻辑/样式/布局等。这意味着改善GUI写的方式具有大的潜在收益。 </p><p>  We are happy with the way the GUI objects are structured and laid out since the 0.17 update. But codewise, it still feels much more bloaty than it should be. The main problem was the amount of places you needed to touch to add some interactive element. Let me show you an example, a simple button used to reset presets in the map generator window.</p><p>我们对GUI对象的结构和布局自0.17更新以来的方式感到满意。但是，码头，它仍然感觉比它应该更加愉快。主要问题是您需要触摸以添加一些交互元素所需的地方。让我向您展示一个例子，一个简单的按钮，用于在地图生成窗口中重置预设。</p><p>          Then, we needed to override the method of the ActionListener in our MapGeneratorClass, so we could listen to the click actions.</p><p>          然后，我们需要覆盖MapGeneratorClass中ActionListener的方法，因此我们可以侦听单击操作。</p><p>  And finally, we could implement the method, where we if/else through the elements we care about, to do the actual logic void MapGeneratorGui::onMouseClick(const agui::MouseEvent&amp; event){ if (event.getSourceWidget() == &amp;this-&gt;resetPresetButton) this-&gt;onResetSettings(); else if (event.getSourceWidget() == &amp;this-&gt;randomizeSeedButton) this-&gt;randomizeSeed(); ...</p><p>  最后，我们可以实现这种方法，我们如果我们考虑的元素/否则我们会进行实际逻辑 void mapgeneratorgui :: onmouseclick（const agui :: mousevent＆amp;活动）{ if（event.getsourceWidget（）==＆amp; this-＆gt; resetPreesetButton） this-和gt; onresetsettings（）; 否则if（event.getSourceWidget（）==＆amp; this-＆gt; randomizeseedbutton） this-＆gt; randomizeeed（）; ......</p><p>This is way too much boilerplate for one button with one simple action. We had over 500 places where we registered actionListeners in the code, so imagine the amount of bloat.</p><p>这是一个带有一个简单动作的一个按钮的样板太多。我们在代码中注册了ActionListeners的500多个地方，所以想象膨胀的数量。</p><p>  We kind of noticed, that when we use lambdas to signal callbacks and similar things in the GUI, it tends to be much more pleasant to use. So what if we made it the primary way to do the GUI?</p><p>  我们有点注意到，当我们使用lambdas来信号回调和类似的东西时，它往往更令人愉快。那么如果我们做到了这样的主要方式，那么做什么？</p><p>  We decided to completely rewrite the way it works, so instead of adding listeners and the filtering from the event catching functions, we can just specify:</p><p>  我们决定完全重写它的工作方式，所以而不是从事件捕获功能添加侦听器和过滤，我们可以确定：</p><p>    Which is a big improvement already, as adding and maintaining the new logic only requires you to look at one place instead of several, and it makes it generally more readable and less prone to errors.</p><p>    这已经是一个很大的改进，因为添加和维护新的逻辑只需要您查看一个地方而不是几个地方，并且它通常更可读，更容易易于错误。 </p><p>  And since we don&#39;t need to  hold the pointer object for comparisons, we can completely remove its definition from the class, and make it anonymous on many places in this fashion:</p><p>由于我们不需要保持指针对象进行比较，我们可以完全从课堂上删除它的定义，并在此时尚的许多地方匿名使它成为：</p><p>  Rewriting all the GUI internals (again) was a big task, but in the end it really felt to be well worth it, as now I can&#39;t imagine how we could stand doing it the old way. It also resulted in several thousands of lines of code being removed.</p><p>  重写所有GUI内部人员（再次）是一项重要任务，但最终它真的很值得，现在我可以和＃39; T想象我们如何站得能够努力做旧的方式。它也导致了数千行代码被删除。</p><p>      There are several main goals to pursue when you try to make the code cleaner. Removing code duplication is the first and biggest priority. It is reasonably easy to solve when the code isn&#39;t structured well, functions are too long, or names are weird, but if you have 5 versions of the same pile of code with slight changes here and there, it is the worst beast. It is just a question of time, until bugfixes/changes are only applied to some variants, and it becomes less and less obvious whether the differences between the variants are intended or circumstantial.</p><p>      当您尝试制作代码清洁剂时，有几个主要目标可以追求。删除代码复制是第一个也是最大的优先级。当代码isn＆＃39; t结构良好时，函数太长，函数太长，或者名字是奇怪的，但如果你有5个版本的同一堆代码，那么这里有略有变化，它是最糟糕的兽。这只是一个时间的问题，直到错误修正/更改仅适用于某些变体，并且它变得越来越不那么明显，是否有变体之间的差异是意图或间接的。</p><p>  The manual building logic is a monster, because of all the things it supports already:</p><p>  手动构建逻辑是一个怪物，因为它已经支持的所有东西：</p><p>    Then, all of this logic needs to be multiplied by 2 (when you are lazy and copy paste), as you can have normal building and ghost building.</p><p>    然后，所有这些逻辑都需要乘以2（当您懒惰和复制粘贴时），您可以拥有正常的建筑和幽灵大楼。</p><p>  And then, you multiply this whole code abomination by 2 again. Why? Because we also need to do all this logic in the  latency hiding mode. Sounds bad already, but it isn&#39;t all of it, since this logic was continually being patched and touched by different people throughout history, the core of the code was a crazy long method with the code looking like the horizon mentioned by Uncle Bob.</p><p>  然后，您将整个代码乘以2倍再次憎恶。为什么？因为我们还需要在延迟隐藏模式下执行所有这些逻辑。听起来很糟糕，但它是＆＃39; t所有的，因为这个逻辑在整个历史上不断地修补并触及了不同的人，代码的核心是一种疯狂的长方法，代码看起来像叔叔提到的地平线鲍勃。</p><p>  Now imagine that you need to change something about this code, especially when you take into consideration, that the code naturally had many corner cases wrong, or fixed only in some variant of the code. This is a great example of how lazy long-term design leads to poor productivity.</p><p>  现在想象一下，你需要改变关于这个代码的事情，特别是当你考虑时，代码自然有许多角落的错误，或仅在代码的某些变体中固定。这是懒惰的长期设计如何导致生产力差的一个很好的例子。 </p><p>  Long story short, this was approached like a hobby side project of mine that took weeks to be finished, but in the end, all the duplications were merged, the code is well structured and fully tested. Managing the code requires a small fraction of the time compared to the previous state, because the reader is not required to read a huge pile of code just to get the big picture and to be able to change anything.</p><p>长话短说，这是一个像我的业余爱好者的侧面项目才会完成，但最终，所有重复都是合并的，代码结构很好并进行了完全测试。管理代码需要与以前的状态相比的一小部分，因为读者不需要读取一堆代码只是为了获得大图片并能够改变任何东西。</p><p>  This reminds me a quote from Lou after a similar kind of refactoring: &#34; Once we are done with this, it will be actually a pleasure to add stuff to this code.&#34;. Isn&#39;t it beautiful? It is not only more efficient and less buggy, it is also more fun to work with, and working on something enjoyable tends to go faster regardless of other aspects.</p><p>  这让我想起了类似种类的重构：＆＃34;一旦我们完成了这一点，它就实际上是一种乐于将东西添加到这个代码。＆＃34; isn＆＃39;它美丽吗？它不仅更有效和更少的越野车，与之工作也是更有乐趣的，并且在不管其他方面，往往更快地努力工作。</p><p>      No, we obviously didn&#39;t get to this point without automated tests, and we mentioned them several times already ( FFF-29,  FFF-288, and more). We try to continuously raise the bar of what code areas are covered by tests, and this lead us to cover yet another area, the GUI. This aligns with the ever repeating underestimation of the amount of engineering care the GUI needs. Having it not tested at all is part of this underestimation, how many times it happened, that we made a release, and it just crashed on something stupid simple in a GUI, just because we didn&#39;t have a test that would click the buttons. And in the end, it proved to not be hard at all to automate the GUI tests. We just have a mode in which the testing environment is created with GUI (even when tests are run without graphics). We declared some helper methods, that allow a very simple definition of where we want the cursor to move, or what we want to click, like this:</p><p>      不，我们显然没有自动测试到达这一点，我们已经提到了几次（FFF-29，FFF-288等）。我们试图连续提高测试所涵盖的代码区域，这导致我们涵盖另一个地区GUI。这与重复低估了GUI需求的低估了低估了。它根本没有测试是这种低估的一部分，它发生了多少次，我们发布了一个释放，它只是因为我们没有测试了一个测试，它只是因为我们没有测试了愚蠢的简单而崩溃了。按钮。最后，它证明并不难以自动化GUI测试。 我们只需使用GUI创建测试环境（即使在没有图形的测试时，即使测试）。我们声明了一些帮助方法，允许一个非常简单的定义，我们希望光标移动，或者我们想要点击的内容：</p><p>    The clicking method is then calling the low level events of input, so all layers of event processing and GUI logic are tested. This is an example of end-to-end test, which is a controversial topic, because some &#34;schools&#34; of test methodology say, that everything should be tested separately, so in this case, we should theoretically test only, that clicking the button first, which creates an InputAction to be processed, and then, have an independent test of the InputAction working properly. I like this approach in some cases, but most of the time I really like that I can penetrate all layers of the logic with only a few lines of code. (more in the Test dependencies part)</p><p>    然后，点击方法调用输入的低级别事件，因此测试所有事件处理和GUI逻辑的所有层。这是端到端测试的一个例子，这是一个有争议的主题，因为一些＆＃34;学校＆＃34;考试方法说，所有应该单独测试一切，所以在这种情况下，我们应该理论上只能测试，首先单击按钮，从而创建要处理的输入，然后，对输入工作的独立测试工作。在某些情况下，我喜欢这种方法，但我真的很喜欢，我可以只用几行代码渗透所有的逻辑层。 （在测试依赖性部分中更多）</p><p>      I have to admit, that I didn&#39;t know what TDD really was until recently. I thought that it is some nonsense, because it sounds really impractical and unrealistic to first write all the tests for some feature (without the ability to try it or even compile it), and then try to implement something that satisfies it.</p><p>      我必须承认，我没有知道TDD真的是什么直到最近。我认为这是一些废话，因为它对某些功能的所有测试（没有尝试它或甚至编译它）来说，它听起来非常不切实无于并且不切实际，然后尝试实现满足它的东西。</p><p>  But that is not TDD, and it had to be shown to me in a &#34;for dummies&#34; way for me to realize how wrong I was.</p><p>  但这不是TDD，它必须在A＆＃34中向我展示;对于假人＆＃34;让我意识到我有多错了。</p><p>  TDD actually is the constant fast swithing between extending the tests and making them pass continously. So as you write tests, you write code to satisfy them basically at the same time. This allows you to instantly test what you write, and mainly use tests as specifiation of what the code should acctually do, which guides the thought process to make you think about where you are headed to, and to write code that is more structured and testable from the very beginning.</p><p>  TDD实际上是延长测试之间的恒定快速旋转，并使它们持续通过。因此，在编写测试时，您将编写代码以同时基本满足它们。这允许您立即测试您所写的内容，主要使用测试作为代码应确认的指令，这指出了思想过程，使您考虑您所在位置，并编写更具结构化和可测试的代码从一开始就。 </p><p>  So after the &#34;AHA&#34; moment of realizing what TDD really is, I started to be instant fan. I&#39;m now putting a lot of effort to try to follow the TDD methodology as much as possible, and to force it on others in the team as well. It feels slower, to write tests even for simple pieces of logic that just bound to be right, but the test proved me wrong several times already, and prevented annoying low-level debugging sessions in the near future.</p><p>所以之后＆＃34; aha＆＃34;实现TDD的时刻真的，我开始是即时粉丝。我现在正在努力尽量努力，尽可能地遵循TDD方法，并强迫它在团队中的其他人。它感觉速度慢，即使是恰到好处的简单逻辑也是正确的，但是测试已经证明了我已经多次证明了我，并阻止了在不久的将来讨厌低级调试会话。</p><p>          If tests should be truly independent, test C, should have some mocks of A and B, so the test of C is independent of the system A + B working correctly. The consensus seems to be, that this leads to more independent design etc.</p><p>          如果测试应该真正独立，测试C，应该有一些A和B的模型，因此C的测试与系统A + B独立工作。共识似乎是，这导致更独立的设计等。</p><p>  This might be applicable in a lot of cases, but I believe that trying to have this approach everywhere is close to impossible, and it would lead to a lot of clutter and  I&#39;m not the only one having problem with this.</p><p>  这可能适用于很多情况，但我相信随时随地试图实现这种方法是接近不可能的，它会导致很多杂乱和我＆＃39; m不是唯一一个有问题的杂乱。</p><p>  For example, lets say that we have a test of electric poles connecting properly on the map. But I can hardly test it when I don&#39;t know that searching for entities on the map works properly.</p><p>  例如，让我们说我们对地图上正确连接的电极测试。但是当我不知道地图上搜索地图上的实体正常工作时，我很难测试它。</p><p>  My conclusion is, that having dependencies like this is fine, as long as the dependencies are also tested, but the problem comes when you break something and a lot of tests start to fail suddenly. When you do small changes the yes/no indication of tests is enough, but it isn&#39;t always an option, especially when you refactor some internal structure, in which case you kind of expect to break a lot of stuff, and you need to have a way to fix them step by step once it can compile again.</p><p>  我的结论是，只要依赖于依赖性也在测试中，就具有这样的依赖性，但是当你打破某些东西并且很多测试开始失败时，问题就会出现问题。当你做小的改变时，是/否的测试是足够的，但它始终是一个选择，特别是当你重构一些内部结构时，在这种情况下，你有点期待打破很多东西，而你一旦它再次编译，需要有一种方法来逐步修复它们。</p><p>  If the tests don&#39;t have any special structure, the situation when 100 tests all fail at the same time is very unfortunate, all you are left with is to try to pick some test semi-randomly, and start debugging it. But it is really misleading when some complicated test case fails in the middle, and you spend a long time debugging it, only to realise that it is some very simple low level bug that is causing the failure.</p><p>  如果测试没有任何特殊的结构，那么局势在100测试时都是非常不幸的，你剩下的就是尝试半随机选择一些测试，然后开始调试它。但是，当一些复杂的测试案件在中间失败时，它真的误导了，你花了很长时间调试它，只是意识到它是导致失败的一些非常简单的低级错误。</p><p>  The goal is pretty easy, I want to be given the most simple fail case of my change.</p><p>  目标很容易，我希望得到我改变的最简单的失败情况。 </p><p>  For this, I implemented a simple test dependency system. The tests are executed and listed in a way, that when you get to debug and check a test, you know that all of its dependencies are already working correctly. I tried to search if others use the dependencies as well, and how they do it, and I surprisingly didn&#39;t find anything.</p><p>为此，我实现了一个简单的测试依赖系统。测试以某种方式执行并列出，即当您要调试并检查测试时，您就知道其所有依赖项已经正常工作。我试图搜索其他人也使用依赖关系，以及他们如何做到，而且我惊奇地没有找到任何东西。</p><p>      I built and used this structure when refactoring away the duplication of ghost/real poles connection logic and it certainly sped up the process of making it work properly, and I&#39;m confident that this is the way to structure test for us in the foreseeable future. Not only it makes test results more useful, but it forces us to split test suites into smaller more-specialised units, which certainly help as well.</p><p>      在重构鬼/真杆连接逻辑的重复时，我建立并使用了这种结构，它肯定会加速使它正常工作的过程，我自信地确信这是对我们的结构测试的方式可预见的未来。不仅它使测试结果更有用，但它迫使我们将测试套件分成更小的专业单位，这也很有帮助。</p><p>      When Boskid joined the team as the QA guy, one of his main roles was making sure that any discovered bug is first covered by a test before it gets actually fixed, and generally improving our code test coverage. This made the releases much more confident, and we had less regression bugs, which directly transitions into long-term efficiency. I strongly believe that this clearly indicates and supports what Uncle bob is saying. Working with tests  feels slower but it is actually faster.</p><p>      当Boskid加入团队作为QA Guy时，他的主要角色之一是确保在实际修复之前首先通过测试首次被发现的错误，并且通常改善我们的代码测试覆盖。这使得释放更有信心，我们的回归错误较少，直接转化为长期效率。我强烈认为，这清楚地表明并支持鲍勃叔叔所说的话。使用测试感觉较慢，但实际上是更快的。</p><p>  Test coverage is an indicator of which parts of the code are executed when the application runs (which usually means running the tests in this context). I never used a tool to measure test coverage before, but since it was one of the topics Uncle Bob talked about, I tried to use it for the first time. I found a tool that works only on Windows, but requires the least amount of setup, which is  OpenCppCoverage, which provides an HTML output like this:</p><p>  测试覆盖范围是当应用程序运行时（通常意味着在此上下文中运行测试）时执行代码的部分的指示符。我从未使用过一个工具以衡量测试覆盖，但由于它是鲍勃叔叔的一个谈话之一，我试图第一次使用它。我找到了一个仅适用于Windows的工具，但需要最少的设置量，它是OpenCPPCoverage，它提供了如此：</p><p>    It is immediately visible, that both of the conditional commands are not triggered in tests. It basically means that either the code just isn&#39;t tested, so it should be covered, or it&#39;s dead code, so it should be removed. I&#39;m quite confident (again), that using this can help us a lot to write clean high quality code.</p><p>    它立即可见，即在测试中都不会触发两个条件命令。它基本上意味着代码只是测试，所以它应该被覆盖，或它＆＃39; s死代码，所以它应该被删除。我非常自信（再次），使用这可以帮助我们编写清洁高质量代码。</p><p>        If you are moved by this, if your emotion when you read this is, &#34; I wish my boss had these priorities&#34;. Consider applying for a  job at Wube!</p><p>        如果你被这一点移动，如果你读到这一点的情绪是，＆＃34;我希望我的老板有这些优先事项＆＃34;考虑在武器申请工作！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://factorio.com/blog/post/fff-366">https://factorio.com/blog/post/fff-366</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/因子/">#因子</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/factorio/">#factorio</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>