<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>设计RISC-V CPU，第2部分：成功执行（某些）说明 Designing a RISC-V CPU, Part 2: Successfully executing (some) instructions</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Designing a RISC-V CPU, Part 2: Successfully executing (some) instructions<br/>设计RISC-V CPU，第2部分：成功执行（某些）说明 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-20 08:56:29</div><div class="page_narrow text-break page_content"><p>The  previous instalment of thisseries was &#34;basically an explanation of what FPGAs are and a &#39;hello world&#39;nMigen example.&#34;  1 In this post, I will be detailing the design of my CPU asit currently stands, and going over the various mistakes I made along the way.As with the previous post, I am primarily aiming this at software engineers whoare new to hardware design – but I hope it will be interesting to anyoneinterested in nMigen, RISC-V, or CPU design generally.</p><p>此前的这一份额是＆＃34;基本上解释了FPGA和A＆＃39; Hello World＆＃39; nmigen例子。＆＃34; 1在这篇文章中，我将详细说明我的CPU目前的设计，并追溯到我沿途所做的各种错误。与上一篇文章一起，我主要针对软件工程师的旨在新的硬件设计 - 但我希望它对尼格珍，RISC-V或CPU设计中的任何人感兴趣。</p><p> I hope the mistakes I made along the way will be a useful frame for consideringthese questions:</p><p> 我希望我沿途的错误将是考虑这些问题的有用框架：</p><p>  You can see the code for my CPU at the time of writing hereor an up to date version  here.</p><p>  您可以在此处在此处撰写最新版本时查看CPU的代码。</p><p>  RISC-V (&#34;risk five&#34;) is an open standard instruction set architecture (ISA).&#34;RISC&#34; means &#34;reduced instruction set computer&#34;, broadly meaning that theISA prioritises simple instructions. In contrast, CISC (complex instruction setcomputer) ISAs are optimised to perform actions in as few instructions aspossible, hence their instructions are often more complex. ARM architecturesare RISC; x86-related architectures are CISC.</p><p>  RISC-V（＆＃34;风险五＆＃34;）是一个开放标准指令集架构（ISA）。＆＃34; RISC＆＃34;手段＆＃34;减少指令集计算机＆＃34;大概意味着Theisa优先考虑简单的指示。相比之下，CISC（复杂的指令套件）ISAS被优化，以便在只有您的目录中执行动作，因此它们的指令通常更复杂。 ARM Architecturesare RISC; X86相关的架构是CISC。</p><p> Usually in industry, ISAs are patented, so in order to implement the ISA youneed an (expensive) license from the vendor. Often, commercial ISAs are poorlydocumented, with the motivation behind design details not always beingavailable even after such a license agreement.</p><p> 通常在工业中，ISAS获得专利，因此为了实现供应商的ISA（昂贵的）许可。通常，商业ISAS差不多，即使在此类许可协议之后，设计细节背后的动机并不总是不行性。</p><p>  An ISA that avoids &#34;over-architecting&#34; for a particular microarchitecturestyle, but which allows efficient implementation in any of these.</p><p>  避免＆＃34的ISA;过度架构和＃34;对于特定的微型校准urestyle，但这允许有效地实现其中任何一个。</p><p> Additionally, a lot of commercial architectures are complex and burdened withbackwards-compatibility constraints. RISC-V offers a fresh start!</p><p> 此外，很多商业架构都很复杂，背负着兼容性约束。 RISC-V提供新的开始！ </p><p> The ISA doesn&#39;t explain the details of how to design a CPU – it justdefines an abstract model of the CPU, mostly by defining what instructions theCPU must support, including:</p><p>ISA不解释如何设计CPU的详细信息 - 它刚刚定义CPU的抽象模型，主要是通过定义TheCPU必须支持的指示，包括：</p><p> The encoding of the instructions (i.e. how to construct the machine code that the CPU will run)</p><p> 指令的编码（即如何构建CPU将运行的机器代码）</p><p> How to actually create a CPU that realises these requirements is up to us \o/</p><p> 如何实际创建一个实现这些要求的CPU取决于我们\ o /</p><p>  I&#39;m trying to design a single-stage CPU; that is, I&#39;m trying to design a CPUthat retires one instruction per clock cycle with no pipelining. Usually CPUshave pipelining in place to maximise efficiency. I am hoping that avoiding thiswill result in a simpler design more suitable to my learning. Perhaps it willcomplicate other aspects of the design (like my program counter having 3outputs), but I&#39;m certainly finding it easier to hold the design in myhead when I only have to think about this clock cycle and the next. I willlikely discuss this in more detail in the next blog post where I implement theload instructions. I have a plan for how to make these work in a single cycle,but they do pose a particular challenge and I may change my design as aconsequence.</p><p>  我试图设计一个单级CPU;也就是说，我试图设计一个Cuthat，每个时钟周期都没有管道的指令。通常是CPOSHAVE PIPELINING，以最大限度地提高效率。我希望能够避免这种速度更加适合我的学习。也许它会使设计的其他方面（如我的程序计数器有3个输出），但是当我只需要思考这个时钟周期和下一个时钟周期时，我肯定会发现它更容易在Myhead中保持设计。我将在我实施的下一个博客文章中更详细地讨论这一点。我有一个计划如何在一个周期中制作这些工作，但他们确实构成了一个特殊的挑战，我可能会改变我的设计作为听力。</p><p>  RISC-V defines various ISA modules; I will be implementing RV32I, the base32-bit integer instruction set.</p><p>  RISC-V定义各种ISA模块;我将实现RV32i，Base32位整数指令集。</p><p> To design my CPU, I first looked at the JAL (jump and link) and the ADDI (addimmediate) instructions, and drew a block diagram of what hardwarewould be needed to decode those instructions. I think the ADDI instruction iseasier to grasp if you&#39;re not used to thinking about how machine code isencoded, so we&#39;ll start with that. If this all totally foreign to you, youmight enjoy my introduction to ARM assembly.</p><p> 要设计我的CPU，我首先查看了jal（跳跃和链接）和addi（addimmediate）的指令，并画出了解码这些指令所需的硬件的框图。如果你＆＃39，我认为addi指令是掌握的，不习惯考虑机器代码如何衡量，所以我们＆＃39; ll从那开始。如果这一切都是完全陌生的，你可以享受我对ARM组装的介绍。</p><p>     An immediate is analogous to a literal value in source code; the value itself is encoded in the instruction, rather than e.g. retrieved from a register.</p><p>     直接类似于源代码中的文字价值;值本身在指令中编码，而不是例如例如。从寄存器中检索。 </p><p>  Once we&#39;ve read the  opcode, we know that bits 12-14 contain the  funct3 field (3 for 3 bits), which encodes whether this is an ADDI instruction (or SLTI, ANDI &amp;c.)</p><p>一旦我们读取了操作码，我们就知道位12-14包含了Funct3字段（3位3位），它们编码这是ADDI指令（或SLTI，ANDI＆amp; c。）</p><p>  Retrieve the value stored in register  rs1 Therefore, our register file needs an input for selecting this register to read, and an output for the data read from that register.</p><p>  检索存储在寄存器RS1中的值，因此，我们的寄存器文件需要输入用于选择该寄存器的输入，以及从该寄存器读取的数据的输出。</p><p> Sign-extension will be necessary too – this is just the process oftaking a number narrower than (in our case) 32 bits, and filling in theremaining bits such that two&#39;s complement arithmetic will be performedcorrectly. I won&#39;t include this in the diagram below.</p><p> 签名将是必要的 - 这只是一个窄于（在我们的案例）32位的数字的过程，并填充了两种＆＃39; s补充算术将被执行。我在下面的图中赢得了这个＆＃39;</p><p> Implicit in all this is that we&#39;ll need some way to retrieve the instructionitself and pass it to the instruction decoder. The  program counter iswhat tells the instruction memory which address to retrieve an instructionfrom.</p><p> 在所有这一切中都是隐式的，我们＆＃39; ll需要某种方式来检索指令等，并将其传递给指令解码器。程序计数器是告诉指令存储器的地址以检索指令。</p><p>     The jump and link (JAL) instruction [...] immediate encodes a signed offsetin multiples of 2 bytes. The offset is sign-extended and added to the  pc toform the jump target address. [...] JAL stores the address of the instructionfollowing the jump ( pc + 4) into register  rd.</p><p>     跳转和链接（jal）指令立即对符号偏移量乘以2个字节的倍数。偏移量是签名的，并添加到PC Toform跳转目标地址。 [...] jal将跳转（PC + 4）的指令的地址存储到寄存器RD中。</p><p> There&#39;s a lot more going on here, particularly if you aren&#39;t familiar withmachine code. We noted above that the program counter sets which instructionwill be executed next. Usually the program counter simply increments to thenext address each cycle – that&#39;s how we continue to execute our program!However, say our program calls a subroutine stored elsewhere in memory; we&#39;dneed a way to  jump to the subroutine address. Or, say we wanted an infiniteloop (ubiquitous in embedded software!); we&#39;d need a way to  jump  4 back tothe address at the start of the loop. JAL allows for these situations.</p><p> 在这里有很多进展，特别是如果你arean＆＃39; t熟悉使用冲突代码。我们上面注意到，程序计数器设置下次执行哪些指令。通常，程序计数器只需递增到每个周期的那个地址到目前述 - 那个＆＃39;我们如何继续执行我们的程序！但是，我们的程序调用存储在内存中其他地方的子程序;我们＆＃39; dneed是一种跳到子程序地址的方法。或者说，我们想要一个英特诺伊州（嵌入式软件中的无处不在！）;我们需要一种方法可以在循环开始时跳跃4返回地址。 jal允许这些情况。</p><p> The &#34;link&#34; part of JAL is the part where the next instruction is stored in thedestination register. This is convenient when the jump is used to execute asubroutine: once the subroutine completes, we can jump back to that storedinstruction address.</p><p> ＆＃34;链接＆＃34; jal的一部分是下一个指令存储在theStinal寄存器中的部分。这是方便的跳转用于执行ASUBRoutine：一旦子程序完成，我们就可以跳回该存储intricle地址。 </p><p>    The LSB  5 of the immediate is not encoded because it must be 0: only offsets in multiples of 2 bytes are supported.</p><p>立即的LSB 5未被编码，因为它必须是0：支持仅支持2个字节的倍数。</p><p> The unshuffling caused me some pain in my code, so it&#39;s amusing to me that itwon&#39;t be part of the block diagram below. But it&#39;s part of the internals of theinstruction decoder, not its interface, which is what we are determining withthese diagrams. The shuffled bits might seem nonsensical, but they&#39;re chosen tomaximise overlap with other instruction formats in RISC-V.</p><p> 无声地引起了我在我的代码中有些痛苦，所以它有趣地对我来说，Itwon＆＃39; t是下面的框图的一部分。但它＆＃39; stinstruction解码器内部的部分，而不是它的界面，这是我们在用这些图中确定的。随着RISC-V中的其他指导格式，默认的比特似乎可能似乎是荒谬的，但它们＆＃39</p><p>   The next challenge is to draw a block diagram that implements both ADDI andJAL. The first obvious problem: the inputs to the ALU are different in bothcases, as is the wiring of the output. We need some kind of logic block thatcan pick between them depending on some control signal: a multiplexer (mux).</p><p>   下一个挑战是绘制一个实现ADDI和JAL的框图。第一个明显的问题：alu的输入在两个杂志中都是不同的，也是输出的接线。我们需要某种逻辑块，根据某些控制信号在它们之间挑选它们：多路复用器（MUX）。</p><p> We also need a way to tell the program counter whether the next instructionaddress should come from a set address or from incrementing the currentaddress.</p><p> 我们还需要一种方法来告诉程序计数器，无论下一个名字身份是否应来自SET地址或递增CurrendAddress。</p><p> Here&#39;s what my design looks like at the moment (excluding a few things I havebecause I know I&#39;ll need them later, like two read select/data signals on theregister file):</p><p> 在这里＆＃39;我的设计目前看起来像什么（不包括一些我已经知道的东西，因为我知道我稍后需要它们，就像上述文件上的两个读取选择/数据信号）：</p><p>   As covered in my previous blog post, I&#39;m using nMigen to implement my design. As I&#39;mcurrently designing a single-stage CPU, more of my design iscombinatorial, rather than synchronous, because I don&#39;t require the additionalstate that pipelining necessitates. This most likely means my design isunable to run quickly, but that&#39;s not a concern of mine.</p><p>   如我之前的博客文章所涵盖，我使用nmigen实现我的设计。作为i＆＃39; Mcurricly设计单级CPU，更多的设计是Combinatorial，而不是同步的，因为我不需要加工所需的额外的状态。这最有可能意味着我的设计不适当地运行，但它不是我的关注点。</p><p> I don&#39;t think it&#39;s helpful to post all the source code of my implementation inthis blog, but I will include some code here to illustrate mistakes that I madeand what I learned from them.</p><p> 我不认为它＆＃39;很有助于发布我的实现Inthis博客的所有源代码，但我将在此处包含一些代码来说明我疯狂地从中吸取的错误。 </p><p>  I initially implemented my program counter incorrectly after I got reallyconfused about when synchronous updates would take effect. I initially only hadthe  pc and  pc_inc outputs because I didn&#39;t really understand the differencebetween  pc and  pc_next. It&#39;s taken some getting used to thinking about thewhole logic circuit &#34;happening at once&#34;  7, rather thinking sequentially likeI would when writing software. This is what led to my confusion. Properlyconceptualising your circuit in this way is key, and a challenge if you&#39;re usedto writing software.</p><p>在同步更新生效时，我最初在安全性地确认后，我最初在安全性地执行了我的程序计数器。我最初只有PC和PC_INC产出，因为我没有真正了解PC和PC_Next。它＆＃39; s采取了一些习惯于考虑Whole逻辑电路＆＃34;发生在一次＆＃34; 7，而是在写软件时依次思考依次思考。这是导致我的混乱。以这种方式正确扫描您的电路是关键，如果您曾经写过软件，则挑战。</p><p>  1  &#34;&#34;&#34; Program Counter &#34;&#34;&#34;  2  import nmigen  as nm  3   4 INSTR_BYTES  =  4  5   6   7  class  ProgramCounter (nm .Elaboratable ) :  8   &#34;&#34;&#34;  9   Program Counter 10  11   * load (in): low to increment, high to load an address 12   * input_address (in): the input used when loading an address 13  14   * pc (out): the address of the instruction being executed this clock cycle 15   * pc_next (out): the address of the instruction being executed next clock 16   cycle 17   * pc_inc (out): the address after that of the instruction being executed 18   this clock cycle 19    &#34;&#34;&#34; 20  21   def  __init__ (self , width = 32 ) : 22  self .load  = nm .Signal () 23  self .input_address  = nm .Signal (width ) 24  self .pc  = nm .Signal (width ) 25  self .pc_next  = nm .Signal (width ) 26  self .pc_inc  = nm .Signal (width ) 27  28   def  elaborate (self , _ ) : 29  m  = nm .Module () 30  31  m .d .comb  += self .pc_inc .eq (self .pc  + INSTR_BYTES ) 32  m .d .sync  += self .pc .eq (self .pc_next ) 33  34   with m .If (self .load ) : 35  m .d .comb  += self .pc_next .eq (self .input_address ) 36   with m .Else () : 37  m .d .comb  += self .pc_next .eq (self .pc_inc ) 38  39   return m</p><p>  1＆＃34;＆＃34;＆＃34;程序柜台＆＃34;＆＃34;＆＃34; 2导入nmigen为nm 3 4 instr_bytes = 4 5 6 7类编程器（nm .elaboraitable）：8＆＃34;＆＃34;＆＃34;＆＃34; 9程序计数器10 11 *负载（IN）：低至增量，高加载地址12 * INPUT_ADDRESS（IN）：在加载地址13 14 * PC（OUT）时使用的输入：执行该指令的地址时钟周期15 * pc_next（out）：下次执行的指令的地址16循环17 * pc_inc（out）：在执行的指令之后的地址在执行18个时钟周期19＆＃34;＆＃34;＆＃34;＆＃34;＆ ＃34; 20 21 def __init__（self，width = 32）：22 self .load = nm .signal（）23 self .input_address = nm .signal（宽）24 self .pc = nm .signal（宽）25 self .pc_next = nm .signal（宽度）26自我.pc_inc = nm。股票（宽度）27 28 def精细精致（self，_）：29 m = nm .module（）30 31 m .d .comb + = self .pc_inc .eq（self .pc + instr_bytes）32 m .d .sync + = self .pc .eq（self .pc_next）33 34，m .if（self .load）：35 m .d .comb + = self .pc_next .eq（self .input_address）36使用m .else（）：37 m .d .comb + = self .pc_next .eq（self .pc_inc）38 39返回m </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://mcla.ug/blog/risc-v-cpu-part-2.html">https://mcla.ug/blog/risc-v-cpu-part-2.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/risc/">#risc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>