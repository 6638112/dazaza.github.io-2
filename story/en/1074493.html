<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>JDK飞行记录器文件格式The JDK Flight Recorder File Format</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The JDK Flight Recorder File Format<br/>JDK飞行记录器文件格式</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-21 22:29:00</div><div class="page_narrow text-break page_content"><p>The  JDK Flight Recorder (JFR) is one of Java’s secret weapons;deeply integrated into the Hotspot VM, it’s a high-performance event collection framework,which lets you collect metrics on runtime aspects like object allocation and garbage collection,class loading, file and network I/O, and lock contention, do method profiling, and much more.</p><p>JDK飞行记录仪（JFR）是Java的秘密武器之一；它深入集成到Hotspot VM中，是一个高性能的事件收集框架，可用于收集运行时方面的指标，如对象分配和垃圾收集、类加载、文件和网络I/O、锁争用、执行方法分析等。</p><p> JFR data is persisted in recording files(since Java 14, also  &#34;realtime&#34; event streaming is supported),which can be loaded for analysis into tools like JDK Mission Control (JMC),or the  jfr utility coming with OpenJDK itself.</p><p>JFR数据保存在记录文件中（因为Java 14也支持实时事件流），可以将其加载到JDK任务控制（JMC）或OpenJDK自带的JFR实用程序中进行分析。</p><p> While there’s lots of blog posts, conference talks, and other coverage on JFR itself,information about the format of recording files is surprisingly heard to come by.There is no official specification,so the only way to actually understand the JFR file format is to read the source code for writing recordings in the JDK itself,which is a combination of  Java and  C++ code.Alternatively, you can study the code for  parsing recordings in JMC (an official JDK project).Btw., JMC comes with a pure Java-based JFR file  writer implementation too.</p><p>虽然有很多关于JFR本身的博客帖子、会议演讲和其他报道，但令人惊讶的是，关于记录文件格式的信息却层出不穷。没有正式的规范，所以真正理解JFR文件格式的唯一方法是读取源代码，用于编写JDK本身的录音，这是java和C++代码的组合。或者，您可以在JMC（一个正式的JDK项目）中学习解析记录的代码。顺便说一句，JMC还提供了一个纯基于Java的JFR文件编写器实现。</p><p> Apart from the source code itself,the only other somewhat related resources are several  JFR-related blog posts by Marcus Hirt,and a post  about JFR event sizes by Richard Startin.But there’s no in-depth discussion or explanation of the file format.As it turns out, all this by design;the OpenJDK team shied away  from creating a spec,&#34;because of the overhead of maintaining and staying compatible with it&#34;.I.e. the JFR file format is an implementation detail of OpenJDK,and as such the only stable contract for interacting with it are the APIs provided by JFR.</p><p>除了源代码本身，唯一其他一些相关的资源是Marcus Hirt的几篇与JFR相关的博客文章，以及Richard Startin的一篇关于JFR事件大小的文章。但对文件格式没有深入的讨论或解释。事实证明，这一切都是有意为之；OpenJDK团队回避创建规范&34；因为维护和保持兼容的开销&#34；。也就是说，JFR文件格式是OpenJDK的一个实现细节，因此与之交互的唯一稳定契约是JFR提供的API。</p><p> Now, also if it is an implementation detail, knowing more about the JFR file format would certainly be useful;for instance, you could use this to implement tools for analyzing and visualizing JFR data in non-JVM programming languages,say Python, or to patch corrupted recording files.So my curiosity was piqued and I thought it’d be fun to try and find out how JFR recording files are structured.In particular, I was curious about which techniques are used for keeping files relatively small,also with hundreds of thousands or even millions of recoreded events.</p><p>现在，如果这是一个实现细节，了解更多关于JFR文件格式的信息肯定会很有用；例如，您可以使用它来实现工具，用非JVM编程语言（比如Python）分析和可视化JFR数据，或者修补损坏的记录文件。所以我的好奇心被激发了，我想尝试了解JFR录音文件是如何构造的会很有趣。特别是，我想知道哪些技术用于保持文件相对较小，以及数十万甚至数百万记录的事件。</p><p> I grabbed a hex editor, the source code of JMC’s recording parser(which I found a bit easier to grasp than the Java/C++ hybrid in the JDK itself),and loaded several example recordings from my  JFR Analytics project,stepping through the parser code in debug mode(fun fact: while doing so, I noticed JMC currently fails to parse events with   char attributes).</p><p>我抓取了一个十六进制编辑器，这是JMC录音解析器的源代码（我发现它比JDK中的Java/C++混合版本更容易掌握），并从我的JFR Analytics项目中加载了几个示例录音，在调试模式下逐步分析解析器代码（有趣的事实：在这样做时，我注意到JMC目前无法解析具有char属性的事件）。</p><p> Just a feeew hours later, and I largely understood how the thing works.As an image says more than a thousand words,and I’ll never say no to an opportunity to draw something in the fabuluous  Excalidraw,so I proudly present to you this visualization of the JFR file format as per my understanding(click to enlarge):</p><p>仅仅几个小时后，我基本上理解了它的工作原理。正如一张图片所说的千言万语，我永远不会拒绝在神奇的Excalidraw中绘制某些东西的机会，因此，根据我的理解，我自豪地向大家展示JFR文件格式的可视化（点击放大）：</p><p>  It’s best viewed on a big screen 😎.Alternatively, here’s a  SVG version.Now this doesn’t go into all the finest aspects,so you probably couldn’t go off and implement a clean-room JFR file parser solely based on this.But it does show the relevant concepts and mechanisms.I suggest you spend some time going through sections one to five in the picture,and dive into the sections for header, metadata, constant pool, and actual recorded events.Studying the image should give you a good understanding of the JFR file format and its structure.</p><p>最好在大屏幕上观看😎.或者，这里有一个SVG版本。现在，这并没有涉及到所有最好的方面，所以您可能无法单独基于此实现一个干净的JFR文件解析器。但它确实展示了相关的概念和机制。我建议您花一些时间浏览图片中的第一到第五部分，然后深入了解标题、元数据、常量池和实际记录的事件。研究图像可以让你很好地理解JFR文件格式及其结构。</p><p> Here are some observations I made as I found my way through the file format:</p><p>以下是我在浏览文件格式时所做的一些观察：</p><p> JFR recordings are organized in chunks: Chunks are self-contained independent containers of recorded events and all the metadata required for interpreting these events.There’s no additional content in recordings besides the chunks, i.e.  concat several chunk files, and you’ll have a JFR recording file.A multi-chunk recording file can be split up into the individual chunks using the   jfr utility which comes with OpenJDK:</p><p>JFR记录被组织成块：块是记录的事件以及解释这些事件所需的所有元数据的独立容器。除了区块之外，录制中没有其他内容，例如，concat几个区块文件，您将拥有一个JFR录制文件。使用OpenJDK附带的jfr实用程序，可以将多块记录文件拆分为各个块：</p><p>  The default chunksize is 12MB, but if needed, you can override this, e.g. using the  -XX:FlightRecorderOptions:maxchunksize=1MB option when starting a recording.A smaller chunk size can come in handy if for instance you only want to transmit a specific section of a long-running recording.On the other hand, many small chunks will increase the overall size of a recording,due to the repeatedly stored metadata and constant pools</p><p>默认chunksize为12MB，但如果需要，您可以覆盖它，例如在开始录制时使用-XX:FlightRecorderOptions:maxchunksize=1MB选项。例如，如果您只想传输长时间运行的录音的特定部分，则较小的数据块大小会很有用。另一方面，由于重复存储元数据和常量池，许多小数据块会增加记录的整体大小</p><p> The event format is self-descriptive: The metadata part of each chunk describes the structure of the contained events, all referenced types, their attributes, etc.; by means of JFR  metadata annotations, such as  @Label,  @Description,  @Timestamp etc., further metadata like human-readable names and description as well as units of measurements are expressed,allowing to consume and parse an event stream without a-priori knowledge of specific event types. In particular, this allows for the definition of  custom event types and displaying them in the generic event browser of JMC (of course, bespoke views such as the &#34;Memory&#34; view rely on type-specific interpretations of individual event types)</p><p>事件格式是自描述性的：每个块的元数据部分描述所包含事件的结构、所有引用的类型及其属性等。；通过JFR元数据注释，如@Label、@Description、@Timestamp等，进一步的元数据，如人类可读的名称和描述以及度量单位被表达出来，允许在不预先知道特定事件类型的情况下使用和解析事件流。特别是，这允许定义自定义事件类型，并将其显示在JMC的通用事件浏览器中（当然，诸如&#34；内存&#34；视图等定制视图依赖于单个事件类型的特定类型解释）</p><p> The format is geared towards space efficiency: Integer values are stored in a variable-length encoded way ( LEB128), which will safe lots of space when storing small values.A constant pool is used to store repeatedly referenced objects, such as String literals,stack traces, class and method names, etc.;for each usage of such constant in a recorded event, only the constant pool index is stored(a var-length encoded  long).Note that Strings can either be stored as raw values within events themselves, or in the constant pool. Unfortunately, no control is provided for choosing between the two; strings with a length between 16 and 128 will be stored in the constant pool, any others as raw value. It could be a nice extension to give event authors more control here, e.g. by means of an annotation on the event attribute definition</p><p>该格式旨在提高空间效率：整数值以可变长度编码方式（LEB128）存储，这将在存储小数值时保护大量空间。常量池用于存储重复引用的对象，如字符串文字、堆栈跟踪、类和方法名等。；对于记录的事件中每次使用此类常量，只存储常量池索引（var长度编码为long）。请注意，字符串可以作为原始值存储在事件本身中，也可以存储在常量池中。不幸的是，没有提供在两者之间进行选择的控制；长度在16到128之间的字符串将存储在常量池中，其他字符串将作为原始值存储。这可能是一个很好的扩展，可以让事件作者在这里拥有更多的控制权，例如通过事件属性定义上的注释</p><p> When using the  jdk.OldObjectSample event type,beware of bug  JDK-8277919,which may cause a bloat of the constant pool,as the same entry is duplicated in the pool many times.This will be fixed in Java 17.0.3 and 18.</p><p>当使用jdk时。OldObjectSample事件类型，请注意错误JDK-8277919，这可能会导致常量池膨胀，因为同一个条目在池中重复多次。这将在Java 17.0.3和18中修复。</p><p> The format is row-based: Events are stored sequentially one after another in recording files; this means that for instance boolean attributes will consume one full byte, also if actually eight boolean values could be stored in a single byte.It could be interesting to explore a columnar format as an alternative,which may help to further reduce recording size,for instance also allowing to efficiently compress event timestamps values using  delta-encoding</p><p>该格式基于行：事件在记录文件中顺序存储；这意味着，例如，布尔属性将消耗一个完整字节，如果一个字节中可以存储八个布尔值的话。探索柱状格式作为替代方案可能会很有趣，这可能有助于进一步减少记录大小，例如，还允许使用增量编码有效地压缩事件时间戳值</p><p> Compression support in JMC reader implementation: The JFR parser implementation of JMC transparently unpacks recording files which are compressed using GZip, ZIP, or LZ4(Marcus Hirt discusses the compression of JFR recordings in  this post).Interestingly, JMC 8.1 still failed to open such compressed recording with an error message.The  jfr utility doesn’t support compressed recording files, and I suppose the JFR writer in the JDK doesn’t produce compressed recordings either</p><p>JMC阅读器实现中的压缩支持：JMC的JFR解析器实现透明地解压使用GZip、ZIP或LZ4压缩的记录文件（Marcus Hirt在本文中讨论了JFR记录的压缩）。有趣的是，JMC 8.1仍然无法打开这样的压缩记录，并显示错误消息。jfr实用程序不支持压缩录音文件，我想JDK中的jfr编写器也不会生成压缩录音</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/飞行/">#飞行</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/flight/">#flight</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/jfr/">#jfr</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>