<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Hthsm：保持C应用程序整洁的分层有限状态机框架 Hthsm: A hierarchical finite state machine framework for keeping C apps tidy</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Hthsm: A hierarchical finite state machine framework for keeping C apps tidy<br/>Hthsm：保持C应用程序整洁的分层有限状态机框架 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-05 15:23:34</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/7f1e2068f7b97e9be3e11f46cbb20684.gif"><img src="http://img2.diglog.com/img/2021/1/7f1e2068f7b97e9be3e11f46cbb20684.gif" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>If you’ve worked on a Bluetooth LE firmware application, you might be familiar with the “well this got complicated fast” epiphany.  In this post, I’m recommending something of a  silver bullet: A  tried-and-true method to keep BLE firmware structured, serviceable, and maintainable. If you’re dealing with an unruly firmware project, treat yourself to some relief and check out what this can do for your project.</p><p>如果您正在研究Bluetooth LE固件应用程序，那么您可能会熟悉“很好，这很快就变得很复杂”。在这篇文章中，我建议您采取一些灵丹妙药：一种经过实践检验的方法，可以使BLE固件保持结构化，可维护和可维护。如果您要处理的固件项目不拘一格，请放心一些，并检查这对您的项目有什么帮助。</p><p>  Bluetooth Low Energy firmware applications have their  inherent complexities. They’re structured as  event-driven systems. That basically mean they react to “events” that can occur at any time. That’s physical event sources like button presses, battery alerts, and sensors inputs, but also to incoming Bluetooth communications from an App. In our experience, even top-tier chip vendors like Nordic Semiconductors provide subpar guidance on how to best orchestrate this system of events and reactions. Any reasonable developer may start to link event sources in code to their corresponding reactions as they work through features they’re developing. The complexity of this patch network soon grows exponentially and starts feeling like a firmware savant is needed just to make sense of it all. As the project grows, the  event-reaction mappings grow in quantity and  likely require being dynamically re-mapped in different modes of operation. If left untreated, the affliction can get the best of you, spreading faster than you add features. If you’re anything like us, there’s inevitable a face-the-music moment where this event-driven  spaghetti code can no longer be tolerated.</p><p>  低功耗蓝牙固件应用程序具有其固有的复杂性。它们被构造为事件驱动的系统。这基本上意味着他们对随时可能发生的“事件”做出反应。这些物理事件源包括按钮按下，电池警报和传感器输入，还包括来自应用程序的传入蓝牙通信。根据我们的经验，即使像Nordic Semiconductors这样的顶级芯片供应商也提供了有关如何最佳地组织事件和反应系统的出色指南。任何合理的开发人员都可以通过正在开发的功能来开始将代码中的事件源链接到其相应的响应。这个补丁网络的复杂性很快成倍增长，并开始感觉到需要固件才能完全理解它们。随着项目的发展，事件反应映射的数量也在增加，并且可能需要在不同的操作模式下动态地重新映射。如果不加以治疗，这种痛苦可以使您获得最大的收益，传播的速度比添加功能要快。如果您像我们一样，那将不可避免地发生在面对面的音乐时刻，这种事件驱动的意大利面条式代码将不再被容忍。</p><p>  This isn’t the glutinous spaghetti that you bite with your teeth. It’s the kind that  compiles into bytes and bites to deal with. If you’re not aware of spaghetti code and its nauseating effects, then let’s briefly recap. “Spaghetti code” is a slang term for code with convoluted structure, so much that it’s difficult to debug and and maintain it.</p><p>  这不是您用牙齿咬的糯米粉。这种类型可以编译为字节和字节以进行处理。如果您不了解意大利面条代码及其令人讨厌的效果，那么请简要回顾一下。 “意大利面条式代码”是具有复杂结构的代码的语，以至于难以调试和维护。</p><p>  Bugs: the worst kind of bugs. It’s the ugly should-have-been-avoidable bugs that crop up and continue to crop up when you lose a handle on the structure of your application.</p><p>  错误：最糟糕的错误。当您对应用程序的结构失去控制时，这些丑陋的本应避免的错误会不断出现。</p><p> Code duplication. The completely unnecessary there-must-be-a-better-way kind of duplication. When the system for handling events is poorly structured, developers struggle to repurpose code across similar events and states of operation. For example, a “battery charging” and “charge complete” state should be able to elegantly share a lot of charging-related functionality.</p><p> 代码重复。完全不必要的重复方式。当用于处理事件的系统的结构不良时，开发人员将难以在类似事件和操作状态之间重新利用代码。例如，“电池充电”和“充电完成”状态应该能够优雅地共享许多与充电相关的功能。</p><p> Loneliness, also known as staffing problems due to your unmaintainable codebase.   No one likes to work alone, so restructure your application in a way that your coworkers and future coworkers cherish.</p><p> 由于您无法维护的代码库，孤独感（也称为人员配置问题）。没有人喜欢独自工作，因此以一种让您的同事和未来的同事珍惜的方式重组您的应用程序。</p><p>  I want to recommend a system that’s worked for me — two steps for developers like us to immunize against the spaghetti affliction right from the start.</p><p>  我想推荐一个对我有用的系统-两步，让像我们这样的开发人员从一开始就免疫意大利面条。 </p><p>  Use an atomic  event queue. Rather than reacting to events all over your different interrupt execution contexts, an event queue allows you to consolidate those portions of your code into one place. It’s your conduit for “deferring” the handling of events from many contexts (like interrupts) into one main context. It additionally solves the issue of thread/interrupt safety, by avoiding concurrent access of shared resources across different contexts.. For example, you don’t want a SPI peripheral used in two contexts that can interrupt one another. Instead, both contexts can queue events for the main function to perform the SPI operations sequentially.</p><p>使用原子事件队列。事件队列允许您将代码的那些部分合并到一个位置，而不是对整个不同的中断执行上下文中的事件做出反应。它是您将事件处理从许多上下文（例如中断）“推迟”到一个主要上下文的管道。通过避免在不同上下文中并发访问共享资源，它还解决了线程/中断安全性问题。例如，您不希望在两个上下文中使用SPI外设可能会相互中断。相反，两个上下文都可以将事件排入队列，以供主要功能按顺序执行SPI操作。</p><p> Use a  hierarchical state machine (HSM), and a framework to implement one. An HSM is the knockout punch for our spaghetti foe. It provides an intuitive and  deterministic scheme to define how events should be handled throughout various modes of operation. HSMs are “hierarchical” in the sense that each state can be configured to inherit behaviors from a “superstate”, a more general state that encapsulates it and potentially other states. The hierarchical aspect of HSMs make them far more practical for real-world firmware applications than a textbook flat state machine. A “battery charging” and “charging complete” state could both inherit and share a bulk of their code from an “charger attached” state.</p><p> 使用分层状态机（HSM）和框架来实现。 HSM是我们意粉敌人的淘汰赛。它提供了一种直观的确定性方案来定义在各种操作模式下如何处理事件。 HSM是“分层的”，从某种意义上说，每个状态都可以配置为从“超级状态”继承行为，“超级状态”是封装它以及可能包含其他状态的更通用的状态。 HSM的分层方面使它们在实际固件应用中比在教科书平面状态机上更加实用。 “电池充电”和“充电完成”状态可以从“充电器连接”状态继承并共享大部分代码。</p><p>  An event queue is the essence of event-driven architecture. If you’re already using one and understand their merit, you may want to jump ahead to the next part.</p><p>  事件队列是事件驱动架构的本质。如果您已经在使用它们并了解它们的优点，则可能需要跳到下一部分。</p><p> Firmware events generally arrive in the context of an interrupt, either hardware or software driven. In the case of some dead-simple events, you might get away handling them right there in the interrupt; But, generally that’s bad practice. There’s a common  embedded development commandment:</p><p> 固件事件通常在硬件或软件驱动的中断上下文中到达。对于一些非常简单的事件，您可能会在中断中立即处理它们。但是，通常这是不好的做法。有一个常见的嵌入式开发诫命：</p><p>    Immunization step #1 is using the atomic queue to  defer event processing to one location in your main context. That keeps us complaint with the embedded commandments, and sets the groundwork for the step #2.</p><p>    免疫步骤1是使用原子队列将事件处理推迟到主上下文中的一个位置。这使我们对嵌入的诫命有所抱怨，并为第二步奠定了基础。</p><p>  An event-queue paradigm has been around for a while. Many developers would be hard-pressed to develop complex applications without it. You use the queue to take all your events and funnel them into a single context where they’re processed one at a time. Right off the bat, that gains you cozy-warm assurances of thread/interrupt safety because event handling isn’t strewn across all sorts of overlapping execution contexts.</p><p>  事件队列范例已经存在了一段时间。没有它，许多开发人员将很难开发复杂的应用程序。您可以使用队列来处理所有事件，并将它们集中到一个上下文中，一次可以处理它们。立即获取线程/中断安全的温馨保证，因为事件处理不会散布在各种重叠的执行上下文中。</p><p> Courteous silicon vendors usually provide developers with some form of an atomic queue.  Nordic provides  nRF52 developers with  their “app scheduler” .  Texas Instruments  provides  CC2640 developers with  their queue module accompanying their TI-RTOS. For our intents and purposes, both of these modules are just different packagings of a functionally-equivalent queue.</p><p> 有礼貌的硅供应商通常会为开发人员提供某种形式的原子队列。 Nordic为nRF52开发人员提供了“应用程序计划程序”。德州仪器（TI）为CC2640开发人员提供了TI-RTOS随附的队列模块。就我们的意图和目的而言，这两个模块只是功能等效队列的不同包装。 </p><p> // eventHandler is always executed in the &#34;main&#34; contextvoid eventHandler(Event event){ switch(event){ case TIMER_FIRED: perform_periodic_task(); start_timer(); break; case BUTTON_PRESS: react_to_button_press(); break; case BUTTON_RELEASE: react_to_button_release(); break; default: break; }}// Interupt handlersvoid timerFired_interrupt(void){ // Add event to the event queue // deferring its handling to the main context queue_push(TIMER_FIRED);}void buttonPress_interrupt(void){ queue_push(BUTTON_PRESS);}void buttonRelease_interrupt(void){ queue_push(BUTTON_RELEASE);}int main(void){ // Initialize and configure button interrupt initialize_buttons(); initialize_timer(); start_timer(); // Main loop for (;;) { // idle() stays in a low-power state until there&#39;s an event idle(); while( !queue_empty() ){ Event event = queue_dequeue(); eventHandler(event); } }}</p><p>// eventHandler始终在＆＃34; main＆＃34;中执行contextvoid eventHandler（Event event）{switch（event）{case TIMER_FIRED：perform_periodic_task（）; start_timer（）;打破;情况BUTTON_PRESS：react_to_button_press（）;打破;案例BUTTON_RELEASE：react_to_button_release（）;打破;默认值：break; }} //中断处理程序void timerFired_interrupt（void）{//将事件添加到事件队列// //将其处理推迟到主上下文queue_push（TIMER_FIRED）;} void buttonPress_interrupt（void）{queue_push（BUTTON_PRESS）;} void buttonRelease_interrupt（void ）{queue_push（BUTTON_RELEASE）;} int main（void）{//初始化和配置按钮中断initialize_buttons（）; initialize_timer（）; start_timer（）; //（;;）的主循环{// idle（）保持低功耗状态，直到发生事件idle（）;。 while（！queue_empty（））{事件event = queue_dequeue（）; eventHandler（event）; }}}</p><p>  At this point, all of your event processing has been deferred and consolidated into a main context, like the above example’s “eventHandler()” function. However, the events still need to be handled in a systematic manner. Unlike the example in Step #1, most firmware projects will include many more events whose handling changes over time. This step recommends using a hierarchical state machine to cleanly implement event handling that adapts throughout different modes/states of operation.</p><p>  至此，您的所有事件处理都已推迟并合并到一个主上下文中，例如上面示例的“ eventHandler（）”函数。但是，仍然需要系统地处理事件。与步骤1中的示例不同，大多数固件项目将包含更多事件，这些事件的处理方式会随时间而变化。此步骤建议使用分层状态机来干净地实现事件处理，以适应整个操作的不同模式/状态。</p><p> If you’re developing a product, like say a low-power wearable, then your device surely has states. Most states are clear-cut and easy to define. I’m talking On, Off, low-power shipping mode, connected, disconnected, etc. At its basis, a state machine is used to encapsulate event-handling behavior for each of these different states of operation.</p><p> 如果您正在开发产品（例如低功耗可穿戴设备），那么您的设备肯定具有状态。大多数状态是明确且易于定义的。我说的是“开”，“关”，低功耗运输模式，已连接，已断开等。在此基础上，状态机用于封装每种不同操作状态的事件处理行为。</p><p> Furthermore, you may find commonality or “hierarchy” among those states — that’s states that include other states. HSMs are “hierarchical” in the sense that states inherit behavior from the states that contain them (superstates). This hierarchy allows your code to stay clear and concise, sharing event-handling subroutines between similar states.</p><p> 此外，您可能会发现这些州（包括其他州在内的州）之间的共性或“层次结构”。从状态继承包含状态的状态（超状态）的意义上讲，HSM是“分层的”。这种层次结构使您的代码保持简洁明了，在相似状态之间共享事件处理子例程。</p><p>  Between the state machine’s consolidation/encapsulation of state behaviors and the hierarchical aspect’s management of complex shared state behaviors, we now have our knockout punch against spaghetti code.</p><p>  在状态机对状态行为的合并/封装与层次结构方面对复杂共享状态行为的管理之间，我们现在有了打击意大利面条式代码的方法。</p><p> If you find this section to be daunting, then skip ahead to the good stuff at the bottom: A link to our open-source HSM implementation called HTHSM. HTHSM’s Github documentation provides a  practical example for implementing an HSM.</p><p> 如果您发现本节令人生畏，请跳至底部的好内容：指向我们称为HTHSM的开源HSM实现的链接。 HTHSM的Github文档提供了实施HSM的实际示例。</p><p> If you want to learn more, I recommend looking into Miro Samek. He’s a guru of all event-driven firmware things and articulately presents his case for state machines in his “ State Machines for Event-Driven Systems”. Like us, he champions the HSM, boasting its practicality in “ Introduction to Hierarchical State Machines”.</p><p> 如果您想了解更多，我建议您研究Miro Samek。他是所有事件驱动固件的专家，并在“事件驱动系统的状态机”中清楚地说明了状态机的情况。像我们一样，他在“分层状态机简介”中以其实用性来拥护HSM。 </p><p> All implementations of state machines are not at all equal, however. If you’re ready to implement a worthwhile state machine, below are my battle-tested recommendations.</p><p>但是，状态机的所有实现都不完全相同。如果您准备实施一台有价值的状态机，则下面是我经过反复考验的建议。</p><p>  For each state, dedicate a function for the handling of its events. Use a function pointer to reference the active state’s event-handler. When an event occurs, this “active state” pointer is used to call the appropriate handler. When transitioning between states, you can simply change the value of that pointer to the desired target state.</p><p>  对于每个状态，请使用一个函数来处理其事件。使用函数指针来引用活动状态的事件处理程序。当事件发生时，此“活动状态”指针用于调用适当的处理程序。在状态之间转换时，您可以简单地将该指针的值更改为所需的目标状态。</p><p> Implement automatic Exit &amp; Enter events on state transitions. They’re are a godsend. When you transition states, the active state will clean up after itself, and the new state (target) has an opportunity to get settled in. This isn’t a big idea, and is in fact just basic courtesy. If your ON state turned the LED on, by gosh, it should have the decency to turn it off when it’s done. Having well defined Exit &amp; Enter make it easy to write firmware that maintains deterministic behavior throughout execution.</p><p> 实施自动退出和输入状态转换事件。他们是天赐之物。当您转换状态时，活动状态会自动清除，新状态（目标）将有机会解决。这不是一个大主意，实际上只是基本的礼貌。如果您的开启状态通过天哪打开了LED，那么完成后应该适当关闭它。定义明确的退出＆amp;使用Enter键可以轻松编写在整个执行过程中保持确定性行为的固件。</p><p> Anarchists be damned, hierarchy is what your state machine needs to be effective. Similar in concept to ”overriding” in OOP, event dispatching starts in the active state and works its way up through its superstates. Substates have an option to suppress event handling from their superstates. Dispatching of Exit &amp; Enter events should be smart enough to determine where on the superstate chain they need to be executed (beneath the least-common ancestor). I mirror  Miro Samek’s sentiment that without hierarchy, state machines lose much of their practicality.</p><p> 无政府主义者该死，状态机是有效的。在概念上与OOP中的“覆盖”类似，事件分派从活动状态开始，并通过其上层状态向上进行。子状态有一个选项可以抑制其超级状态的事件处理。出口与出入境输入事件应该足够聪明，以确定在超级状态链中的哪些位置需要执行它们（在最不常见的祖先之下）。我反映了米罗·萨梅克（Miro Samek）的观点，即没有等级制，状态机将失去很多实用性。</p><p>  Wondering if I’m leaving you to implement your own HSM from scratch? Absolutely not. The Humble Transistor made an open-source HSM framework called  HTHSM. We use it internally and are excited to share it with you. You can access examples and the source code at the  HTHSM repo on Github.</p><p>  想知道我是否要让您从头开始实施自己的HSM吗？绝对不。卑微晶体管制造了一个称为HTHSM的开源HSM框架。我们在内部使用它，很高兴与您分享。您可以在Github上的HTHSM存储库中访问示例和源代码。</p><p>  I hope you found this post informative and maybe even a bit helpful. If you’re using an HSM in your project, have feedback on this post, or questions in general, feel free to drop me a line at  ray@thehumbletransistor.com. I’d be great to hear from you .</p><p>  我希望您发现这篇文章有益，甚至可能有所帮助。如果您在项目中使用HSM，对本文有任何反馈或有任何疑问，请随时通过ray@thehumbletransistor.com与我联系。我很高兴收到您的来信。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.thehumbletransistor.com/blog-feed/spaghetti-and-the-hsm">https://www.thehumbletransistor.com/blog-feed/spaghetti-and-the-hsm</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/保持/">#保持</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/状态/">#状态</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>