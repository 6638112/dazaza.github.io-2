<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Zig的介绍C程序员的整数铸造 An intro to Zig's integer casting for C programmers</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">An intro to Zig's integer casting for C programmers<br/>Zig的介绍C程序员的整数铸造 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-11 19:50:51</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/3d479970e38284144665646269423f4d.png"><img src="http://img2.diglog.com/img/2021/5/3d479970e38284144665646269423f4d.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Today we&#39;ll just talk about integer casting, but Zig also provides explicit casting support for floats, bools, enums, pointers, and more. For the full list of explicit casts, see  https://ziglang.org/documentation/master/#Explicit-Casts</p><p>今天我们＆＃39; ll只是谈论整数铸造，但Zig还为浮子，布尔，枚举，指针等提供了显式的铸造支持。有关显式演员的完整列表，请参阅https://ziglang.org/documentation/master/#explict -casts</p><p> There are two major problems with integer casting in C - you don&#39;t always know when it happens, and you don&#39;t always know what it does. A bit of a bold claim, but what I mean here is that a purely textual analysis of a C program (e.g, via {% c-line %}grep{% c-line-end %} or {% c-line %}ctrl+f{% c-line-end %}) cannot find all of the integer casts (due to implicit conversions) and of the ones it does find, there is no textual way to distinguish truncation, reinterpretation, or extension.</p><p> 在c中有两个主要问题 - 你不会＆＃39; t始终知道它何时发生，而且你不会始终知道它是什么。一点是一个粗体索赔，但我的意思是C程序的纯文本分析（例如，通过{％C-Line％} Grep {％C-Line-end％}或{％C-Line％ ctrl + f {％c-line-end％}）找不到所有整数投压（由于隐式转换）和它确实发现的那些，没有文本方式来区分截断，重新诠释或扩展。</p><p>  {% c-block language=&#34;c&#34; %} #include &lt;stdlib.h&gt; int main (void) {     if (sizeof(int) &lt; -1) abort();     return 0; } {% c-block-end %}</p><p>  {％c-block语言=＆＃34; c＆＃34; ％} #include＆lt; stdlib.h＆gt; int main（void）{if（sizeof（int）＆lt; -1）abort（）;返回0; {％c-block-end％}</p><p> You won&#39;t even get a warning unless {% c-line %}-Wextra{% c-line-end %} or {% c-line %}-Weverything{% c-line-end %} is turned on. What&#39;s happening is that {% c-line %}-1{% c-line-end %} is implicitly converted to unsigned (since the result of {% c-line %}sizeof{% c-line-end %} is unsigned) and results in a very large number.</p><p> 除非{％c-line％}  -  wextra {％c-line-end％}或{％c-line％}  -  weverything {％c-line-end％}，否则您甚至会收到警告上。 ＆＃39; s发生的是{％c-line％}  -  1 {％c-line-end％}被隐式转换为unsigned（因为{％c-line％} sizeof {％c-line-终端％}是无符号），并导致大量数量。</p><p>  Zig solves these problems by 1) eliminating implicit conversions unless they are guaranteed to be safe (for example, assigning a {% c-line %}u8{% c-line-end %} value to a {% c-line %}u16{% c-line-end %} variable cannot fail or lose data) and 2) giving each casting operator its own built-in function, making it easy to audit their use with simple text-based tools.</p><p>  ZIG通过1）消除了隐式转换，除非保证是安全的（例如，将{％C-Line％} U8 {％C-Line％}值分配给{％C-Line％} U16 {％C-Line-End％}变量不能失败或丢失数据）和2）为每个铸造操作员提供自己的内置功能，使其易于审核它们与简单的基于文本的工具一起使用。</p><p>   {% c-line %}@as(){% c-line-end %}is only allowed when the casting operation is unambiguous and safe, meaning no information will be lost and the target type is guaranteed to be able to hold the source type.</p><p>   {％C-Line％} @ as（）{％c-line-end％}只允许在铸造操作是明确和安全的时，这意味着没有任何信息将被丢失，并且保证目标类型能够保持源类型。</p><p>  {% c-block language=&#34;zig&#34; %} var x = 5;              // not allowed - should x be signed? unsigned? what size? var x = @as(u8, 5);     // type inference allows the compiler to determine that x is type u8 {% c-block-end %}</p><p>  {％c-block语言=＆＃34; Zig＆＃34; ％} v x = 5; //不允许 - 应该签署x吗？无符号？什么尺寸？ var x = @as（U8,5）; //类型推断允许编译器确定x为键入U8 {％c-block-end％} </p><p>  {% c-block language=&#34;zig&#34; %} var x : u8 = 5; var y = @as(i32, x); {% c-block-end %}</p><p>{％c-block语言=＆＃34; Zig＆＃34; ％} var x：u8 = 5; var y = @as（i32，x）; {％c-block-end％}</p><p>  {% c-block language=&#34;zig&#34; %} var x : u8 = 5; var y = @as(u32, x); {% c-block-end %}</p><p>  {％c-block语言=＆＃34; Zig＆＃34; ％} var x：u8 = 5; var y = @as（u32，x）; {％c-block-end％}</p><p>  {% c-line %}@truncate(){% c-line-end %} is used to explicitly cast to a smaller-size integer with the same signedness, by removing the most-significant bits. It&#39;s the equivalent of an explicit C cast from a larger to a smaller integer of the same sign.</p><p>  {％c-line％} @ truncate（）{％c-line-end％}通过删除最有效的比特，用于显式地投射到具有相同符号的较小大小的整数。它＆＃39;＆＃39等同于从较大符号的较大图中的显式c扩展的。</p><p> {% c-block language=&#34;zig&#34; %} var x = @as(u16, 513);    // x in binary: 0000001000000001 var y = @truncate(u8, x); // y in binary:         00000001 {% c-block-end %}</p><p> {％c-block语言=＆＃34; Zig＆＃34; ％} var x = @as（U16,513）; // x在二进制：0000001000000001 v v r = @truncate（u8，x）; // y在二进制：00000001 {％c-block-end％}</p><p> Warning: You can call {% c-line %}@truncate(){% c-line-end %} on signed integers, but you need to make sure that&#39;s really what you want to do - since {% c-line %}@truncate{% c-line-end %} always removes the most significant bits, the resulting value may or may not be negative, regardless of whether the original value was negative.</p><p> 警告：您可以在符号整数上调用{％c-line％} @ truncate（）{％c-line-end％}，但您需要确保您真正想要做的 - 自从{％ c-line％} @ truncate {％c-line-end％}始终删除最高有效位，结果值可能会或可能不会为负，而不管原始值是否为负。</p><p>  {% c-line %}@bitCast{% c-line-end %} is used to to cast between types that are the same size, preserving the bitpattern. In other words the data in memory does not change, but its interpretation may. In the context of integer casting, this is relevant when casting between signed and unsigned types, if the source value is outside the bounds of the target type. For example, given the {% c-line %}u8{% c-line-end %} value {% c-line %}180{% c-line-end %}, the bitpattern is {% c-line %}10110100{% c-line-end %}. If we use {% c-line %}@bitCast{% c-line-end %} to convert this to an {% c-line %}i8{% c-line-end %} (assuming 2s complement notation), the value becomes {% c-line %}-76{% c-line-end %}. However if the original value were e.g. {% c-line %}100{% c-line-end %}, it would still be {% c-line %}100{% c-line-end %} after {% c-line %}@bitCast{% c-line-end %} since {% c-line %}100{% c-line-end %} has the same bitwise representation for {% c-line %}i8{% c-line-end %} and {% c-line %}u8{% c-line-end %}.</p><p>  {％c-line％} @ bitcast {％c-line-end％}用于在与位弄置于相同大小的类型之间投射。换句话说，内存中的数据不会改变，但其解释可能。在整数铸造的上下文中，如果源值在目标类型的边界之外，则在符号和无符号类型之间投射时，这是相关的。例如，给定{％c-line％} u8 {％c-line-end％}值{％c-line％} 180 {％c-line-end％}，则位覆盖器是{％c-line％ 10110100 {％c-line-end％}。如果我们使用{％c-line％} @ bitcast {％c-line-end％}将此转换为{％c-line％} i8 {％c-line-end％}（假设2s补充符号），该值变为{％C-Line％}  -  76 {％C-Line-End％}。但是，如果原始值为例如{％c-line-exp％}％c-line％} 100 {％c-line-end％}，它仍然是{％c-line％} @ bitcast {％c-line-end％} {％c-line-end％} @ bitcast {由于{％C-LINE％} I8 {％C-LINE％} I8 {％C-LINE-END％}具有相同的位表示，因此C-Line-end％}具有相同的位表示。 {％C-LINE％} U8 {％C-LINE-END％}。</p><p> {% c-block language=&#34;zig&#34; %} var x = @as(u8, 180);     // x in binary: 10110100 (value is 180) var y = @bitCast(i8, x);  // y in binary: 10110100 (value is -76) {% c-block-end %}</p><p> {％c-block语言=＆＃34; Zig＆＃34; ％} var x = @as（U8,180）; //二进制：10110100（值为180）var y = @bitcast（i8，x）; //二进制：10110100（值为-76）{％c-block-end％} </p><p>  Finally, we have {% c-line %}@intCast{% c-line-end %}. In some ways {% c-line %}@intCast{% c-line-end %} is the dual of {% c-line %}@bitCast{% c-line-end %} - it casts between integer types at runtime, preserving the value but not necessarily the bitpattern. For example, {% c-line %}@intCast{% c-line-end %} could be used to convert an {% c-line %}i32{% c-line-end %} value of {% c-line %}3{% c-line-end %} to a {% c-line %}u8{% c-line-end %}. Since it&#39;s not always possible to do this (for example - a {% c-line %}u16{% c-line-end %} value of {% c-line %}0xFFFF{% c-line-end %} cannot be stored in a {% c-line %}u8{% c-line-end%}) {% c-line %}@intCast{% c-line-end %} can invoke safety-checked undefined behavior. In other words, if runtime safety is active (either due to the build mode or {% c-line %}@setRuntimeSafety(true){% c-line-end %}), then calling {% c-line %}@intCast{% c-line-end %} with invalid parameters will panic the program rather than leaving an unexpected value in the destination. If runtime safety is turned off, you get undefined behavior.</p><p>最后，我们有{％c-line％} @ intcast {％c-line-end％}。在某些方面{％C-Line％} @ intcast {％c-line-end％}是{％c-line％} @ bitcast {％c-line-end％}的双程 - 它在整数类型之间投射运行时，保留值但不一定是位替纳特。例如，{％c-line％} @ intcast {％c-line-end％}可用于转换{％c-％c-的％c-line％} i32 {％c-line-end％}值。 LINE％} 3 {％C-LINE-END％}至{％C-LINE％} U8 {％C-LINE-END％}。由于它并不总是可以执行此操作（例如 -  {％C-Line％} U16 {％C-Line％} 0xFFFF {％C-Line-- END％}不能存储在{％C-LINE％} U8 {％C-LINE-END％}）中{％C-LINE％} @ intcast {％C-Line-ex％}可以调用安全检查的未定义行为。换句话说，如果运行时安全处于活动状态（由于构建模式或{％C-Line％} @ setRuntimesAfetty（true）{％c-line-end％}），则调用{％c-line％} @具有无效参数的intcast {％c-line-end％}将恐慌程序而不是在目标中留下意外值。如果关闭运行时安全，则会获得未定义的行为。</p><p> {% c-block language=&#34;zig&#34; %} // zig build-exe test.zig &amp;&amp; ./test pub fn main() void {     var x = @as(i16, 180);     var y = @intCast(u8, x); // this is fine     var z = @intCast(i8, y); // this will crash } {% c-block-end %}</p><p> {％c-block语言=＆＃34; Zig＆＃34; ％} // zig build-exe test.zig＆amp;＆amp; ./test pub fn main（）void {var x = @as（i16,180）; var y = @intcast（u8，x）; //这是精细var z = @Intcast（i8，y）; //这将崩溃} {％c-block-end％}</p><p> {% c-block language=&#34;console&#34; %} ➜  ~ zig run test.zig thread 14280091 panic: integer cast truncated bits /Users/ehaas/test.zig:4:13: 0x1018bf5bc in main (test)     var z = @intCast(i8, y);             ^ /Users/ehaas/source/zig/build/lib/zig/std/start.zig:410:22: 0x1018c177c in std.start.callMain (test)             root.main();                      ^ /Users/ehaas/source/zig/build/lib/zig/std/start.zig:362:12: 0x1018bf767 in std.start.callMainWithArgs (test)     return @call(.{ .modifier = .always_inline }, callMain, .{});            ^ /Users/ehaas/source/zig/build/lib/zig/std/start.zig:332:12: 0x1018bf6a5 in std.start.main (test)     return @call(.{ .modifier = .always_inline }, callMainWithArgs, .{ @intCast(usize, c_argc), c_argv, envp });            ^ ???:?:?: 0x7fff2032e620 in ??? (???) ???:?:?: 0x0 in ??? (???) [1]    79460 abort      zig run test.zig {% c-block-end %}</p><p> {％c-block语言=＆＃34;控制台＆＃34; ％}➜〜zig运行test.zig线程14280091恐慌：整数突出位/用户/ ehaas/test.zig：4:13：0x1018bf5bc在main（test）var z = @intcast（i8，y）; ^ /users/ehaas/source/zig/build/lib/zig/std/start.zig：410：22：0x1010:22：0x1010c177c在std.start.callmain（test）root.main（）; ^ /Users/ehaas/source/zig/build/lib/zig/std/start.zig：362：12：0x1018bf767在std.start.callmainwithargs（test）return @call（。{.modifier = .always_inline}，callmain ，。{}）; ^ /users/ehaas/source/zig/build/lib/zig/std/start.zig：332:12：0x1018bf6a5在std.start.main（test）return @call（。{.modifier = .always_inline}，callmainwithargs ，。{@Intcast（USIZE，C_ARGC），C_ARGV，ENVP}）; ^ ???：？：？：0x7FFF2032E620在??? （???）???：？：？：0x0在??? （???）[1] 79460 abort zig运行test.zig {％c-block-end％}</p><p> Thus, when calling {% c-line %}@intCast{% c-line-end %} you should always check that the target type can hold the source value, unless you&#39;re certain the value will fit.</p><p> 因此，当调用{％C-Line％} @ intcast {％c-line-ex％}时，您应该始终检查目标类型是否可以保存源值，除非您＆＃39;重新确定值将适合。</p><p> What if you&#39;re not sure if the result will fit, and you don&#39;t want to check each time you add or multiply? In that case you&#39;ll want to see our next article,  Preventing integer overflow in Zig</p><p> 如果你＆＃39怎么办？如果结果将适合，而且你不想每次添加或乘以检查吗？在这种情况下，你想要看到我们的下一篇文章，阻止在Zig中的整数溢出 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.lagerdata.com/articles/an-intro-to-zigs-integer-casting-for-c-programmers">https://www.lagerdata.com/articles/an-intro-to-zigs-integer-casting-for-c-programmers</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/介绍/">#介绍</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/zig/">#zig</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/line/">#line</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>