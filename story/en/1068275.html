<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>从Kafka开始 Starting with Kafka</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Starting with Kafka<br/>从Kafka开始 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-26 01:13:34</div><div class="page_narrow text-break page_content"><p>I just want to share my thoughts on Kafka after using it for a few months, always from a practical point of view. I don’t know anything more than the basics about Kafka internals. I knew the principles of log processing and so on but had never got my hands dirty. So this is just the opinion of a newcomer, not an expert.</p><p>我只想在几个月内使用它后分享我对Kafka的想法，始终从实际的角度来看。我对Kafka Internals的基础知识不了解。我知道日志处理的原则等，但从来没有让我的手脏了。所以这只是新人的意见，而不是专家。</p><p>  Everything began because we started seeing event-gathering use cases: a website, with a reasonably high amount of traffic that wants to gather events, to measure in real-time what’s going on. Like a customized version of Google analytics but without sampling. We’ve spent the last few months working on an integration with Kafka to cover these use cases.</p><p>  一切都开始，因为我们开始看到活动收集用例：一个网站，具有相当大的流量，想要收集活动，以实时测量发生的事情。像Google Analytics的定制版本，但没有采样。我们在过去几个月里工作了与Kafka一体化，以涵盖这些用例。</p><p>  I have to admit that I was biased against Kafka, I thought it was a large, complex piece of technology that added nothing but an extra layer of complexity.</p><p>  我必须承认我偏向了Kafka，我认为这是一个大型，复杂的技术，只添加了额外的复杂性。</p><p>  I still think the same, it is complex, adding Kafka to your stack will add a bunch of services and some extra decisions to make about configuration and so on. In most cases, a single process app sending data to a file and a small HTTP server serving it will perform much better with less downtime. If you compare the burden of understanding, setting-up, configuring and starting to use compared to, for example, Redis, it’s a massive amount of work.</p><p>  我仍然认为是一样的，它很复杂，将Kafka添加到您的堆栈将添加一堆服务和一些额外的决策，以便进行配置等。在大多数情况下，将数据发送到文件的单个进程应用程序和服务器的小型HTTP服务器，在更少的停机时间内将执行更好。如果您比较了解，设置，配置和开始使用的负担，例如Redis，这是一个大量的工作。</p><p>  Of course, when things get difficult is when Kafka shines and all that complexity gives you the flexibility to tackle massive amounts of load and complex producer, consumer, processor use cases. But even in this situation, you’ll need to know much more than just Kafka 101.</p><p>  当然，当事情变得困难时，当Kafka闪耀以及所有复杂性的时候，这些复杂性使您可以灵活地解决大量负载和复杂的生产者，消费者，处理器用例。但即使在这种情况下，你也需要不仅仅是Kafka 101。</p><p>  To be honest, this is true no matter what tech you use, a simple load balancer can become a nightmare to maintain under certain circumstances. High-load software projects always get complex somehow, in the same way that an F1 car needs a highly complex system, a good bunch of engineers and mechanics, and constant maintenance to go fast, so does a software project.</p><p>  为了诚实，这是真的，无论你使用什么技术，一个简单的负载平衡器都可以成为在某些情况下保持的噩梦。高负荷软件项目总是以某种方式变得复杂，与F1汽车需要高度复杂的系统，一堆工程师和力学，并持续维护快速，软件项目也是如此。</p><p>  The key here is how soon you hit the complexity; ideally, a tool should become complex as your project does.</p><p>  这里的关键是你多久达到复杂程度;理想情况下，工具应在您的项目中变得复杂。 </p><p>  Anyway, the most interesting thing about Kafka is that it enables something pretty useful for projects at scale: a clear way to coordinate and measure and scale data consumption. I’m wondering why HTTP load balancers didn’t get the consumer approach of Kafka. And the same kind of metrics. And a non-HTTP protocol and a way to coordinate workers :)</p><p>无论如何，关于Kafka最有趣的事情是它使得它可以在规模上实现一些非常有用的东西：一个明确的方式来协调和测量和缩放数据消耗。我想知道为什么HTTP负载平衡器没有得到Kafka的消费者方法。和同样的指标。和一个非HTTP协议和协调工作人员的方式:)</p><p>  Coordinate: Kafka doesn’t only rely on the server to do things, clients know things like “What partition I should consume.” or load-balancing between brokers.</p><p>  坐标：Kafka不仅依靠服务器做事，客户知道“我应该消耗的分区是什么分区”。或者在经纪之间的负载平衡。</p><p>  Scale: when consuming it is clear when you need more computing power just by looking at the number of unprocessed messages. This sounds obvious to do but it’s not, at least to me. This is a pretty old queueing problem that is useful to understand and measure (there is a lot of theory written about queueing from the early days in telecommunication systems) but it’s usually hidden in most pieces of software.</p><p>  缩放：当您通过查看未处理的消息的数量时，您可以清楚地耗尽更多的计算能力。这听起来很明显，但这并不是，至少对我来说。这是一个非常古老的排队问题，可以理解和衡量（从电信系统的早期征收有很多关于排队的理论），但通常隐藏在大多数软件中。</p><p>  Kafka is not the only tool that does these things, I guess all message brokers do this but I never used them.</p><p>  Kafka不是唯一做这些事情的工具，我猜所有留言经纪人都这样做，但我从未使用过他们。</p><p>  Anyway, some practical information that I didn’t know but wish I had known:</p><p>  无论如何，我不知道的一些实用信息，但希望我知道：</p><p>  You need to know more things than I expected to be able to use it: partitions, messages, assignments, brokers, consumers, different kinds of timeouts… and that’s just the surface.</p><p>  您需要了解更多的事情，而不是预期的能够使用它：分区，消息，分配，经纪人，消费者，不同类型的超时......那就是表面。</p><p>  Setting up a cluster by yourself is a pain in the ass. Using Confluent cloud is expensive but it just works, that’s why people use it.</p><p>  自行建立群集是屁股的痛苦。使用汇合云是昂贵的，但它只是有效，这就是人们使用它的原因。 </p><p>  Even for a local install, Kafka is a PITA. I recommend using  Redpanda, a single command and you have a Kafka compatible API up and running. No Zookeeper, no docker-compose up, no Kubernetes.</p><p>即使对于本地安装，Kafka也是一个皮塔饼。我建议使用RedPanda，一个命令，你有一个兼容Kafka兼容API和运行。没有动物园，没有docker-compose，没有kubernetes。</p><p>  Kafka does not have a good HTTP interface (for a good reason). HTTP Proxy is the default choice but Confluent cloud does not provide it (Redpanda does). I think using a custom protocol is the right choice but there is an impedance mismatch between HTTP based systems and Kafka (although not in all cases).</p><p>  Kafka没有一个很好的HTTP界面（有充分的原因）。 HTTP代理是默认选择，但云云不提供（RedPanda Do）。我认为使用自定义协议是正确的选择，但是在基于HTTP的系统和Kafka之间存在阻抗不匹配（虽然不在所有情况下）。</p><p>    Managing errors in consumers is hard. The good part is that the data is in Kafka so you can replay it but the bad part is that if the problem is a logic problem (not a temporal glitch) you are in bigger trouble.  This article explains it pretty well.</p><p>    管理消费者的错误很难。好的部分是数据在kafka中，所以你可以重播它，但是如果问题是你处于更大的麻烦的逻辑问题（不是颞小故障）。本文解释说很好。</p><p>  So, if you ask me, you need to know what you are doing before you add Kafka to your stack but it does bring really good architectural patterns when your platform usage starts to grow.</p><p>  所以，如果你问我，你需要知道在将Kafka添加到堆栈之前要做什么，但它确实会在您的平台使用开始增长时带来非常好的架构模式。</p><p>  We have been happily ingesting millions of events per minute for some months now, without any major problems. Actually, Kafka saved us from some complicated situations. Probably a fast HTTP server writing batches to a file would also have worked but I think that when you want to scale things up without much pain Kafka is a good solution.</p><p>  我们现在幸福地摄取了数百万的每分钟活动，几个月，没有任何重大问题。实际上，Kafka从一些复杂的情况下救了我们。可能是一个快速的HTTP服务器写入文件的批处理也将有效，但我认为当你想在没有太多痛苦的情况下缩放罢工时，Kafka是一个很好的解决方案。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.tinybird.co/2021/06/25/starting-with-kafka/">https://blog.tinybird.co/2021/06/25/starting-with-kafka/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/kafka/">#kafka</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/starting/">#starting</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>