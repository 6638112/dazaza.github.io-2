<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Lisp中的Shell语言 A Shell Language in Lisp</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A Shell Language in Lisp<br/>Lisp中的Shell语言 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-29 02:22:08</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/5c9fe7d5c4b31f86a0f4cec6d580bce3.png"><img src="http://img2.diglog.com/img/2021/1/5c9fe7d5c4b31f86a0f4cec6d580bce3.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>First of all, let&#39;s clarify what we mean by: shell. The  shell is the basic command interpreter of an operating system. When you use  cd, ls, rm, you are using instructions from the  shell. It&#39;s as simple as that...</p><p>首先，让我们弄清楚我们的意思：shell。 Shell是操作系统的基本命令解释器。当使用cd，ls，rm时，您使用的是外壳程序中的指令。就这么简单...</p><p>  Those who developed the Unix  shell have done a remarkable job, even if one can sometimes hesitate about the relevance of some command names, whose encrypted form is sometimes difficult to interpret for a neophyte. However, the main concept at the heart of Unix, the  pipe has been a revolution. At a time when machines had very little memory, the ability to  simply chain line-by-line processing suddenly allowed the transition to the execution scale that until then required large specific programs. Thus, as Brian Kernighan, the inventor of the  awk interpreter with Aho and Weinberg, recounts, one could now count the presence of particular words within a document too big to hold in memory, in  one single line of code.</p><p>  那些开发了Unix shell的人做得非常出色，即使有时人们对某些命令名称的相关性犹豫不决，这些命令名称的加密形式有时对于新手来说很难解释。但是，作为Unix核心的主要概念，管道是一场革命。在机器内存很少的时候，简单地逐行处理链式处理的能力突然允许过渡到执行规模，此规模直到那时才需要大型特定程序。因此，随着Aho和Weinberg的awk解释器的发明者Brian Kernighan重新计算，现在人们可以用一行代码来计算文档中特定单词的存在，以至于无法保存在内存中。</p><p>  It is no coincidence that the names of  Aho,  Weinberger and  Kernighan appear here ( awk is the combination of their initials). Indeed, Unix has not only introduced the notion of  pipe, it has also generalized the use of  regular expressions. And  awk was designed to get the best from these expressions.</p><p>  Aho，Weinberger和Kernighan的名字出现在这里并不是巧合（awk是其首字母的组合）。确实，Unix不仅引入了管道的概念，而且还推广了正则表达式的使用。而awk旨在从这些表达式中获得最大的收益。</p><p> Thanks to  awk, users were finally able to act on the data returned by the operating system.  awk introduced some fairly revolutionary concepts, such as dictionaries and field extracted from the input line. However,  awk has a rather unorthodox syntax and rereading an old script can sometimes be a challenge. I don&#39;t want to get into any controversy about this, I have been an enthusiastic user of  gawk for a long time, in pain, but happy to have had such a useful tool at hand.</p><p> 多亏了awk，用户终于可以对操作系统返回的数据进行操作。 awk引入了一些相当革命性的概念，例如字典和从输入行中提取的字段。但是，awk具有相当不合常规的语法，因此重新读取旧脚本有时可能是一个挑战。我不想对此引起任何争议，我长期以来一直是gawk的热情用户，但痛苦不已，但很高兴拥有这样一个有用的工具。</p><p> And for a long time, I wondered if there could be an alternative to  awk...</p><p> 长期以来，我想知道awk是否可以替代...</p><p>  LispE is a home-made Lisp interpreter, written with the hope of implementing C++ code that is as elegant and readable as possible. It&#39;s hard for me to objectively quantify whether I achieved the desired result, but I think I produced one of the cleanest code in my entire career. If I were to have only one measure, it would be a comparison with my earlier work, most of it being quite crude both in terms of implementation and design.</p><p>  LispE是一个自制的Lisp解释器，旨在实现尽可能优雅和可读的C ++代码。我很难客观地量化我是否达到了预期的结果，但是我认为我编写了整个职业中最干净的代码之一。如果仅采取一种措施，那将是与我以前的工作的比较，无论是在实现还是设计方面，大多数都非常粗糙。</p><p> The advantage of producing your own interpreter is that you can do with it what you want with it... Really what you want to do with it...</p><p> 产生自己的口译员的好处是您可以随心所欲地使用它。 </p><p>   I can already hear some amused comments: Really, you were complaining about the exotic syntax of  awk and you want to use  Lisp instead?</p><p>我已经可以听到一些有趣的评论了：真的，您在抱怨awk的奇特语法，您想改用Lisp吗？</p><p> To that, I would answer only one thing... Ok! That&#39;s true... Let&#39;s say that  Lisp is a bit saturated in  parentheses.</p><p> 为此，我只回答一件事...好！没错。假设Lisp的括号有点饱和。</p><p> But, the language is powerful, very flexible with a syntax that is both very simple and functional (in both senses of the word).</p><p> 但是，该语言功能强大，非常灵活，并且语法既简单又实用（从字义上讲）。</p><p>   LispE offers an environment where it is possible to edit and execute Lisp instructions directly. In particular,  LispE offers an interactive interpreter which allows, for example, to test instructions or to check the value of global variables at the end of an execution.</p><p>   LispE提供了一个可以直接编辑和执行Lisp指令的环境。特别是，LispE提供了一个交互式解释器，该解释器允许例如在执行结束时测试指令或检查全局变量的值。</p><p> Moreover, this interactive interpreter allows the execution of instructions from the  shell. To do so, all you need is to precede the instruction with a &#39;!&#39;.</p><p> 而且，该交互式解释器允许从外壳执行指令。为此，您所需要做的就是在指令之前加上＆＃39;！＆＃39。</p><p>  It is even possible to store the result of this instruction in a  Lisp variable. All you have to do is write:  !var=instruction so that  var receives the content of the execution of  instruction:</p><p>  甚至可以将该指令的结果存储在Lisp变量中。您所要做的就是编写：！var = instruction，以便var接收指令执行的内容：</p><p>    If you browse the  history, you will certainly find this line.  command is an instruction exposed by  LispE which allows the execution of a  shell command and returns the result of this command in the form of a list.</p><p>    如果浏览历史记录，肯定会找到此行。 command是LispE公开的一条指令，它允许执行Shell命令并以列表形式返回此命令的结果。 </p><p>  But  LispE goes further. We have also added additional command line options, which allow to integrate a call to  LispE within a  pipe sequence.</p><p>但是LispE更进一步。我们还添加了其他命令行选项，这些选项允许在管道序列中集成对LispE的调用。</p><p>  This is the simplest option. It is used on the command line in front of a  pipe.</p><p>  这是最简单的选择。它在管道前面的命令行上使用。</p><p>  LispE reads what the  pipe returns and initializes a list:  _args, where each element corresponds to a line read on  stdin.</p><p>  LispE读取管道返回的内容并初始化一个列表：_args，其中每个元素对应于在stdin上读取的一行。</p><p> LispE is then run as an interactive interpreter, which allows you to build the necessary code step by step, at your own pace.</p><p> 然后，LispE作为交互式解释器运行，使您可以按照自己的步调逐步构建必要的代码。</p><p> ls -al  | lispe -a_args contains therefore:(  &#34;. &#34;   &#34;.. &#34;   &#34;.DS_Store &#34;   &#34;.git &#34;   &#34;Lispe &#34;   &#34;Makefile &#34;   &#34;Makefile.in &#34;   &#34;README.md &#34;   &#34;check &#34; \  &#34;checkrgx.py &#34;   &#34;examples &#34;   &#34;include &#34;   &#34;macCopie.sh &#34;   &#34;src &#34;   &#34;template &#34;   &#34;versionne.lisp &#34;   &#34; &#34;)</p><p> ls -al | lispe -a_args因此包含：（＆＃34 ;.＆＃34;＆＃34; ..＆＃34;＆＃34; .DS_Store＆＃34;＆＃34; .git＆＃34;＆＃34; Lispe＆＃34;＆＃34;＆＃34; Makefile.in＆＃34;＆＃34; README.md＆＃34;＆＃34;检查＆＃34; \＆＃34; checkrgx.py＆＃34;＆amp; examples＆＃34;＆＃34; include＆＃34;＆＃34; macCopie.sh＆＃34;＆＃34; src＆＃34;＆＃34;模板＆＃34;＆＃34;＆＃34;＆＃34;＆＃34;）</p><p> It is also possible to build a program that can examine the contents of this list and process it:</p><p> 也可以构建一个程序来检查此列表的内容并对其进行处理：</p><p>  Let&#39;s note that if we want to edit the program in the internal editor of  LispE, we have to place the edit command afterwards:</p><p>  让我们注意，如果要在LispE的内部编辑器中编辑程序，则必须在其后放置edit命令： </p><p>   This option, on the other hand, allows you to really place the interpreter within a  pipe sequence.</p><p>另一方面，此选项允许您将解释器真正放置在管道序列中。</p><p>   The  instructions are executed for each new line coming from the  pipe, unlike  -a which reads all lines in advance.</p><p>   指令是针对管道中的每条新行执行的，这与-a预先读取所有行不同。</p><p>  accu1,accu2,...,accu9: Nine predefined accumulators initialized to 0 at start upl0: is the  complete current linel1,l2,l3...: are variables corresponding to a field of   &#39;l0 &#39;.ln: corresponds to the number of fields found  in   &#39;l0 &#39;.ll: is a list composed of all the fields</p><p>  accu1，accu2，...，accu9：在启动upl0时初始化为0的九个预定义累加器：是完整的当前行l1，l2，l3 ...：是与＆l; l0＆＃39;字段相对应的变量。 ln：对应于在＃10中找到的字段数。.ll：是由所有字段组成的列表</p><p>  ls -al  | lispe -p   &#39;l10 &#39;  # yields:  # .  # ..  # DS_Store  # .git  # Lispe  # Makefile  # Makefile.in  # README.md  # check  # checkrgx.py  # ...  # We calculate the size of all the files in the directoryls -al  | lispe -p   &#39;(+= accu1 l6) &#39;.54480011044...</p><p>  ls -al | lispe -p＆＃39; l10＆＃39; ＃产生：＃。 ＃..＃DS_Store＃.git＃Lispe＃Makefile＃Makefile.in＃README.md＃check＃checkrgx.py＃...＃我们计算目录中所有文件的大小-al | lispe -p＆＃39;（+ = accu1 l6）＆＃39; .54480011044 ...</p><p>  ls -al  | lispe -p   &#39;(print (type l2) &#34; &#34; (type l3)) &#39;   &#34;  # integer_ string_ # integer_ string_ # integer_ string_ # integer_ string_ # integer_ string_ ...</p><p>  ls -al | lispe -p＆＃39;（print（l2型）＆＃34;＆＃34;（l3型））＆＃39; ＆＃34; ＃integer_ string_＃integer_ string_＃integer_ string_＃integer_ string_＃integer_ string_ ...</p><p>  ls -al  | lispe -p   &#39;(type l2) (type l3) &#39;.  # Here only (type l3) is displayed, even if the set has been executed  # string_  # string_  # string_...</p><p>  ls -al | lispe -p＆＃39;（类型l2）（类型l3）＆＃39;。 ＃即使设置已执行，此处仅显示（类型l3）＃string_＃string_＃string _...</p><p>  ls -al  | lispe -p   &#39;(loop v ll (print (type v) &#34; &#34;) &#39;  # string_ integer_   # string_ integer_ string_ string_ integer_ string_ string_ integer_ string_ string_ string_ string_ string_ integer_ string_ string_ string_ string_ integer_ string_ string_ string_ string_ integer_ string   # string_ integer_ string_ string_ integer_ string_ string_ integer_ string_ string_ string_ string_ string_ integer_ string_ string_ string_ string_ integer_ string_ string_ string_ string_ integer_ string   # string_ integer_ string_ string_ integer_ string_ string_ integer_ string_ string_ string_ string_ string_ integer_ string_ string_ string_ string_ integer_ string_ string_ string_ string_ integer_ string   # string_ integer_ string_ string_ integer_ string_ string_ integer_ string_ string_ string_ string_ string_ integer_ string_ string_ string_ string_ integer_ string_ string_ string_ string_ integer_ string   # string_ integer_ string_ string_ integer_ string_ string_ integer_ string_ string_ string_ string_ string_ integer_ string_ string_ string_ string_ integer_ string_ string_ string_ string_ integer_ string</p><p>  ls -al | lispe -p＆＃39;（loop v ll（print（type v）＆＃34;＆＃34;）＆＃39;＃string_ integer_＃string_ integer_ string_ string_ integer_ string_ string_ integer_ string_ string_ string_ string_ string_ integer_ string_ string_字符串_整数_字符串_字符串_字符串_字符串_字符串_整数字符串_字符串_字符串_字符串_整数_字符串_字符串_字符串_字符串_整数_字符串＃字符串_整数_字符串_字符串_整数_字符串_字符串_字符串_字符串_整数_字符串_字符串_字符串_字符串_整数_字符串＃字符串_整数_字符串_字符串ing_字符串_字符串_字符串_整数_字符串_字符串_字符串_字符串_整数_字符串_字符串_字符串_字符串_整数_字符串 </p><p>    ls -al  | lispe -pb   &#39;(setq s 0) -pe  &#39;(println   &#34;Sum= &#34; s)  &#39; -p  &#39;(+= s l5)  &#39;  Allows to calculate the sum of the size of the files present in a directory.</p><p>ls -al | lispe -pb＆＃39;（setq s 0）-pe＆＃39;（println＆＃34; Sum =＆＃34; s）＆＃39; -p＆＃39;（+ = s l5）＆＃39;允许计算目录中存在的文件大小的总和。</p><p>  This option works on the same principle as  -p but instead of taking code, it uses a file containing a program.</p><p>  该选项的工作原理与-p相同，但是它不使用代码，而是使用包含程序的文件。</p><p> IMPORTANT: this file must contain a  runpipe function that serves as an entry point to the program.</p><p> 重要说明：该文件必须包含一个runpipe函数，该函数充当程序的入口点。</p><p>      To make sure that the transformation to a  shell language is completed, we add the  -r/-R options associated with  -p/-P.</p><p>      为了确保完成对外壳语言的转换，我们添加了与-p / -P关联的-r / -R选项。</p><p> These options check if a regular expression matches the input line before executing or not the code given with  -p/-P.</p><p> 这些选项在执行前检查正则表达式是否与输入行匹配-p / -P给定的代码。</p><p>   # The following form filters out lines that do not contain at least 3 digits in sequencels -al  | lispe -r   &#34;\d\d\d &#34; -p   &#34;l0 &#34;  # which gives:  # -rw-r--r-- 1 roux NLE\Domain Users 10244 26 Sep 16:42 .DS_Store  # -rwxr-xr-x@ 1 roux NLE\Domain Users 1715 30 Sep 09:18 Makefile  # -rwxr-xr-x@ 1 roux NLE\Domain Users 3297 23 Sep 14:02 checkrgx.py  # Same thing but with an internal regular expression (see documentation)ls -al  | lispe -R   &#34;%d%d%d &#34; -p   &#34;l0 &#34;</p><p>   ＃以下形式过滤掉序列中不包含至少3位数字的行-al | lispe -r＆＃34; \ d \ d \ d＆＃34; -p＆＃34; l0＆＃34; ＃给出以下代码：＃-rw-r--r-- 1个roux NLE \ Domain用户10244 26 Sep 16:42 .DS_Store＃-rwxr-xr-x @ 1个roux NLE \ Domain用户1715 Sep 9:18 Makefile＃ -rwxr-xr-x @ 1 roux NLE \ Domain用户3297 23 Sep 14:02 checkrgx.py＃相同，但带有内部正则表达式（请参见文档） lispe -R＆＃34;％d％d％d＆＃34; -p＆＃34; l0＆＃34; </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/naver/lispe/wiki/7.-Shell">https://github.com/naver/lispe/wiki/7.-Shell</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/shell/">#shell</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/language/">#language</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lispe/">#lispe</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>