<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Rust中的宏：带有示例的教程 Macros in Rust: A Tutorial with Examples</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Macros in Rust: A Tutorial with Examples<br/>Rust中的宏：带有示例的教程 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-26 07:38:17</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/12cb7c4c9cc3718f7e348cc71911a02e.png"><img src="http://img2.diglog.com/img/2021/2/12cb7c4c9cc3718f7e348cc71911a02e.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In this tutorial, we’ll cover everything you need to know about Rust macros, including an introduction to macros in Rust and a demonstration of how to use Rust macros with examples.</p><p>在本教程中，我们将介绍有关Rust宏的所有必要知识，包括Rust中的宏介绍以及示例中如何使用Rust宏的演示。</p><p>    Rust has excellent support for macros. Macros enable you to write code that writes other code, which is known as metaprogramming.</p><p>    Rust对宏提供了出色的支持。宏使您能够编写编写其他代码的代码，这称为元编程。</p><p> Macros provide functionality similar to functions but without the runtime cost. There is some compile-time cost, however, since macros are expanded during compile time.</p><p> 宏提供的功能类似于功能，但没有运行时成本。但是，由于在编译期间扩展了宏，因此存在一些编译时的开销。</p><p> Rust macros are very different from macros in C. Rust macros are applied to the token tree whereas C macros are text substitution.</p><p> Rust宏与C中的宏非常不同。Rust宏应用于令牌树，而C宏是文本替换。</p><p>   Declarative macros enable you to write something similar to a match expression that operates on the Rust code you provide as arguments. It uses the code you provide to generate code that replaces the macro invocation</p><p>   声明性宏使您可以编写类似于在作为参数提供的Rust代码上运行的match表达式的内容。它使用您提供的代码来生成替换宏调用的代码</p><p> Procedural macros allow you to operate on the abstract syntax tree (AST) of the Rust code it is given. A proc macro is a function from a  TokenStream (or two) to another  TokenStream, where the output replaces the macro invocation</p><p> 程序宏允许您对给出的Rust代码的抽象语法树（AST）进行操作。 proc宏是从TokenStream（或两个）到另一个TokenStream的函数，其中输出替换宏调用</p><p> Let’s zoom in on both declarative and procedural macros and explore some examples of how to use macros in Rust.</p><p> 让我们放大声明性和过程宏，并探讨一些如何在Rust中使用宏的示例。 </p><p>  These macros are declared using  macro_rules!. Declarative macros are a bit less powerful but provide an easy to use interface for creating macros to remove duplicate code. One of the common declarative macro is  println!. Declarative macros provide a  match like an interface where on match the macro is replaced with code inside the matched arm.</p><p>这些宏使用macro_rules！声明。声明性宏的功能稍差一些，但提供了易于使用的接口来创建宏以删除重复的代码。常见的声明性宏之一是println!。声明性宏提供了与接口类似的匹配，在匹配时，匹配的宏将替换为匹配臂内部的代码。</p><p>  // use macro_rules! &lt;name of macro&gt;{&lt;Body&gt;}macro_rules! add{ // macth like arm for macro ($a:expr,$b:expr)=&gt;{ // macro expand to this code {// $a and $b will be templated using the value/variable provided to macro $a+$b } }}fn main(){ // call to macro, $a=1 and $b=2 add!(1,2);}</p><p>  //使用macro_rules！ ＆lt;宏的名称＆gt; {＆lt;正文＆gt;} macro_rules！ add {//宏类似$的宏（$ a：expr，$ b：expr）=＆gt; {{宏扩展为此代码{// $ a和$ b将使用提供给宏的值/变量进行模板化$ a + $ b}}} fn main（）{//调用宏，$ a = 1和$ b = 2相加！（1,2）;}</p><p> This code creates a macro to add two numbers.   [macro_rules!] are used with the name of the macro,  add, and the body of the macro.</p><p> 这段代码创建了一个宏，将两个数字相加。 [macro_rules！]与宏的名称，添加和宏的主体一起使用。</p><p> The macro doesn’t add two numbers, it just replaces itself with the code to add two numbers. Each arm of the macro takes an argument for functions and multiple types can be assigned to arguments. If the  add function can also take a single argument, we add another arm.</p><p> 宏不会将两个数字相加，它只是将自己替换为添加两个数字的代码。宏的每个分支都为函数提供一个参数，并且可以将多种类型分配给参数。如果add函数也可以接受单个参数，则添加另一条手臂。</p><p>  macro_rules! add{ // first arm match add!(1,2), add!(2,3) etc ($a:expr,$b:expr)=&gt;{ { $a+$b } };// Second arm macth add!(1), add!(2) etc ($a:expr)=&gt;{ { $a } }}fn main(){// call the macro let x=0; add!(1,2); add!(x);}</p><p>  macro_rules！ add {//第一臂匹配add！（1,2），add！（2,3）etc（$ a：expr，$ b：expr）=＆gt; {{$ a + $ b}}; //第二臂macth add！（1），add！（2）等（$ a：expr）=＆gt; {{$ a}}} fn main（）{//调用宏let x = 0;加（1,2）;加！（x）;}</p><p> There can be multiple branches in a single macro expanding to different code based on different arguments. Each branch can take multiple arguments, starting with the  $ sign and followed by a token type:</p><p> 一个宏中可以有多个分支，可以根据不同的参数扩展为不同的代码。每个分支可以采用多个参数，以$符号开头，后跟令牌类型：</p><p> block — a block (i.e. a block of statements and/or an expression, surrounded by braces)</p><p> 块-块（即语句和/或表达式的块，用大括号括起来） </p><p> In the example, we use the  $typ argument with token type  ty as a datatype like  u8,  u16, etc. This macro converts to a particular type before adding the numbers.</p><p>在示例中，我们将令牌类型为ty的$ typ参数用作u8，u16等数据类型。在添加数字之前，此宏会转换为特定类型。</p><p> macro_rules! add_as{// using a ty token type for macthing datatypes passed to maccro ($a:expr,$b:expr,$typ:ty)=&gt;{ $a as $typ + $b as $typ }}fn main(){ println!(&#34;{}&#34;,add_as!(0,2,u8));}</p><p> macro_rules！ add_as {//将ty令牌类型用于传递给maccro的macthing数据类型（$ a：expr，$ b：expr，$ typ：ty）=＆gt; {$ a为$ typ + $ b为$ typ}} fn main （）{println！（＆＃34; {}＆＃34;，add_as！（0,2，u8））;}</p><p> Rust macros also support taking a nonfixed number of arguments. The operators are very similar to the regular expression.  * is used for zero or more token types and  + for zero or one argument.</p><p> Rust宏还支持采用非固定数量的参数。运算符与正则表达式非常相似。 *用于零个或多个令牌类型，而+用于零个或一个参数。</p><p> macro_rules! add_as{ ( // repeated block $($a:expr) // seperator ,// zero or more * )=&gt;{ { // to handle the case without any arguments 0 // block to be repeated $(+$a)* } }}fn main(){ println!(&#34;{}&#34;,add_as!(1,2,3,4)); // =&gt; println!(&#34;{}&#34;,{0+1+2+3+4})}</p><p> macro_rules！ add_as {（//重复的块$（$ a：expr）//分隔符，//零个或多个*）=＆gt; {{//处理不带任何参数的情况0 //重复的块$（+ $ a）*}}} fn main（）{println！（＆＃34; {}＆＃34;，add_as！（1,2,3,4））; // =＆gt; println！（＆＃34; {}＆＃34;，{0 + 1 + 2 + 3 + 4}）}</p><p> The token type that repeats is enclosed in  $(), followed by a separator and a  * or a  +, indicating the number of times the token will repeat. The separator is used to distinguish the tokens from each other. The  $() block followed by  * or  + is used to indicate the repeating block of code. In the above example,  +$a is a repeating code.</p><p> 重复的令牌类型包含在$（）中，后跟分隔符和*或+，表示令牌将重复的次数。分隔符用于将令牌彼此区分开。 $（）块后跟*或+表示重复的代码块。在上面的示例中，+ $ a是重复代码。</p><p> If you look closely, you’ll notice an additional zero is added to the code to make the syntax valid. To remove this zero and make the  add expression the same as the argument, we need to create a new macro known as  TT muncher.</p><p> 如果仔细观察，您会发现在代码中添加了另一个零，以使语法有效。要删除此零并使add表达式与参数相同，我们需要创建一个称为TT muncher的新宏。</p><p> macro_rules! add{ // first arm in case of single argument and last remaining variable/number ($a:expr)=&gt;{ $a };// second arm in case of two arument are passed and stop recursion in case of odd number ofarguments ($a:expr,$b:expr)=&gt;{ { $a+$b } };// add the number and the result of remaining arguments ($a:expr,$($b:tt)*)=&gt;{ { $a+add!($($b)*) } }}fn main(){ println!(&#34;{}&#34;,add!(1,2,3,4));}</p><p> macro_rules！ add {//如果有单个参数，则第一个分支，最后一个剩余变量/数字（$ a：expr）=＆gt; {$ a}; //如果传递了两个元素，则第二个分支；如果是奇数，则停止递归ofarguments（$ a：expr，$ b：expr）=＆gt; {{$ a + $ b}}; //添加数字和剩余参数的结果（$ a：expr，$（$ b：tt）*） =＆gt; {{$ a + add！（$（$ b）*）}}} fn main（）{println！（＆＃34; {}＆＃34;，add！（1,2,3,4 ））;} </p><p> The TT muncher processes each token separately in a recursive fashion. It’s easier to process a single token at a time. The macro has three arms:</p><p>TT muncher以递归方式分别处理每个令牌。一次处理一个令牌比较容易。宏具有三个分支：</p><p>  The macro arguments don’t need to be comma-separated. Multiple tokens can be used with different token types. For example, brackets can be used with the  ident token type. The Rust compiler takes the matched arm and extracts the variable from the argument string.</p><p>  宏参数不需要用逗号分隔。可以将多个令牌与不同的令牌类型一起使用。例如，方括号可与ident令牌类型一起使用。 Rust编译器采用匹配的分支，并从参数字符串中提取变量。</p><p> macro_rules! ok_or_return{// match something(q,r,t,6,7,8) etc// compiler extracts function name and arguments. It injects the values in respective varibles. ($a:ident($($b:tt)*))=&gt;{ { match $a($($b)*) { Ok(value)=&gt;value, Err(err)=&gt;{ return Err(err); } } } };}fn some_work(i:i64,j:i64)-&gt;Result&lt;(i64,i64),String&gt;{ if i+j&gt;2 { Ok((i,j)) } else { Err(&#34;error&#34;.to_owned()) }}fn main()-&gt;Result&lt;(),String&gt;{ ok_or_return!(some_work(1,4)); ok_or_return!(some_work(1,0)); Ok(())}</p><p> macro_rules！ ok_or_return {//匹配某些内容（q，r，t，6,7,8）etc //编译器提取函数名称和参数。它将值注入到各个变量中。 （$ a：ident（$（$ b：tt）*））=＆gt; {{match $ a（$（$ b）*）{Ok（value）=＆gt; value，Err（err）=＆gt; {返回Err（err）; }}}};} fn some_work（i：i64，j：i64）-＆gt; Result＆lt;（i64，i64），String＆gt; {如果i + j＆gt; 2 {Ok（（i，j））}}其他{错误（＆＃34; error＆＃34; .to_owned（））}} fn main（）-＆gt; Result＆lt;（），String＆gt; {ok_or_return！（some_work（1,4））; ok_or_return！（some_work（1,0））;好的（（））}</p><p> The  ok_or_return macro returns the function if an operation returns  Err or the value of an operation returns  Ok. It takes a function as an argument and executes it inside a match statement. For arguments passed to function, it uses repetition.</p><p> 如果某个操作返回Err或某个操作的值返回Ok，则ok_or_return宏将返回该函数。它以一个函数作为参数，并在match语句中执行它。对于传递给函数的参数，它使用重复。</p><p> Often, few macros need to be grouped into a single macro. In these cases, internal macro rules are used. It helps to manipulate the macro inputs and write clean TT munchers.</p><p> 通常，很少需要将宏分组为一个宏。在这些情况下，将使用内部宏规则。它有助于操纵宏输入并编写干净的TT muncher。</p><p> To create an internal rule, add the rule name starting with  @ as the argument. Now the macro will never match for an internal rule until explicitly specified as an argument.</p><p> 要创建内部规则，请添加以@开头的规则名称作为参数。现在，除非明确将其指定为参数，否则该宏将永远不会匹配内部规则。</p><p> macro_rules! ok_or_return{ // internal rule. (@error $a:ident,$($b:tt)* )=&gt;{ { match $a($($b)*) { Ok(value)=&gt;value, Err(err)=&gt;{ return Err(err); } } } };// public rule can be called by the user. ($a:ident($($b:tt)*))=&gt;{ ok_or_return!(@error $a,$($b)*) };}fn some_work(i:i64,j:i64)-&gt;Result&lt;(i64,i64),String&gt;{ if i+j&gt;2 { Ok((i,j)) } else { Err(&#34;error&#34;.to_owned()) }}fn main()-&gt;Result&lt;(),String&gt;{ // instead of round bracket curly brackets can also be used ok_or_return!{some_work(1,4)}; ok_or_return!(some_work(1,0)); Ok(())}</p><p> macro_rules！ ok_or_return {//内部规则。 （@error $ a：ident，$（$ b：tt）*）=＆gt; {{match $ a（$（$ b）*）{Ok（value）=＆gt; value，Err（err）=＆gt; {return Err（err）; }} //}公共规则可以由用户调用。 （$ a：ident（$（$ b：tt）*））=＆gt; {ok_or_return！（@ error $ a，$（$ b）*）};} fn some_work（i：i64，j：i64）- ＆gt; Result＆lt;（i64，i64），String＆gt; {如果i + j＆gt; 2 {Ok（（i，j））}否则{Err（＆＃34; error＆＃34; .to_owned（））}} fn main （）-＆gt; Result＆lt;（），String＆gt; {//也可以使用ok_or_return！代替圆括号大括号！{some_work（1,4）}; ok_or_return！（some_work（1,0））;好的（（））} </p><p>   Do put together all the concepts we’ve covered to this point, let’s create a macro that makes a struct public by suffixing the  pub keyword.</p><p>务必将到目前为止已涵盖的所有概念放在一起，让我们创建一个宏，通过在pub关键字后缀将结构公开。</p><p> First, we need to parse the Rust struct to get the name of the struct, fields of the struct, and field type.</p><p> 首先，我们需要解析Rust结构以获得结构的名称，结构的字段和字段类型。</p><p>  A  struct declaration has a visibility keyword at the start (such as  pub), followed by the  struct keyword and then the name of the  struct and the body of the  struct.</p><p>  struct声明的开头有一个可见性关键字（例如pub），其后是struct关键字，然后是该结构的名称和该结构的主体。</p><p>  macro_rules! make_public{ ( // use vis type for visibility keyword and ident for struct name $vis:vis struct $struct_name:ident { } ) =&gt; { { pub struct $struct_name{ } } }}</p><p>  macro_rules！ make_public {（//使用vis类型作为可见性关键字，使用ident作为结构名称$ vis：vis struct $ struct_name：ident {}）=＆gt; {{pub struct $ struct_name {}}}}</p><p> The  $vis will have visibility and  $struct_name will have a struct name. To make a struct public, we just need to add the  pub keyword and ignore the  $vis variable.</p><p> $ vis将具有可见性，$ struct_name将具有结构名称。要公开一个结构，我们只需要添加pub关键字而忽略$ vis变量。</p><p>  A  struct may contain multiple fields with the same or different data types and visibility. The  ty token type is used for the data type,  vis for visibility, and  ident for the field name. We’ll use  * repetition for zero or more fields.</p><p>  一个结构可以包含具有相同或不同数据类型和可见性的多个字段。 ty令牌类型用于数据类型，vis用于可见性，ident用于字段名称。我们将对零个或多个字段使用*重复。</p><p> macro_rules! make_public{ ( $vis:vis struct $struct_name:ident { $( // vis for field visibility, ident for field name and ty for field data type $field_vis:vis $field_name:ident : $field_type:ty ),* } ) =&gt; { { pub struct $struct_name{ $( pub $field_name : $field_type, )* } } }}</p><p> macro_rules！ make_public {（$ vis：vis struct $ struct_name：ident {$（// vis表示字段可见性，ident表示字段名称，ty表示字段数据类型$ field_vis：vis $ field_name：ident：$ field_type：ty），*}）） =＆gt; {{pub struct $ struct_name {$（pub $ field_name：$ field_type，）*}}}} </p><p>  Often the  struct has some metadata attached or procedural macros, such as  #[derive(Debug)]. This metadata needs to stay intact. Parsing this metadata is done using the  meta type.</p><p>通常，该结构具有一些附加的元数据或过程宏，例如＃[derive（Debug）]。此元数据需要保持不变。使用元类型来解析此元数据。</p><p> macro_rules! make_public{ ( // meta data about struct $(#[$meta:meta])* $vis:vis struct $struct_name:ident { $( // meta data about field $(#[$field_meta:meta])* $field_vis:vis $field_name:ident : $field_type:ty ),*$(,)+ } ) =&gt; { { $(#[$meta])* pub struct $struct_name{ $( $(#[$field_meta:meta])* pub $field_name : $field_type, )* } } }}</p><p> macro_rules！ make_public {（// //有关结构$（＃[$ meta：meta]）* * vis：vis的结构$ struct_name：ident {$（//有关字段$（＃[$ field_meta：meta]）* $ field_vis：vis $ field_name：ident：$ field_type：ty），* $（，）+}）=> {{$（＃[$ meta]）* pub struct $ struct_name {$（$（＃（＃[$ field_meta：meta]）* pub $ field_name：$ field_type，）*}}}}</p><p> Our  make_public macro is ready now. To see how  make_public works, let’s use  Rust Playground to expand the macro to the actual code that is compiled.</p><p> 我们的make_public宏现在准备就绪。要查看make_public的工作原理，让我们使用Rust Playground将宏扩展为已编译的实际代码。</p><p> macro_rules! make_public{ ( $(#[$meta:meta])* $vis:vis struct $struct_name:ident { $( $(#[$field_meta:meta])* $field_vis:vis $field_name:ident : $field_type:ty ),*$(,)+ } ) =&gt; { $(#[$meta])* pub struct $struct_name{ $( $(#[$field_meta:meta])* pub $field_name : $field_type, )* } }}fn main(){ make_public!{ #[derive(Debug)] struct Name{ n:i64, t:i64, g:i64, } }}</p><p> macro_rules！ make_public {（$（＃[$ meta：meta]）* $ vis：vis struct $ struct_name：ident {$（$（$（＃[$ field_meta：meta]）** $ field_vis：vis $ field_name：ident：$ field_type：ty ），* $（，）+}）=＆gt; {$（＃[$ meta]）* pub struct $ struct_name {$（$（＃（＃[$ field_meta：meta]）* pub $ field_name：$ field_type，）*}}}} fn main（）{make_public！{＃[派生（调试）]结构名称{n：i64，t：i64，g：i64，}}}</p><p>  // some importsmacro_rules! make_public { ($ (#[$ meta : meta]) * $ vis : vis struct $ struct_name : ident { $ ($ (#[$ field_meta : meta]) * $ field_vis : vis $ field_name : ident : $ field_type : ty), * $ (,) + }) =&gt; { $ (#[$ meta]) * pub struct $ struct_name { $ ($ (#[$ field_meta : meta]) * pub $ field_name : $ field_type,) * } }}fn main() { pub struct name { pub n: i64, pub t: i64, pub g: i64, }}</p><p>  //一些importmacro_rules！ make_public {（$（＃[$ meta：meta]）* $ vis：vis struct $ struct_name：ident {$（$（$ [＃[$ field_meta：meta]）* $ $ field_vis：vis $ field_name：ident：$ field_type：ty ），* $（，）+}）=> {$（＃[$ meta]）* pub struct $ struct_name {$（$（$（＃[$ field_meta：meta]）* pub $ field_name：$ field_type，）*}}}} fn main（）{pub struct name {pub n：i64，酒吧t：i64，酒吧g：i64，}}</p><p>  Declarative macros have a few limitations. Some are related to Rust macros themselves while others are more specific to declarative macros.</p><p>  声明性宏有一些限制。一些与Rust宏本身相关，而另一些与声明性宏更特定。</p><p>   Procedural macros are a more advanced version of macros. Procedural macros allow you to expand the existing syntax of Rust. It takes arbitrary input and returns valid Rust code.</p><p>   过程宏是宏的更高级版本。过程宏允许您扩展Rust的现有语法。它接受任意输入并返回有效的Rust代码。 </p><p> Procedural macros are functions that take a  TokenStream as input and return another  Token Stream. Procedural macros manipulate the input  TokenStream to produce an output stream.</p><p>程序宏是将TokenStream作为输入并返回另一个Token Stream的函数。程序宏操纵输入的TokenStream生成输出流。</p><p>     Attribute-like macros enable you to create a custom attribute that attaches itself to an item and allows manipulation of that item. It can also take arguments.</p><p>     类似于属性的宏使您可以创建将其自身附加到项目并允许对该项目进行操作的自定义属性。它还可以接受参数。</p><p>   To write an attribute-like macro, start by creating a project using  cargo new macro-demo --lib. Once the project is ready, update the  Cargo.toml to notify cargo the project will create procedural macros.</p><p>   要编写类似属性的宏，请先使用cargo new macro-demo --lib创建一个项目。项目准备就绪后，更新Cargo.toml以通知货物该项目将创建程序宏。</p><p>   Procedural macros are public functions that take  TokenStream as input and return another  TokenStream. To write a procedural macro, we need to write our parser to parse  TokenStream. The Rust community has a very good crate,  syn, for parsing  TokenStream.</p><p>   程序宏是将TokenStream作为输入并返回另一个TokenStream的公共函数。要编写程序宏，我们需要编写解析器以解析TokenStream。 Rust社区有一个很好的板条箱syn，用于解析TokenStream。</p><p> synprovides a ready-made parser for Rust syntax that can be used to parse  TokenStream. You can also parse your syntax by combining low-level parsers providing  syn.</p><p> 为Rust语法提供了现成的解析器，可用于解析TokenStream。您还可以通过组合提供syn的低级解析器来解析语法。</p><p>   Now we can write an attribute-like a macro in  lib.rs using the  proc_macro crate provided by the compiler for writing procedural macros. A procedural macro crate cannot export anything else other than procedural macros and procedural macros defined in the crate can’t be used in the crate itself.</p><p>   现在，我们可以使用编译器提供的proc_macro包在lib.rs中编写类似属性的宏，以编写过程宏。程序宏板条箱不能导出程序宏以外的其他任何东西，并且在板条箱中定义的程序宏不能在板条箱本身中使用。</p><p> // lib.rsextern crate proc_macro;use proc_macro::{TokenStream};use quote::{quote};// using proc_macro_attribute to declare an attribute like procedural macro#[proc_macro_attribute]// _metadata is argument provided to macro call and _input is code to which attribute like macro attachespub fn my_custom_attribute(_metadata: TokenStream, _input: TokenStream) -&gt; TokenStream { // returing a simple TokenStream for Struct TokenStream::from(quote!{struct H{}})}</p><p> // lib.rsextern板条箱proc_macro;使用proc_macro :: {TokenStream};使用quote :: {quote}; //使用proc_macro_attribute声明属性，例如程序宏＃[proc_macro_attribute] // _metadata是提供给宏调用和_input的参数是代码，其属性如宏Attachespub fn my_custom_attribute（_metadata：TokenStream，_input：TokenStream）-> TokenStream {//为Struct TokenStream :: from（quote！{struct H {}}）}重现一个简单的TokenStream </p><p> To test the macro we added, create an ingratiation test by creating a folder named  tests and adding the file  attribute_macro.rs in the folder. In this file, we can use our attribute-like macro for testing.</p><p>要测试我们添加的宏，请通过创建一个名为tests的文件夹并在该文件夹中添加文件attribute_macro.rs来创建一个证书测试。在此文件中，我们可以使用类似属性的宏进行测试。</p><p> // tests/attribute_macro.rsuse macro_demo::*;// macro converts struct S to struct H#[my_custom_attribute]struct S{}#[test]fn test_macro(){// due to macro we have struct H in scope let demo=H{};}</p><p> // // tests / attribute_macro.rsuse macro_demo :: *; //宏将struct S转换为struct H＃[my_custom_attribute] struct S {}＃[test] fn test_macro（）{// demo = H {};}</p><p>  Now that we understand the basics of procedural macros, lets use  syn for some advanced  TokenStream manipulation and parsing.</p><p>  现在，我们了解了程序宏的基础，让我们使用syn进行一些高级TokenStream操作和解析。</p><p> To learn how  syn is used for parsing and manipulation, let’s take an example from thee   syn GitHub repo. This example creates a Rust macro that trace variables when value changes.</p><p> 要了解syn如何用于解析和操作，让我们以syn GitHub存储库中的示例为例。本示例创建一个Rust宏，该宏在值更改时跟踪变量。</p><p>   The  trace_vars macro takes the name of the variable it needs to trace and injects a print statement each time the value of the input variable i.e  a changes. It tracks the value of input variables.</p><p>   trace_vars宏使用它需要跟踪的变量的名称，并在每次输入变量的值（即a更改）插入一条print语句。它跟踪输入变量的值。</p><p> First, parse the code to which the attribute-like macro attaches.  syn provides an inbuilt parser for Rust function syntax.  ItemFn will parse the function and throw an error if the syntax is invalid.</p><p> 首先，解析类似于属性的宏所附加的代码。 syn提供了用于Rust函数语法的内置解析器。如果语法无效，ItemFn将解析该函数​​并引发错误。</p><p> #[proc_macro_attribute]pub fn trace_vars(_metadata: TokenStream, input: TokenStream) -&gt; TokenStream {// parsing rust function to easy to use struct let input_fn = parse_macro_input!(input as ItemFn); TokenStream::from(quote!{fn dummy(){}})}</p><p> ＃[proc_macro_attribute] pub fn trace_vars（_metadata：TokenStream，输入：TokenStream）-＆gt; TokenStream {//将rust函数解析为易于使用的结构let input_fn = parse_macro_input！（输入为ItemFn）； TokenStream :: from（quote！{fn dummy（）{}}）} </p><p> Now that we have the parsed  input, let’s move to  metadata. For  metadata, no inbuilt parser will work, so we’ll have to write one ourselves using  syn‘s  parse module.</p><p>现在我们有了已解析的输入，让我们转到元数据。对于元数据，没有内置的解析器将起作用，因此我们必须使用syn’s parse模块自己编写一个。</p><p>  For  syn to work, we need to implement the  Parse trait provided by  syn.  Punctuated is used to create a  vector of  Indent separated by  ,.</p><p>  为了使syn正常工作，我们需要实现syn提供的Parse特性。标点符号用于创建由，分隔的缩进向量。</p><p> struct Args{ vars:HashSet&lt;Ident&gt;}impl Parse for Args{ fn parse(input: ParseStream) -&gt; Result&lt;Self&gt; { // parses a,b,c, or a,b,c where a,b and c are Indent let vars = Punctuated::&lt;Ident, Token![,]&gt;::parse_terminated(input)?; Ok(Args { vars: vars.into_iter().collect(), }) }}</p><p> struct Args {vars：HashSet＆lt; Ident＆gt;}}用于Args的impl解析{fn parse（input：ParseStream）-＆gt;结果＆lt; Self＆gt; {//解析a，b，c或a，b，c，其中a，b和c为Indent let vars =标点符号：:＆lt; Ident，Token！[，]＆gt; :: parse_terminated（input）?; Ok（Args {vars：vars.into_iter（）。collect（），}）}}</p><p>  #[proc_macro_attribute]pub fn trace_vars(metadata: TokenStream, input: TokenStream) -&gt; TokenStream { let input_fn = parse_macro_input!(input as ItemFn);// using newly created struct Args let args= parse_macro_input!(metadata as Args); TokenStream::from(quote!{fn dummy(){}})}</p><p>  ＃[proc_macro_attribute] pub fn trace_vars（元数据：TokenStream，输入：TokenStream）-＆gt; TokenStream {let input_fn = parse_macro_input！（input as ItemFn）; //使用新创建的struct Args let args = parse_macro_input！（metadata as Args）; TokenStream :: from（quote！{fn dummy（）{}}）}</p><p> We will now modify the  input_fn to add  println! when the variable changes the value. To add this, we need to filter outlines that have an assignment and insert a print statement after that line.</p><p> 现在，我们将修改input_fn以添加println！当变量更改值时。要添加此内容，我们需要过滤具有赋值的轮廓，并在该行之后插入打印语句。</p><p> impl Args { fn should_print_expr(&amp;self, e: &amp;Expr) -&gt; bool { match *e { Expr::Path(ref e) =&gt; { // variable shouldn&#39;t start wiht :: if e.path.leading_colon.is_some() { false// should be a single variable like `x=8` not n::x=0 } else if e.path.segments.len() != 1 { false } else {// get the first part let first = e.path.segments.first().unwrap();// check if the variable name is in the Args.vars hashset self.vars.contains(&amp;first.ident) &amp;&amp; first.arguments.is_empty() } } _ =&gt; false, } }// used for checking if to print let i=0 etc or not fn should_print_pat(&amp;self, p: &amp;Pat) -&gt; bool { match p {// check if variable name is present in set Pat::Ident(ref p) =&gt; self.vars.contains(&amp;p.ident), _ =&gt; false, } }// manipulate tree to insert print statement fn assign_and_print(&amp;mut self, left: Expr, op: &amp;dyn ToTokens, right: Expr) -&gt; Expr { // recurive call on right of the assigment statement let right = fold::fold_expr(self, right);// returning manipulated sub-tree parse_quote!({ #left #op #right; println!(concat!(stringify!(#left), &#34; = {:?}&#34;), #left); }) }// manipulating let statement fn let_and_print(&amp;mut self, local: Local) -&gt; Stmt { let Local { pat, init, .. } = local; let init = self.fold_expr(*init.unwrap().1);// get the variable name of assigned variable let ident = match pat { Pat::Ident(ref p) =&gt; &amp;p.ident, _ =&gt; unreachable!(), };// new sub tree parse_quote! { let #pat = { #[allow(unused_mut)] let #pat = #init; println!(concat!(stringify!(#ident), &#34; = {:?}&#34;), #ident); #ident }; } }}</p><p> impl Args {fn should_print_expr（＆amp; self，e：＆amp; Expr）-＆gt; bool {match * e {Expr :: Path（ref e）=＆gt; {//变量不应该从::开始，如果e.path.leading_colon.is_some（）{false //应该是一个像`x = 8`而不是n :: x = 0}的变量，否则为e。 path.segments.len（）！= 1 {false} else {//得到第一部分let first = e.path.segments.first（）。unwrap（）; //检查变量名是否在Args中。 vars hashset self.vars.contains（＆amp; first.ident）＆amp;＆amp; first.arguments.is_empty（）}} _ =＆gt; false，}} //用于检查是否要打印让i = 0等等fn should_print_pat（＆self; p：＆amp; Pat）-＆gt; bool {match p {//检查变量名是否存在于集合Pat :: Ident（ref p）=＆gt;中。 self.vars.contains（＆amp; p.ident），_ =＆gt; false，}} ///操纵树以插入打印语句fn Assign_and_print（＆amp; mut self，左：Expr，op：＆amp; dyn ToTokens，右：Expr）-＆gt; Expr {//赋权语句右边的递归调用let right = fold :: fold_expr（self，right）; //返回操纵的子树parse_quote！（{#left #op #right; println！（concat！（stringify ！（＃left），＆＃34; = {：？}＆＃34;），#left）;}）} //操作let语句fn let_and_print（＆amp; mut self，local：Local）-＆gt; Stmt {让本地{pat，init，..} =本地； let init = self.fold_expr（* init.unwrap（）。1）; //获取分配变量的变量名称let ident = match pat {Pat :: Ident（ref p）=＆gt; ＆amp; p.ident，_ =＆gt; （），}; //新的子树parse_quote！ {let #pat = {＃[allow（unused_mut）] let #pat = #init; println！（concat！（stringify！（＃ident），＆＃34; = {：？}＆＃34;），#ident）; #ident}; }}}</p><p> In the above example, the  quote macro is used for templating and writing Rust.  # is used for injecting the value of the variable.</p><p> 在上面的示例中，quote宏用于模板化和编写Rust。 ＃用于注入变量的值。 </p><p> Now we’ll do a DFS over  input_fn and insert the print statement.  syn provides a  Fold trait that can be implemented for DFS over any  Item. We just need to modify the trait methods that correspond with the token type we want to manipulate.</p><p>现在，我们将在input_fn上执行DFS并插入print语句。 syn提供了Fold特质，可以在任何项目上为DFS实施该特质。我们只需要修改与我们要操作的标记类型相对应的特征方法。</p><p> impl Fold for Args { fn fold_expr(&amp;mut self, e: Expr) -&gt; Expr { match e {// for changing assignment like a=5 Expr::Assign(e) =&gt; {// check should print if self.should_print_expr(&amp;e.left) { self.assign_and_print(*e.left, &amp;e.eq_token, *e.right) } else {// continue with default travesal using default methods Expr::Assign(fold::fold_expr_assign(self, e)) } }// for changing assigment and operation like a+=1 Expr::AssignOp(e) =&gt; {// check should print if self.should_print_expr(&amp;e.left) { self.assign_and_print(*e.left, &amp;e.op, *e.right) } else {// continue with default behaviour Expr::AssignOp(fold::fold_expr_assign_op(self, e)) } }// continue with default behaviour for rest of expressions _ =&gt; fold::fold_expr(self, e), } }// for let statements like let d=9 fn fold_stmt(&amp;mut self, s: Stmt) -&gt; Stmt { match s { Stmt::Local(s) =&gt; { if s.init.is_some() &amp;&amp; self.should_print_pat(&amp;s.pat) { self.let_and_print(s) } else { Stmt::Local(fold::fold_local(self, s)) } } _ =&gt; fold::fold_stmt(self, s), } }}</p><p> 对Args进行impl折叠{fn fold_expr（＆amp; mut self，e：Expr）-＆gt; Expr {match e {//用于更改赋值，例如a = 5 Expr :: Assign（e）=＆gt; {//检查是否应该打印self.should_print_expr（＆amp; e.left）{self.assign_and_print（* e.left，＆amp; e.eq_token，* e.right）}否则{//使用默认方法继续默认穿越Expr :: Assign（fold :: fold_expr_assign（self，e））}} //用于更改分配和操作，例如a + = 1 Expr :: AssignOp（e）=＆gt; {//检查是否应该打印self.should_print_expr（＆amp; e.left）{self.assign_and_print（* e.left，＆amp; e.op，* e.right）}否则{//继续使用默认行为Expr :: AssignOp（fold :: fold_expr_assign_op（self，e））}} //其余表达式继续默认行为_ =＆gt; fold :: fold_expr（self，e），}} // for let语句，例如let d = 9 fn fold_stmt（＆amp; mut self，s：Stmt）-＆gt; Stmt {match s {Stmt :: Local（s）=＆gt; {如果s.init.is_some（）＆amp;＆amp; self.should_print_pat（＆amp; s.pat）{self.let_and_print（s）} else {Stmt :: Local（fold :: fold_local（self，s））}} _ =＆gt; fold :: fold_stmt（self，s），}}}</p><p> The  Fold trait is used to do a DFS of  Item. It enables you to use different behavior for various token types.</p><p> 折叠特征用于对物料进行DFS。它使您可以对各种令牌类型使用不同的行为。</p><p>  #[proc_macro_attribute]pub fn trace_var(args: TokenStream, input: TokenStream) -&gt; TokenStream {// parse the input let input = parse_macro_input!(input as ItemFn);// parse the arguments let mut args = parse_macro_input!(args as Args);// create the ouput let output = args.fold_item_fn(input);// return the TokenStream TokenStream::from(quote!(#output))}</p><p>  ＃[proc_macro_attribute] pub fn trace_var（args：TokenStream，输入：TokenStream）-＆gt; TokenStream {//解析输入let input = parse_macro_input！（input as ItemFn）; //解析参数let mut args = parse_macro_input！（args as Args）; //创建输出let output = args.fold_item_fn（input）; //返回TokenStream TokenStream :: from（quote！（＃output））}</p><p> This code example is from the   syn examples repo, which is an excellent resource to learn about procedural macros.</p><p> 此代码示例摘自syn示例存储库，这是学习程序宏的绝妙资源。</p><p>  Custom derive macros in Rust allow auto implement traits. These macros enable you to implement traits using  #[derive(Trait)].</p><p>  Rust中的自定义派生宏允许自动实现特征。这些宏使您可以使用＃[derive（Trait）]实现特征。</p><p>   To write a custom derive macro in Rust, we can use  DeriveInput for parsing input to derive macro. We’ll also use the  proc_macro_derive macro to define a custom derive macro.</p><p>   要在Rust中编写一个自定义的派生宏，我们可以使用DeriveInput来解析要派生宏的输入。我们还将使用proc_macro_derive宏定义自定义衍生宏。 </p><p> #[proc_macro_derive(Trait)]pub fn derive_trait(input: proc_macro::TokenStream) -&gt; proc_macro::TokenStream { let input = parse_macro_input!(input as DeriveInput); let name = input.ident; let expanded = quote! { impl Trait for #name { fn print(&amp;self) -&gt; usize { println!(&#34;{}&#34;,&#34;hello from #name&#34;) } } }; proc_macro::TokenStream::from(expanded)}</p><p>＃[proc_macro_derive（Trait）] pub fn generate_trait（input：proc_macro :: TokenStream）-＆gt; proc_macro :: TokenStream {让输入= parse_macro_input！（输入为DeriveInput）；让名称= input.ident;让扩展=报价！ {impl Trait for #name {fn print（＆amp; self）-＆gt;使用ize {println！（＆＃34; {}＆＃34;，＆＃34;你好，来自＃name＆＃34;）}}}； proc_macro :: TokenStream :: from（展开）}</p><p> More advanced procedural macros can be written using  syn. Check out  this example from  syn‘s repo.</p><p> 可以使用syn编写更高级的程序宏。从syn’s仓库中查看此示例。</p><p>  Function-like macros are similar to declarative macros in that they’re invoked with the macro invocation operator  ! and look like function calls. They operate on the code that is inside the parentheses.</p><p>  类似函数的宏与声明性宏类似，因为它们是通过宏调用运算符来调用的！看起来像函数调用。它们对括号内的代码进行操作。</p><p>   Function-like macros are executed not at runtime but at compile time. They can be used anywhere in Rust code. Function-like macros also take a  TokenStream and return a  TokenStream.</p><p>   类似函数的宏不是在运行时执行，而是在编译时执行。它们可以在Rust代码的任何地方使用。类似函数的宏也需要TokenStream并返回TokenStream。</p><p>    In this Rust macros tutorial, we covered the basics of macros in Rust, defined declarative and procedural macros, and walked through how to write both types of macros using various syntax and community-built crates. We also outlined the advantages of using each type of Rust macro.</p><p>    在本Rust宏教程中，我们介绍了Rust中的宏基础知识，定义的声明性和过程宏，并逐步介绍了如何使用各种语法和社区构建的包编写两种类型的宏。我们还概述了使用每种类型的Rust宏的优点。</p><p> Debugging Rust applications can be difficult, especially when users experience issues that are difficult to reproduce. If you’re interested in monitoring and tracking performance of your Rust apps, automatically surfacing errors, and tracking slow network requests and load time,  try LogRocket.    LogRocket is like a DVR for web apps, recording literally everything that happens on your Rust app. Instead of guessing why problems happen, you can aggregate and report on what state your application was in when an issue occurred. LogRocket also monitors your app’s performance, reporting metrics like client CPU load, client memory usage, and more.</p><p> 调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您希望监视和跟踪Rust应用程序的性能，自动显示错误以及跟踪缓慢的网络请求和加载时间，请尝试LogRocket。 LogRocket就像Web应用程序的DVR，实际上记录了Rust应用程序中发生的所有事情。无需猜测为什么会发生问题，您可以汇总并报告问题发生时应用程序所处的状态。 LogRocket还监视您的应用程序的性能，报告诸如客户端CPU负载，客户端内存使用情况等指标。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.logrocket.com/macros-in-rust-a-tutorial-with-examples/">https://blog.logrocket.com/macros-in-rust-a-tutorial-with-examples/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/教程/">#教程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/带有/">#带有</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>