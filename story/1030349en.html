<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Facebook的大部分流量现在使用Quic和HTTP/3</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Facebook的大部分流量现在使用Quic和HTTP/3</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-22 08:51:38</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/26084ab8f493471f0b529289b45c01c1.png"><img src="http://img2.diglog.com/img/2020/10/26084ab8f493471f0b529289b45c01c1.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>We are replacing the de facto protocol the internet has used for decades with   QUIC , the latest and most radical step we’ve taken to optimize our network protocols to create a better experience for people on our services. Today, more than 75 percent of our internet traffic uses QUIC and HTTP/3 (we refer to QUIC and HTTP/3 together as QUIC). QUIC has shown significant improvements in several metrics, including request errors, tail latency, response header size, and numerous others that meaningfully affect the experience of people using our apps.</p><p>我们正在用Quic取代互联网几十年来使用的事实上的协议，这是我们为优化我们的网络协议，为人们创造更好的使用我们服务的体验而采取的最新和最激进的步骤。今天，超过75%的互联网流量使用Quic和HTTP/3(我们将Quic和HTTP/3统称为Quic)。Quic已经在几个指标上显示出显著的改进，包括请求错误、尾部延迟、响应头大小，以及许多其他有意义地影响使用我们应用程序的用户体验的指标。</p><p> The Internet Engineering Task Force (IETF) is   currently developing  both QUIC and HTTP/3 for standardization.</p><p>互联网工程任务组(IETF)目前正在开发用于标准化的QUIC和HTTP/3。</p><p>  Broadly speaking, QUIC is a   replacement  for the Transmission Control Protocol (TCP), one of the main protocols for internet communication. QUIC was originally developed internally by Google as Google QUIC, or gQUIC, and was presented to the IETF in 2015. Since then, it has been redesigned and improved by the broader IETF community, forming a new protocol we now call QUIC.   HTTP/3  is the next iteration of HTTP, the standard protocol for web-based applications and servers. Together, QUIC and HTTP/3 represent the latest and greatest in internet-focused protocols, incorporating decades of  best practices and lessons that we, Google, and the IETF community learned through running protocols on the internet .</p><p>广义地说，QUIC是传输控制协议(TCP)的替代协议，TCP是互联网通信的主要协议之一。Quic最初由谷歌内部开发，名为Google Quic，或gQUIC，并于2015年提交给IETF。从那时起，更广泛的IETF社区对其进行了重新设计和改进，形成了我们现在称为Quic的新协议。HTTP/3是HTTP的下一代，HTTP是基于Web的应用程序和服务器的标准协议。总之，Quic和HTTP/3代表了以互联网为中心的最新和最伟大的协议，融合了我们、谷歌和IETF社区通过在互联网上运行协议而学到的数十年的最佳实践和经验教训。</p><p> QUIC and HTTP/3 generally outperform TCP and HTTP/2, which in turn outperform TCP and HTTP/1.1. TCP and HTTP/2 first introduced the concept of allowing a single network connection to support multiple data streams in a process called stream multiplexing. QUIC and HTTP/3 take this one step further by allowing streams to be truly independent by avoiding TCP’s dreaded head of line blocking, where lost packets jam and slow down all streams on a connection.</p><p>QUIC和HTTP/3通常优于TCP和HTTP/2，而TCP和HTTP/2又优于TCP和HTTP/1.1。TCP和HTTP/2首先引入了允许单个网络连接在称为流复用的过程中支持多个数据流的概念。Quic和HTTP/3更进一步，通过避免TCP可怕的队头阻塞(丢失的数据包会堵塞连接上的所有流并减慢连接上的所有流)，从而允许流真正独立。</p><p> QUIC employs state-of-the-art loss recovery, which allows it to perform better than most TCP implementations under poor network conditions. TCP is also prone to ossification, where the protocol becomes difficult to upgrade because network middleboxes such as firewalls make assumptions about the packets’ format. QUIC avoids this issue by being fully encrypted, making protocol extensibility a first-class citizen and guaranteeing that future improvements can be made. QUIC also allows new ways to instrument, observe, and visualize transport behavior through   QLOG , a JSON-based tracing format designed specifically for QUIC.</p><p>Quic采用最先进的丢失恢复技术，这使得它在恶劣的网络条件下比大多数TCP实现执行得更好。TCP也容易僵化，协议很难升级，因为网络中间盒(如防火墙)会对数据包的格式进行假设。QUIC通过完全加密避免了这个问题，使协议的可扩展性成为一等公民，并保证将来可以进行改进。Quic还允许以新的方式通过QLOG检测、观察和可视化传输行为，QLOG是一种专门为Quic设计的基于JSON的跟踪格式。</p><p>  We developed our own implementation of QUIC, called   mvfst , in order to rapidly test and deploy QUIC on our own systems. We have a history of writing and deploying our own protocol implementations, first with our HTTP client/server library,   Proxygen , and following that with the   Zero protocol  and then   Fizz , our TLS 1.3 implementation. Facebook apps utilize both Fizz and Proxygen to communicate with our servers via   Proxygen Mobile . We’ve also developed two security solutions for TLS, an extension called   delegated credentials  for securing certificates and   DNS over TLS , for encrypting and authenticating web traffic over TLS.</p><p>我们开发了我们自己的Quic实现，称为mvfst，以便在我们自己的系统上快速测试和部署Quic。我们有编写和部署自己的协议实现的历史，首先是使用HTTP客户端/服务器库Proxygen，然后是Zero协议，然后是Fizz，即我们的TLS1.3实现。Facebook应用程序利用Fizz和Proxygen通过Proxygen Mobile与我们的服务器进行通信。我们还为TLS开发了两个安全解决方案，一个称为委托凭据的扩展，用于保护证书和TLS上的DNS，用于加密和验证TLS上的Web流量。</p><p>  We wanted our new protocol to seamlessly integrate with our existing software and allow our developers to work quickly. As a proving ground, we decided to deploy QUIC on a large subset of Facebook network traffic, specifically internal network traffic that included proxied public traffic to Facebook. If QUIC didn’t work well for internal traffic, we knew it likely wouldn’t work well on the larger internet either.</p><p>我们希望我们的新协议能够与我们现有的软件无缝集成，并允许我们的开发人员快速工作。作为试验场，我们决定在Facebook网络流量的一个大子集上部署Quic，特别是内部网络流量，其中包括到Facebook的代理公共流量。如果Quic不能很好地处理内部流量，我们知道它在更大的互联网上也可能不能很好地工作。</p><p> In addition to shaking out bugs and other problematic behaviors, this strategy let us design a method that makes our   network load balancer  deeply   QUIC-aware  and maintains our   load balancer’s zero-downtime release guarantees .</p><p>除了消除Bug和其他有问题的行为之外，此策略还让我们设计了一种方法，使我们的网络负载均衡器深入了解Quic，并维护我们的负载均衡器的零停机释放保证。</p><p> With this solid foundation in place, we moved toward deploying QUIC to people on the internet. Because of mvfst’s design, we were able to smoothly integrate QUIC support into Proxygen Mobile.</p><p>有了这个坚实的基础，我们开始向互联网上的人们部署Quic。由于mvfst的设计，我们能够顺利地将Quic Support集成到Proxygen Mobile中。</p><p>  The Facebook app was our first target for using QUIC on the internet. Facebook has a mature infrastructure that allows us to safely roll out changes to apps in a limited fashion before we release them to billions of people. We began with an experiment in which we enabled QUIC for dynamic   GraphQL  requests in the Facebook app. These are requests that do not have static content such as images and videos in the response.</p><p>Facebook应用程序是我们在互联网上使用Quic的第一个目标。Facebook有一个成熟的基础设施，允许我们在将应用程序的更改发布给数十亿人之前，以有限的方式安全地推出这些更改。我们从一个实验开始，在这个实验中，我们在Facebook应用程序中为动态GraphQL请求启用了Quic。这些请求在响应中没有静态内容，例如图像和视频。</p><p> Our tests have shown that QUIC offers improvements on several metrics. People on Facebook experienced a 6 percent reduction in request errors, a 20 percent tail latency reduction, and a 5 percent reduction in response header size relative to HTTP/2. This had cascading effects on other metrics as well, indicating that peoples’ experience was greatly enhanced by QUIC.</p><p>我们的测试表明，Quic在几个指标上都有改进。与HTTP/2相比，Facebook上的用户体验到请求错误减少了6%，尾部延迟减少了20%，响应头大小减少了5%。这也对其他指标产生了级联效应，表明Quic极大地增强了人们的体验。</p><p> However, there were regressions. What was most puzzling was that, despite QUIC being enabled only for dynamic requests, we observed increased error rates for static content downloaded with TCP. The root cause of this would be a common theme we’d run into when transitioning traffic to QUIC: App logic was changing the type and quantity of requests for certain types of content based on the speed and reliability of requests for other types of content. So improving one type of request may have had detrimental side effects for others.</p><p>然而，也有一些倒退。最令人费解的是，尽管Quic只针对动态请求启用，但我们观察到使用TCP下载的静态内容的错误率增加了。其根本原因是我们在将流量转换到Quic时遇到的一个共同主题：应用程序逻辑基于对其他类型内容的请求的速度和可靠性来更改对某些类型内容的请求类型和数量。因此，改进一种类型的请求可能会对其他类型的请求产生有害的副作用。</p><p> For example, a heuristic that adapted how aggressively the app requested new static content from the server was tuned in a way that created issues with QUIC. When the app makes a request to, say, load the text content of a News Feed, it waits to see how long this request takes, then determines how many image/video requests to make from there. We found the heuristic was tuned with arbitrary thresholds, which probably worked OK for TCP. But when we switched to QUIC, these thresholds were inaccurate, and the app tried to request too much at once, ultimately causing News Feed to take longer to load.</p><p>例如，调整应用程序向服务器请求新静态内容的积极程度的启发式方法会导致Quic出现问题。例如，当应用程序请求加载News Feed的文本内容时，它会等待查看该请求需要多长时间，然后确定从那里发出多少图像/视频请求。我们发现启发式可以使用任意阈值进行调整，这对于TCP来说可能工作得很好。但当我们切换到Quic时，这些阈值并不准确，应用程序试图一次请求太多，最终导致News Feed需要更长的时间才能加载。</p><p>  The next step was to deploy QUIC for static content (e.g., images and videos) in the Facebook apps. Before doing this, however, we had to address two main concerns: the CPU efficiency of mvfst and the effectiveness of our primary congestion control implementation,   BBR .</p><p>下一步是为Facebook应用程序中的静态内容(如图像和视频)部署Quic。然而，在这样做之前，我们必须解决两个主要问题：mvfst的CPU效率和我们的主要拥塞控制实现BBR的有效性。</p><p> Up to this point, mvfst was designed to help developers move quickly and keep up with ever-changing drafts of QUIC. Dynamic requests, whose responses are relatively small compared with those of static requests, do not require significant CPU usage, nor do they put a congestion controller through its paces.</p><p>到目前为止，mvfst的设计初衷是帮助开发人员快速行动，跟上Quic不断变化的草案。与静态请求相比，动态请求的响应相对较小，因此不需要大量的CPU使用量，也不会让拥塞控制器进行测试。</p><p> To address these concerns, we developed performance testing tools that allowed us to assess CPU usage and how effectively our congestion controller could utilize network resources. We used these tools and synthetic load tests of QUIC in our load balancer to make several improvements. One important area, for example, was optimizing how we pace UDP packets to allow for smoother data transmission. To improve CPU usage, we employed a number of techniques,  including using generic segmentation offload (  GSO ) to efficiently send batches of UDP packets at once. We also optimized the data structures and algorithms that handle unacknowledged QUIC data.</p><p>为了解决这些问题，我们开发了性能测试工具，使我们能够评估CPU使用率以及拥塞控制器利用网络资源的效率。我们在负载均衡器中使用这些工具和Quic的合成负载测试进行了一些改进。例如，一个重要的领域是优化我们如何调整UDP数据包的速度，以实现更顺畅的数据传输。为了提高CPU使用率，我们采用了许多技术，包括使用通用分段卸载(GSO)来一次高效地发送成批的UDP数据包。我们还优化了处理未确认的QUIC数据的数据结构和算法。</p><p>  Before turning on QUIC for all content in the Facebook app, we partnered with several stakeholders, including our video engineers. They have a deep understanding of the important product metrics and helped us analyze the experimental results in the Facebook app as we enabled QUIC.</p><p>在为Facebook应用程序中的所有内容打开Quic之前，我们与几个利益相关者合作，包括我们的视频工程师。他们对重要的产品指标有深刻的理解，并在我们启用Quic时帮助我们分析Facebook应用程序中的实验结果。</p><p> The experiments showed that QUIC had a transformative effect on video metrics in the Facebook app. Mean time between rebuffering (MTBR), a measure of the time between buffering events, improved in aggregate by up to 22 percent, depending on the platform. The overall error count on video requests was reduced by 8 percent. The rate of video stalls was reduced by 20 percent. Several other metrics, including meta-metrics, considering a variety of factors and specifically outlier conditions, were significantly improved as well. QUIC improved the video viewing experience, with an outsized impact on networks with relatively poorer conditions, especially those in emerging markets.</p><p>实验表明，Quic对Facebook应用程序中的视频指标产生了革命性的影响。平均重新缓冲间隔时间(MTBR)是对缓冲事件之间时间的度量，根据平台的不同，总体上可提高高达22%。视频请求的总错误计数减少了8%。视频摊位率下降20%。其他几个指标，包括考虑了各种因素和特别是异常值条件的指标，也得到了显著改进。Quic改善了视频观看体验，对条件相对较差的网络产生了过大的影响，特别是新兴市场的网络。</p><p> But the path to these results came with roadblocks of its own. Similar to our experience with dynamic content, we encountered heuristics in the app that had been tuned to TCP’s behavior. For example, the apps on iOS and Android had differing mechanisms for estimating the available download bandwidth. These estimators sometimes overestimated the available bandwidth when using QUIC, causing the app to play a higher-quality video than the network could support and resulting in stalls.</p><p>但通往这些结果的道路上也有自己的路障。与我们处理动态内容的经历类似，我们在应用程序中遇到了针对TCP行为进行调整的启发式方法。例如，iOS和Android上的应用程序有不同的机制来估计可用下载带宽。在使用Quic时，这些估计器有时会高估可用带宽，导致应用程序播放超出网络支持的更高质量的视频，并导致停机。</p><p> We also had to tune and iterate the flow control parameters. Flow control limits the amount of data a receiver is willing to buffer from the sender. The Facebook app had a statically defined flow control limit for HTTP/2 that was implicitly tuned for TCP and did not perform well with QUIC. It took some experimental iteration for us to find the new optimal flow control value.</p><p>我们还必须调整和迭代流控制参数。流量控制限制了接收方愿意从发送方缓冲的数据量。Facebook应用程序对HTTP/2有一个静态定义的流量控制限制，该限制是针对TCP隐式调优的，在使用Quic时表现不佳。为了找到新的最优流量控制值，我们进行了一些实验迭代。</p><p>   QUIC’s performance on the Facebook app has been a testament to its ability to improve peoples’ experience on the internet, even on rich and complex applications like Facebook. In the future, we plan to continue to utilize more of QUIC’s existing features, such as connection migration and true 0-RTT connection establishment, as well as invest in improvements to congestion control and loss recovery.</p><p>Quic在Facebook应用程序上的表现证明了它有能力改善人们在互联网上的体验，即使是在Facebook这样丰富而复杂的应用程序上也是如此。未来，我们计划继续利用Quic的更多现有功能，如连接迁移和真正的0-RTT连接建立，并投资于改进拥塞控制和损失恢复。</p><p> We deployed QUIC to the Instagram apps as well, using the same strategies as our Facebook deployment — testing it on a small percentage of Instagram’s traffic and then scaling up. Today, QUIC is deployed on Instagram for iOS and Instagram for Android. Both versions of Instagram have seen metrics that are comparable to or better than those of the Facebook app. Facebook and Instagram on the web also have QUIC enabled, so as more web browsers enable support for QUIC, as   Google has recently done for Chrome  and   Apple has done for Safari beta , even more people will benefit from the improvements. Beyond Instagram, we believe we can bring the benefits of QUIC to every experience in our family of apps, with QUIC eventually representing not just the majority but the entirety of Facebook’s internet traffic.</p><p>我们也在Instagram应用程序上部署了Quic，使用与我们的Facebook部署相同的策略-在Instagram的一小部分流量上进行测试，然后扩大规模。今天，Quic被部署在用于iOS的Instagram和用于Android的Instagram上。两个版本的Instagram都看到了与Facebook应用程序相当或更好的指标。Facebook和Instagram在网络上也启用了Quic，所以随着更多的网络浏览器支持Quic，就像谷歌最近对Chrome和苹果对Safari测试版所做的那样，更多的人将从这些改进中受益。除了Instagram，我们相信我们可以将Quic的好处带到我们应用系列的每一种体验中，Quic最终不仅代表了Facebook的大部分互联网流量，而且代表了整个Facebook的互联网流量。</p><p> The IETF is on track to finalize the QUIC protocol as a request for comments (RFC) document sometime in 2021. Once this happens, even more websites, applications, and networking libraries will start offering QUIC for general use. In the very near future, new protocols like QUIC will be essential to unlocking innovative internet applications. For us, QUIC is a starting point from which we can continue to enhance people’s Facebook experience.</p><p>IETF有望在2021年的某个时候将QUIC协议最终确定为征求意见(RFC)文档。一旦发生这种情况，甚至会有更多的网站、应用程序和网络库开始提供Quic供一般用户使用。在不久的将来，像Quic这样的新协议将对解锁创新的互联网应用至关重要。对我们来说，Quic是一个起点，我们可以从这个起点继续提升人们的Facebook体验。</p><p> There are so many people within and outside of Facebook who have made this deployment possible. We would like to thank everyone who has participated in the IETF QUIC working group over the past several years, tirelessly debating and designing QUIC. The working group comprises a multitude of individuals from many different backgrounds who have produced a truly remarkable protocol in a relatively short period of time.</p><p>Facebook内外有如此多的人使这一部署成为可能。我们要感谢过去几年来参加IETF Quic工作组的每一个人，他们不知疲倦地辩论和设计Quic。工作组由来自许多不同背景的众多个人组成，他们在相对较短的时间内制定了一项真正了不起的议定书。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://engineering.fb.com/networking-traffic/how-facebook-is-bringing-quic-to-billions/">https://engineering.fb.com/networking-traffic/how-facebook-is-bringing-quic-to-billions/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/facebook/">#facebook</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/现在/">#现在</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/quic/">#quic</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1030347.html"><img src="http://img2.diglog.com/img/2020/10/thumb_0498fa6474ad6d2d18227c6c018514cb.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030347.html">用于Firefox的Facebook容器</a></div><span class="my_story_list_date">2020-10-22 8:51</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030299.html"><img src="http://img2.diglog.com/img/2020/10/thumb_23ec8b9a770a16f26e00a0765ab03cfa.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030299.html">Facebook蜇巴比伦蜜蜂</a></div><span class="my_story_list_date">2020-10-21 20:48</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030287.html"><img src="http://img2.diglog.com/img/2020/10/thumb_225d87ac68c8edb4768ce0f3c94212cb.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030287.html">
Facebook正在致力于社区，这是一个基于当地团体的Nextdoor克隆</a></div><span class="my_story_list_date">2020-10-21 19:49</span></div><div class="col-sm"><div><a target="_blank" href="/story/1030274.html"><img src="http://img2.diglog.com/img/2020/10/thumb_590890d29d872f398fc029e757d226bb.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1030274.html">Venn是一家线性电视和ESPORTS网络，可在Roku、Twitch、YouTube、Facebook游戏和Plex等各种流媒体服务上使用，在首轮融资2600万美元</a></div><span class="my_story_list_date">2020-10-21 17:7</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>