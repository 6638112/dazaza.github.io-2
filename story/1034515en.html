<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何编写用于日志记录的单元测试</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">如何编写用于日志记录的单元测试</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-11 19:42:29</div><div class="page_narrow text-break page_content"><p>Once in a while I get asked the question whether one should write  solitary tests for logging functionality. My answer to this question is the typical consultant answer: “It depends”. In essence, logging is an infrastructure concern. The end result is log data that is being written to a resource which is external to an application. Usually the generated data ends up in a file, a database or it might even end up in a cloud service.</p><p>每隔一段时间，我就会被问到是否应该为日志记录功能编写单独的测试。我对这个问题的回答是典型的咨询师回答：“这要看情况”。从本质上讲，日志记录是一个基础设施问题。最终结果是写入应用程序外部资源的日志数据。通常情况下，生成的数据最终会保存在文件或数据库中，甚至可能会保存在云服务中。</p><p> Because logging crosses the process boundary of an application, it is more useful to write  sociable tests to verify this particular functionality. It doesn’t make sense to use solitary tests in this particular case.</p><p>因为日志记录跨越了应用程序的进程边界，所以编写社交测试来验证这一特定功能更有用。在这种情况下使用单独测试是没有意义的。</p><p> That being said, there are situations where business requirements explicitly state that logging should be a part of the interface of an application. In this situation, the intent of logging should be expressed explicitly by the code which in turn should also be exercised by solitary tests. The excellent book  Growing Object Oriented Software Guided By Tests, written by Steve Freeman and Nat Pryce, mentions that there are generally two separate types of logging:</p><p>也就是说，在某些情况下，业务需求明确规定日志记录应该是应用程序接口的一部分。在这种情况下，日志记录的意图应该由代码明确表达，而代码也应该通过单独的测试来执行。史蒂夫·弗里曼(Steve Freeman)和纳特·普赖斯(Nat Pryce)合著的优秀著作《Growing Object Oriented Software Guided by Test》提到，通常有两种不同类型的日志记录：</p><p>  A support log contains messages that are intended for those that perform operational activities. These messages are used to determine whether the system behaves correctly or not. The log level for these messages is usually of type  error or  info.</p><p>支持日志包含针对执行操作活动的人员的消息。这些消息用于确定系统运行是否正确。这些消息的日志级别通常是ERROR或INFO类型。</p><p> A diagnostic log on the other hand holds messages that are targeted towards software developers. These messages provide valuable insights into the details of a running system. The log level for these messages is usually of type  debug or  trace.</p><p>另一方面，诊断日志保存针对软件开发人员的消息。这些消息提供了对正在运行的系统的详细信息的有价值的见解。这些消息的日志级别通常为DEBUG或TRACE类型。</p><p> Given these two types of logging, the basic idea is that code which expresses the intent of support logging should be exercised by solitary tests. Code statements that initiate diagnostic logging are usually not covered by tests.</p><p>考虑到这两种类型的日志记录，基本思想是表达支持日志记录意图的代码应该通过单独的测试来执行。启动诊断日志记录的代码语句通常不在测试范围内。</p><p> Let’s have a look at an example that demonstrates both support and diagnostic logging in action.</p><p>让我们看一个同时演示支持和诊断日志记录的示例。</p><p> public class ExpenseSheetController : Controller{ private readonly ICommandHandler&lt;CreateExpenseSheet&gt; _commandHandler; private readonly ISupportNotifier _supportNotifier; public ExpenseSheetController(ICommandHandler&lt;CreateExpenseSheet&gt; commandHandler, ISupportNotifier supportNotifier) { _commandHandler = commandHandler; _supportNotifier = supportNotifier; } [HttpPost] [ServiceFilter(typeof(PerformanceTracing))] public IActionResult Create(CreateExpenseSheetFormModel formModel) { try { var command = new CreateExpenseSheet(Guid.NewGuid(), formModel.EmployeeId); _commandHandler.Handle(command); } catch(Exception ex) { _supportNotifier.ErrorDuringExpenseSheetCreation(ex, formModel.EmployeeId); return BadRequest(); } _supportNotifier.ExpenseSheetCreated(formModel.EmployeeId); return Ok(); }}</p><p>公共类ExpenseSheetController：控制器{私有只读ICommandHandler；CreateExpenseSheet&&gt;；_CommandHandler；私有只读ISupportNotifier_SupportNotifier；公共ExpenseSheetController(ICommandHandler&lt；CreateExpenseSheet&gt；命令处理程序，ISupportNotifiersupportNotifier){_CommandHandler=命令句柄；_supportNotifier=supportNotifier；}[HttpPost][ServiceFilter(typeof(perpeof。Return BadRequest()；}_supportNotifier.ExpenseSheetCreated(formModel.EmployeeId)；Return OK()；}}</p><p> Here we have the implementation of a controller that can receive a request for creating a new expense sheet. Notice that the constructor of this controller class expects an instance of the  ISupportNotifier interface. This dependency is being used by the implementation of the  Create method for logging an error when an exception occurs. It is also used for logging when an expense sheet has been successfully created.</p><p>这里我们实现了一个控制器，它可以接收创建新报销单的请求。注意，这个控制器类的构造函数需要ISupportNotifier接口的一个实例。当发生异常时，Create方法的实现使用此依赖项来记录错误。它还用于在成功创建报销单时进行日志记录。</p><p>  public class SupportNotifier : ISupportNotifier{ private readonly ILogger&lt;SupportNotifier&gt; _logger; public SupportNotifier(ILogger&lt;SupportNotifier&gt; logger) { _logger = logger; } public void ExpenseSheetCreated(Guid employeeId) { _logger.LogInformation(&#34;Expense sheet created for employee with ID &#39;{employeeId}&#39;.&#34;); } public void ErrorDuringExpenseSheetCreation(Exception ex, Guid employeeId) { _logger.LogError(ex, $&#34;Unable to create a new expense sheet for employee with ID &#39;{employeeId}&#39;&#34;); }}</p><p>公共类支持通知器：ISupportNotifier{Private Readonly ILogger&lt；SupportNotifier&gt；_Logger；Public SupportNotifier(ILogger&lt；SupportNotifier&gt；Logger){_logger=logger；}Public void ExpenseSheetCreated(GUID EmploeID){_logger.LogInformation(&#34；为ID&#39；{ployeeID}&#39；&#39；&#34；)；}Public void ExpenseSheetCreated(GUID EmployeeID){_logger.LogInformation(&#34；为ID&#39；{ployeeID}&#39；&#34；)；}Public void ErrorDuringExpenseSheet。{ployeeId}&#39；&#34；)；}}。</p><p> This code demonstrates that support logging uses log levels  error or  info depending on the context. Verifying thecode of the  SupportNotifier class itself can be done by using sociable tests. It’s not a good idea to writesolitary tests for the  SupportNotifier class. This would imply that a test double should be used as an instance of  ILogger. As we already touched on in a  previous blog post, it’s much better to avoid using test doubles for types that you don’t own. In this particular case it would even be quite hard to do as the  Logxx methods of  ILogger are actually extension methods and not regular methods.</p><p>这段代码演示了支持日志记录根据上下文使用日志级别、错误或信息。验证SupportNotifier类本身的代码可以通过使用社交测试来完成。为SupportNotifier类编写保留性测试不是一个好主意。这意味着应该将test Double用作ILogger的实例。正如我们在之前的一篇博客文章中已经提到的，最好避免对您不拥有的类型使用测试替身。在这种情况下，甚至很难做到这一点，因为ILogger的Logxx方法实际上是扩展方法，而不是常规方法。</p><p>  [Specification]public class When_handling_a_request_for_creating_a_new_expense_sheet{ [Establish] public void Context() { var commandHandler = Substitute.For&lt;ICommandHandler&lt;CreateExpenseSheet&gt;&gt;(); _supportNotifier = Substitute.For&lt;ISupportNotifier&gt;(); _sut = new ExpenseSheetController(commandHandler, _supportNotifier); } [Because] public void Of() { var formModel = new CreateExpenseSheetFormModel { EmployeeId = new Guid(&#34;94EDE8F3-9675-4DD7-A18F-E37B1F323699&#34;) }; _sut.Create(formModel); } [Observation] public void Then_it_should_notify_support() { _supportNotifier.Received() .ExpenseSheetCreated(new Guid(&#34;94EDE8F3-9675-4DD7-A18F-E37B1F323699&#34;)); } private ExpenseSheetController _sut; private ISupportNotifier _supportNotifier;}[Specification]public class When_an_error_occurs_while_handling_a_request_for_creating_a_new_expense_sheet{ [Establish] public void Context() { _supportNotifier = Substitute.For&lt;ISupportNotifier&gt;(); _exception = new InvalidOperationException(&#34;Meltdown&#34;); var commandHandler = Substitute.For&lt;ICommandHandler&lt;CreateExpenseSheet&gt;&gt;(); commandHandler.WhenForAnyArgs(ch =&gt; ch.Handle(null)) .Throw(_exception); _sut = new ExpenseSheetController(commandHandler, _supportNotifier); } [Because] public void Of() { var formModel = new CreateExpenseSheetFormModel { EmployeeId = new Guid(&#34;D1067157-5C73-4140-9D29-0FE5C1C4C2FB&#34;) }; _sut.Create(formModel); } [Observation] public void Then_it_should_notify_support_that_a_new_expense_sheet_has_been_created() { _supportNotifier.Received() .ErrorDuringExpenseSheetCreation(_exception, new Guid(&#34;D1067157-5C73-4140-9D29-0FE5C1C4C2FB&#34;)); } private ExpenseSheetController _sut; private ISupportNotifier _supportNotifier; private Exception _exception;}</p><p>[规范]公共类When_handling_a_request_for_creating_a_new_expense_sheet{[建立]公共空上下文(){var命令句柄=Substitute.For&lt；ICommandHandler&lt；CreateExpenseSheet&gt；&gt；()；_SupportNotifier=Substitute.For&lt；ISupportNotifier&gt；()；_sut=新的ExpenseSheetController(命令句柄，_SupportNotifier)；}[因为]公共空的(){var formModel=new CreateExpenseSheetFormModel{EmployeeID=new Guid(&#34；94EDE8F3-9675-4DD7-A18F-E37B1F323699&#34；)}；_sut.Create(FormModel)；}[Observation]PUBLIC VALID THEN_IT_HUTIFY_NOTIFY_SUPPORT(){_supportNotifier.Receired().ExpenseSheetCreated(new Guid(&#34；94EDE8F3-9675-4DD7-A18F-E37B1F323699&#34；))；}Private ExpenseSheetController_Sut；Private ISupportNotifierSupportNotifier；}[规范]公共类When_an_error_occurs_while_handling_a_request_for_creating_a_new_expense_sheet{[建立]公共无效上下文(){_SupportNotifier=Substitute.For&lt；ISupportNotifier&gt；()；_Except=新的InvalidOperationException(&#34；Meltdown&#34；)；变量命令Handler=Substitute.For&lt；ICommandHandler&lt；CreateExpenseSheet&gt；&gt；()；命令Handler.WhenForAnyArgs(ch=&gt；ch.Handle(NULL)).Throw(_Except)；_sut=new ExpenseSheetController(命令处理程序，_supportNotifier)；}[因为]PUBLIC VOID of(){var formModel=new CreateExpenseSheetFormModel{EmployeeID=new Guid(&#34；D1067157-5C73-4140-9D29-0FE5C1C4C2FB&#34；)}；_sut.Create(FormModel)；}[Observation]PUBLIC VALID Then_it_should_notify_support_that_a_new_expense_sheet_has_been_created(){_supportNotifier.Receired().ErrorDuringExpenseSheetCreation(_Exception，new GUID(&#34；D1067157-5C73-4140-9D29-0FE5C1C4C2FB&#34；))；}私有费用SheetController_sut；私有ISupportNotifier_supportNotifier；私有异常异常；}。</p><p> These tests verify whether support logging occurs when an expense sheet has been created or when an exception gets raised. This way we express the intent of the operational requirements.</p><p>这些测试验证是否在创建报销单或引发异常时进行支持日志记录。通过这种方式，我们表达了操作需求的意图。</p><p>   By applying this attribute, the  PerformanceTracing action filter is being registered to surround the execution of the controller method. Let’s have a look at the implementation of this action filter.</p><p>通过应用此属性，可以注册PerformanceTracing操作筛选器以包围控制器方法的执行。让我们来看看这个操作过滤器的实现。</p><p> public class PerformanceTracing : ActionFilterAttribute{ private readonly ILogger&lt;PerformanceTracing&gt; _logger; private readonly Stopwatch _stopWatch; public PerformanceTracing(ILogger&lt;PerformanceTracing&gt; logger) { _logger = logger; _stopWatch = new Stopwatch(); } public override void OnActionExecuting(ActionExecutingContext context) { _stopWatch.Start(); } public override void OnActionExecuted(ActionExecutedContext context) { _stopWatch.Stop(); var controllerName = context.Controller.GetType().Name; var controllerActionName = context.ActionDescriptor.DisplayName; _logger.LogTrace($&#34;Action &#39;{controllerActionName}&#39; of controller {controllerName} executed in &#34; + $&#34;{_stopWatch.ElapsedMilliseconds} ms.&#34;); }}</p><p>公共类PerformanceTracing：ActionFilterAttribute{私有只读ILogger；PerformanceTracing；_logger；私有只读秒表_stopwatch；公共PerformanceTracing(ILogger&lt；PerformanceTracing&gt；记录器){_logger=记录器；_stopwatch=新秒表()；}公共重写void OnActionExecuting(ActionExecutingContext Context){_stopWatch.Start()；}公共重写void OnActionExecuted(ActionExecuted。在&#34；+$&#34；{_stopWatch.ElapsedMillisecond}毫秒内执行的控制器{ControlerName}的操作&#39；{ControlerActionName}&#39；)；}}。</p><p> This implementation is a nice example of diagnostic logging. The action filter measures the execution time of a controller method and logs the result. Notice that we’re injecting the  ILogger interface directly into the constructor.By registering the  PerformanceTracing action filter using the  ServiceFilter attribute, we ensure that an instance of  ILogger gets resolved and properly injected. We didn’t provide any tests for this implementation.</p><p>这个实现是诊断日志记录的一个很好的例子。操作筛选器测量控制器方法的执行时间并记录结果。注意，我们将ILogger接口直接注入到构造函数中。通过使用ServiceFilter属性注册PerformanceTracing操作筛选器，我们可以确保ILogger的实例得到解析和正确注入。我们没有为这个实现提供任何测试。</p><p> I think it’s useful to consider support logging and diagnostic logging as two separate concepts, even though they quite often use the same mechanisms under the hood.</p><p>我认为将支持日志记录和诊断日志记录视为两个独立的概念是有用的，尽管它们通常在幕后使用相同的机制。</p><p>  If you and your team want to learn more about how to  write maintainable unit tests							and  get the most out of TDD practices, make sure to have look at our							 trainings and workshops or checkout							the  books section. Feel free to reach							out at  info null@ nullprincipal-it null.be.</p><p>如果您和您的团队想要了解更多关于如何编写可维护的单元测试并最大限度地利用TDD实践的知识，请务必查看我们的培训和研讨会或查看书籍部分。请随时联系INFO NULL@null主体-it null.be。</p><p>    Thank you for visiting my blog. I’m a professional software developer since Y2K. 									A   blogger since Y2K+5. Provider									of  training and coaching in									XP practices. Curator of the  									Awesome Talks list. Past organizer of the  									European Virtual ALT.NET meetings. Thinking and learning about all kinds of 									technologies since forever.</p><p>感谢您访问我的博客。我从2000年起就是一名专业的软件开发人员。从Y2K+5开始写博客。提供XP实践方面的培训和指导。令人敬畏的谈话名单的策展人。欧洲虚拟ALT.NET会议的前组织者。一直在思考和学习各种技术。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://principal-it.eu/2020/11/unit-tests-for-logging/">https://principal-it.eu/2020/11/unit-tests-for-logging/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/用于/">#用于</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/unit/">#unit</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/日志/">#日志</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1033817.html"><img src="http://img2.diglog.com/img/2020/11/thumb_cf529431b6b5d8f1f9aace4257242cd0.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033817.html">FFmpeg用于水平、垂直和网格中堆叠视频(2x2、3x2)</a></div><span class="my_story_list_date">2020-11-8 13:29</span></div><div class="col-sm"><div><a target="_blank" href="/story/1033051.html"><img src="http://img2.diglog.com/img/2020/11/thumb_0faf346073a33bae5c8a4e4b69d97b11.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1033051.html">TAD，用于查看和分析表格数据的桌面应用程序</a></div><span class="my_story_list_date">2020-11-4 5:28</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031937.html"><img src="http://img2.diglog.com/img/2020/10/thumb_f110ab582e0f2c3b8ef013cbc2f866e2.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031937.html">Manim：用于解释数学视频的动画引擎</a></div><span class="my_story_list_date">2020-10-29 12:37</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031462.html"><img src="http://img2.diglog.com/img/2020/10/thumb_3fc7f9c30dfdb8de31d78dddb9939322.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031462.html">OpenMPTCP路由器v0.56发布，提供聚合互联网连接的免费解决方案</a></div><span class="my_story_list_date">2020-10-27 20:35</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>