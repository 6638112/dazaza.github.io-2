<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Erlang/o TP 24 highlights Erlang/OTP 24 Highlights</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Erlang/OTP 24 Highlights<br/>Erlang/o TP 24 highlights </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-12 20:14:00</div><div class="page_narrow text-break page_content"><p>Finally Erlang/OTP 24 is here! A release that for me has been  about 10 yearsin the making.  As is  tradition by  now, this blog post will go through theadditions to Erlang/OTP that I am most excited about!</p><p>最后Erlang / OTP 24在这里！发布对我来说大约是10多年来的制作。与现在的传统一样，这个博客帖子将通过帖子到Erlang / OTP，我最兴奋！</p><p> Erlang/OTP 24 includes contributions from 60+ external contributors totalling1400+ commits, 300+ PRs and changing 0.5 million(!) lines of code. Though I’m notsure the line number should count as we vendored all of  AsmJit andre-generated the wxWidgets support. If we ignore AsmJit and wx, there are still260k lines of code added and 320k lines removed, which is about 100k more thanwhat our releases normally contain.</p><p> Erlang / OTP 24包括来自60多个外部贡献者Totaling1400 +提交，300+ PRS和改变0.5百万（！）代码行的贡献。虽然我是不确定的行号应该计数，因为我们奉承了所有ASMJIT ANDRE生成的WXWidgets支持。如果我们忽略了ASMJIT和WX，则添加了静止的260K行代码，并删除了320k行，大约100k大约我们的版本通常包含。</p><p> You can download the readme describing the changes here:  Erlang/OTP 24 Readme.Or, as always, look at the release notes of the application you are interested in.For instance here:  Erlang/OTP 24 - Erts Release Notes - Version 12.0.</p><p> 您可以下载描述更改的README：ERLANG / OTP 24 README.OR，一如既往地查看您感兴趣的应用程序的发行说明。在此处：ERLANG / OTP 24  -  ERTS发行说明 - 版本12.0版本。</p><p>      The most anticipated feature of Erlang/OTP 24 has to be the JIT compiler.A lot has already been said about it:</p><p>      Erlang / OTP 24最预期的特征必须是JIT编译器。很多关于它的批次：</p><p>   However, besides the performance gains that the JIT brings, what I am the mostexcited about is the benefits that come with running native codeinstead of interpreting. What I’m talking about is the native code tooling thatnow becomes available to all Erlang programmers, such as integration with  perf.</p><p>   但是，除了JIT带来的性能增益，我最令人兴奋的是，它是运行诠释的原生代码的好处。我所谈论的是当地代码工具，On Nower可供所有erlang程序员可用，例如与perf的集成。</p><p> As an example, when building a dialyzer plt of a small core of Erlang, theprevious way to profile would be via something like  eprof.</p><p> 例如，当构建erlang的小核心的透析器PLT时，这是通过eprof这样的东西的推导方式。</p><p>  This increases the time to build the PLT from about 1.2 seconds to 15 seconds onmy system. In the end, you get something like the below that will guide you towhat you need to optimize. Maybe take a look at  erl_types:t_has_var*/1and check if you really need to call it 13-15 million times!</p><p>  这会增加将PLT从大约1.2秒构建到15秒内的时间。最后，您可以在下面的内容中获取一些，这将指导您拖曳您需要优化的Towhat。也许看看ERL_TYPES：T_HAS_VAR * / 1和检查您是否真的需要拨打13-15万次！ </p><p> &gt; eprof:analyze(total).FUNCTION CALLS % TIME [uS / CALLS]-------- ----- ------- ---- [----------]erl_types:t_sup1/2 2744805 1.68 752795 [ 0.27]erl_types:t_subst/2 2803211 1.92 858180 [ 0.31]erl_types:t_limit_k/2 3783173 2.04 913217 [ 0.24]maps:find/2 4798032 2.14 957223 [ 0.20]erl_types:t_has_var/1 15943238 5.89 2634428 [ 0.17]erl_types:t_has_var_list/1 13736485 7.51 3360309 [ 0.24]------------------------ --------- ------- -------- [----------]Total: 174708211 100.00% 44719837 [ 0.26]</p><p>＆gt; EPROF：分析（总计）。功能呼叫％[US / Call] ------------------- - ] ERL_TYPES：T_SUP1 / 2 2744805 1.68 752795 [0.27] ERL_TYPES：T_SUBST / 2 2803211 1.92 858180 [0.31] ERL_TYPES：T_LIMIT_K / 2 3783173 2.04 913217 [0.24]地图：Find / 2 4798032 2.14 957223 [0.20] ERL_TYPES：T_HAS_VAR / 1 15943238 5.89 2634428 [0.17] ERL_TYPES：T_HAS_VAR_LIST / 1 13736485 7.51 3360309 [0.24] ----------------------------- -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -  --------“100.00％44719837 [0.26]</p><p> In Erlang/OTP 24 we can get the same result without having to pay the prettysteep cost of profiling with eprof. When running the same analysis as aboveusing  perf it takes roughly 1.3 seconds to run.</p><p> 在Erlang / OTP 24中，我们可以获得相同的结果，而无需支付eprof的分析成本。在运行与上述顺笔相同的分析时，运行大约1.3秒钟。</p><p>  Then we can use tools such as  perf report,  hotspot or  speedscope toanalyze the results.</p><p>  然后我们可以使用Perf报告，热点或SpeedScope等工具来分析结果。</p><p>   In the above, we can see that we get roughly the same result as when using eprof, though interestingly not exactly the same. I’ll leave the whys ofthis up to the reader to find out :)</p><p>   在上面，我们可以看到我们在使用EPROF时大致相同，但有趣的是不完全相同。我会让你的问题留给读者来找出:)</p><p> With this little overhead when profiling, we can run scenarios that previouslywould take too long to run when profiling. For those brave enough it might evenbe possible to run always-on profiling in production!</p><p> 在分析时，在剖析时，我们可以运行以前发生的场景，以便在分析时运行太长。对于那些勇敢的勇气，它可能甚至可以在生产中始终运行貌相！</p><p> The journey with what can be done with  perf has only started. In  PR-4676 wewill be adding frame pointer support which will give a much more accurate callframes when profiling and, in the end, the goal is to have mappings to Erlangsource code lines instead of only functions when using  perf report and hotspot to analyze a perf recording.</p><p> 与perf可以完成的旅程只开始了。在PR-4676中，我们将添加框架指针支持，该支持将在剖析时提供更准确的响尾符，并且最终目标是将映射到Erlangsource码线而不是仅在使用PER PER报告和热点以分析PERF时的功能记录。</p><p>    Erlang’s error messages tend to get a lot of (valid) critisism for being hard tounderstand. Two great new features have been added to help the user understandwhy something has failed.</p><p>    Erlang的错误消息倾向于获得很多（有效）的危及态度。已添加两个巨大的新功能，以帮助用户了解某些事情失败。 </p><p>    Thanks to the work of  Richard Carlsson and  Hans Bolinder, when you compileErlang code you now get the line and column of errors and warnings printed inthe shell together with a  ^-sign showing exactly where the erroractually was. For example, if you compile the below:</p><p>感谢Richard Carlsson和Hans Bolinder的工作，当您编译商朗代码时，您现在可以获得错误的错误和栏目，并用^--sign一起打印壳体的漏洞，显示误差是何处。例如，如果您编译如下：</p><p>     $ erlc test.erlt.erl:6:16: only association operators &#39;=&gt;&#39; are allowed in map construction% 6| #{ a =&gt; A, b := B }.% | ^</p><p>     $ erlc test.erlt.erl：6：16：只有关联运营商＆＃39; =＆＃39;允许在地图建设％6 | ＃{a =＆gt; A，B：= B}。％| ^</p><p> This behavior also extends into most of the Erlang code editors so thatwhen you use VSCode or Emacs through  Erlang LS or  flycheck you alsoget a narrower warning/error indicator, for example in Emacs using  Erlang LS.</p><p> 此行为也扩展到大多数Erlang代码编辑器中，以便使用vscode或Emacs通过Erlang LS或Flycheck您的Alsoget一个较窄的警告/错误指示符，例如使用Erlang LS的Emacs。</p><p>     One of the other big changes when it comes to error information is theintroduction of  EEP-54. In the past many of the  BIFs (built-in functions)would give very cryptic error messages:</p><p>     涉及错误信息时的其他大变化之一是EEP-54的介绍。在过去的许多BIF（内置函数）中会给出非常密码的错误消息：</p><p>  In the example above, the only thing we know is that one or more of thearguments are invalid, but without checking the documentationthere is no way of knowing which one and why. This is especially a problem forBIFs where the arguments may fail for different reasons depending on factors notvisible in the arguments. For example in the  ets:update_counter call below:</p><p>  在上面的示例中，我们唯一知道的是，一个或多个棘手是无效的，但没有检查文档无法知道哪一个和为什么。这尤其是Forbif的问题，其中参数可能因不同原因而失败，具体取决于参数中不可知的因素。例如，在ETS中：Update_counter呼叫以下：</p><p>  We don’t know if the call failed because the table did not exist at allor if the key  k that we wanted to update did not exist in the table.</p><p>  我们不知道该呼叫是否失败，因为如果在表中未存在的键k，则表格不存在，则表格不存在。</p><p>  1 &gt;  element ({ a , b , c },  1 ). **  exception  error :  bad  argument  in  function  element / 2  called  as  element ({ a , b , c }, 1 )  ***  argument  1 :  not  an  integer  ***  argument  2 :  not  a  tuple 2 &gt;  ets : new ( table ,[ named_table ]). table 3 &gt;  ets : update_counter ( table ,  k ,  1 ). **  exception  error :  bad  argument  in  function  ets : update_counter / 3  called  as  ets : update_counter ( table , k , 1 )  ***  argument  2 :  not  a  key  that  exists  in  the  table</p><p>  1＆gt;元素（{a，b，c}，1）。 **异常错误：函数元素/ 2中的错误参数称为元素（{a，b，c}，1）***参数1：不是整数***参数2：不是元组2＆gt; ETS：new（表，[named_table]）。表3＆gt; ETS：Update_counter（表，k，1）。 **异常错误：功能ETS中的糟糕参数：UPDATE_COUNTER / 3称为ETS：UPDATE_COUNTER（表，K，1）***参数2：不是表中存在的键 </p><p> That looks much better and now we can see what the problem was!The standard logging formatters also include the additional informationso that if this type of error happens in a production environment you willget the extra error information:</p><p>这看起来更好，现在我们可以看到问题是什么！标准记录格式化程序还包括其他信息，如果在生产环境中发生此类错误时，您将重新输入额外的错误信息：</p><p> 1&gt; proc_lib:spawn(fun() -&gt; ets:update_counter(table, k, 1) end).&lt;0.94.0&gt;=CRASH REPORT==== 10-May-2021::11:20:35.367023 === crasher: initial call: erl_eval:&#39;-expr/5-fun-3-&#39;/0 pid: &lt;0.94.0&gt; registered_name: [] exception error: bad argument in function ets:update_counter/3 called as ets:update_counter(table,k,1) *** argument 1: the table identifier does not refer to an existing ETS table ancestors: [&lt;0.92.0&gt;]</p><p> 1＆gt; proc_lib：spawn（fun（） - ＆gt; ETS：Update_counter（表，k，1）结束）。＆lt; 0.94.0＆gt; =崩溃报告==== 10-may-2021 :: 11：20：35.367023 == = Crasher：初始呼叫：erl_eval：＆＃39; -expr / 5-fun-3  - ＆＃39; / 0 pid：＆lt; 0.94.0＆gt;注册_Name：[]异常错误：功能ETS中的错误参数：UPDATE_COUNTER / 3称为ETS：UPDATE_COUNTER（表，K，1）***参数1：表标识符不引用现有的ETS表祖先：[＆lt; 0.92.0＆gt;]</p><p> EEP-54 is not only useful for error messages coming from BIFs but can be usedby any application that wants to provide extra information about their exceptions.For example, we have been working on providing better error information around io:format in  PR-4757.</p><p> EEP-54不仅适用于来自BIF的错误消息，而且可以使用任何想要提供有关其例外信息的应用程序。例如，我们一直在致力于在PR-4757中提供围绕IO：格式的更好的错误信息。</p><p>    Since Erlang/OTP R14 (released in 2010), the Erlang compiler and run-time systemhave co-operated to optimize for the pattern of code used by gen_server:call like functionality to avoid scanning a potentiallyhuge mailbox. The basic pattern looks like this:</p><p>    自Erlang / OTP R14（2010年发布）以来，Erlang编译器和运行时系统都是合作的，以优化Gen_Server使用的代码模式：调用类似功能以避免扫描潜在的邮箱。基本模式如下所示：</p><p> call ( To ,  Msg )  -&gt;  Ref  =  make_ref (),  To  !  { call ,  Ref ,  self (),  Msg },  receive  { reply ,  Ref ,  Reply }  -&gt;  Reply  end .</p><p> 呼叫（至msg） - ＆gt; ref = make_ref（），到！ {呼叫，ref，self（），msg}，接收{回复，参考，回复}  - ＆gt;回复结束。</p><p> The compiler can from this figure out that when  Ref is created, there can beno messages in the mailbox of the process that contains  Ref and therefore itcan skip all of those when receiving the  Reply.</p><p> 编译器可以从这个铭文中，当创建ref时，在包含参考的过程的邮箱中可以有班留言，因此在收到回复时，它会跳过所有这些。</p><p> This has always worked great in simple scenarios like this, but as soon as youhad to make the scenarios a little more complex it tended to break thecompiler’s analysis and you would end up scanning the entire mailbox. For example,in the code below Erlang/OTP 23 will not optimize the receive.</p><p> 这始终在这样的简单场景中始终繁荣，但只要you adad使场景更加复杂，它往往会打破复选者的分析，并且您将最终扫描整个邮箱。例如，在Erlang / OTP 23下面的代码中不会优化接收。 </p><p> call ( To ,  Msg ,  Async )  -&gt;  Ref  =  make_ref (),  To  !  { call ,  Ref ,  self (),  Msg },  if  Async  -&gt;  { ok ,  Ref };  not  Async  -&gt;  receive  { reply ,  Ref ,  Reply }  -&gt;  Reply  end  end .</p><p>呼叫（至，msg，异步） - ＆gt; ref = make_ref（），到！ {呼叫，ref，self（），msg}，如果异步 - ＆gt; {好的，ref};不是异步 - ＆gt;收到{回复，参考，回复}  - ＆gt;回复结束结束。</p><p> That all changes with Erlang/OTP 24! Many more complex scenarios are nowcovered by the optimization and a new compiler flag has been added to tell theuser if an optimization is done.</p><p> 所有改变都与Erlang / OTP 24变化！许多复杂的方案默认通过优化，并添加了一个新的编译器标志，以告诉众心数子如果完成优化。</p><p> $ erlc +recv_opt_info test.erltest.erl:6: Warning: OPTIMIZED: reference used to mark a message queue position% 6| Ref  = make_ref (),test.erl:12: Warning: OPTIMIZED: all clauses match reference created by make_ref/0 at test.erl:6% 12| receive</p><p> $ erlc + recv_opt_info test.erltest.erl：6：警告：优化：用于标记消息队列位置％6 |的参考ref = make_ref（），test.erl：12：警告：优化：所有子句匹配由make_ref / 0创建的参考.erl：6％12 |收到</p><p> Even patterns such as multi_call are now optimized to not scan the mailbox ofthe process.</p><p> 偶数模式（如Multi_Call）现在优化以不扫描进程的邮箱。</p><p> multi_call ( ToList ,  Msg )  -&gt;  %% OPTIMIZED: reference used to mark a message queue position  Ref  =  make_ref (),  %% INFO: passing reference created by make_ref/0 at test.erl:18  [ To  !  { call ,  Ref ,  self (),  Msg }  ||  To  &lt;-  ToList ],  %% INFO: passing reference created by make_ref/0 at test.erl:18  %% OPTIMIZED: all clauses match reference  %% in function parameter 2  [ receive  { reply ,  Ref ,  Reply }  -&gt;  Reply  end  ||  _  &lt;-  ToList ].</p><p> multi_call（polist，msg） - ＆gt; %%优化：用于标记消息队列位置的引用Ref = make_ref（），%% Info：通过test.erl：18 [to！ {呼叫，ref，self（），msg} ||到＆lt;  -  polist]，%%信息：通过test.erl：18 %%优化：18 %%的传递引用：所有子句匹配功能参数中的参数2 [接收{回复，参考，回复}  - ＆gt;回复结束|| _＆lt; polist]。</p><p> There are still a lot of places where this optimization does not trigger. Forinstance as soon as any of the make_ref/send/receive are in different modules itwill not work. However, the new improvements in Erlang/OTP 24 make the number ofscenarios a lot fewer and now we also have the tools to check and see if theoptimization is triggered!</p><p> 这种优化不会触发的很多地方。一旦任何Make_ref / SEND / RECECT在不同的模块中，才能往来一开始就不起作用。但是，Erlang / OTP 24的新改进使得Scenarios的数量较少，现在我们也有工具来检查，看看是否触发了优化！</p><p>     When doing a call to another Erlang process, the pattern used by gen_server:call,  gen_statem:call and others normally looks somethinglike this:</p><p>     在拨打另一个erlang进程时，Gen_Server使用的模式：呼叫，Gen_statem：呼叫和其他人通常看起来像这样的东西： </p><p> call ( To ,  Msg ,  Tmo )  -&gt;  MonRef  =  erlang : monitor ( process ,  To ),  To  !  { call ,  MonRef ,  self (),  Msg },  receive  { &#39;DOWN&#39; , MonRef ,_,_, Reason }  -&gt;  { error ,  Reason };  { reply ,  MonRef ,  Reply }  erlang : demonitor ( MonRef ,[ flush ]),  { ok ,  Reply }  after  Tmo  -&gt;  erlang : demonitor ( MonRef ,[ flush ]),  { error ,  timeout }  end .</p><p>呼叫（到，msg，TMO） - ＆gt; monref = erlang：监视（过程，to），到！ {call，monref，self（），msg}，接收{＆＃39;下降＆＃39; ，monref，_，_，原因}  - ＆gt; {错误，原因}; {reply，monref，回复} erlang：魔法员（蒙德夫，[刷新]），{好的，回复}在tmo  - ＆gt之后; Erlang：魔法员（Monref，[Flush]），{错误，超时}结束。</p><p> This normally works well except for when a timeout happens. When a timeouthappens the process on the other end has no way to know that the reply is nolonger needed and so will send it anyway when it is done with it. This causesall kinds of problems as the user of a third-party library would never know whatmessages to expect to be present in the mailbox.</p><p> 除了发生超时时，这通常很好。当Timeouthappens在另一端的过程中没有办法知道回复是所需的NOLONGER，因此在它完成时会发送它。这导致所有问题作为第三方库的用户永远不会知道什么需要在邮箱中存在。</p><p> There have been numerous attempts to solve this problem using the primitivesthat Erlang gives you, but in the end, most ended up just adding a  handle_infoin their  gen_servers that ignored any unknown messages.</p><p> 有许多尝试使用Primitivesthat Erlang来解决这个问题，但到底最终只是在他们的Gen_Servers中添加了忽略任何未知消息的Gen_Infoin。</p><p> In Erlang/OTP 24,  EEP-53 has introduced the  alias functionality to solve this problem.An  alias is a temporary reference to a process that can be usedto send messages to. In most respects, it works just as a PID except thatthe lifetime of an alias is not tied with the lifetime of the process itrepresents. So when you try to send a late reply to an alias that has beendeactivated the message will just be dropped.</p><p> 在ERLANG / OTP 24中，EEP-53引入了别名功能来解决这个问题。别名是对可以使用发送消息的过程的临时引用。在大多数方面，它就像一个PID一样，除了别名的寿命没有与进程意图的寿命相关联。因此，当您尝试发送延迟回复的别名时，才能丢弃邮件。</p><p> The code changes needed to make this happen are very small and are already usedbehind the scenes in all the standard behaviors of Erlang/OTP. The only thingneeded to be changed in the example code above is that a new option must begiven to  erlang:monitor and the reply reference should now be the aliasinstead of the calling PID. That is, like this:</p><p> 使这种情况发生的代码更改非常小，并且已经在Erlang / OTP的所有标准行为中使用了幕府。上面唯一要在示例代码中更改的内容是新选项必须为Erlang开始：监视器，回复引用现在应该是调用PID的aliasinstead。那就是这样的：</p><p> call ( To ,  Msg ,  Tmo )  -&gt;  MonAlias  =  erlang : monitor ( process ,  To ,  [{ alias ,  demonitor }]),  To  !  { call ,  MonAlias ,  MonAlias ,  Msg },  receive  { &#39;DOWN&#39; ,  MonAlias ,  _  ,  _,  Reason }  -&gt;  { error ,  Reason };  { reply ,  MonAlias ,  Reply }  erlang : demonitor ( MonAlias ,[ flush ]),  { ok ,  Reply }  after  Tmo  -&gt;  erlang : demonitor ( MonAlias ,[ flush ]),  { error ,  timeout }  end .</p><p> 呼叫（到，msg，TMO） - ＆gt; monalias = erlang：监视器（进程，to，[{alias，emontor}]），到！ {呼叫，monalias，monalias，msg}，接收{＆＃39;下降＆＃39; ，monalias，_，_，原因}  - ＆gt; {错误，原因}; {回复，蒙大亚大亚，回复} Erlang：魔法员（Monalias，[Flush]），{OK，回复} TMO  - ＆gt之后; Erlang：魔法员（Monalias，[Flush]），{错误，超时}结束。</p><p>     In Erlang/OTP 23  erl_docgen was extended to be able to emit  EEP-48 styledocumentation. This allowed the documentation to be used by  h(lists) inthe Erlang shell and external tools such as  Erlang LS. However, thereare very few applications outside Erlang/OTP that use  erl_docgen tocreate documentation, so  EEP-48 style documentation was unavailable tothose applications. Until now!</p><p>     在Erlang / OTP 23中，Erl_Docgen被扩展到能够发出EEP-48 StyleDocumentation。这允许H（列表）Inthe Erlang Shell和Erlang LS等外部工具使用的文档。然而，在Erl_Docgen oTP中使用ERL_DOCGEN TOCREATE文档的exereare很少的应用程序，因此EEP-48样式文件不可用。到现在！ </p><p> Radek Szymczyszyn has  added support for  EEP-48 into  edoc which meansthat from Erlang/OTP 24 you can view both the documentation of  lists:foldl/3and  recon:info/1.</p><p>Radek Szymczyszyn已增加对EEP-48的支持，该eDOC是从Erlang / OTP 24中的意思，您可以查看列表的文档：Foldl / 3和Recon：Info / 1。</p><p> $ rebar3 as docs shellErlang/OTP 24 [erts-12.0] [source] [jit]Eshell V11.2.1 (abort with ^G)1&gt; h(recon,info,1). -spec info(PidTerm) -&gt; [{info_type(), [{info_key(), Value}]}, ...] when PidTerm :: pid_term(). Allows to be similar to erlang:process_info/1, but excludes fields such as the mailbox, which tend to grow and be unsafe when called in production systems. Also includes a few more fields than what is usually given (monitors, monitored_by, etc.), and separates the fields in a more readable format based on the type of information contained.</p><p> $ rebar3作为文档shellerlang / otp 24 [ofts-12.0] [source] [giit] eshell v11.2.1（中止^ g）1＆gt; h（侦察，信息，1）。 -spec信息（pidterm） - ＆gt; [{info_type（），[{info_key（），value}]}，......]当pidterm :: pid_term（）时。允许类似于erlang：process_info / 1，但排除邮箱等字段，往往在生产系统中调用时趋于增长并保持不安全。还包括多于通常给出的字段（监视，监视器，监视器，监视器等），并根据包含的信息的类型将字段以更可读的格式分隔。</p><p> For more information about how to enable this in your project seethe  Doc chunks section in the Edoc User’s Guide.</p><p> 有关如何在EDOC用户指南中的项目Seethe Doc Chunks部分中启用它的详细信息。</p><p>    The  gen_tcp module has gotten support for optionally using the new  socketnif API instead of the previous inet driver. The new interface can be configuredto be used either on a system level through setting the applicationconfiguration parameter like this:  -kernel inet_backend socket, or on a perconnection bases like this:  gen_tcp:connect(localhost,8080,[{inet_backend,socket}]).</p><p>    Gen_TCP模块已支持，可选地使用新的SocketNIF API而不是先前的INET驱动程序。新接口可以通过设置如下所示的应用程序配置参数来配置新的接口：-kernel Inet_Backend套接字，或者在这样的匹配基础上：Gen_TCP：Connect（LocalHost，8080，[{Inet_Backend，Socket}]） 。</p><p> If you do this you will notice that the  Socket returned by  gen_tcp no longeris a port but instead of a tuple containing (among other things) a PID and areference.</p><p> 如果您这样做，您会注意到Gen_TCP返回的套接字不再是一个端口，而不是包含一个PID和BERFERED的元组</p><p>  This data structure is and always has been  opaque, and therefore should not be inspecteddirectly but instead only used as an argument to other  gen_tcp and  inetfunctions.</p><p>  此数据结构始终是不透明的，因此不应被检查，而是仅用作其他Gen_TCP和Inetfunction的参数。</p><p> You can then use  inet:i/0 to get a listing of all open sockets in the system:</p><p> 然后，您可以使用INET：I / 0获取系统中所有打开套接字的列表： </p><p> 2 &gt;  inet : i (). Port  Module  Recv  Sent  Owner  Local  Address  Foreign  Address  State  Type  esock [ 19 ]  gen_tcp_socket  0  0  &lt; 0 . 98 . 0 &gt;  localhost : 44082  localhost : http - alt  CD : SD  STREAM</p><p>2＆gt; INET：I（）。端口模块RECV发送所有者本地地址外地地址状态类型ESOCK [19] GEN_TCP_SOCKET 0 0 < 0。 98。 0＆gt; localhost：44082 localhost：http  -  alt cd：sd流</p><p> The  gen_tcp API should be completely backward compatible with the oldimplementation, so if you can, please test it and report any bugs that you findback to us.</p><p> Gen_TCP API应完全向后兼容Goldimplementation，因此如果您可以，请测试并报告您对我们来说的任何错误。</p><p> Why should you want to test this? Because in some of our benchmarks, we get upto 4 times the throughput vs the old implementation. In others,there is no difference or even a loss of throughput. So, as always, you need tomeasure and check for yourself!</p><p> 你为什么要测试这个？因为在我们的一些基准中，我们得到了吞吐量的4倍，而旧的实现。在别人中，没有差异甚至吞吐量损失。所以，一如既往，你需要积水并检查自己！</p><p>    When creating supervisor hierarchies for applications that manage connectionssuch as  ssl or  ssh, there are times when there is a need for terminatingthat supervisor hierarchy from within. Some event happens on the socket thatshould trigger a graceful shutdown of the processes associated with theconnection.</p><p>    在创建管理ConnectionSUCH作为SSL或SSH的应用程序的管理程序的层次结构时，有时需要从内部终止主管层次结构。一些事件发生在套接字上，即触发与连接相关联的进程的正常关闭。</p><p>  It requires the child to know the ID of the child that needs to be terminatedand the PID of the supervisor to talk to. This is simple when there is justone process in the supervisor, but when there are supervisors undersupervisors, this becomes harder and harder to figure out.</p><p>  它要求孩子知道需要终止的孩子的ID和主管的PID交谈。当监督员刚刚获得过程时，这很简单，但当有过主管的弱者时，这变得越来越难以弄清楚。</p><p>  Calling  supervisor:terminate_child/2 is a synchronous operation. This meansthat if you do the call in the child, you may end up in a deadlock as the topsupervisor wants to terminate the child while the child is blocking in the callto terminate itself.</p><p>  调用主管：terminate_child / 2是同步操作。这意味着如果您在孩子中进行呼叫，您可能会在僵局中最终成为一个僵局，因为TopsuperVisor希望在孩子在Callto终止上终止孩子时终止孩子。</p><p> To solve this problem  EEP-56 has added a mechanism in which a child can bemarked as significant and if such a child terminates, it can trigger an automaticshutdown of the supervisor that it is part of.</p><p> 为了解决这个问题，EEP-56已经增加了一种机制，其中一个孩子可以像这样一个人那样偏重，如果这样的孩子终止，它可以触发它的主管是一部分的主导者。 </p><p> This way a child process can trigger the shutdown of a supervisor hierarchy fromwithin, without the child having to know anything about the supervisor hierarchynor risking dead-locking itself during termination.</p><p>这样一个子程进程可以触发来自inwithin的监督层次结构的关闭，如果在终止期间，没有孩子必须了解风险锁定自身的主控层。</p><p>     With Erlang/OTP 24 comes support for  Edwards-curve Digital Signature Algorithm( EdDSA).  EdDSA can be used when connecting to or acting as a TLS 1.3client/server.</p><p>     使用Erlang / OTP 24来支持Edwards-Curve数字签名算法（EDDSA）。连接或充当TLS 1.3Client / Server时，可以使用EDDSA。</p><p> EdDSA is a type of  elliptic curve signature algorithm ( ECDSA)that can be used for secure communication. The security of  ECDSA relies on a strong cryptographically secure random number which can cause issues whenthe random number is by mistake not secure enough, as has been the case in severaluses of ECDSA (none of them in Erlang as far as we know :).</p><p> EDDSA是一种椭圆曲线签名算法（ECDSA），可用于安全通信。 ECDSA的安全性依赖于强大的加密安全随机数，这可能导致随机数量的问题是错误的，因为在ecdsa的几乎没有足够的情况下，如此，据我们所知，所以据我们所知</p><p> EdDSA does not rely on a strong random number to be secure. This means thatwhen you are using  EdDSA, the communication is secure even if your randomnumber generator is not.</p><p> eddsa并不依赖于强大的随机数来获得安全。这意味着您使用EDDSA时，即使您的OrceNumber发生器不是，通信也是安全的。</p><p> Despite the added security,  EdDSA is claimed to be faster than other elipticcurve signature algorithms. If you have  OpenSSL 1.1.1 or later, then as ofErlang/OTP 24 you will have access to this algorithm!</p><p> 尽管安全性增加，但德德萨被声称比其他ElepicCurve签名算法更快。如果您已openssl 1.1.1或更高版本，那么随着Overlang / OTP 24，您将访问此算法！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://blog.erlang.org/My-OTP-24-Highlights/">http://blog.erlang.org/My-OTP-24-Highlights/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/erlang/">#erlang</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>