<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>对旧版x86指令进行基准测试 Benchmarking Legacy x86 Instructions</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Benchmarking Legacy x86 Instructions<br/>对旧版x86指令进行基准测试 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-28 21:56:59</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/aa0c74306f39f2bbe62b634e55530b26.jpg"><img src="http://img2.diglog.com/img/2021/1/aa0c74306f39f2bbe62b634e55530b26.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Laugh, scroll past, then I started wondering, “what are the chances this obscure opcode is faster than optimized loads?” and I realized I had just been  nerd sniped. So I decided to dig up my half-remembered memories of how to benchmark opcodes and get to the bottom of this meme.</p><p>笑，滚动过去，然后我开始怀疑：“这种晦涩的操作码比优化的加载更快的机会是什么？”我意识到我只是被书呆子狙击了。因此，我决定总结一下关于如何对操作码进行基准测试的记忆，并深入研究此模因。</p><p> For those of us who do not recall every opcode that Intel dreamed up, the  Intel reference manual is a useful reference and says the following:</p><p> 对于那些不记得英特尔梦dream以求的每个操作码的人，英特尔参考手册是一个有用的参考，并指出以下内容：</p><p> XLAT/XLATB -  Locates a byte entry in a table in memory, using the contents of the AL register as a table index, then copies the contents of the table entry back into the AL register. The index in the AL register is treated as an unsigned integer. The XLAT and XLATB instructions get the base address of the table in memory from either the DS:EBX or the DS:BX registers</p><p> XLAT / XLATB-使用AL寄存器的内容作为表索引在内存中的表中找到字节条目，然后将表条目的内容复制回AL寄存器。 AL寄存器中的索引被视为无符号整数。 XLAT和XLATB指令从DS：EBX或DS：BX寄存器获取内存中表的基地址</p><p>     My guess was  the equivalent load opcode version would outperform xlatb. How I tested this simple question is worth writing up, if only to have a reference for micro benchmarking from end to end.</p><p>     我的猜测是等效的负载操作码版本将胜过xlatb。如果只是作为端到端微观基准测试的参考，那么我如何测试这个简单的问题就值得写。</p><p>  Feel free to skip this if you’re familiar with benchmarking, CISC vs RISC and why I guessed what I guessed</p><p>  如果您熟悉基准测试，CISC与RISC，以及为什么我猜到我猜到的原因，请随时跳过</p><p>  What I did to test my guess is called micro benchmarking. The difference from regular benchmarking is in the focus and minimization of context. It helps in answering very small questions such as “What is the fastest way to sort an array of numbers in C”, and ignoring memory pressure, design and other considerations that are important in the real world of benchmarking.</p><p>  我为检验自己的猜测所做的工作称为微基准测试。与常规基准测试的区别在于上下文的重点和最小化。它有助于回答非常小的问题，例如“用C对数字数组进行排序的最快方法是什么”，并且可以忽略内存压力，设计以及在基准测试现实世界中重要的其他考虑因素。</p><p> The challenge in micro benchmarking is that there is a lot of noise in the process. Compilers, operating systems, CPU temperature and frequency changes can all serve to create large shifts in the performance of the benched code snippet.</p><p> 微型基准测试的挑战在于过程中存在很多噪音。编译器，操作系统，CPU温度和频率变化都可以使基准代码段的性能发生较大变化。 </p><p>  Minimize hardware considerations. This means removing frequency scaling, branching, any chance of the data being evicted from the cache.</p><p>尽量减少硬件考虑。这意味着消除频率缩放，分支，从缓存中清除数据的任何可能性。</p><p>  No interaction with the system. This means no system calls, but also no memory allocations and hopefully remove the role the runtime plays (for example if we’re benchmarking .NET code)</p><p>  与系统无交互。这意味着没有系统调用，也没有内存分配，并且有望删除运行时所扮演的角色（例如，如果我们对.NET代码进行基准测试）</p><p> These typically lead micro benchmarks to being written in assembly code and measuring runtime using the  rdtsc opcode.</p><p> 这些通常会导致微型基准测试以汇编代码编写并使用rdtsc操作码来测量运行时。</p><p> To understand this at a basic level, I really recommend the book  Inside the Machine (Jon Stokes), another option is  Modern Microprocessors in 90 minutes but for more than that, the relatively up to date reference is  Real World Technologies articles on CPU architecture.</p><p> 为了从基本的角度理解这一点，我确实推荐了一本书《机器内部》（乔恩·斯托克斯），另一种选择是在90分钟内使用现代微处理器，但除此之外，相对最新的参考是有关CPU体系结构的Real World Technologies文章。</p><p> The reference for nearly everything relating to opcode latency for Intel and AMD CPUs is  Agners guides and  uops.info.</p><p> Agners指南和uops.info几乎是与Intel和AMD CPU的操作码延迟有关的所有内容的参考。</p><p> If you want to measure these latencies and what exactly a CPU is doing when executing an opcode, you need to read the Performance Measurement Counters embedded in the hardware. This gives us precisely numbers for (example) how many L1 cache hits and misses happened in a code block, how many branch mispredictions happened and so forth.</p><p> 如果要测量这些延迟以及执行操作码时CPU到底在做什么，则需要读取硬件中嵌入的性能测量计数器。这为我们提供了准确的数字，例如（例如）代码块中发生了多少次L1缓存命中和未命中，发生了多少分支错误预测等。</p><p>   The basic idea behind the XLAT instruction is the idea behind Complex Instruction Set Computers (CISC), that states hardware should implement common instruction sequences with dedicated instructions that perform the same task but faster. This is the idea behind many of the weird x86 instructions (or other CPUs).</p><p>   XLAT指令背后的基本思想是复杂指令集计算机（CISC）背后的思想，该思想指出，硬件应该使用共同的指令来实现通用指令序列，这些指令执行相同的任务但速度更快。这是许多奇怪的x86指令（或其他CPU）背后的想法。 </p><p> However, since that time, all modern CPUs have turned RISC-like, by internally using a reduced instruction set and translating the ISA opcodes into internal commands, some implemented using CPU microcode. This also allows for different optimizations such as micro opcode fusion. Another note, CPU designers spend a lot of time optimizing the commonly use instructions, which makes them very fast (for example xor rax,rax is free) This leaves very little room for opcodes like xlatb to shine.</p><p>但是，从那时起，所有现代CPU都通过内部使用精简指令集并将ISA操作码转换为内部命令（其中一些使用CPU微代码实现）而变得类似于RISC。这也允许进行不同的优化，例如微操作码融合。另一个要注意的是，CPU设计人员花费大量时间来优化常用指令，这使它们变得非常快（例如xor rax，rax是免费的），这几乎没有空间让xlatb等操作代码发光。</p><p> While we’re dunking on CISC, I came across the following great snippet on the difference between the good parts of CISC and the bad parts.</p><p> 当我们灌输CISC时，我遇到了以下有关CISC好的部分和坏的部分的区别的摘要。</p><p> We should distinguish the “Complex” instructions of CISC CPUs - complicated, rarely used, and universally low performance, from the “Featureful” instructions common to both CISC and RISC CPUs, which combine a small sequence of operations, are commonly used, and high performance. -  erincandescent</p><p> 我们应该将CISC CPU的“复杂”指令（复杂，很少使用且普遍性能低下）与CISC和RISC CPU通用的“功能”指令区分开来，因为这些指令结合了少量的操作序列，并且使用率很高。性能。 -白炽灯</p><p>  What I ended up doing was running the different code snippets in the Andreas Abel’s micro benchmarking harness, available on  GitHub. The machine used for execution was a VM running on a Broadwell i7-5500U, Debian 9.9, kernel version 4.9 with the host CPU frequency governor set to disabled (max clock speed all the time).</p><p>  我最终要做的是在GitHub上的Andreas Abel的微型基准测试工具中运行不同的代码段。用于执行的机器是一台运行在Broadwell i7-5500U，Debian 9.9，内核版本4.9上的VM，其主机CPU频率调节器设置为禁用（始终保持最大时钟速度）。</p><p>   In order to remove as much variance as possible, it’s best to make sure all accesses are kept inside the L1 cache (code and data). For this reason, the following initializations are required</p><p>   为了尽可能消除差异，最好确保所有访问都保留在L1缓存（代码和数据）中。因此，需要以下初始化</p><p> Aim RBX at RSP, making sure the array accessed is inside the L1 data cache</p><p> 将RBX对准RSP，确保所访问的阵列位于L1数据缓存内</p><p> In addition, this opcode sequence is small enough to be in the same L1 code cache line so no effort was required there (manually verified).</p><p> 此外，该操作码序列足够小，可以位于同一L1代码高速缓存行中，因此在那里无需任何操作（手动验证）。 </p><p> For this experiment, what matters is the number of cycles required to execute (which is a close approximation of time) and the cycles elapsed (wall time). In addition, I’ll also measure how many loads happened while executing this snippet, by tracking the  MEM_LOAD_UOPS_RETIRED.L1_HIT PMC.</p><p>对于此实验，重要的是执行所需的周期数（这是时间的近似值）和经过的周期（墙时间）。此外，我还将通过跟踪MEM_LOAD_UOPS_RETIRED.L1_HIT PMC来衡量执行此代码段时发生了多少负载。</p><p>       Second, as is generally known, memory loads are the most expensive part of any algorithm, but once the data is in L1, the difference in number of loads doesn’t seem to matter. The xlatb sequence has only one data load yet is slower than the optimized x64 version.</p><p>       其次，众所周知，内存负载是所有算法中最昂贵的部分，但是一旦数据存储在L1中，负载数量的差异似乎并不重要。 xlatb序列只有一个数据加载，但是比优化的x64版本慢。</p><p> Second, the core cycle count for the xlatb instruction precisely matches the  Agner table (page 229). Good to know our measurements line up with others :)</p><p> 其次，xlatb指令的核心周期计数与Agner表精确匹配（第229页）。很高兴知道我们的测量与其他产品一致:)</p><p> Last, note that reducing the amount of instructions used does not decrease time required linearly. Why? The number of instructions is not linearly correlated to the actions performed by the processor. A classic example is xor rcx,rcx. This opcode never actually executes. Instead, the CPU just updates a pointer in the register renaming file.</p><p> 最后，请注意减少指令的使用量并不能线性减少所需的时间。为什么？指令的数量与处理器执行的动作没有线性关系。一个典型的例子是xor rcx，rcx。此操作码从不实际执行。相反，CPU只是更新寄存器重命名文件中的指针。</p><p> To examine these type of questions, another tool is required - the Intel Architecture Code Analyzer ( IACA - unfortunately now deprecated). This tool will look at the machine code and tell you how different Intel CPUs will execute them. Let’s look at one case in particular to see why removing instructions doesn’t always linearly save time. Attached are only the relevant parts of the output, which are the micro-op count.</p><p> 要检查这些类型的问题，需要使用另一种工具-英特尔架构代码分析器（IACA-现在已弃用）。该工具将查看机器代码，并告诉您如何在不同的Intel CPU中执行它们。让我们具体研究一种情况，以了解为什么删除说明并不能总是线性地节省时间。仅附带输出的相关部分，即微操作数。</p><p>    The important bit is noting that in snippet 0, the opcodes xor rcx,rcx; mov cl,al takes up one execution unit (xor rcx rcx is not bound to an execution port).</p><p>    重要的一点是，在代码段0中，操作码xor rcx，rcx; mov cl，al占用一个执行单元（xor rcx rcx未绑定到执行端口）。</p><p> In snippet 1, the opcode movzx rcx,al doesn’t take up an execution port at all.</p><p> 在代码段1中，操作码movzx rcx，al根本不占用执行端口。 </p><p> You can also play around with llvm-mca which does something similar, and see the same results, by using Compiler Explorer ( snippet link).</p><p>您也可以使用编译器资源管理器（代码段链接）来玩llvm-mca，它会执行类似的操作，并看到相同的结果。</p><p>  All my machines are Windows machines, where accessing the PMCs is not as fun or easy as it is on Linux. The proper reaction should be “so run it inside a VM”, but apparently Hyper-V doesn’t expose PMCs to guests by default and I couldn’t find a way to do it easily.</p><p>  我所有的机器都是Windows机器，访问PMC并不像在Linux上那样有趣或容易。正确的反应应该是“在虚拟机中运行”，但是显然，Hyper-V默认情况下不会将PMC暴露给来宾，而且我找不到轻松实现此目的的方法。</p><p> I ran into every possible frustration while searching for a cheap bare metal cloud machine, including Oracle gating the bare metal instances behind a request form that requires a human being to look at.</p><p> 在寻找便宜的裸机云设备时，我遇到了各种可能的挫败感，包括Oracle在要求人看的请求表后面设置裸机实例。</p><p> In the end, VMWare Workstation exposes PMCs to guests so a friend with power to spare gave me a VM to test.</p><p> 最后，VMWare工作站将PMC暴露给来宾，因此有能力的朋友给了我一台VM进行测试。</p><p>  The meme is wrong, no surprise. An optimized sequence of x64 instructions beats out a single complex instruction. This isn’t always true (POPCNT as a counter example) but some instructions are legacy for a reason. If LLVM doesn’t output the opcode, it’s probably for the best.</p><p>  该模因是错误的，不足为奇。优化的x64指令序列击败了一条复杂的指令。这并不总是正确的（以POPCNT为例），但是出于某些原因，有些说明是遗留的。如果LLVM不输出操作码，则可能是最好的选择。</p><p> Also this was an opportunity to rediscover micro benchmarking. It’s quite likely I made some measurement mistakes, so if you found any, feel free to contact me.</p><p> 这也是重新发现微基准测试的机会。我很可能在测量方面犯了一些错误，因此，如果发现任何错误，请随时与我联系。</p><p>   @damageboy for generally knowing everything and in this case, for writing a series of blog posts on micro benchmarking .NET instructions available  here that pushed me to do this sort of stuff</p><p>   @damageboy通常了解所有情况，在这种情况下，是因为撰写了有关微基准测试.NET的一系列博客文章（这里提供了相关说明），促使我去做这种事情 </p><p> And again to Andreas Abel for saving me a lot of time with his micro benchmarking harness available on  GitHub</p><p>再次感谢Andreas Abel使用GitHub上的微基准测试工具为我节省了很多时间 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.acepace.net/2019-07-27-xlatb/">https://www.acepace.net/2019-07-27-xlatb/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/x86/">#x86</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/legacy/">#legacy</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/操作码/">#操作码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>