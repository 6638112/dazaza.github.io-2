<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>GCC铁锈月报，2022年2月GCC Rust Monthly Report, February 2022</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">GCC Rust Monthly Report, February 2022<br/>GCC铁锈月报，2022年2月</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-26 08:55:37</div><div class="page_narrow text-break page_content"><p>Thanks again to  Open Source Security, inc and  Embecosm for their ongoing support for this project.</p><p>再次感谢开源安全公司和Embecosm对该项目的持续支持。</p><p>  February was a big month for GCC Rust; our previous Google Summer of Code student Arthur Cohen joins us in Embecosm, Germany, working on the compiler full time. With the additional resource, we can split up work and delegate tasks allowing multiple streams of complex work to take place, which frees Philip up to work on Slice’s and bugs in the type system.</p><p>2月对GCC来说是一个重要的月份；我们之前的谷歌代码暑期学生阿瑟·科恩（Arthur Cohen）在德国的Embecosm加入我们，全职从事编译器的工作。有了额外的资源，我们可以拆分工作并委派任务，从而允许进行多个复杂的工作流，这将使Philip能够处理类型系统中的切片和bug。</p><p> Concerning our macro expansion milestone, we have the building blocks in place and support most declarative macros though there are some quirks and bugs to work through still. The remaining time of this milestone will be spent on setting up the builtin macros and fixing bugs.</p><p>关于我们的宏扩展里程碑，我们已经准备好了构建块，并且支持大多数声明性宏，尽管仍然有一些怪癖和错误需要解决。这个里程碑的剩余时间将用于设置内置宏和修复bug。</p><p> Other than macros, there has been a focus on code cleanup and bug fixing in February, which has been fruitful.</p><p>除了宏之外，2月份的工作重点是代码清理和bug修复，这是富有成效的。</p><p>  It’s time for our next community call, feel free to join in! 🙂</p><p>是我们下一个社区电话的时候了，欢迎加入！🙂</p><p>   Add Support for index and Range lang items and boiler plate for Slice typechecking  PR974</p><p>添加对索引和范围项目的支持，以及用于切片类型检查PR974的锅炉板</p><p>                 We have improved our canonical-path tracking so that we can build up paths for the legacy mangling scheme. So for example impl blocks nested under modules are given a prefix of impl in their path.</p><p>我们已经改进了我们的规范路径跟踪，以便我们可以为遗留的损坏方案建立路径。例如，嵌套在模块下的impl块在其路径中被赋予一个impl前缀。</p><p> struct Foo(i32);mod A { impl Foo { fn test(&amp;self) -&gt; i32 { self.0 } }}fn test() { let a = Foo(123); let b:i32 = a.test();}</p><p>struct Foo（i32）；mod A{impl Foo{fn test（&amp；self）->i32{self.0}}}fn test（）{let A=Foo（123）；let b:i32=A.test（）；}</p><p> As you can see we have the crate-name of example -&gt; structure A -&gt; impl block for example::A -&gt; function name test.</p><p>如您所见，我们有示例的板条箱名称-&gt；结构A-&gt；impl块例如：：A-&gt；函数名测试。</p><p> i32 example::A::&lt;impl example::Foo&gt;::test (const struct example::Foo &amp; const self){ i32 D.85; D.85 = self-&gt;0; return D.85;}void example::test (){ const struct example::Foo a; const i32 b; try { a.0 = 123; b = example::A::&lt;impl example::Foo&gt;::test (&amp;a); } finally { a = {CLOBBER}; }}</p><p>i32示例：：A:：&lt；impl示例：：Foo&gt；：：test（const struct example:：Foo&amp；const self）{i32 D.85；D.85=self-&gt；0；返回D.85；}void example:：test（）{const struct example:：Foo a；const i32 b；try{a.0=123；b=example:：a:&lt；impl example:：Foo&gt；：：test（&amp；a）；}最后{a={CLOBBER}；}</p><p>   We added support for any, all and not predicates on cfg expansions so in this example this ensures that both A and B are specified for the all predicate.</p><p>我们在cfg扩展中添加了对any、all和not谓词的支持，因此在本例中，这确保了为all谓词指定A和B。</p><p> struct Foo;impl Foo { #[cfg(all(A, B))] fn test(&amp;self) {}}fn main() { let a = Foo; a.test();}</p><p>struct Foo；impl Foo{#[cfg（all（A，B））]fn test（&amp；self）{}fn main（）{let A=Foo；A.test（）}</p><p>   Rust allows us to specify key-value pairs for config expansion this is mostly associated with host/os/cpu options such as os = “linux” for example but here is an example below you can try in compiler explorer.</p><p>Rust允许我们为配置扩展指定键值对，这主要与主机/os/cpu选项有关，例如os=“linux”，但下面是一个示例，您可以在编译器资源管理器中尝试。</p><p> struct Foo;impl Foo { #[cfg(A = &#34;B&#34;)] fn test(&amp;self) {}}fn main() { let a = Foo; a.test();}</p><p>struct Foo；impl Foo{#[cfg（A=&#34；B&#34；）]fn test（&amp；self）{}fn main（）{let a=Foo；a.test（）；}</p><p>     Inline without any option is analogous to C style inline keyword giving a hint to the compiler that this function is a good candidate for inlining. Inline always can be acheived with GCC’s inline always attribute:  https://gcc.gnu.org/onlinedocs/gcc/Inline.html. Finally never we can mark functions as DECL_UNINLINEABLE. The one difference is that inline optimizations require optimizations to be enabled. So when compiling at -O0 no inlining will occur, any level greater than this, the inline pass will be enforced.</p><p>不带任何选项的Inline类似于C风格的Inline关键字，它向编译器提示此函数是内联的良好候选函数。Inline always可以通过GCC的Inline always属性实现：https://gcc.gnu.org/onlinedocs/gcc/Inline.html.最后，我们永远不能将函数标记为DECL_不可线性。一个区别是，内联优化需要启用优化。因此，当在-O0编译时，不会发生内联，任何级别大于此级别，都将强制执行内联传递。</p><p>       Work on method resolution has continued steadily and we now support the deref_mut lang item so that for methods that require a &amp;mut self reference we try to lookup any relevant deref_mut lang item to get the indirection required from the receiver.</p><p>方法解析方面的工作一直在稳步进行，我们现在支持deref_mut lang项目，因此对于需要a&amp；我们尝试从任何相关的接收者处获取所需的间接引用。</p><p> extern &#34;C&#34; { fn printf(s: *const i8, ...);} #[lang = &#34;deref&#34;]pub trait Deref { type Target; fn deref(&amp;self) -&gt; &amp;Self::Target;}#[lang = &#34;deref_mut&#34;]pub trait DerefMut: Deref { fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;}impl&lt;T&gt; Deref for &amp;T { type Target = T; fn deref(&amp;self) -&gt; &amp;T { *self }}impl&lt;T&gt; Deref for &amp;mut T { type Target = T; fn deref(&amp;self) -&gt; &amp;T { *self }}pub struct Bar(i32); impl Bar { pub fn foobar(&amp;mut self) -&gt; i32 { self.0 }}pub struct Foo&lt;T&gt;(T);impl&lt;T&gt; Deref for Foo&lt;T&gt; { type Target = T; fn deref(&amp;self) -&gt; &amp;Self::Target { &amp;self.0 }}impl&lt;T&gt; DerefMut for Foo&lt;T&gt; { fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target { unsafe { let a = &#34;mut_deref\n\0&#34;; let b = a as *const str; let c = b as *const i8; printf(c); } &amp;mut self.0 }}pub fn main() -&gt; i32 { let bar = Bar(123); let mut foo: Foo&lt;Bar&gt; = Foo(bar); let foobar = foo.foobar(); foobar - 123}</p><p>外部人员&#34；C&#34；{fn printf（s:*const i8，…）；}#[lang=&#34；deref&#34；]pub trait Deref{type Target；fn Deref（&amp；self）->self:：Target；}#[lang=&#34；deref#mut&#34；]pub trait DerefMut:Deref{fn Deref_mut（&amp；mut self）&gt；&amp；mut self:：Target；}impl&lt；T&gt；德雷夫；T{type Target=T；fn-deref（&amp；self）&gt；&amp；T{*self}impl&lt；T&gt；德雷夫；mut T{type Target=T；fn deref（&amp；self）&gt；&amp；T{*self}发布结构条（i32）；impl Bar{pub fn foobar（&amp；mut self）->i32{self.0}pub struct Foo&lt；T&gt；（T） )；impl&lt；T&gt；为Foo&lt；T&gt；{type Target=T；fn deref（&amp；self）&gt；&amp；self:：Target{&amp；self.0}}impl&lt；T&gt；对Foo&lt；T&gt；{fn deref_mut（&amp；mut self）&gt；&amp；mut self：：Target{safe{let a=&amp#34；mut_deref\n\0&#34；；let b=a as*const str；let c=b as*const i8；printf（c）；}&amp；莫特·赛尔夫。0}pub fn main（）-&gt；i32{let bar=bar（123）；let mut foo:foo&lt；bar&gt；=foo（bar）；let foobar=foo.foobar（）；foobar-123}</p><p>   We have merged our first pass of the macro expansion pass. The approach taken here is that we reuse our existing parser to call the apropriate functions as specified as part of the MacroFragmentType enum if the parser does not have errors parsing that item then it must be a match. Then once we match a rule we have a map of the token begin/end offsets for each fragment match, this is then used to adjust and create a new token stream for the macro rule definition so that when we feed it to the parser the tokens are already substituted. The resulting expression or item is then attached to the respective macro invocation and this is then name resolved and used for hir lowering.</p><p>我们已经合并了我们的第一个宏观扩张通道。这里采用的方法是，我们重用现有的解析器来调用作为MacroFragmentType枚举的一部分指定的适当函数。如果解析器在解析该项时没有错误，那么它必须是匹配的。然后，一旦我们匹配了一个规则，我们就有了每个片段匹配的令牌开始/结束偏移的映射，然后用它来调整和创建宏规则定义的新令牌流，这样当我们将其提供给解析器时，令牌就已经被替换了。生成的表达式或项随后附加到相应的宏调用，然后解析名称并用于hir降低。</p><p> In this example the macro has two rules so we demonstrate that we match the apropriate rule and transcribe it respectively.</p><p>在这个例子中，宏有两个规则，所以我们证明我们匹配了适当的规则，并分别转录了它。</p><p> macro_rules! add { ($a:expr,$b:expr) =&gt; { $a + $b }; ($a:expr) =&gt; { $a };}fn main() -&gt; i32 { let mut x = add!(1); x += add!(2, 3); x - 6}</p><p>宏规则！添加{（$a:expr，$b:expr）=&gt；{$a+$b}；（$a:expr）=&gt；{$a}；}fn main（）-&gt；i32{let mut x=add！（1）；x+=add！（2,3）；x-6}</p><p>  macro_rules! Test { ($a:ident, $b:ty) =&gt; { struct $a($b); };}Test!(Foo, i32);fn main() -&gt; i32 { let a = Foo(123); a.0 - 123}</p><p>宏规则！测试{（$a:ident，$b:ty）=&gt；{struct$a（$b）；}；}测验（富，i32）；fn main（）-&gt；i32{let a=Foo（123）；a.0-123}</p><p> Here we take into account the context of the macro invocation and parse it into AST::Items. In the even of failure to match a rule the compiler error looks like the following:</p><p>这里我们考虑宏调用的上下文，并将其解析为AST:：Items。如果未能匹配规则，编译器错误如下所示：</p><p> &lt;source&gt;:11:17: error: Failed to match any rule within macro 1 | macro_rules! add { | ~ ...... 11 | let mut x = add!(1, 2, 3); | ^</p><p>&lt；来源&gt；：11:17：错误：未能匹配宏1 |宏|规则中的任何规则！加{| ~..11 |让mut x=add！（1,2,3）|^</p><p> More error handling has been added for when the transcribed rule actually is not fully used so for example:</p><p>当转录规则实际上没有完全使用时，添加了更多错误处理，例如：</p><p>    In rust ranges are turned into structs so what seems like piece of syntax to specify some kind of constraint is actually something which can be assigned and manipulated. This is one of the building blocks in our journey to support slices.</p><p>在rust中，范围被转换为结构，因此，指定某种约束的语法片段实际上是可以赋值和操作的。这是我们支持切片过程中的一个组成部分。</p><p> #[lang = &#34;RangeFull&#34;]pub struct RangeFull;#[lang = &#34;Range&#34;]pub struct Range&lt;Idx&gt; { pub start: Idx, pub end: Idx,}#[lang = &#34;RangeFrom&#34;]pub struct RangeFrom&lt;Idx&gt; { pub start: Idx,}#[lang = &#34;RangeTo&#34;]pub struct RangeTo&lt;Idx&gt; { pub end: Idx,}#[lang = &#34;RangeInclusive&#34;]pub struct RangeInclusive&lt;Idx&gt; { pub start: Idx, pub end: Idx,}fn test() { let a = 1..2; // range let b = 1..; // range from let c = ..3; // range to let d = 0..=2; // range inclusive}</p><p>#[lang=&#34；RangeFull&#34；]pub struct RangeFull#[lang=&#34；范围&#34；]pub struct Range&lt；Idx&gt；{pub start:Idx，pub end:Idx，}#[lang=&#34；RangeFrom&#34；]pub struct RangeFrom&lt；Idx&gt；{pub start:Idx，}#[lang=&#34；RangeTo&#34；]酒吧结构RangeTo&lt；Idx&gt；{pub end:Idx，}#[lang=&#34；range inclusive&#34；]pub struct range inclusive&lt；Idx&gt；{pub start:Idx，pub end:Idx，}fn test（）{let a=1..2；//range let b=1..；//range from let c=..3；//range to let d=0..=2；//range inclusive}</p><p>   Another building block to support slices is the ability to suport the index lang item core::ops::index so that a range can be an argument and the code in core::slice::index can actually become the starting point in giving us a slice from an array.</p><p>支持切片的另一个构建块是支持索引lang item core:：ops:：index的能力，这样一个范围就可以作为参数，core:：slice:：index中的代码实际上可以成为从数组中获取切片的起点。</p><p> #[lang = &#34;index&#34;]trait Index&lt;Idx&gt; { type Output; fn index(&amp;self, index: Idx) -&gt; &amp;Self::Output;}struct Foo(i32, i32);impl Index&lt;isize&gt; for Foo { type Output = i32; fn index(&amp;self, index: isize) -&gt; &amp;i32 { if index == 0 { &amp;self.0 } else { &amp;self.1 } }}fn main() -&gt; i32 { let a = Foo(1, 2); let b = a[0]; let c = a[1]; c - b - 1}</p><p>#[lang=&#34；索引&#34；]特质指数&lt；Idx&gt；{type Output；fn index（&amp；self，index:Idx）-&gt；&amp；self:：Output；}struct Foo（i32，i32）；impl索引&lt；isize&gt；对于Foo{type Output=i32；fn index（&amp；self，index:isize）->；i32{let a=Foo（1,2）；let b=a[0]；let c=a[1]；c-b-1}</p><p>    Macro match arms can contain repetition operators, which indicate the possibilty of passing multiple instances of a single token or metavariable.</p><p>宏匹配臂可以包含重复运算符，它指示传递单个标记或元变量的多个实例的可能性。</p><p> You can denote such repetitions using Kleene operators: Three variants are available,  ?,  + and  *. Each corresponds to varying bounds on the amount of tokens associated with the operator, similarly to regular expressions.</p><p>您可以使用Kleene运算符表示此类重复：有三种变体可用，？，+及*。每一个都对应于与运算符关联的标记数量的不同界限，类似于正则表达式。</p><p> macro_rules! kleene { ($a:ident $(,)?) =&gt; {{ }}; ($($i:literal tok)+) =&gt; {{ }}; ($($e:expr)*) =&gt; {{ }};}</p><p>宏规则！kleene{（$a:ident$（，）？）=&gt；{{}；（$（$i:literal tok）+）=&gt；{{ }}; （$（$e:expr）*）=&gt；{{ }};}</p><p>  Either a singular identifier, with zero or one commas (pattern:  &lt;comma&gt;, kleene operator:  ? (0 -&gt; 1))</p><p>单数标识符，带有零个或一个逗号（模式：&lt；逗号&gt；，kleene运算符：？（0-&gt；1））</p><p> One or more literal followed by the separator  tok (pattern  $i:literal tok, kleene operator:  + (1 -&gt;  +inf))</p><p>一个或多个文本后跟分隔符tok（模式$i:literal tok，kleene运算符：+（1-&gt；+inf））</p><p> The first of implementing macro repetitions comes in matching the actual patterns given to the users. We are now able to match simple repetitions, with a few limitations and bugs still. For example, the Rust reference specifies valid separators to use after fragment specifiers, which we do not check yet. It is for example forbidden to add an identifier after an  $&lt;&gt;:expr specifier, since that could cause ambiguity: The only allowed separators after an expression are thus  =&gt;,  &lt;comma&gt; or  ;.</p><p>实现宏重复的第一步是匹配给定给用户的实际模式。我们现在能够匹配简单的重复，但仍有一些限制和缺陷。例如，Rust引用指定了在片段说明符之后使用的有效分隔符，我们还没有检查这些分隔符。例如，禁止在$&lt&gt；：expr说明符，因为这可能会导致歧义：表达式后唯一允许的分隔符是=&gt&书信电报；逗号&gt；或</p><p>  Once those repetition patterns are matched, it is easy to figure out how many repetitions of said pattern were given by the user. We store this data alongside the rest of the fragment, to make sure that we expand said pattern a correct amount of times when transcribing.</p><p>一旦匹配了这些重复模式，就很容易计算出用户给出了多少重复模式。我们将这些数据与片段的其余部分一起存储，以确保在转录时将所述模式扩展正确的次数。</p><p>     we will have matched the repetition 3 times, and attributed a repetition amount of 3 to the  $e meta-variable.</p><p>我们将匹配重复3次，并将重复量3归因于$e元变量。</p><p>   Following the matching of these repetitions, we can recursively expand all tokens contained in the pattern.</p><p>在匹配这些重复之后，我们可以递归地扩展模式中包含的所有标记。</p><p> Considering once again the previous declaration and invocation, we can parse the following pattern as the one to expand:</p><p>再次考虑前面的声明和调用，我们可以将以下模式解析为要展开的模式：</p><p>  This pattern is then recursively expanded as if it was a regular macro invocation. In order to make sure that each meta-variable gets expanded correctly, we only give a subset of the matched fragments to the new subsitution context.</p><p>然后，该模式被递归地扩展，就好像它是一个常规的宏调用一样。为了确保每个元变量得到正确的扩展，我们只给新的替代上下文提供匹配片段的子集。</p><p> macro_rules! lit_plus_tok { ($($e:literal tok)*) =&gt; {}}lit_plus_tok!(&#34;rustc&#34; tok &#39;v&#39; tok 1.59 tok);// Original matched fragments: { &#34;lit&#34;: [&#34;rustc&#34;, &#39;v&#39;, 1.59] }// We then expand the repetition pattern once with { &#34;lit&#34;: [&#34;rustc&#34;] },// once with { &#34;lit&#34;: [&#39;v&#39;] },// and finally once with { &#34;lit&#34;: [1.59] },</p><p>宏规则！lit_plus_tok{（$（$e:literal tok）*）=&gt；{}lit_plus_tok！（&#34；rustc&#34；tok&#39；v&#39；tok 1.59 tok）；//原始匹配片段：{&#34；lit&#34；：[&#34；rustc&#34；，&#39；v&#39；，1.59]}//然后我们用{&#34；lit&#34；：[&#34；rustc&#34；]曾经与{&#34；lit&#34；：[&#39；v&#39；]}，//最后一次是{&#34；lit&#34；：[1.59]}，</p><p> Once again, certain restrictions apply, which we have yet to implement: Some specifiers get expanded eagerly, while some stay under the form inputted by the user.</p><p>同样，我们还没有实现某些限制：一些说明符急切地得到扩展，而一些保留在用户输入的表单下。</p><p>  Likewise, not all repetition patterns are covered properly. Some issues remain to be ironed out for a complete and correct implementation.</p><p>同样，并不是所有的重复模式都被恰当地覆盖。为了全面、正确地实施，有些问题仍有待解决。</p><p>  In order to implement some specific behaviour, the rust standard library requires some macros to be built into the compiler. You can find a full list  here.</p><p>为了实现某些特定的行为，rust标准库需要在编译器中内置一些宏。你可以在这里找到完整的清单。</p><p> gccrs should implement to allow for the compilation of the standard rust library, as both  core and  std depend on a multitude of them.</p><p>GCCR的实施应考虑到标准rust库的编译，因为core和std都依赖于它们。</p><p> These macros are defined as empty within the core library, and their transcriber is provided in the compiler as a simple function. We implement those builtins in  gccrs as functions returning fragments of abstract syntax trees, which are inserted during the macro-expansion phase and then lowered to an intermediate representation alongside the rest of the user’s code.</p><p>这些宏在核心库中定义为空，它们的转录器在编译器中作为一个简单函数提供。我们在GCCR中实现这些内置函数，作为返回抽象语法树片段的函数，这些片段在宏扩展阶段插入，然后与用户代码的其余部分一起降低到中间表示形式。</p><p> We have a long list of macros ahead of us, some of which we should be able to implement easily. If you are interested in contributing, we have opened 3 good first issues regarding builtin macros with detailed guides on how to solve them.</p><p>我们面前有一长串宏，其中一些应该可以轻松实现。如果你有兴趣参与进来，我们已经打开了关于内置宏的3个好的第一个问题，以及如何解决它们的详细指南。</p><p> Thanks a lot to  bjorn3 for all the help regarding builtin macros and their implementation details.</p><p>非常感谢bjorn3对内置宏及其实现细节的帮助。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gcc/">#gcc</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gt/">#gt</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>