<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>文本布局是松散的分段层次</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">文本布局是松散的分段层次</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-27 22:23:57</div><div class="page_narrow text-break page_content"><p>I love text layout, and have been working with it in one form or other for over 35 years. Yet, knowledge about it is quite arcane. I don’t believe there is a single place where it’s all properly written down. I have some explanation for that: while basic text layout is very important for UI, games, and other contexts, a lot of the “professional” needs around text layout are embedded in  much more complicated systems such as Microsoft Word or a modern Web browser.</p><p>我喜欢文本布局，并且已经以这样或那样的形式使用它超过35年了。然而，关于它的知识相当晦涩难懂。我不相信有一个地方都写得很好。我对此有一些解释：虽然基本文本布局对于UI、游戏和其他上下文非常重要，但是许多关于文本布局的“专业”需求都嵌入到更为复杂的系统中，如Microsoft Word或现代Web浏览器。</p><p> A complete account of text layout would be at least a small book. Since there’s no way I can write that now, this blog post is a small step towards that – in particular, an attempt to describe the “big picture,” using the conceptual framework of a “loose hierarchy.” Essentially, a text layout engine breaks the input into finer and finer grains, then reassembles the results into a text layout object suitable for drawing, measurement, and hit testing.</p><p>一本完整的文本布局至少要有一本小书。既然我现在不可能写出这一点，这篇博文就是朝着这个方向迈出的一小步--特别是试图用“松散层次”的概念框架来描述“大图景”。基本上，文本布局引擎将输入分解成越来越细的颗粒，然后将结果重新组合成适合绘制、测量和命中测试的文本布局对象。</p><p> The main hierarchy is concerned with laying out the entire paragraph as a single line of text. Line breaking is also important, but has a separate, parallel hierarchy.</p><p>主层次结构涉及将整个段落布局为单行文本。换行符也很重要，但有一个独立的、平行的层次结构。</p><p>  The hierarchy is: paragraph segmentation as the coarsest granularity, followed by rich text style and BiDi analysis, then itemization (coverage by font), then Unicode script, and shaping clusters as the finest.</p><p>层次结构是：段落分割是最粗的粒度，紧随其后的是富文本样式和BiDi分析，然后是分项(按字体覆盖)，然后是Unicode脚本，并将聚类整形为最细的。</p><p>   The coarsest, and also simplest, segmentation task is paragraph segmentation. Most of the time, paragraphs are simply separated by newline (U+000A) characters, though Unicode in its infinite wisdom specifies a number of code point sequences that function as paragraph separators in plain text:</p><p>最粗略也是最简单的分割任务是段落分割。大多数情况下，段落只是用换行符(U+000A)分隔，尽管Unicode在其无限智慧中指定了许多在纯文本中用作段落分隔符的代码点序列：</p><p>  In rich text, paragraphs are usually indicated through markup rather than special characters, for example  &lt;p&gt; or  &lt;br&gt; in HTML. But in this post, as in most text layout APIs, we’ll treat rich text as plain text + attribute spans.</p><p>在富文本中，段落通常通过标记而不是特殊字符来指示，例如HTML中的&lt；p&gt；或&lt；br&gt；。但在这篇文章中，就像在大多数文本布局API中一样，我们将把富文本视为纯文本+属性范围。</p><p>  A paragraph of rich text may contain  spans that can affect formatting. In particular, choice of font, font weight, italic or no, and a number of other attributes can affect text layout. Thus, each paragraph is typically broken into a some number of  style runs, so that within a run the style is consistent.</p><p>富文本段落可能包含可能影响格式设置的跨度。具体地说，字体、字体粗细、斜体或无斜体以及许多其他属性的选择会影响文本布局。因此，每个段落通常被分成一定数量的样式运行，以便在运行中样式是一致的。</p><p> Note that some style changes don’t  necessarily affect text layout. A classic example is color. Firefox, rather famously, does  not define segmentation boundaries here for color changes. If a color boundary cuts a ligature, it uses fancy graphics techiques to render parts of the ligature in different color. But this is a subtle refinement and I think not required for basic text rendering. For more details, see  Text Rendering Hates You.</p><p>请注意，某些样式更改不一定会影响文本布局。颜色就是一个典型的例子。众所周知，Firefox在这里没有为颜色更改定义分段边界。如果颜色边界切割了一个连字，它就会使用奇特的图形技术将部分连字渲染成不同的颜色。但这是一种微妙的改进，我认为对于基本的文本渲染不是必需的。有关更多详细信息，请参见文本呈现讨厌您。</p><p>  Completely separate from the style spans, a paragraph may in general contain both left-to-right and right-to-left text. The need for bidirectional (BiDi) text is certainly one of the things that makes text layout more complicated.</p><p>段落与样式跨度完全分开，通常可以包含从左到右和从右到左的文本。对双向(BiDi)文本的需要肯定是使文本布局更加复杂的原因之一。</p><p> Fortunately, this part of the stack is defined by a standard ( UAX #9), and there are a number of good implementations. The interested reader is referred to  Unicode Bidirectional Algorithm basics. The key takeaway here is that BiDi analysis is done on the plain text of the entire paragraph, and the result is a sequence of  level runs, where the level of each run defines whether it is LTR or RTL.</p><p>幸运的是，堆栈的这一部分是由标准(UAX#9)定义的，并且有许多好的实现。感兴趣的读者请参阅Unicode双向算法基础。这里的关键要点是，BiDi分析是在整个段落的纯文本上完成的，结果是一系列级别运行，其中每个运行的级别定义它是LTR还是RTL。</p><p> The level runs and the style runs are then merged, so that in subsequent stages each run is of a consistent style and directionality. As such, for the purpose of defining the hierarchy, the result of BiDi analysis could alternatively be considered an implicit or derived rich text span.</p><p>然后合并标高管路和样式管路，以便在后续阶段中每个管路具有一致的样式和方向性。因此，出于定义层次的目的，BiDi分析的结果可替换地被认为是隐式的或导出的富文本跨度。</p><p> In addition to BiDi, which I consider a basic requirement, a more sophisticated text layout engine will also be able to handle vertical  writing modes, including mixed cases where short strings are horizontal within the vertical primary direction. Extremely sophisticated layout engines will also be able to handle ruby text and other ways of annotating the main text flow with intercalated strings. See  Requirements for Japanese Text Layout for many examples of sophisticated layout requirements; the scope of this blog post really is basic text layout of the kind needed in user interfaces.</p><p>除了BiDi(我认为这是一项基本要求)之外，更复杂的文本布局引擎还将能够处理垂直书写模式，包括短串在垂直主方向内水平的混合情况。极其复杂的布局引擎还将能够处理拼音文本和使用插入字符串注释主要文本流的其他方式。有关复杂布局要求的许多示例，请参阅日语文本布局要求；这篇博客文章的范围实际上是用户界面中所需的那种基本文本布局。</p><p>  Itemization is the trickiest and least well specified part of the hierarchy. There is no standard for it, and no common implementation. Rather, each text layout engine deals with it in its own special way.</p><p>分项是层次结构中最棘手、指定最少的部分。它没有标准，也没有通用的实现。相反，每个文本布局引擎都以自己的特殊方式处理它。</p><p> Essentially, the result of itemization is to choose a single concrete font for a run, from a  font collection. Generally a font collection consists of a main font (selected by font name from system fonts, or loaded as a custom asset), backed by a  fallback stack, which are usually system fonts, but thanks to  Noto it is possible to bundle a fallback font stack with an application, if you don’t mind spending a few hundred megabytes for the assets.</p><p>本质上，分项的结果是从字体集合中为运行选择一种具体的字体。通常，字体集合由主字体(通过字体名称从系统字体中选择，或作为自定义资产加载)组成，并有后备堆栈(通常是系统字体)，但多亏了Noto，如果您不介意为资产花费几百兆字节，则可以将后备字体堆栈与应用程序捆绑在一起。</p><p>  First, it’s not so easy to determine whether a font can render a particular string of text. One reason is  Unicode normalization. For example, the string “é” can be encoded as U+00E9 (in NFC encoding) or as U+0065 U+0301 (in NFD encoding). Due to the principle of  Unicode equivalence, these should be rendered identically, but a font may have coverage for only one or the other in its  Character to Glyph Index Mapping (cmap) table. The shaping engine has all the Unicode logic to handle these cases.</p><p>首先，确定字体是否可以呈现特定的文本字符串并非易事。原因之一是Unicode标准化。例如，字符串“é”可以编码为U+00E9(NFC编码)或U+0065U+0301(NFD编码)。由于Unicode等价的原则，它们应该以相同的方式呈现，但是字体在其字符到字形索引映射(Cmap)表中可能只覆盖其中的一个或另一个。整形引擎拥有处理这些情况的所有Unicode逻辑。</p><p> Of course, realistic fonts with Latin coverage will have both of these particular sequences covered in the cmap table, but edge cases certainly do happen, both in extended Latin ranges, and other scripts such as Hangul, which has complex normalization rules (thanks in part to a Korean standard for normalization which is somewhat at odds with Unicode). It’s worth noting that  DirectWrite gets Hangul normalization quite wrong.</p><p>当然，具有拉丁文覆盖的现实字体将在Cmap表中包含这两个特定的序列，但边缘情况肯定会发生，无论是在扩展的拉丁文范围中，还是在其他脚本中，如具有复杂规范化规则的Hangul(部分归功于与Unicode有些不一致的韩国标准化标准)。值得注意的是，DirectWrite对韩文规范化的理解是完全错误的。</p><p> I believe a similar situation exists with the Arabic presentation forms; see  Developing Arabic fonts for more detail on that.</p><p>我相信阿拉伯语的演示形式也存在类似的情况；有关这方面的更多详细信息，请参阅开发阿拉伯语字体。</p><p> Because of these tricky normalization and presentation issues, the most robust way to determine whether a font can render a string is to try it. This is how LibreOffice has worked for a while, and in 2015  Chromium followed. See also  Eliminating Simple Text for more background on the Chromium text layout changes.</p><p>由于这些棘手的规范化和表示问题，确定字体是否可以呈现字符串的最可靠的方法是尝试。这就是LibreOffice一段时间以来的工作方式，2015年Chromium紧随其后。有关Chromium文本布局更改的更多背景信息，请参阅消除简单文本。</p><p> Another whole class of complexity is emoji. A lot of emoji can be rendered with either  text or emoji presentation, and there are no hard and fast rules to pick one or the other. Generally the text presentation is in a symbol font, and the emoji presentation is in a separate color font. A particularly tough example is the smiling emoji, which began its encoding life as 0x01 in  Code page 437, the standard 8-bit character encoding of the original IBM PC, and is now U+263A in Unicode. However, the suggested default presentation is text, which won’t do in a world which expects color. Apple on iOS unilaterally chose an emoji presentation, so many text stacks follow Apple’s lead. (Incidentally, the most robust way to encode such emoji is to append a  variation selector to pin down the presentation.)</p><p>另一个复杂的类别是表情符号。许多表情符号可以用文本或表情符号呈现，没有硬性的规则来选择其中之一。通常，文本呈现为符号字体，而表情符号呈现为单独的颜色字体。一个特别棘手的例子是微笑表情符号，它的编码生命始于代码页437中的0x01，这是最初IBM PC的标准8位字符编码，现在是Unicode中的U+263a。但是，建议的默认演示文稿是文本，这在需要颜色的世界中是行不通的。IOS上的苹果单方面选择了表情符号演示，因此许多文字堆栈都跟随苹果的脚步。(顺便说一句，对这样的表情进行编码的最健壮的方法是附加一个变体选择器来固定演示文稿。)。</p><p> Another source of complexity when trying to write a cross-platform text layout engine is querying the system fonts. See  Font fallback deep dive for more information about that.</p><p>在尝试编写跨平台文本布局引擎时，另一个复杂性来源是查询系统字体。有关这方面的更多信息，请参见字体后备深度潜水。</p><p> I should note one thing, which might help people doing archaeology of legacy text stacks: it used to be pretty common for text layout to resolve “compatibility” forms such as NFKC and NFKD, and this can lead to various problems. But today it is more common to solve that particular problem by providing a font stack with  massive Unicode coverage, including all the code points in the relevant compatibility ranges.</p><p>我应该注意一件事，这可能会帮助人们对遗留文本栈进行考古：过去，文本布局解决诸如NFKC和NFKD之类的“兼容性”形式是很常见的，这可能会导致各种问题。但是今天，通过提供具有大量Unicode覆盖范围(包括相关兼容范围内的所有代码点)的字体堆栈来解决该特定问题更为常见。</p><p>  The  shaping of text, or the transformation of a sequence of code points into a sequence of positioned glyphs, depends on the script. Some scripts, such as Arabic and Devanagari, have extremely elaborate shaping rules, while others, such as Chinese, are a fairly straightforward mapping from code point into glyph. Latin is somewhere in the middle, starting with a straightforward mapping, but ligatures and kerning are also required for high quality text layout.</p><p>文本的整形或将代码点序列转换为定位字形序列取决于脚本。有些文字(如阿拉伯语和梵文)具有极其精细的整形规则，而另一些文字(如中文)则是从代码点到字形的相当简单的映射。拉丁语介于两者之间，从简单的映射开始，但连字和紧排也是高质量文本布局所必需的。</p><p> Determining script runs is reasonably straightforward - many characters have a Unicode script property which uniquely identifies which script they belong to. However, some characters, such as space, are “common,” so the assigned script just continues the previous run.</p><p>确定脚本运行相当简单-许多字符都有一个Unicode脚本属性，该属性唯一地标识它们属于哪个脚本。但是，有些字符(如空格)是“通用的”，因此分配的脚本只是继续前一次运行。</p><p> A simple example is “hello мир”. This string is broken into two script runs: “hello “ is  Latn, and “мир” is  Cyrl.</p><p>一个简单的例子是“Helloмир”。此字符串分为两个脚本运行：“hello”表示Latn，“мир”表示cyrl。</p><p>  At this point, we have a run of constant style, font, direction, and script. It is ready for  shaping. Shaping is a complicated process that converts a string (sequence of Unicode code points) into positioned glyphs. For the purpose of this blog post, we can generally treat it as a black box. Fortunately, a very high quality open source implementation exists, in the form of HarfBuzz.</p><p>在这一点上，我们有了一系列恒定的样式、字体、方向和脚本。它已经准备好整形了。整形是将字符串(Unicode代码点序列)转换为定位字形的复杂过程。就这篇博客文章而言，我们通常可以将其视为一个黑匣子。幸运的是，以HarfBuzz的形式存在一个非常高质量的开源实现。</p><p> We’re not  quite done with segmentation, though, as shaping assigns substrings in the input to  clusters of glyphs. The correspondence depends a lot on the font. In Latin, the string “fi” is often shaped to a single glyph (a ligature). For complex scripts such as Devanagari, a cluster is most often a syllable in the source text, and complex reordering can happen within the cluster.</p><p>不过，我们还没有完全完成分段，因为Shaping会将输入中的子字符串分配给字形簇。通信在很大程度上取决于字体。在拉丁语中，字符串“fi”通常被塑造成单一的字形(连字)。对于梵文这样的复杂脚本，簇通常是源文本中的一个音节，并且在簇中可能会发生复杂的重新排序。</p><p> Clusters are important for  hit testing, or determining the correspondence between a physical cursor position in the text layout and the offset within the text. Generally, they can be ignored if the text will only be rendered, not edited (or selected).</p><p>群集对于命中测试或确定文本布局中的物理光标位置与文本中的偏移之间的对应关系非常重要。通常，如果只呈现文本，而不会编辑(或选择)文本，则可以忽略它们。</p><p> Note that these shaping clusters are distinct from grapheme clusters. The “fi” example has two grapheme clusters but a single shaping cluster, so a grapheme cluster boundary can cut a shaping cluster. Since it’s possible to move the cursor between the “f” and “i”, one tricky problem is to determine the cursor location in that case. Fonts  do have a  caret table, but implementation is spotty. A more robust solution is to portion the width of the cluster equally to each grapheme cluster within the cluster. See also  Let’s Stop Ascribing Meaning to Code Points for a detailed dive into grapheme clusters.</p><p>注意，这些成形群集与字素群集不同。“fi”示例有两个字素簇，但只有一个整形簇，因此一个字素簇边界可以切割一个整形簇。由于可以在“f”和“i”之间移动光标，因此在这种情况下确定光标位置是一个棘手的问题。字体确实有插入符号表，但实现情况参差不齐。更健壮的解决方案是将簇的宽度平均分配给簇内的每个字素簇。另请参见停止将含义赋予代码点，以详细了解字素簇。</p><p>  While short strings can be considered a single strip, longer strings require breaking into lines. Doing this properly is quite a tricky problem. In this post, we treat it as a separate (small) hierarchy, parallel to the main text layout hierarchy above.</p><p>虽然短字符串可以被认为是一个单独的条带，但较长的字符串需要断成行。做好这件事是一个相当棘手的问题。在这篇文章中，我们将其视为一个独立的(小)层次结构，与上面的主要文本布局层次结构平行。</p><p> The problem can be factored into identifying line break  candidates, then choosing a subset of those candidates as line breaks that satisfy the layout constraints. The main constraint is that lines should fit within the specified maximum width. It’s common to use a greedy algorithm, but high end typography tends to use an algorithm that minimizes a raggedness score for the paragraph. Knuth and Plass have a famous paper,  Breaking Paragraphs into Lines, that describes the algorithm used in TeX in detail. But we’ll focus on the problems of determining candidates and measuring the widths, as these are tricky enough.</p><p>该问题可以考虑到识别换行符候选者，然后选择这些候选者的子集作为满足布局约束的换行符。主要限制是线条应适合指定的最大宽度。使用贪婪算法是很常见的，但是高端排版往往使用一种最小化段落粗糙分数的算法。Knuth和Plass有一篇著名的论文，“将段落拆分成行”，详细描述了TeX中使用的算法。但我们将集中讨论确定候选人和测量宽度的问题，因为这些问题已经够棘手的了。</p><p> In theory, the Unicode Line Breaking Algorithm ( UAX #14) identifies positions in a string that are candidate line breaks. In practice, there are some additional subtleties. For one, some languages (Thai is the most common) don’t use spaces to divide words, so need some kind of natural language processing (based on a dictionary) to identify word boundaries. For two, automatic  hyphenation is often desirable, as it fills lines more efficiently and makes the right edge less ragged. Liang’s algorithm is most common for automatically inferring “soft hyphens,” and there are many good implementations of it.</p><p>理论上，Unicode换行符算法(UAX#14)识别字符串中作为候选换行符的位置。在实践中，还有一些额外的微妙之处。首先，一些语言(泰语是最常见的)不使用空格来分隔单词，因此需要某种自然语言处理(基于字典)来识别单词边界。其次，自动连字通常是可取的，因为它可以更有效地填充各行，并使右边缘不那么粗糙。梁的算法是最常用的自动推断“软连字符”的算法，并且有很多很好的实现。</p><p> Android’s line breaking implementation (in the  Minikin library) applies an additional refinement: since email addresses and URLs are common in strings displayed on mobile devices, and since the UAX #14 rules give poor choices for those, it has an additional parser to detect those cases and apply different rules.</p><p>Android的换行实现(在Minikin库中)应用了额外的改进：由于电子邮件地址和URL在移动设备上显示的字符串中很常见，而且UAX#14规则为这些提供了糟糕的选择，因此它有一个额外的解析器来检测这些情况并应用不同的规则。</p><p> Finally, if words are very long or the maximum width is very narrow, it’s possible for a word to exceed that width. In some cases, the line can be “overfull,” but it’s more common to break the word at the last grapheme cluster boundary that still fits inside the line. In Android, these are known as “desperate breaks.”</p><p>最后，如果单词非常长或最大宽度非常窄，则单词有可能超过该宽度。在某些情况下，行可能会“超满”，但更常见的情况是在仍然适合行内的最后一个字素簇边界处断开单词。在Android中，这些被称为“绝望的休息”。</p><p> So, to recap, after the paragraph segmentation (also known as “hard breaks”), there is a loose hierarchy of 3 line break candidates: word breaks as determined by UAX #14 (with possible “tailoring”), soft hyphens, and finally grapheme cluster boundaries. The first is preferred, but the other two may be used in order to satisfy the layout constraints.</p><p>因此，简单地说，在段落分割(也称为“硬中断”)之后，有一个由3个换行候选者组成的松散层次结构：由UAX#14(可能的“剪裁”)确定的分词、软连字符，最后是字素簇边界。第一个是优选的，但是为了满足布局约束，可以使用另外两个。</p><p> This leaves another problem, which is suprisingly tricky to get fully right: how to measure the width of a line between two candidate breaks, in order to validate that it fits within the maximum width (or, in the more general case, to help compute a global raggedness score). For Latin text in a normal font, this seems almost ridiculously easy: just measure the width of each word, and add them up. But in the general case, things are nowhere nearly so simple.</p><p>这就留下了另一个问题，这个问题要完全正确是非常棘手的：如何测量两个候选中断之间的线的宽度，以便验证它是否符合最大宽度(或者，在更一般的情况下，帮助计算全局粗糙度分数)。对于普通字体的拉丁文文本，这似乎非常简单：只需测量每个单词的宽度，然后将它们相加即可。但在一般情况下，事情远没有这么简单。</p><p> First, while in Latin, most line break candidates are at space characters, in the fully general case they can cut anywhere in the text layout hierarchy, even in the middle of a cluster. An additional complication is that hyphenation can add a hyphen character.</p><p>首先，虽然在拉丁语中，大多数换行符候选字符都在空格字符处，但在完全通用的情况下，他们可以在文本布局层次结构中的任何位置进行剪切，甚至可以在簇的中间进行剪切。另一个复杂之处在于，连字符可以添加连字符。</p><p> Even without hyphenation, because  shaping is Turing Complete, the width of a line (a substring between two line break candidates) can be any function. Of course, such extreme cases are rare; it’s most common for the widths to be exactly equal to the sum of the widths of the words, and even in the other cases this tends to be a good approximation.</p><p>即使没有连字符，因为整形是图灵完成的，所以线的宽度(两个换行符候选之间的子字符串)可以是任何函数。当然，这样的极端情况很少见；最常见的情况是宽度正好等于单词的宽度之和，即使在其他情况下，这也往往是一个很好的近似值。</p><p> So getting this exactly right in the general case is conceptually not difficult, but is horribly inefficient: for each candidate for the end of the line, perform text layout (mostly shaping) on the substring from the beginning of the line (possibly inserting a hyphen), and measure the width of that layout.</p><p>因此，在一般情况下准确做到这一点在概念上并不困难，但效率低得可怕：对于行尾的每个候选对象，从行的开头对子字符串执行文本布局(主要是整形)(可能插入连字符)，并测量布局的宽度。</p><p> Very few text layout engines even try to handle this general case, using various heuristics and approximations which work well most of the time, but break down when presented with a font with shaping rules that change widths aggressively. DirectWrite does, however, using very clever techniques that took several years of iteration. The full story is in  harfbuzz/harfbuzz#1463 (comment). Further analysis, towards a goal of getting this implemented in an open source text layout engine, is in  yeslogic/allsorts#29. If and when either HarfBuzz or Allsorts implements the lower-level logic, I’ll probably want to write another blog post explaining in more detail how a higher level text layout engine can take advantage of it.</p><p>很少有文本布局引擎甚至尝试处理这种一般情况，使用各种启发式和近似法，这些试探法和近似法在大多数情况下都工作得很好，但当提供具有积极改变宽度的成形规则的字体时，它们就失效了。然而，DirectWrite确实使用了非常聪明的技术，这些技术花了几年的迭代时间。完整的故事在harfbuzz/harfbuzz#1463(评论)。对于在开源文本布局引擎中实现这一目标的进一步分析，请参阅yeslogic/allsorts#29。如果HarfBuzz或Allsorts实现了低级逻辑，我可能会想写另一篇博客文章，更详细地解释高级文本布局引擎如何利用它。</p><p> A great example of how line breaking can go wrong is  Firefox bug 479829, in which an “f + soft hyphen + f” sequence in the text is shaped as the “ff” ligature, then the line is broken at the soft hyphen. Because Firefox reuses the existing shaping rather than reshaping the line, it actually renders with the ligature glyph split across lines:</p><p>换行可能出错的一个很好的例子是Firefox bug 479829，在该错误中，文本中的“f+软连字符+f”序列被塑造为“ff”连字，然后在软连字符处断行。因为Firefox重用了现有的形状，而不是重塑线条，所以它实际上使用跨行分割的连字字形进行渲染：</p><p>   While I still feel a need for a solid, high-level, cross-platform text layout engine, there are good implementations to study. In open source, on of my favorites (though I am biased), is the Android text stack, based on  Minikin for its lower levels. It is fairly capable and efficient, and also makes a concerted effort to get “all of Unicode” right, including emoji. It is also reasonably simple and the code is accessible.</p><p>虽然我仍然觉得需要一个可靠的、高级别的、跨平台的文本布局引擎，但还有很好的实现需要研究。在开放源码中，我最喜欢的(虽然我有偏见)之一是Android文本栈，它基于Minikin，因为它的级别较低。它相当有能力和效率，并且齐心协力把“所有的Unicode”都做好，包括表情符号。它也相当简单，并且代码是可访问的。</p><p> While not open source,  DirectWrite is also well worth study, as it is without question one of the most capable engines, supporting Word and the previous iteration of Edge before it was abandonded in favor of Chromium. Note that there is a  proposal for a cross-platform implementation and also potentially to take it open-source. If that were to happen, it would be something of a game changer.</p><p>虽然DirectWrite不是开源的，但它也很值得研究，因为它无疑是最强大的引擎之一，支持Word和Edge在被Chromium抛弃之前的上一次迭代。请注意，有一项关于跨平台实现的建议，也有可能将其开源。如果这真的发生了，它将在某种程度上改变游戏规则。</p><p> Chromium and Firefox are a rich source as well, especially as they’ve driven a lot of the improvements in HarfBuzz. However, their text layout stacks are quite complex and do not have a clean, documented API boundary with the rest of the application, so they are not as suitable for study as the others I’ve chosen here.</p><p>Chrome和Firefox也是一个丰富的来源，特别是它们推动了HarfBuzz的很多改进。但是，它们的文本布局堆栈相当复杂，并且与应用程序的其余部分没有一个干净的、有文档记录的API边界，因此它们不像我在这里选择的其他应用程序那样适合研究。</p><p>  Paragraph and style segmentation (with BiDi) is done at higher levels, in  Layout.java and  StaticLayout.java. At that point, runs are handed to  Minikin for lower-level processing. Most of the rest of the hierarchy is in Layout.cpp, and ultimately shaping is done by HarfBuzz.</p><p>段落和样式分段(使用BiDi)在较高级别上完成，在Layout.java和StaticLayout.java中。在这一点上，运行被交给Minikin进行较低级别的处理。层次结构的其余大部分位于layout.cpp中，最终由HarfBuzz完成整形。</p><p>  Android deals with shaping boundaries by using heuristics to further segment the text to implied word boundaries (which are also used as the grain for layout cache). If a font does shaping across these boundaries, the shaping context is simply lost. This is a reasonable compromise, especially in mobile, as results are always consistent, ie the width for measurement never mismatches the width for layout. And none of the fonts in the system stack have exotic behavior such as shaping across spaces.</p><p>Android通过使用启发式算法进一步将文本分割成隐含的单词边界(这些边界也用作布局缓存的颗粒)来处理边界形状。如果字体跨越这些边界进行整形，则整形上下文就会丢失。这是一个合理的折衷方案，特别是在移动设备中，因为结果总是一致的，即测量的宽度永远不会与布局的宽度不匹配。而且系统堆栈中的字体都没有异国情调，比如跨空格整形。</p><p> Android does base its itemization on cmap coverage, and builds sophisticated bitmap structures for fast queries. As such, it can get normalization issues wrong, but overall this seems like a reasonable compromise. In particular, most of the time you’ll run into normalization issues is with Latin and the combining diacritical marks, both of which are supplied by Roboto, which in turn has massive Unicode coverage (and thus less need to rely on normalization logic). But with custom fonts, handling may be less than ideal, resulting in more fallback to Roboto than might actually be needed.</p><p>Android确实以Cmap覆盖为基础进行条目划分，并构建了复杂的位图结构以实现快速查询。因此，它可能会在正常化问题上出错，但总体而言，这似乎是一个合理的妥协。特别是，大多数时候您会遇到规范化问题是拉丁语和组合变音符号，这两者都是由Roboto提供的，而Roboto又有大量的Unicode覆盖(因此不太需要依赖规范化逻辑)。但是使用自定义字体时，处理可能不太理想，导致Roboto出现比实际需要更多的后备。</p><p> Note that Minikin was also the starting point for  libTxt, the text layout library used in Flutter.</p><p>请注意，Minikin也是libTxt的起点，libTxt是Ffltter中使用的文本布局库。</p><p>  Some notes on things I’ve found while studying the API; these observations are quite a bit in the weeds, but might be useful to people wanting to deeply understand or engage the API.</p><p>一些关于我在研究API时发现的东西的笔记；这些观察结果不是很清楚，但对于想要深入了解或使用API的人来说可能会很有用。</p><p> Hit testing in DirectWrite is based on leading/trailing positions, while in Android it’s based on primary and secondary. The latter is more useful for text edition, but leading/trailing is a more well-defined concept (for one, it doesn’t rely on paragraph direction). For more information on this topic, see  linebender/piet#323. My take is that proper hit testing requires iterating through the text layout to access lower level structures.</p><p>DirectWrite中的命中测试基于前导/尾随位置，而Android中的命中测试基于主要和次要位置。后者对于文本编辑更有用，但是前导/尾随是一个定义更明确的概念(首先，它不依赖于段落方向)。有关此主题的详细信息，请参阅折线机/Piet#323。我的观点是，正确的命中测试需要遍历文本布局以访问较低级别的结构。</p><p> While Core Text (see below) exposes a hierarchy of objects, DirectWrite uses the  TextLayout as the primary interface, and exposes internal structure (even including lines) by iterating over a callback per run in the confusingly named  Draw method. The granularity of this callback is a  glyph run, which corresponds to “script” in the hierarchy above. Cluster information is provided in an associated  glyph run description structure.</p><p>Core Text(见下文)公开对象的层次结构，而DirectWrite使用TextLayout作为主要接口，并通过在命名混乱的Draw方法中每次运行的回调迭代来公开内部结构(甚至包括行)。此回调的粒度为字形运行，对应于上面层次结构中的“script”。簇信息在相关联的字形运行描述结构中提供。</p><p> There are other ways to access lower level text layout capabilities, including  TextAnalyzer, which computes BiDi and line break opportunities, script runs, and shaping. In fact, the various methods on that interface represents much of the internal structure of the text layout engine. Itemization, however, is done in the  FontFallback interface, which was added later.</p><p>还有其他方法可以访问低级文本布局功能，包括TextAnalyzer，它计算BiDi和换行符机会、脚本运行和整形。事实上，该接口上的各种方法代表了文本布局引擎的大部分内部结构。但是，分项是在稍后添加的FontFallback接口中完成的。</p><p>  Another high quality implementation is  Core Text. I don’t personally find it as well designed as DirectWrite, but it does get the job done. In general, though, Core Text is considered a lower level interface, and applications are recommended to use a higher level mechanism (Cocoa text on macOS, Text Kit on iOS).</p><p>另一个高质量的实现是核心文本。我个人认为它没有DirectWrite设计得那么好，但它确实能完成工作。不过，一般而言，Core Text被认为是较低级别的接口，建议应用程序使用较高级别的机制(MacOS上的Cocoa Text，iOS上的Text Kit)。</p><p> When doing text layout on macOS, it’s probably better to use the platform-provided itemization method ( CTFontCreateForString), rather than getting the font list and doing itemization in the client. See  linebender/skribo#14 for more information on this tradeoff.</p><p>在MacOS上进行文本布局时，最好使用平台提供的分项方法(CTFontCreateForString)，而不是在客户端获取字体列表并进行分项。有关此权衡的更多信息，请参见Linebender/Skribo#14。</p><p>  At this point, the Druid GUI toolkit does not have its own native text layout engine, but rather  does provide a  cross-platform API which is delegated to platform text layout engines, DirectWrite and Core Text in particular.</p><p>此时，Druid GUI工具包没有自己的原生文本布局引擎，而是提供了跨平台API，该API被委托给平台文本布局引擎，特别是DirectWrite和Core Text。</p><p> The situation on Linux is currently unsatisfactory, as it’s based on the Cairo toy text API. There is work ongoing to improve this, but no p</p><p>Linux上的情况目前并不令人满意，因为它基于开罗玩具文本API。目前正在进行改进这方面的工作，但没有任何进展。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://raphlinus.github.io/text/2020/10/26/text-layout.html">https://raphlinus.github.io/text/2020/10/26/text-layout.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/布局/">#布局</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/layout/">#layout</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文本/">#文本</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>