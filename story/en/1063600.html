<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Elijah Miller的NEC V30在PI帽子上 Elijah Miller’s NEC v30 on a Pi hat</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Elijah Miller’s NEC v30 on a Pi hat<br/>Elijah Miller的NEC V30在PI帽子上 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-05 04:09:30</div><div class="page_narrow text-break page_content"><p>While talking about home brew 8080 and 8086 systems on  Discord an ebay search brought me to  Elijah’s store page where  this small little curiosity was up for sale. It’s literally just a NEC v30 on a Raspberry Pi hat, for a mere $15 USD! Interestingly enough the v30 can operate at 3.3v meaning no special hardware is required to interface to the GPIO bus on a Pi. This reminds me so much of the  CP/M cartridge for the Commodore 64, and the price being so right I quickly ordered one and eagerly awaited to 2 weeks shipping to Asia.</p><p>在谈论家庭时，BREW 8080和8086个在Discord的系统上eBay搜索将我带到了以Elijah的商店页面，那么这个小小的好奇心就是出售。这是一个覆盆子Pi帽子上的NEC v30，仅为15美元！有趣的是，V30可以在3.3V中运行，意味着在PI上的GPIO总线上不需要特殊硬件。这让我如此提醒我的CP / M墨盒为COMMOMORE 64，价格如此正确，我很快就会迅速订购一个，热切期待到2周发货到亚洲。</p><p> While I have Pi 4’s that I run Windows 10 on to drive some displays &amp; power point, I wanted to use the slightly faster Pi400 for this. The Pi400 has a compatible GPIO expansion port so just like a cartridge it’s a simple matter of slotting the card, powering up and building the software. While there is an included binary, it’s a 32bit one, and I’m running Manjaro on the Pi400 for a similar look/feel as the PineBook Pro. Anyways the dependences are SDL2, and an odly named ‘wiringPi’ library that allows C programs to interface to the GPIO.</p><p> 虽然我有PI 4，我运行Windows 10开启驾驶某些显示器＆amp; Power Point，我想使用稍微更快的PI400。 PI400具有兼容的GPIO扩展端口，因此就像墨盒一样，这是打开卡片的简单问题，加电和构建软件。虽然存在包含的二进制文件，但它是一个32bit 1，而我正在在pi400上运行manjaro以获得类似的外观/景象作为pinebook pro。无论如何，依赖是SDL2，以及一个odly命名为“WIRINPI”库，允许C程序接口GPIO。</p><p> You can download the emulator over on  homebrew8088, specifically the  Raspberry Pi Second Project. The last ‘ver 2’ download has the project configured for a v30 which is an 8086 analogue, unlike the v20 which is an 8088. When physically interfacing to the processor things like this really matter!</p><p> 您可以在Homebrew8088上下载仿真器，特别是Raspberry PI第二项目。最后一个'ver 2'下载具有配置为8086模拟的V30的项目，与V20不同，这是8088的V20。当物理地接地到处理器的事物，如此重要！</p><p> With the emulator built it was pretty simple to fire it up, and boot into MS-DOS:</p><p> 使用模拟器建造，很简单地击中它，并启动进入MS-DOS：</p><p>  I have to admit I was a little startled at first as I really had no idea if this was going to work at all. I’d spoken to an engineer friend and he was saying plugging a CPU directly into the GPIO bus, and toggling connections to actually emulate the board was both crazy and that without any electrical buffers it’d most likely either fry the processor and maybe the Pi as well. I suspect this being low voltage may be sparing both, although I have no EE so I’m not going to pretend to know.</p><p>  我必须承认我一开始就是一点点惊讶，因为我真的不知道这一点是为了工作。我和一个工程师朋友说话，他说直接进入GPIO总线的CPU，并切换连接实际模仿电路板既疯狂，没有任何电气缓冲器，它最有可能炒处理器，也许是pi也是如此。我怀疑这是低电压可能会备受舒缩，虽然我没有EE所以我不会假装知道。</p><p>  Loading up Norton SI confirms what Elijah had posted on Ebay is that it runs very slowly about 1/3rd the speed of an XT. Now I may not know anything about hardware but this seemed at least something a profiler could at least tell me what is going on, and if someone like me helicoptering in on the shoulder of giants could see something.</p><p>  加载Norton Si证实了Elijah在eBay上发布的是它的速度非常缓慢，约1/3速度XT的速度。现在我可能不知道关于硬件的任何东西，但这至少是一个探查者至少可以告诉我发生了什么，如果像我这样的人在巨人的肩膀上直升机可以看到一些东西。</p><p>  This will build a profiled version of the emulator that’ll let us know which functions are being called both the number of times, and how much time to do so. Not knowing anything but having profiled other emulators, the usual pattern is that you spend most time fetching and possibly translating memory; Both in feeding instructions and pushing/popping data from stack and pointers. Waiting is usually for initialisation and for IO.</p><p>  这将构建一个仿真器的成本版本，这将让我们知道哪些函数被称为次数，以及多少时间。不了解其他任何仿真器的任何东西，通常的模式是您花费大多数时间获取和可能翻译内存;两者都在喂养指令和从堆栈和指针推出/弹出数据。等待通常用于初始化和IO。 </p><p> Once you’ve run your profiled executable, it’ll dump a binary file gmon.out which you can then use gprof to format to a text file like this:</p><p>一旦您运行了配置的可执行文件，它将转储二进制文件GMON.OUT，然后您可以使用GPROF格式化为如下文本文件：</p><p>  And then looking at the report you can see where the top time, along with top calls are. Some things just take a while to complete and other well they get called far too often.</p><p>  然后查看报告，您可以看到顶级时间以及顶级呼叫的位置。有些事情只是花了一段时间，才能完成，他们经常被称为。</p><p> Each sample counts as 0.01 seconds. % cumulative self self totaltime seconds seconds calls s/call s/call name39.91 0.71 0.71 286883 0.00 0.00 Print_Char_9x16(SDL_Render er*, int, int, unsigned char)16.30 1.00 0.29 1 0.29 1.02 Start_System_Bus(int)12.37 1.22 0.22 1100374 0.00 0.00 Data_Bus_Direction_8086_OUT()7.87 1.36 0.14 5954106 0.00 0.00 CLK()</p><p> 每个样本计数为0.01秒。 ％累积自我自我总秒秒秒秒调用S /呼叫S /呼叫名称39.91 0.71 0.71 286883 0.71 286883 0.71 286883 0.00 0 0.00 0 0.200 0 0.200 0.291.30 1.00 0.29 1 0.29 1.02 START_SYSTEM_BUS（INT）12.37 1.22 0.22 1100374 0.22 1100374 0.22 1100374 0.22 1100374 0.22 1100374 0.22 1100374 0.22 1100374 0.22 1100374 0.22 1100374 0.22 1100374 0.23 0.00 data_bus_direction_8086_out（）7.87 1.36 0.14 5954106 0.00 0 0.00 CLK（）</p><p> As expected Start_System_Bus takes 1 second, followed by 1,100,374 calls to set the Data_Bus_Direction_8086_OUT (no doubt the Pi needs to alternate between reading and writing to the CPU), followed by 5,954,106 ticks of the CLK function. Of course the real culprit is Print_Char_9x16 which was called 286,883 times, and is responsible for nearly 40% of the tuntime!</p><p> 正如预期的start_system_bus需要1秒钟，后跟一个1,100,374呼叫设置data_bus_direction_8086_out（毫无疑问，PI需要在读取和写入CPU之间交替），后跟CLK函数的5,954,106滴度。当然，真正的罪魁祸首是Print_char_9x16，它被称为286,883次，并负责近40％的Tuntime！</p><p> Obviously for a simple MS-DOS boot the screen should  not be calling any print char anywhere near this many times. Clearly something is amiss. Not knowing anything I added a simple counter to block at the top of the Print_Char_9x16 function to let it only execute 1:1000 times, and I got this:</p><p> 显然，对于简单的MS-DOS启动，屏幕不应在多次附近的任何地方调用任何打印字符。显然有些东西是不对劲。不知道我在print_char_9x16函数的顶部添加了一个简单的计数器，让它只执行1：1000次，我得到了这个：</p><p>  Obviously it’s not right, which means that the culprit really isn’t Print_Char_9x16 but rather what is calling it. It was a simple change to each of the Mode functions to only render a fraction of the time, and I changed it to a define to let me fire it more often. This is a simple diff, assuming WordPress doesn’t screw it up. It’s not pretty but it gets the job done.</p><p>  显然它不对，这意味着罪魁祸首真的不是print_char_9x16，而是呼叫它。这是对每个模式的简单变化，只能呈现一小部分时间，并且我将其改为定义，让我更频繁地发射。这是一个简单的差异，假设WordPress不会拧紧。这不漂亮，但它得到了完成的工作。</p><p> $ diff -ruN ver2/vga.cpp ver2-j/vga.cpp --- ver2/vga.cpp	2020-07-29 10:36:51.000000000 +0800+++ ver2-j/vga.cpp	2021-06-04 01:51:33.546124473 +0800@@ -1,5 +1,9 @@ #include &#34;vga.h&#34; +static int do9x16 = 0;+#define VIDU 5000++ void Print_Char_18x16(SDL_Renderer *Renderer, int x, int y, unsigned char Ascii_value) { 	for (int i = 0; i &lt; 9; i++)@@ -23,6 +27,12 @@ void Mode_0_40x25(SDL_Renderer *Renderer, char* Video_Memory, char* Cursor_Position) {+do9x16++;+if(do9x16&gt;VIDU)+ {do9x16=0;}+else+ {return;}+ 	int index = 0; 	for (int j = 0; j &lt; 25; j++) 	{@@ -36,6 +46,7 @@ 	Print_Char_18x16(Renderer, (Cursor_Position[0] * 18), (Cursor_Position[1] * 16), 0xDB); 	SDL_RenderPresent(Renderer);	 }+ void Print_Char_9x16(SDL_Renderer *Renderer, int x, int y, unsigned char Ascii_value) { 	for (int i = 0; i &lt; 9; i++)@@ -57,6 +68,12 @@ } void Mode_2_80x25(SDL_Renderer *Renderer, char* Video_Memory, char* Cursor_Position) {+do9x16++;+if(do9x16&gt;VIDU)+ {do9x16=0;}+else+ {return;}+ 	int index = 0; 	for (int j = 0; j &lt; 25; j++) 	{@@ -102,6 +119,12 @@ void Graphics_Mode_320_200_Palette_0(SDL_Renderer *Renderer, char* Video_Memory) {+do9x16++;+if(do9x16&gt;VIDU)+ {do9x16=0;}+else+ {return;}+ 	SDL_RenderClear(Renderer); 			int index = 0; 				 			for (int j = 0; j &lt; 100; j++)@@ -156,6 +179,12 @@ } void Graphics_Mode_320_200_Palette_1(SDL_Renderer *Renderer, char* Video_Memory) {+do9x16++;+if(do9x16&gt;VIDU)+ {do9x16=0;}+else+ {return;}+ 	SDL_RenderClear(Renderer); 			int index = 0; 			for (int j = 0; j &lt; 100; j++)</p><p> $ diff -run ver2 / vga.cpp ver2-j / vga.cpp --- ver2 / vga.cpp 2020-07-29 10：36：51.000000000 +0800 +++ ver2-j / vga.cpp 2021-06- 04 01：51：33.546124473 + 0800 @@ -1,5 +1,9 @@ #include＆＃34; vga.h＆＃34; + static int do9x16 = 0; +＃定义Vidu 5000 ++ void print_char_18x16（sdl_render *渲染器，int x，int y，无符号char ascii_value）{for（int i = 0; i＆lt; 9; i ++）@@ -23 ，6 +27,12 @@ void mode_0_40x25（sdl_renderer *渲染器，char * video_memory，char * cursor_position）{+ do9x16 ++; + if（do9x16＆gt; vidu）+ {do9x16 = 0;} + else + {return;} + int inde = 0; for（int j = 0; j＆lt; 25; j ++）{@@ -36,6 +46,7 @@ print_char_18x16（渲染器，（cursor_position [0] * 18），（cursor_position [1] * 16），0xdb ）; sdl_rederpresent（渲染器）; } + void print_char_9x16（sdl_renderer *渲染器，int x，int y，unsigned char ascii_value）{for（int i = 0; i＆lt; 9; i ++）@@ -57,6 +68,12 @@} void mode_2_80x25（ sdl_rederer *渲染器，char * video_memory，char * cursor_position）{+ do9x16 ++; + if（do9x16＆gt; vidu）+ {do9x16 = 0; +否则+ {return;} + int index = 0; for（int j = 0; j + 25; j ++）{@@ -102,6 +119,1212 @@ void graphics_mode_320_200_palette_0（sdl_renderer * renderer，char * video_memory）{+ do9x16 ++; + if（do9x16＆gt; vidu）+ {do9x16 = 0;} +否则+ {return;} + sdl_renderclear（渲染器）; int index = 0; for（int j = 0; j＆lt; 100; j ++）@@ -156,6 +179,1212 @@} void graphics_mode_320_200_palette_1（sdl_renderer *渲染器，char * video_memory）{+ do9x16 ++; + if（do9x16＆gt; vidu）+ {do9x16 = 0;} +否则+ {return;} + sdl_renderclear（渲染器）; int index = 0; for（int j = 0; j＆lt; 100; j ++） </p><p> While it feels more responsive on the console, it’s still incredibly slow. SI was returning the same speed which means that although we aren’t hitting the screen anywhere near as often it’s still doing far too much. Is it really a GPIO bus limitation? Again I have no idea. But the next function of course is the clock.</p><p>虽然在控制台上感觉更敏感，但它仍然令人难以置信的速度。 SI返回相同的速度，这意味着我们在尽可能靠近附近的任何地方击中屏幕，但它仍然太多。它真的是GPIO公交限制吗？我不知道。但是下一个函数当然是时钟。</p><p> First I tried dividing the usleep in half thinking that maybe it’s not getting called enough. And running SI revealed that I’d gone from a 0.3 to a 0.1! Obviously this is not the desired effect! So instead of a divide I multiplied it by four:</p><p> 首先，我尝试将浏览的半人数分为一半，也许它不会被称为足够的话。并跑步透露，我从0.3到0.1开始！显然这不是所需的效果！所以我乘以四分之一的鸿沟：</p><p> diff -ruN ver2/timer.cpp ver2-j/timer.cpp --- ver2/timer.cpp	2020-08-12 00:32:13.000000000 +0800+++ ver2-j/timer.cpp	2021-06-04 02:06:25.505904407 +0800@@ -7,7 +7,7 @@ { while(Stop_Flag != true) {- usleep(54926); + usleep(54926*4); IRQ0(); } }</p><p> diff -Run Ver2 / Timer.cpp ver2-j / timer.cpp --- ver2 / timer.cpp 2020-08-12 00：32：13.000000000 +0800 ++ ver2-j / timer.cpp 2021-06-04 02：06：25.505904407 + 0800 @@ -7,7 +7,7 @@ {wher（stop_flag！= true）{ -  elleep（54926）; + ULEEP（54926 * 4）; IRQ0（）; }}</p><p>   Now it’s scoring a 1.5! Obviously these are all ‘magic numbers’ and tied to the Pi400 and more importantly I haven’t studied the code at all, I’m not trying to disparage or anything, if anything it’s just a quick example why profiling your code can be so important! At the same time trying to run games is so incredibly slow I don’t even know if my changes had any actual impact to speed as emulation of benchmarks can be such a finickie thing.</p><p>   现在它得分1.5！显然这些都是“魔法数字”并绑定到PI400，更重要的是我根本没有研究代码，我不是在尝试贬低或任何东西，如果这只是一个快速的例子，为什么分析你的代码是这样的重要的！与此同时，试图运行游戏是如此令人难以置信的速度慢我甚至不知道我的变化是否对速度的任何实际影响，因为基准的模拟可能是如此的Finickie的事情。</p><p>  My goto game, Battletech 3025 Crescent Hawks Inception loads to the first splash but then seems to hang. I could be impatient or there could be further issues but I’m just some impatient tourist with a C compiler…</p><p>  我的goto游戏，Battletech 3025 Crescent Hawks初始加载到第一个飞溅但似乎挂起。我可能会不耐烦，或者可能有进一步的问题，但我只是带有C编译器的一些不耐烦的旅游者......</p><p>  Each sample counts as 0.01 seconds. % cumulative self self total time seconds seconds calls us/call us/call name 95.41 129.23 129.23 22696621 5.69 5.69 Read_Memory_Array(unsigned long long, char*, int) 2.90 133.15 3.92 Start_System_Bus(int) 0.88 134.34 1.19 64369074 0.02 0.02 CLK() 0.30 134.74 0.40 keyboard() 0.16 134.96 0.22 412873 0.53 0.53 Print_Char_9x16(SDL_Renderer*, int, int, unsigned char) 0.08 135.07 0.11 11273939 0.01 0.01 Data_Bus_Direction_8086_OUT()</p><p>  每个样本计数为0.01秒。 ％累积自我自我总时间秒秒拨打我们/呼叫美国/呼叫名称95.41 129.23 129.23 22696621 5.69 5.69 READ_MEMORY_ARRAY（无符号长长，CHAR *，INT）2.90 133.15 3.92 START_SYSTEM_BUS（INT）0.88 134.34 1.19 64369074 0.02 0.0.020 0.0202 0.0202 134.74 0.40键盘（）0.16 134.96 0.22 412873 0.53 0.53 PRINT_CHAR_9X16（SDL_RENTERER *，INT，INT，INT，无符号CHAR）0.08 135.07 0.11 11273939 0.01 0.01 0.01 0.01 0.010101010100100.01 0.01 0.01</p><p> Which is now what I expect with the bulk of the emulation now calling Read_Memory, with the Clock following that and of course our tamed screen renderer (although its still called far too much!) with the Data_Bus_Direction being further down the list. No doubt some double buffering and checking what changed in between calls would go a LONG way to optimise it, just as would actually studying the source code.</p><p> 现在是我对现在调用Read_Memory的大部分仿真的预期，当然，当然我们的命名屏幕渲染器（虽然它仍然太多了！），但数据_bus_direction正在列表中进一步下降。毫无疑问，在呼叫之间发生了一些双重缓冲和检查，可以很长一段时间来优化它，就像实际研究源代码一样。 </p><p> The one cool thing about this is that if I wanted to write a PC emulator this way gives me the confidence that the CPU is not only 100% cycle accurate, but it’s 100% bug for bug accurate since we are using a physical processor.</p><p>关于这一点的那么很酷的是，如果我想写一个PC仿真器，请让我的信心让CPU不仅仅是100％的循环准确，而是因为我们使用物理处理器，这是Bug准确的100％错误。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://virtuallyfun.com/wordpress/2021/06/04/elijah-millers-nec-v30-on-a-pi-hat/">https://virtuallyfun.com/wordpress/2021/06/04/elijah-millers-nec-v30-on-a-pi-hat/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/miller/">#miller</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/int/">#int</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>