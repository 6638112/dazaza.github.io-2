<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>从流程外部注入Node.js / V8动态代码 Node.js/V8 dynamic code injection from outside of the process</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Node.js/V8 dynamic code injection from outside of the process<br/>从流程外部注入Node.js / V8动态代码 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-30 15:44:59</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/d32850774ccdc68bffdb78de329f5d34.png"><img src="http://img2.diglog.com/img/2021/1/d32850774ccdc68bffdb78de329f5d34.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Remote debugging is fun to play around with. This article describes a method to dynamically change the behavior of a running Node.js process by enabling the remote inspector interface and then use the Chrome debug protocol.</p><p>远程调试很有趣。本文介绍了一种方法，该方法可通过启用远程检查器界面，然后使用Chrome调试协议来动态更改正在运行的Node.js进程的行为。</p><p> On Linux and MacOS, it is possible to send a SIGUSR1 signal to a running Node.js process. The process will open a websocket server listening on local interfaces only. By connecting to the websocket server, one can start a debugging session on the Node.js process and therefore inject code into it. Eventually, one can shut down the websocket interface before disconnecting from the socket.</p><p> 在Linux和MacOS上，可以将SIGUSR1信号发送到正在运行的Node.js进程。该过程将打开仅在本地接口上侦听的websocket服务器。通过连接到Websocket服务器，可以在Node.js进程上启动调试会话，从而将代码注入其中。最终，人们可以在从套接字断开连接之前先关闭websocket接口。</p><p>  Instrumenting code is probably one of the coolest tasks I have ever been asked to perform. Sqreen for Node.js requires users to import the agent (an npm package named  sqreen) into their application so it can provide security features directly within the process.</p><p>  检测代码可能是我被要求执行的最酷的任务之一。 Sqreen for Node.js要求用户将代理（名为sqreen的npm软件包）导入其应用程序，以便它可以直接在该过程中提供安全功能。</p><p> Recently, I decided to challenge myself by seeing if I could do the same with the constraint of instrumenting an already running application. What follows here is a fun example of remote debugging in Node.js.</p><p> 最近，我决定挑战自己，看看我是否可以在检测已经运行的应用程序的约束下做同样的事情。接下来是一个有趣的Node.js远程调试示例。</p><p> Note: the method exposed in this blog post should not be used in production or in any real product. This article merely describes hacks I used to obtain an interesting result with remote debugging in Node.js. However, some of the tools I used here can be used to collect specific data regarding a production application. For instance, take a look at  my older post about memory leak debugging.</p><p> 注意：此博客文章中公开的方法不应在生产或任何实际产品中使用。本文仅描述了我用来通过Node.js中的远程调试获得有趣结果的黑客。但是，我在这里使用的一些工具可用于收集有关生产应用程序的特定数据。例如，看一下我关于内存泄漏调试的较早的文章。</p><p>  As described in a  previous article, is it possible to enable the debugger on a running Node.js process under the following conditions:</p><p>  如上一篇文章中所述，是否可以在以下情况下在正在运行的Node.js进程上启用调试器：</p><p>    If all these assumptions are true, then you can send the SIGUSR1 signal to the application. This can be done through the shell:</p><p>    如果所有这些假设都成立，那么您可以将SIGUSR1信号发送到应用程序。这可以通过外壳完成： </p><p>      At this point, we have successfully changed the state of the Node.js process and enabled the debugger. This can be confirmed by using Google Chrome or Chromium and checking the content of  chrome://inspect</p><p>至此，我们已经成功更改了Node.js进程的状态并启用了调试器。可以通过使用Google Chrome或Chromium并检查chrome：// inspect的内容来确认</p><p>   This is where the fun begins. Now that the process is running in debug mode, we want to connect to it and start using the  Chrome DevTools Protocol to find the instance of  http.Server and inject what we want to it.</p><p>   这就是乐趣的开始。现在，该进程正在调试模式下运行，我们希望连接到该进程并开始使用Chrome DevTools协议查找http.Server的实例，然后将所需的内容注入其中。</p><p> To do that, we will use the  chrome-remote-interface package: it will help us use the DevTools Protocol with a friendly programmatic interface. What we want to do is too advanced for us to do it with the Chrome DevTools for Node.js.</p><p> 为此，我们将使用chrome-remote-interface软件包：它将帮助我们将DevTools协议与友好的编程接口一起使用。对于我们来说，要使用Node.js的Chrome DevTools来完成我们想做的事情太先进了。</p><p> The goal here is to obtain a pointer on the instance of  http.Server running in the process to later change its state.</p><p> 这里的目标是获取在进程中运行的http.Server实例上的指针，以稍后更改其状态。</p><p>       The methods we use after are all part of this domain so we don’t need to enable any other domains. Should we need another one, we would need to enable it first too.</p><p>       我们之后使用的方法都是该域的一部分，因此我们不需要启用任何其他域。如果我们需要另一个，我们也需要首先启用它。</p><p>  The  Runtime.evaluate command runs an arbitrary expression in the remote process. In other words, we can run any code in the Node.js process we connected to. Here we do the following:</p><p>  Runtime.evaluate命令在远程进程中运行任意表达式。换句话说，我们可以在连接到的Node.js进程中运行任何代码。在这里，我们执行以下操作：</p><p> We use the  includeCommandLineAPI flag, without it, the  require method would not be provided to the script environment and the execution would return an error</p><p> 我们使用includeCommandLineAPI标志，如果没有该标志，则不会向脚本环境提供require方法，并且执行将返回错误 </p><p> The return value of this method contains a pointer to the prototype of  http.Server in the Node.js process heap. We will pass it to the following instruction</p><p>该方法的返回值包含一个指向Node.js进程堆中http.Server原型的指针。我们将其传递给以下指令</p><p>  These two calls give us a pointer to every instance of  http.Server based on the result of the previous call.  ServerPrototypeResult.result.objectId is a string referencing the value of  require(&#39;http&#39;).Server.prototype. On this string, we call  Runtime.queryObjects, which returns a pointer to an array. This array contains the list of objects which have  http.Server.prototype as a prototype.</p><p>  这两个调用根据先前调用的结果为我们提供了指向http.Server的每个实例的指针。 ServerPrototypeResult.result.objectId是一个字符串，引用了require（＆＃39; http＆＃39;）。Server.prototype的值。在此字符串上，我们调用Runtime.queryObjects，它返回一个指向数组的指针。此数组包含以http.Server.prototype作为原型的对象列表。</p><p> We call  Runtime.getProperties on this array to obtain the list of properties of the array. There will be a property named  0 that will point to the instance of the HTTP server we want to identify (and if there is more than one object in the process with this same prototype, we would have more numbered properties).</p><p> 我们在此数组上调用Runtime.getProperties以获取该数组的属性列表。将有一个名为0的属性，该属性将指向我们要标识的HTTP服务器的实例（如果在使用同一原型的过程中有多个对象，则将有更多的编号属性）。</p><p>    serverInstance contains a string value that is our pointer to the instance of  http.Server running in the target process!</p><p>    serverInstance包含一个字符串值，该字符串值是我们指向目标进程中运行的http.Server实例的指针！</p><p>  Let’s say we can run a function with the HTTP server as an argument, how would we make it log every incoming request? I propose the following function:</p><p>  假设我们可以使用HTTP服务器作为参数来运行一个函数，如何使它记录每个传入的请求？我提出以下功能：</p><p>   Get the list of listeners on the  ’request’ event of the HTTP server</p><p>   在HTTP服务器的“请求”事件中获取侦听器列表</p><p>  Wrap the listeners with a function that will log the HTTP method and URL for all incoming HTTP requests</p><p>  使用将为所有传入HTTP请求记录HTTP方法和URL的函数包装侦听器 </p><p> Now, how do we inject that on the instance of  http.Server? Well, let’s do it using the pointers we found in the previous part of this article. To do it, let’s add the following code to our remote debugger script.</p><p>现在，我们如何将其注入到http.Server实例上？好吧，让我们使用在本文前面的部分中找到的指针进行操作。为此，我们将以下代码添加到我们的远程调试器脚本中。</p><p>  The first call to  Runtime.evaluate loads the  patchListeners function and attaches it to  process. This is because we can’t use the  includeCommandLineAPI argument on  Runtime.callFunctionOn and therefore,  require will never be defined when using it.</p><p>  对Runtime.evaluate的首次调用将加载patchListeners函数并将其附加到进程。这是因为我们无法在Runtime.callFunctionOn上使用includeCommandLineAPI参数，因此在使用它时将永远不会定义require。</p><p> Runtime.callFunctionOn will call a given function with the value for  this defined by the  objectId argument.</p><p> Runtime.callFunctionOn将使用由objectId参数定义的值来调用给定函数。</p><p> So we call the function  function() { process.patchListeners(this) } with  this being the value referred by the pointer in  serverInstance.  serverInstance is a pointer to the HTTP server!</p><p> 因此，我们将调用函数function（）{process.patchListeners（this）}，并将其作为serverInstance中指针所引用的值。 serverInstance是指向HTTP服务器的指针！</p><p> After doing this, we call a script to delete the ugly pollution we added on the  process object.</p><p> 完成此操作后，我们调用一个脚本来删除添加到过程对象上的丑陋污染。</p><p> At the end, we can disable the debug mode and disconnect from the instance using</p><p> 最后，我们可以使用以下命令禁用调试模式并与实例断开连接</p><p>      And the injector (we assume that the  patchListeners function is in a module named  toInject.js):</p><p>      还有注入器（我们假设patchListeners函数位于名为toInject.js的模块中）： </p><p>  When we start the server and run a few HTTP requests against the server, it logs nothing. Now, when we executed the injector script against it (after having placed it in debug mode), it produces the following logs:</p><p>当我们启动服务器并对服务器运行一些HTTP请求时，它什么也不记录。现在，当我们对其执行注入程序脚本（将其置于调试模式之后）时，它将生成以下日志：</p><p>  Note that even if there are no logs to show it, the debugger has been disabled and we would need to send the USR1 signal again if we want to connect back to it.</p><p>  请注意，即使没有日志显示，调试器也已被禁用，如果我们想重新连接到它，我们将需要再次发送USR1信号。</p><p>  In this article, we took a running Node.js HTTP server and, from another local Node.js process, we were able to inject a script into it to make it log all incoming HTTP requests.</p><p>  在本文中，我们使用了一个正在运行的Node.js HTTP服务器，并且从另一个本地Node.js进程中，我们能够向其中注入脚本以使其记录所有传入的HTTP请求。</p><p> This highlights the power of the Chrome DevTools protocol: it is possible to programmatically change anything in a running process.</p><p> 这凸显了Chrome DevTools协议的强大功能：可以在运行过程中以编程方式更改任何内容。</p><p> I am not sure there is a real life/production usage for this method just yet, but there are countless cool tools that can be built to help debug and understand how a Node.js process works using the methods of this article. It was overall pretty fun to play with remote debugging in Node.js and hack around with such great tools.</p><p> 我不确定该方法是否具有现实生活/生产用途，但是可以构建许多凉爽的工具来帮助调试和了解使用本文方法的Node.js进程如何工作。在Node.js中进行远程调试并使用如此出色的工具进行破解，总体而言非常有趣。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.sqreen.com/remote-debugging-nodejs-runtime-code-injection/">https://blog.sqreen.com/remote-debugging-nodejs-runtime-code-injection/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/v8/">#v8</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>