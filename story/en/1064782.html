<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>我打破了你吗？ 反向依赖性验证 Did I break you? Reverse dependency verification</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Did I break you? Reverse dependency verification<br/>我打破了你吗？ 反向依赖性验证 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-10 15:33:30</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/12b2155fb5a3543f8b2db27d1a41020e.jpg"><img src="http://img2.diglog.com/img/2021/6/12b2155fb5a3543f8b2db27d1a41020e.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>SoundCloud was founded 13 years ago, and throughout its history, the company and much of its tech stack has changed. We started with a  monolithic Ruby on Rails app, and since then, have worked to  extract, isolate, and reuse logic in many subsystems, and later on in separate microservices. We  introduced different storage mechanisms and data analysis apps, and our frontend has also expanded from a single website to mobile apps, integrations with third parties, an Xbox app, and more recently, a full-fledged PWA to run on Chromebooks.</p><p>SoundCloud成立于13年前，在整个历史中，公司和大部分技术堆栈都发生了变化。我们在Rails App上启动了一条单片Ruby，从那时起，已致力于在许多子系统中提取，隔离和重用逻辑，然后在单独的微服务中。我们介绍了不同的存储机制和数据分析应用程序，我们的前端也从一个网站扩展到移动应用程序，与第三方，Xbox App，最近，一个全面的PWA在Chromebook上运行。</p><p>  Internally, we’re committed to giving teams flexibility to pick whatever tools they deem best to solve the technological challenges of everyday product development. While this means a lot of autonomy, it also gradually led to a fragmented environment of languages, frameworks, processes, and documents, making cross-team collaboration and onboardability harder. We have, thus, moved into a model of providing sensible recommendations and supporting an opinionated tech stack.</p><p>  在内部，我们致力于为团队提供灵活性，以便选择他们认为最佳的任何工具，以解决日常产品开发的技术挑战。虽然这意味着很多自主权，但它也逐渐导致了一种碎片化的语言环境，框架，流程和文件，使跨团队协作和更难的责任。因此，我们迁移到提供合理的建议和支持自以为是的技术堆栈的模型。</p><p> In that sense,  complexity became opt-in: In general, libraries, tooling, and the engineering experience should be as simple as possible, with no configuration, but still provide the ability to support more complex use cases, depending on each problem-requirement set.</p><p> 从那种意义上讲，复杂性变得选择：通常，图书馆，工具和工程经验应该尽可能简单，没有配置，但仍然可以提供支持更复杂的用例的能力，具体取决于每个问题 - 要求放。</p><p> With time, we identified some similarities in the implementations of our solutions and naturally repeated choices. Engineers experienced with a given programming language were more likely to pick the same for a following project, while in other cases, the ease of integration with, say, a specific database engine pushed a new integrator to decide for it again. We  built more tooling to help develop these existing apps, we wrote more documentation to cover the “gotchas” of a framework,  standards arose to organize the system architecture, etc.</p><p> 随着时间的推移，我们在我们解决方案的实施中确定了一些相似之处和自然反复选择。与给定的编程语言经验丰富的工程师更有可能为以下项目选择相同的可能性，而在其他情况下，可以易于集成，例如，特定数据库引擎推动了一个新的集成商再次决定。我们建立了更多的工具来帮助开发这些现有应用程序，我们写了更多的文档来涵盖框架的“Gotchas”，标准旨在组织系统架构等。</p><p> This cycle ended up consolidating some ideas as de facto  Golden Paths for our different disciplines: web development, data science, infrastructure, etc. Engineers are still free to choose their tooling, but the positive reinforcement cycle was already set: Why spend time  reinventing the wheel when lots has already been invested in building mature solutions? Drifts from the Golden Paths exist, but they’ve become increasingly rare.</p><p> 这个周期结束了将一些想法巩固为我们的不同学科的事实上的金色路径：Web开发，数据科学，基础设施等。工程师仍然可以自由选择他们的工具，但积极的加固周期已经设置：为什么花费时间重新调整时间批量已经投资建设成熟解决方案时？从金色的道路漂移存在，但他们越来越少见。</p><p>  We  settled on the Golden Path for developing backend applications in the JVM ecosystem. Since adopting  Twitter’s Finagle, we’ve also built extensive tooling on top, up to a point in which we could derive a library of our own: JVMKit, which helps building JVM applications by providing an implementation of common patterns and protocols used at SoundCloud.</p><p>  我们解决了在JVM生态系统中开发后端应用程序的金色路径。自从采用Twitter的FinAgle以来，我们还在顶部建立了广泛的工具，达到了我们可以推导出我们自己的库的一点：JVMKIT，它可以通过提供SoundCloud中使用的常用模式和协议的实现来帮助构建JVM应用程序。</p><p>  Because Scala applications make up the vast majority of apps at SoundCloud, JVMKit mainly targets them, but it should be possible to use from any other JVM language as well — we currently run services in Java,  Clojure, and  JRuby as well, even though we try to steer everybody toward the Golden Path. It provides opt-in modules for serving public traffic in the shape of BFFs, as well as integration with MySQL, Kafka, Memcached, and Prometheus, among other functionality.</p><p>  由于Scala应用程序在SoundCloud构成绝大多数应用程序，因此JVMKIT主要针对它们，但也可以从任何其他JVM语言中使用 - 我们目前在Java，Clojure和JRuby中运行服务，即使我们也是如此试着把每个人都转向金色的道路。它提供了选择加入模块，用于提供BFF的形式的公共流量，以及与MySQL，Kafka，Memcached和Prometheus的集成以及其他功能。 </p><p> With such a broad audience, it’s no surprise that JVMKit was largely adopted across SoundCloud, and it powers much of what we provide to our users — it became a critical component of our technology stack, with hundreds of services depending on it and thousands of instances running it in production.</p><p>通过如此广泛的受众，JVMKIT在很大程度上采用了SoundCloud，它毫不奇怪，它为我们提供的用户提供了大部分 - 它成为我们技术堆栈的关键组成部分，具体取决于它和数千个实例在生产中运行它。</p><p> JVMKit’s repository sees active development: New features, bug fixes, and security patches land every week. Different from an open source project, in which dependent projects are unknown, within the SoundCloud organization, we can draw a transparent view on all callers to JVMKit’s APIs to see which apps are lagging behind and which are on the straight cutting edge.</p><p> JVMKIT的存储库看到了活动开发：新功能，错误修复和安全补丁每周都在陆地。与开源项目不同，在SoundCloud组织中，依赖项目未知，我们可以在所有呼叫者到JVMKIT的API上绘制透明视图，以查看哪个应用程序滞后在后面，并且在直线边缘上。</p><p> We then ask ourselves: How exactly can we make sure the entire company follows JVMKit’s release cycle? As a platform team and developers of JVMKit, we want to minimize the disruptions to each team’s roadmap, onboarding into new APIs, replacement of deprecated calls, etc. In other words, we want to minimize the work we put on our colleagues’ plates so they can focus on higher objectives. For that, we have built automation to perform batch upgrades across all of our repositories — ideally, JVMKit upgrades are completely transparent.</p><p> 然后我们问自己：我们究竟如何确保整个公司遵循JVMKIT的发布周期？作为JVMKIT的平台团队和开发人员，我们希望将每个团队路线图的中断最大限度地减少到新的API，更换不推荐的电话等。换句话说，我们希望尽量减少我们在同事板上的工作他们可以专注于更高的目标。为此，我们建立了自动化，在我们所有的存储库中执行批量升级 - 理想情况下，JVMKIT升级完全透明。</p><p>  To identify which services depend on JVMKit, we rely on these relationships being explicitly defined in terms of code. As part of the previously introduced concept of the Golden Path for backend development, we do that through the build scripts that are part of each repository. For the majority of our backend repositories, this means  sbt builds. The same idea is applied to our other Golden Paths, with  Gradle on Android and npm for web development, for example:</p><p>  要确定哪些服务取决于JVMKIT，我们依靠这些关系在代码中明确定义。作为前面引入了后端开发的Golden Path概念的一部分，我们通过构建脚本来执行每个存储库的一部分。对于我们的大部分后端存储库，这意味着SBT构建。相同的想法适用于我们的其他金色路径，Android和NPM的Gradle和Web开发，例如：</p><p> val jvmkitVersion  =  &#34;15.0.0&#34; lazy  val root  =  (project in file ( &#34;.&#34; ) )  .settings ( libraryDependencies  ++ = Seq (  &#34;com.soundcloud&#34;  % %  &#34;jvmkit-admin-server&#34;  % jvmkitVersion ,  &#34;com.soundcloud&#34;  % %  &#34;jvmkit-json-play&#34;  % jvmkitVersion ,  . . .  )  )</p><p> Val JVMKitVersion =＆＃34; 15.0.0＆＃34; Lazy Val Root =（文件中的项目（＆＃34;。＆＃34;））.settings（librarydependencies ++ = seq（＆＃34; com.soundcloud＆＃34;％＆＃34; jvmkit-admin-server＆ ＃34;％JVMKitVersion，＆＃34; com.soundcloud＆＃34;％％＆＃34; jvmkit-json-play＆＃34;％jvmkitversion，......））</p><p> Every five minutes, changes to the default branch of each of SoundCloud’s repositories hosted on GitHub are indexed by  Zoekt, a search engine based on regular expression matching (read  this article for more in-depth information). Out of the box, Zoekt provides a web interface that we then make available to all SoundCloud engineers, but we also added the ability to query its results through a simple scripting API.</p><p> 每五分钟，通过Zoekt，基于正则表达式匹配的搜索引擎索引GitHub上托管的每个SoundCloud的存储库的默认分支的更改（阅读本文以获取更多深度信息）。在框中，Zoekt提供了一个Web界面，然后我们可以为所有SoundCloud工程师提供，但我们还添加了通过简单的脚本API查询结果的能力。</p><p>  By combining Zoekt’s API and the standardization across the company, we can write a simple query like  &#34;jvmkit&#34; f:^build.sbt and list all the projects that depend on JVMKit — in other words, we can build a level of the reverse dependency graph in which JVMKit is the root.</p><p>  通过组合Zoekt的API和整个公司的标准化，我们可以写一个简单的查询，如＆＃34; JVMKIT＆＃34; f：^ build.sbt并列出依赖于jvmkit的所有项目 - 换句话说，我们可以构建一个级别的反向依赖图，其中jvmkit是根。 </p><p>  With these tools at hand, we can now start thinking about how we can automatically verify whether a change in JVMKit will integrate smoothly with other projects. For the sake of the example, let’s take an arbitrary service called  likes, which is responsible for managing which tracks each user liked on SoundCloud. If we were to write such an algorithm in pseudocode, this is how it would look:</p><p>使用这些工具手头，我们现在可以开始思考我们如何自动验证JVMKit的更改是否与其他项目顺利集成。为此示例，让我们参加名为喜欢的任意服务，这负责管理哪些跟踪SoundCloud上的用户。如果我们要在伪代码中编写这样的算法，这就是它的样子：</p><p> 1. Clone &#34;likes&#34; repository2. Find build.sbt3. Replace the jvmkitVersion value with the latest snapshot4. Compile &#34;likes&#34;</p><p> 1.克隆＆＃34;喜欢＆＃34; repository2。查找build.sbt3。用最新的快照4替换JVMkitVersion值。编译＆＃34;喜欢＆＃34;</p><p> If all steps in the algorithm succeed, we guarantee that the new changes in JVMKit didn’t cause issues with  likes. We can generalize this idea and run the algorithm for each and every repository we previously identified as reverse dependencies of JVMKit — if all of them succeed, the new JVMKit version is good to go!</p><p> 如果算法中的所有步骤成功，我们保证了JVMKIT的新变化并没有引起类似的原因。我们可以概括这个想法并运行我们之前被标识为JVMKIT的反向依赖性的每个存储库的算法 - 如果所有这些都成功，新的JVMKIT版本很好！</p><p> Our work is done, right? Not really. There are other cases that our algorithm currently doesn’t consider. For instance, what happens if we were planning to release a JVMKit version and coincidentally on that day, the  main branch of  likes was broken? We shouldn’t consider it the fault of that JVMKit version’s bump. To isolate that scenario, we can compile the target project with no changes whatsoever.</p><p> 我们的工作完成了，对吗？并不真地。还有其他情况下我们的算法目前不考虑。例如，如果我们计划释放JVMKIT版本并在那一天巧合，那么喜欢的原因，那么喜欢的主要分支被打破了？我们不应该认为这是jvmkit版本的凹凸的错。要隔离那种情况，我们可以编译目标项目，没有任何变化。</p><p> If JVMKit’s new version introduces an API-breaking change — requiring, thus, a  major version bump — we allow for the engineers running the upgrade to automatically fix the breaking change by executing a set of processors directly in the repositories source code with tools like  sed,  awk,  lint, etc.</p><p> 如果JVMKIT的新版本引入了一个API破坏性的变化，因此需要一个主要版本颠簸 - 我们允许通过直接在存储库源代码中直接执行一组处理器来自动修复升级的工程师自动修复破坏性更改，awk，棉绒等。</p><p> Now, when the release is a minor or patch change, surely the project will compile, but does it behave as we expect it to? We should also run automated tests to ensure our business logic is still respected. Once again, here we can leverage the standardization provided by the Golden Path: All Scala projects that are built with  sbt will execute their tests with the same command:  sbt test.</p><p> 现在，当发布是一个次要或补丁变化时，肯定是项目将编译，但它表现得像我们期望的？我们还应该运行自动测试，以确保我们的业务逻辑仍仍然尊重。这里再一次，我们可以利用Golden Path提供的标准化：使用SBT构建的所有Scala项目都将使用相同的命令执行其测试：SBT测试。</p><p>  1. Clone &#34;likes&#34; repository2. Compile &#34;likes&#34;3. Run tests on &#34;likes&#34;4. Find build.sbt5. Replace the jvmkitVersion value with the latest snapshot6. Run source code processors for automatic API fixing7. Compile &#34;likes&#34;8. Run tests on &#34;likes&#34;</p><p>  1.克隆＆＃34;喜欢＆＃34; repository2。编译＆＃34;喜欢＆＃34; 3。运行测试＆＃34;喜欢＆＃34; 4。查找build.sbt5。用最新的快照6替换JVMKITversion值。运行自动API修复的源代码处理器7。编译＆＃34;喜欢＆＃34; 8。运行测试＆＃34;喜欢＆＃34; </p><p> With this, it becomes clearer who the culprit for a failure is, depending upon which step of this sequence the algorithm stops. We’re also more confident of a smooth integration if it completes successfully.</p><p>有了这个，它变得更加清晰，失败的罪魁祸首是算法停止的这一序列的步骤。如果成功完成，我们也更加对平滑集成。</p><p>  Instead of going through the described process manually and in an ad hoc fashion every time we decide to release a new build of JVMKit, we can develop the automation even further and leverage a continuous integration system to perform the checks for every single commit in the library repository.</p><p>  每次我们决定发布JVMKit的新版本时，我们都可以进一步开发自动化并利用持续的集成系统来开发自动化，而不是通过临时流行，而不是通过临时流程进行手动和临时时尚。存储库。</p><p> As mentioned earlier, at SoundCloud, we have hundreds of projects that rely on JVMKit, which makes compiling and running their tests a time-consuming task. To speed up JVMKit’s development and feedback loop, we decided to split the automation into two:</p><p> 如前所述，在SoundCloud，我们拥有数百个依赖JVMKIT的项目，它使得编译和运行其测试耗时的任务。要加快JVMKIT的开发和反馈循环，我们决定将自动化分为两个：</p><p> A nightly, long-running pipeline that verifies the new JVMKit against all projects in the organization</p><p> 一夜，长期运行的管道，可以验证新的JVMKIT针对组织中的所有项目</p><p> A faster pipeline, limited to a small allowlist of projects, that runs on every pull request</p><p> 一个更快的管道，限制为一个小的项目项目，在每个拉拉请求上运行</p><p> This is achieved through scripts that fetch project lists from Zoekt and translate them  into pipeline descriptors that can be ingested by our CD system. The generated pipelines include steps to run tests, depending on whether these exist on each of the target projects.</p><p> 这是通过从zoekt获取项目列表的脚本来实现的，并将它们转换为可以被我们的CD系统摄取的管道描述符。生成的流水线包括运行测试的步骤，具体取决于这些目标是否存在于每个目标项目上。</p><p> On top of that, in the real world, not all projects are well behaved. There are different reasons we might want to skip specific steps of the verification algorithm: when the test suite takes too long, if  it’s known to be flaky, or when the project needs a specific environment configuration or special dependencies that aren’t provided out of the box. For these cases, we also introduced a denylist that serves as input to the CI pipeline generator script.</p><p> 最重要的是，在现实世界中，并非所有项目都表现良好。我们可能希望跳过验证算法的具体步骤的原因：当测试套件花费太长时，如果已知是片状的，或者项目需要特定的环境配置或没有提供的特殊依赖项盒子。对于这些情况，我们还推出了一种校舍，用于输入CI管道发生器脚本的输入。 </p><p>   Observing the running pipelines is an engaging activity. Every day, we can have a view on how our projects will behave when moving forward, and when failures occur, it’s also easy to pinpoint reasons: If a single project failed due to an API change, we can dive into possible shortcomings of its implementations or uses of JVMKit’s APIs that weren’t originally intended. If many (or all) projects fail, then it’s obvious that the issue is with JVMKit itself, and we can quickly act on providing fixes.</p><p>观察运行管道是一种参与活动。每天，我们都可以了解我们的项目在前进时的行为如何，并且当发生故障时，它也很容易定位原因：如果单个项目由于API变化而失败，我们可以潜入其实现的可能性缺点或使用JVMKIT的API，其最初是最初的意图。如果许多（或全部）项目失败，那么问题很明显，问题与JVMKIT本身，我们可以快速行动提供修复程序。</p><p> We’ve reached an interesting point in our development practices for JVMKit after years of investment: With good tooling and automation in every step of the process, we’re confident when releasing a change to the library that powers dozens of teams, hundreds of systems, thousands of instances, and millions of users. We’re fearless about releasing JVMKit more often than ever with no impact or disruption to our team’s planned roadmap, while also ensuring technological standardization across SoundCloud.</p><p> 经过多年的投资后我们在JVMKIT的开发实践中达到了一个有趣的观点：在整个过程中的工具和自动化良好，我们在释放对图书馆的更改时，我们有信心为数十名队伍，数百个系统发布，数千个实例，数百万用户。我们无所畏惧地释放JVMKIT比以往任何时候都没有影响或中断我们的团队计划的路线图，同时还可以确保SoundCloud的技术标准化。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://developers.soundcloud.com/blog/did-i-break-you">https://developers.soundcloud.com/blog/did-i-break-you</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/依赖性/">#依赖性</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/jvmkit/">#jvmkit</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>