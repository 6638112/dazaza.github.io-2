<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Airdrop Anywhere  - 使它在Windows上工作 AirDrop Anywhere – Making it work on Windows</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">AirDrop Anywhere – Making it work on Windows<br/>Airdrop Anywhere  - 使它在Windows上工作 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-15 07:34:49</div><div class="page_narrow text-break page_content"><p>In  episode 3 we worked through an implementation of AirDrop using C# that allows receiving files between Apple devices. In this episode we’ll look at implementing the bits necessary to open this up to non-Apple devices.</p><p>在第3集中，我们通过使用C＃的AirDrop的实现工作，允许在Apple设备之间接收文件。在这一集中，我们将查看实现将其打开至非Apple设备所需的比特。</p><p>  Now that we can send files between Apple devices we’re in a good position to start opening things up to non-Apple devices. However, as mentioned in  episode 1, it is unlikely that a non-Apple device has hardware support for adhoc wireless connections between devices. This makes implementation of AirDrop  directly on non-Apple devices practically impossible without additional hardware. Instead we’ll implement a proxy that can run on a platform with supported hardware (e.g. an Apple device or Linux device running  OWL).</p><p>  既然我们可以在Apple设备之间发送文件，我们处于一个很好的位置，开始向非Apple设备开放。然而，如集中1中所述，非Apple设备不太可能对设备之间的ADHOC无线连接具有硬件支持。这使得AirDrop的实施直接在非Apple设备上实际上不可能，无需额外的硬件。相反，我们将实现一个可以在具有支持硬件的平台上运行的代理（例如，Apple设备或运行owl的Linux设备）。</p><p> Initially I thought that splitting things into three projects was the sanest approach to building this -  AirDropAnywhere.Core would contain the core parts implementing the AirDrop protocol with  AirDropAnywhere.Cli containing the CLI components and  AirDropAnywhere.Web containing a set of endpoints to support non-Apple devices. Instead I’ve decided to collapse hosting of all server  and client pieces into  AirDropAnywhere.Cli - this simplifies the build pipeline and provides a single executable that can act as either a client or a server to our AirDrop implementation. In practice this is implemented using the  command support in Spectre.Console meaning the system now looks something like this:</p><p> 最初，我认为将事物分为三个项目是建立它的最理和方法 -  AirDropanywhere.Core将包含与Airdropanywhere.Cli的核心部分，其中包含CLI组件和AirdropanyWhere.Web包含一组端点以支持非Apple设备。相反，我决定将所有服务器和客户端部件托管到AirDropanywhere.Cli中 - 这简化了构建流水线，并提供了一个可执行文件，可以充当客户端或服务器到我们的AirDrop实现。在实践中，这是使用频谱中的命令支持来实现的.Console意味着系统现在看起来像这样的东西：</p><p>  Let’s run through some of the key concepts in the design and then dig into implementation details&amp;mldr</p><p>  让我们通过设计中的一些关键概念，然后挖掘实施细节和amp; mldr</p><p>  In order to support non-AirDrop devices we need to have the concept of a “peer” - an arbitrary client that connects to our server and is made discoverable to AirDrop-compatible devices. This becomes a core abstraction in the code and the mechanism in which various subsystems communicate with each other. Say hello to  AirDropPeer:</p><p>  为了支持非AirDrop设备，我们需要拥有“对等体”的概念 - 连接到我们服务器的任意客户端，并可在AirDrop-兼容设备中进行可发现。这成为代码中的核心抽象和各种子系统彼此通信的机制。对Airdroppeer说你好：</p><p> /// &lt;summary&gt; /// Exposes a way for the AirDrop HTTP API to communicate with an arbitrary peer that does /// not directly support the AirDrop protocol.  /// &lt;/summary&gt;  public  abstract  class  AirDropPeer {  /// &lt;summary&gt;   /// Gets the unique identifier of this peer.   /// &lt;/summary&gt;   public  string  Id  {  get ;  }  /// &lt;summary&gt;   /// Gets the (display) name of this peer.   /// &lt;/summary&gt;   public  string  Name  {  get ;  protected  set ;  }  /// &lt;summary&gt;   /// Determines whether the peer wants to receive files from a sender.    /// &lt;/summary&gt;   /// &lt;param name=&#34;request&#34;&gt;   /// An &lt;see cref=&#34;AskRequest&#34;/&gt; object representing information about the sender   /// and the files that they wish to send.   /// sender   /// &lt;/param&gt;   /// &lt;returns&gt;   /// &lt;c&gt;true&lt;/c&gt; if the receiver wants to accept the file transfer, &lt;c&gt;false&lt;/c&gt; otherwise.   /// &lt;/returns&gt;   public  abstract  ValueTask &lt; bool &gt;  CanAcceptFilesAsync ( AskRequest  request );  /// &lt;summary&gt;   /// Notifies the peer that a file has been uploaded. This method is for every   /// file extracted from the archive sent by an AirDrop-compatible device.   /// &lt;/summary&gt;   /// &lt;param name=&#34;filePath&#34;&gt;   /// Path to an extracted file.   /// &lt;/param&gt;   public  abstract  ValueTask  OnFileUploadedAsync ( string  filePath ); }</p><p> ///＆lt;＆gt; ///对AirDrop HTTP API公开一种方法，以与任意对等体进行通信// /不直接支持AICDrop协议。 ///＆lt; //摘要＆gt;公共抽象类Airdroppeer {///＆lt;摘要＆gt; ///获取此对等体的唯一标识符。 ///＆lt; //摘要＆gt;公共字符串ID {GET; } ///＆lt;摘要＆gt; ///获取此对等体的（显示）名称。 ///＆lt; //摘要＆gt;公共字符串名称{GET;保护集; } ///＆lt;摘要＆gt; ///确定对等体是否要从发件人接收文件。 ///＆lt; //摘要＆gt; ///＆lt; param name =＆＃34;请求＆＃34;＆gt; ///一个＆lt;见Cref =＆＃34; askrequest＆＃34; /＆gt;代表有关发送方///的信息以及他们希望发送的文件的信息。 ///发件人////＆lt; / param＆gt; ///＆lt;返回＆gt; ///＆lt; c＆gt; true＆lt; / c＆gt;如果接收器想要接受文件传输，则＆lt; c＆gt; false＆lt; / c＆gt;除此以外。 ///＆lt; /返回＆gt;公共抽象百分表＆lt; BOOL＆GT; canacceptfileSasync（askrequest请求）; ///＆lt;＆gt; ///通知对等体已上载文件。此方法用于从ACTrop兼容设备发送的存档中提取的每个///文件。 ///＆lt; //摘要＆gt; /// <＆lt; param name =＆＃34; filepath＆＃34;＆gt; ///提取文件的路径。 ///＆lt; / param＆gt;公共抽象valuetask onfileuploadeDasync（字符串Filepath）; }</p><p> This is fairly straightforward - there’s a unique identifier for the peer, a display name and some methods to allow the AirDrop HTTP API to communicate with the peer. This is implemented as an abstract class rather than an interface because we need to manage the identifier in the framework - we use this as the host name in mDNS and AirDrop is particularly fussy about what characters it allows in the hostname. We simply use a random 12 character alpha-numeric identifier which satisfies AirDrop’s requirements and means the implementor doesn’t need to know about this detail.</p><p> 这相当简单 - 对等体的唯一标识符，显示名称和一些方法，以允许AirDrop HTTP API与对等体通信。这实现为抽象类而不是一个接口，因为我们需要管理框架中的标识符 - 我们将其使用它作为MDNS中的主机名和AirDrop在主机名中允许的字符尤为挑剔。我们只需使用满足AirDrop的要求的随机12个字符的alpha-numeric标识符，这意味着实现者不需要了解这个细节。 </p><p> An implementation of  AirDropPeer is provided by the underlying peering mechanism - in our case we’re allowing clients to connect using  SignalR over Websockets so we provide an implementation that layers upon its messaging protocol. When a peer connects to our server we register it so that the core pieces in  AirDropAnywhere.Core are aware of its presence. Similarly when the peer disconnects we unregister it. That functionality is exposed on   AirDropService:</p><p>AirDroppeer的实现是由底层的凝视机制提供 - 在我们的情况下，我们允许客户端在WebSock上使用SignalR连接，因此我们提供了一个在其消息传递协议上的应用程序。当对等体连接到我们的服务器时，我们注册它以便Airdrodwherewhere.Core中的核心作品意识到其存在。同样，当对等体断开连接时，我们无法注册。该功能在Airtropservice上暴露：</p><p> /// &lt;summary&gt; /// Registers an &lt;see cref=&#34;AirDropPeer&#34;/&gt; so that it becomes discoverable to /// AirDrop-compatible devices. /// &lt;/summary&gt; /// &lt;param name=&#34;peer&#34;&gt; /// An instance of &lt;see cref=&#34;AirDropPeer&#34;/&gt;. /// &lt;/param&gt;  public  ValueTask  RegisterPeerAsync ( AirDropPeer  peer ); /// &lt;summary&gt; /// Unregisters an &lt;see cref=&#34;AirDropPeer&#34;/&gt; so that it is no longer discoverable by /// AirDrop-compatible devices. If the peer is not registered then this operation is no-op. /// &lt;/summary&gt; /// &lt;param name=&#34;peer&#34;&gt; /// A previously registered instance of &lt;see cref=&#34;AirDropPeer&#34;/&gt;. /// &lt;/param&gt;  public  ValueTask  UnregisterPeerAsync ( AirDropPeer  peer ); /// &lt;summary&gt; /// Attempts to get an &lt;see cref=&#34;AirDropPeer&#34;/&gt; by its unique identifier. /// &lt;/summary&gt; /// &lt;param name=&#34;id&#34;&gt;Unique identifier of a peer.&lt;/param&gt; /// &lt;param name=&#34;peer&#34;&gt; /// If found, the instance of &lt;see cref=&#34;AirDropPeer&#34;/&gt; identified by &lt;paramref name=&#34;id&#34;/&gt;, /// &lt;c&gt;null&lt;/c&gt; otherwise. /// &lt;/param&gt; /// &lt;returns&gt; /// &lt;c&gt;true&lt;/c&gt; if the peer was found, &lt;c&gt;false&lt;/c&gt; otherwise. /// &lt;/returns&gt;  public  bool  TryGetPeer ( string  id ,  out  AirDropPeer  peer )</p><p> ///＆lt;＆gt; ///寄存器＆lt; see cref =＆＃34; airdroppeer＆＃34; /＆gt;这样它就会发现/// AirDrop-兼容设备。 ///＆lt; //摘要＆gt; ///＆lt; param name =＆＃34;同行＆＃34;＆gt; ///＆lt; see cref =＆＃34; airdroppeer＆＃34; /＆gt ;. ///＆lt; / param＆gt; Public ValueTask RegisterPeerAsync（Airdroppeer对等体）; ///＆lt;＆gt; /// verteators一个＆lt; see cref =＆＃34; airdroppeer＆＃34; /＆gt;因此，它不再可被/// AirDrop-兼容设备发现。如果未注册对等体，则此操作是NO-OP。 ///＆lt; //摘要＆gt; ///＆lt; param name =＆＃34;同行＆＃34;＆gt; ///先前注册的＆lt; see cref =＆＃34; airdroppeer＆＃34; /＆gt ;. ///＆lt; / param＆gt;公共valuetask unregisterpeeraSync（Airdroppeer对等体）; ///＆lt;＆gt; ///试图获得一个＆lt;参见cref =＆＃34; airdroppeer＆＃34; /＆gt;通过其唯一的标识符。 ///＆lt; //摘要＆gt; ///＆lt; param name =＆＃34; id＆＃34;＆gt;对等体的唯一标识符。＆lt; / param＆gt; ///＆lt; param name =＆＃34;同行＆＃34;＆gt; ///如果找到，则＆lt; see cref =＆＃34; airdroppeer＆＃34; /＆gt;由＆lt; paramref name =＆＃34; Id＆＃34; /＆gt; ///＆lt; c＆gt; null＆lt; ///＆gt;除此以外。 ///＆lt; / param＆gt; ///＆lt;返回＆gt; ///＆lt; c＆gt; true＆lt; / c＆gt;如果发现对等体，则为假＆lt; / c＆gt;除此以外。 ///＆lt; /返回＆gt; Public Bool TractetPeer（String ID，Out Airdroppeer对等体）</p><p> These methods provide the surface area needed for the core pieces of AirDrop Anywhere to make a non-AirDrop compatible device discoverable. Let’s break down how this interacts with other parts of the code.</p><p> 这些方法提供了核心AirDrop所需的表面积，以使非AITDOP兼容设备可发现。让我们分解它如何与代码的其他部分交互。</p><p>  When registering a peer  AirDropService creates an instance of  MulticastDnsService using the  Id property as the host &amp; instance names. It keeps track of the peer in a dictionary keyed by  Id. Then it tells  MulticastDnsServer to announce DNS records for that service over the  awdl0 interface - this is exactly what happened in the previous version of the code except we’re now dynamically announcing the existence of the peer rather than statically defining it. This announcement causes AirDrop to call the  /Discover HTTP API using the hostname announced via mDNS - in our case the hostname is the same as the unique identifier of the peer.</p><p>  注册对等体AirdroSeService时，使用ID属性作为主机和amp创建MulticastDNSService的实例;实例名称。它会跟踪由ID键入的字典中的对等体。然后它告诉MulticastDNSServer在AWDL0接口上宣布那个服务的DNS记录 - 这正是前一个版本的代码中发生的事情，除非我们现在动态地宣布对等体的存在而不是静态定义它。此公告导致AirDrop使用MDNS通知的主机名调用/发现HTTP API  - 在我们的情况下，主机名与对等体的唯一标识符相同。</p><p> AirDropRouteHandler has been modified to inject the instance of  AirDropPeer associated with a request when it is instantiated - it does this by extracting the first part of the host header and performing a lookup using  TryGetPeer. If that hostname resolves to an  AirDropPeer then it continues executing the request as usual, otherwise it returns an HTTP 404. I say “as usual”, but what does that mean for each API in AirDrop?</p><p> AirdroproTehandler已被修改为在实例化时注入与请求相关联的Airdroppeer实例 - 它通过提取主机标题的第一部分并使用TrygetPeer执行查找来实现此操作。如果该主机名解析为AirDroppeer，那么它将继续像往常一样执行请求，否则它会返回HTTP 404.我说“像往常”，但AirDrop中的每个API是什么意思？</p><p> /Discover - we’re currently operating in “Everybody” mode (instead of “Contacts-only” mode) so this API always returns details of the peer - notably its  Name for rendering in the AirDrop UI.</p><p> /发现 - 我们目前正在“每个人”模式（而不是“仅”联系人“模式），因此此API始终返回对等体的详细信息 - 特别是它的名称呈现在AirDrop UI中的呈现。</p><p> /Ask - previously this always consented - now it makes a blocking call to  AirDropPeer.CanAcceptFilesAsync to allow the peer to decide if the operation should continue or not</p><p> /询问 - 先前始终同意 - 现在它会阻止呼叫AirDroppeer.CanaCceptFileSAsync，以允许对等体决定操作是否应继续 </p><p> /Upload - previously this extracted uploaded files directly to the server’s file system. Not very useful! Now it notifies the peer of each file that was extracted and exposes that file to the peer via HTTPS to allow it to download it.</p><p>/上传 - 以前将上传的文件直接提取到服务器的文件系统。不是很有用！现在它通知对等待的每个文件通过HTTPS将该文件暴露给对等体以允许它下载它。</p><p>  Unregistration effectively does the opposite of registration - it removes any trace of the peer in the server and announces it over mDNS with a TTL of 0 seconds. Announcing with a 0s TTL causes downstream mDNS caches to discard the records associated with the peer, making it disappear from any AirDrop browsers. Removing it from our server’s state causes any requests to the HTTP API to return a 404 because  TryGetPeer does not return the peer anymore.</p><p>  卸载有效地与注册相反 - 它会删除服务器中的任何迹线，并通过0秒的TTL宣布通过MDNS宣布。使用0s TTL宣布导致下游MDNS缓存丢弃与对等体关联的记录，使其从任何AirDrop浏览器中消失。从服务器的状态删除它会导致HTTP API的任何请求返回404，因为TriceGeer不再返回对等体。</p><p>  We’ve discussed how peering is intended to work, so let’s dive into the implementation details for peering using SignalR. Out of the box SignalR provides connectivity via Websockets with fallback to server-sent events or long polling ( here is a good post on the differences between the transports), but it abstracts it all away using the concept of a “hub”. Clients connect to the hub and they can call methods on it or the server can call methods on the client - it’s a two way connection. Additionally we can implement  streaming from the server to the client or vice versa.</p><p>  我们已经讨论了窥视是如何旨在工作的，因此让我们潜入使用信号凝视的实现细节。出于框中的信号R通过WebSockets通过WebSockets提供连接到服务器发送的事件或长轮询（以下是运输之间的差异的好帖子），但它将其全部使用“集线器”的概念摘要。客户端连接到集线器，他们可以在其上调用方法或服务器可以在客户端上调用方法 - 这是两种连接。此外，我们可以从服务器实现流传输到客户端，反之亦然。</p><p> There are some restrictions on the server calling the client - notably that the client is unable to return a response to the server. However, by implementing bi-directional streaming, we can layer a fully async request/response mechanism on top of SignalR’s streaming capablities. Consider a hub with the following  method:</p><p> 对客户端的服务器有一些限制 - 特别是客户端无法返回对服务器的响应。但是，通过实施双向流，我们可以在信号传输的流级顶部层层层层上的完全异步请求/响应机制。考虑具有以下方法的集线器：</p><p> /// &lt;summary&gt; /// Starts a bi-directional stream between the server and the client. /// &lt;/summary&gt; /// &lt;param name=&#34;stream&#34;&gt; /// &lt;see cref=&#34;IAsyncEnumerable{T}&#34;/&gt; of &lt;see cref=&#34;AirDropHubMessage&#34;/&gt;-derived messages /// from the client. /// &lt;/param&gt; /// &lt;param name=&#34;cancellationToken&#34;&gt; /// &lt;see cref=&#34;CancellationToken&#34;/&gt; used to cancel the operation. /// &lt;/param&gt; /// &lt;returns&gt; /// &lt;see cref=&#34;IAsyncEnumerable{T}&#34;/&gt; of &lt;see cref=&#34;AirDropHubMessage&#34;/&gt;-derived messages /// from the server. /// &lt;/returns&gt;  public  async  IAsyncEnumerable &lt; AirDropHubMessage &gt;  StreamAsync (  IAsyncEnumerable &lt; AirDropHubMessage &gt;  stream ,  [ EnumeratorCancellation ]  CancellationToken  cancellationToken );</p><p> ///＆lt;＆gt; ///在服务器和客户端之间启动双向流。 ///＆lt; //摘要＆gt; ///＆lt; param name =＆＃34;流＆＃34;＆gt; ///＆lt;见Cref =＆＃34; Iasyncenumer {T}＆＃34; /＆gt; ＆lt;见Cref =＆＃34; AirdrophubMessage＆＃34; /＆gt;从客户端的消息///。 ///＆lt; / param＆gt; ///＆lt; param name =＆＃34; cancellationToken＆＃34;＆gt; ///＆lt;见Cref =＆＃34; cancellationToken＆＃34; /＆gt;用于取消操作。 ///＆lt; / param＆gt; ///＆lt;返回＆gt; ///＆lt;见Cref =＆＃34; Iasyncenumer {T}＆＃34; /＆gt; ＆lt;见Cref =＆＃34; AirdrophubMessage＆＃34; /＆gt;从服务器中使用的消息///。 ///＆lt; /返回＆gt;公共Async Iasyncencenomable＆lt; airdrophubmessage＆gt; Streamasync（IasyNcenumerAble＆lt; airdrophubmessage＆gt; Stream，[enumeratorsCancellation]消除了CancellationTokenToken）;</p><p> This allows the server to send messages to the client (via the returned  IAsyncEnumerable&lt;T&gt;) and for the client to send messages to the server via the  IAsyncEnumerable&lt;T&gt; stream parameter.  AirDropHubMessage generates a unique  Id for each sent message, and a  ReplyTo property containing the identifier of a message that the current message is in reply to. If  ReplyTo is not set then the message is considered to be unsolicited.</p><p> 这允许服务器向客户端发送消息（通过返回的ariasyncenumer＆lt; t＆gt;）和客户端通过IASyncenumerAble＆lt; t＆gt向服务器发送消息。流参数。 AirdrophubMessage为每个已发送的消息生成唯一ID，以及包含当前消息回复的消息的标识符的ReplyTo属性。如果未设置ReplyTo，则将消息被认为是未经请求的。</p><p> When a client connects to the hub it calls  StreamAsync and the server spins up a thread that is responsible for processing messages from the client’s  IAsyncEnumerable. It uses a   Channel&lt;T&gt; as the “queue” of messages produced by the server - as messages are posted to the  Channel&lt;T&gt; they are yielded to SignalR which sends them over the connection to the client.</p><p> 当客户端连接到集线器时，它调用StreamAxync，并且服务器旋转了一个负责从客户端的IASyncencomerable处理消息的线程。它使用通道＆lt; t＆gt;作为服务器产生的消息的“队列” - 作为消息发布到通道＆lt; t＆gt;它们被产生给信号函数，它通过与客户端的连接发送它们。 </p><p>  Under the hood the  T used in our  Channel&lt;T&gt; is actually a struct called  MessageWithCallback that contains an  AirDropHubMessage and an optional callback that is called if the message is in response to another message. Callbacks are handled by implementing  IValueTaskSource - this is the  ValueTask equivalent of using  TaskCompletionSource and allows consumers of our SignalR implementation of  AirDropPeer to  await the result of an operation, even though that result is happening asynchronously on another thread (the one handling messages from the client). We keep track of the callback by storing a message’s unique identifier and the  IValueTaskSource representing the callback in a  Dictionary associated with the connection. When a message is received from the client we check to see if the  ReplyTo property value is in that  Dictionary and, if so, we invoke the callback with the message from the client.</p><p>在我们的频道中使用的罩下方的罩下方＆lt; t＆gt;实际上是一个名为MessageWithCallback的结构，其中包含AirdrophubMessage和一个可选的回调，如果邮件响应另一个消息，则调用。通过实现ivaluetaskSource来处理回调 - 这是使用TaskCompletionsource的ValueTask等效，并且允许SignerR实现Airdroppeer的消费者等待操作的结果，即使该结果正在发生在另一个线程上（来自客户端的一个处理消息）发生）。通过存储消息的唯一标识符以及表示与连接关联的字典中的回调的唯一标识符以及IVALUETASKSource来跟踪回调。当从客户端接收到消息时，我们将检查replyto属性值是否在该字典中，如果是的话，我们可以使用客户端调用邮件的回调。</p><p> IValueTaskSource is relatively easy to implement, there’s a struct in the runtime that implements the majority of its logic called  ManualResetValueTaskSourceCore&lt;T&gt;, so our implementation, called   CallbackValueTaskSource, simply wraps it:</p><p> ivaluetasksource相对容易实现，运行时中有一个结构，它可以实现其大多数称为manualresetvaluetaskskourcecore＆lt; t＆gt;，所以我们的实现称为CallbackValuetAskource，只需包装它：</p><p> /// &lt;summary&gt; /// Implementation of &lt;see cref=&#34;IValueTaskSource{T}&#34;/&gt; that enables /// a request/response-style conversation to occur over a SignalR full /// duplex connection to a client. This is used to enable the hub to /// perform a callback. /// &lt;/summary&gt;  private  class  CallbackValueTaskSource  :  IValueTaskSource &lt; AirDropHubMessage &gt; {  private  ManualResetValueTaskSourceCore &lt; AirDropHubMessage &gt;  _valueTaskSource ;  public  void  SetResult ( AirDropHubMessage  message )  =&gt;  _valueTaskSource . SetResult ( message );  public  AirDropHubMessage  GetResult ( short  token )  =&gt;  _valueTaskSource . GetResult ( token );  public  ValueTaskSourceStatus  GetStatus ( short  token )  =&gt;  _valueTaskSource . GetStatus ( token );  public  void  OnCompleted (  Action &lt; object? &gt;  continuation ,  object?  state ,  short  token ,  ValueTaskSourceOnCompletedFlags  flags  )  =&gt;  _valueTaskSource . OnCompleted ( continuation ,  state ,  token ,  flags );  public  void  Reset ()  =&gt;  _valueTaskSource . Reset (); }</p><p> ///＆lt;＆gt; ///实现＆lt;见Cref =＆＃34; rivaluetasksource {t}＆＃34; /＆gt;这使得可以///请求/响应式对话，以发生与客户端的SignalR Full ///双工连接。这用于使集线器启用到///执行回调。 ///＆lt; //摘要＆gt;私人类CallbackValuetAskSource：ivalueTasksource＆lt; airdrophubmessage＆gt; {私有ManualResetValuetAskesourceCecore＆lt; airdrophubmessage＆gt; _valuetasksource; public void setresult（airdrophubmessage消息）=＆gt; _valuetasksource。 setResult（消息）;公共AirdrophubMessage GetResult（短令牌）=＆gt; _valuetasksource。 GetResult（令牌）;公众valuetaskesourcestatus getstatus（短令牌）=＆gt; _valuetasksource。 getStatus（令牌）;公共空白onCompleted（动作＆lt;＆gt;＆gt;延续，对象？状态，短令牌，valuetaskouskourceoncompletedflags标志）=＆gt; _valuetasksource。 OnCompleted（延续，州，令牌，旗帜）;公共void reset（）=＆gt; _valuetasksource。重启 （）; }</p><p> When a reply message is received, and we’ve found a callback, we simply call  SetResult(AirDropHubMessage) with the message. If a caller was  awaiting a  ValueTask that wraps the  IValueTaskSource it’ll resume execution.</p><p> 当收到回复消息时，我们发现了一个回调，我们只需用消息调用setResult（AirdrophubMessage）。如果呼叫者正在等待valueTask，它将恢复执行的ivaluetasksource。</p><p> It’s important to note the  Reset method on this class - in order to minimise allocations we use an [ ObjectPool(https://docs.microsoft.com/en-us/aspnet/core/performance/objectpool?view=aspnetcore-5.0) to keep a few instances of the class around for re-use. When we want an instance we call  ObjectPool.Get() to get one, use it and then return it to the pool when we’re done.  Reset allows us to safely re-use that instance later.</p><p> 重要的是要注意此类上的重置方法 - 以最大限度地减少我们使用[ObjectPool的分配（https://docs.microsoft.com/en-us/aspnet/core/performance/objectspool?view=aspnetcore-5.0）为了重复使用，保留课程的一些实例。当我们想要一个实例时，我们调用ObjectPool.get（）获取一个，请使用它，然后在我们完成时将其返回给池。重置允许我们稍后安全地重新使用该实例。</p><p> That’s a lot of words! Let’s take a look at how that works when implemented in the SignalR peer (note: code has been delibrately simplified for the post):</p><p> 这是很多话！让我们来看看它在SignalSR对等体中实现的工作原理（注意：代码已熟知帖子）：</p><p> // AirDropRouteHandler.AskAsync - simply calls `await` on the `CanAcceptFilesAsync` method  public  async  Task  AskAsync () {  var  askRequest  =  ...;  var  canAcceptFiles  =  await  _peer . CanAcceptFilesAsync ( askRequest );  // do stuff with result   // ...  } // AirDropHubPeer.CanAcceptFilesAsync  public  ValueTask &lt; bool &gt;  CanAcceptFilesAsync ( AskRequest  askRequest ) {  // transform the AskRequest into something understood by our SignalR client   CanAcceptFilesRequestMessage  request  =  ...;  // get a callback instance from our pool   var  callback  =  _callbackPool . Get ();  try  {  // write the request and its callback to the server&#39;s IAsyncEnumerable   await  _serverQueue . WriteAsync ( new  MessageWithCallback ( request ,  callback ));  // wait for the callback to be signalled, typically by a message being sent by the client   // on another thread. This call will block until that happens.   var  result  =  await  new  ValueTask &lt; AirDropHubMessage &gt;( this ,  _valueTaskSource . Version );  if  ( result  is  CanAcceptFilesResponseMessage  typedResult )  {  return  typedResult . Accepted ;  }  // should never happen, likely a bug!   throw  new  InvalidCastException (  $&#34;Cannot convert message of type {result.GetType()} to {typeof(CanAcceptFilesResponseMessage)}&#34;  );  }  finally  {  // we&#39;re done with the callback, return it to our pool   _callbackPool . Return ( callback );  } }</p><p> // airdroprotehandler.askasync  - 只需调用`canacceptfilessasync`方法public async任务Askasync（）{var askrequest = ...; var canacceptfiles = await _peer。 canacceptfilessasync（askrequest）; //使用结果// ...} // airdrophubpeer.canaCceptfilessync公共valuet ass＆lt; BOOL＆GT; canacceptfileSasync（Askrequest Askrequest）{//将askrequest转换为我们的signalr客户端canacceptfilesRequestMessage请求= ...; //从池var回调= _callbackpool获取回调实例。得到 （）;尝试{//将请求和其回调写入服务器＆＃39; s ariasyncenumer等待_serverqueue。 WriteAsync（New MessageWithCallback（请求，回调））; //通常通过客户端//在另一个线程上发送的消息来发信号通知回调。此呼叫将阻止，直到发生。 var结果=等待新的valuetask＆lt; airdrophubmessage＆gt;（这个，_valuetasksource。版本）;如果（结果是CANACceptFilesResponseMessage TypedEdResult）{返回typedResult。接受; } //永远不会发生，可能是一个错误！抛出新的InvalidcastException（$＆＃34;无法将类型{resule.gettype（）}的消息转换为{typeof（canacceptfilesresponsemessage）}＆＃34;）;最后{//我们＆＃39;重新完成回调，将其返回给我们的池_callbackpool。返回（回调）; }} </p><p> This might seem a little convoluted but it allows us to have a pretty useful request/response implementation over the top of a full duplex stream between our server and client. Importantly, the core pieces don’t need to know  any details on how messages are relayed to the peer, they just  await the call.</p><p>这可能似乎有点复杂，但它允许我们在服务器和客户端之间的完整双工流的顶部具有相当有用的请求/响应实现。重要的是，核心作品无需了解消息如何将消息转移到对等体，他们只是等待呼叫。</p><p>  By default SignalR uses  System.Text.Json to serialize/deserialize messages across the wire. Usually that works just fine but here we’re using bi-directional streaming with the abstract base class  AirDropHubMessage.  System.Text.Json has no idea how it should handle derivatives of this type so we need to give it a helping hand - enter   PolymorphicJsonConverter. This  JsonConverter reads and writes JSON associated with the  concrete type of the object but wraps it in a named field so that it knows what runtime  Type to deserialize to. We then add attributes to  AirDropHubMessage that teach the converter which mappings it should handle:</p><p>  默认情况下，Systemr使用system.text.json串行/反序列化电线的消息。通常，这正常好，但在这里我们正在使用双向流媒体与抽象基类AirdrophubMessage。 system.text.json不知道它应该如何处理这种类型的衍生物，所以我们需要提供帮助的手 - 进入多晶jsonconverter。此JsonConverter读取和写入与对象的具体类型相关联的JSON，但在命名字段中包装它，以便它知道要反序列化的运行时类型。然后，我们将属性添加到AirdrophubMessage，从而教授它应该处理的转换器的转换器：</p><p> [PolymorphicJsonInclude(&#34;connect&#34;, typeof(ConnectMessage))] // ... more mappings here ...  public  abstract  class  AirDropHubMessage {  public  string  Id  {  get ;  }  public  string?  ReplyTo  {  get ;  } } public  class  ConnectMessage  :  AirDropHubMessage {  public  string  Name  {  get ;  } }</p><p> [polymorphicjsoninclude（＆＃34; connect＆＃34; typeof（connectmessage））] // ...更多映射在这里...公共抽象类airdrophubmessage {public string id {get;公共字符串？回复{get;公共类ConnectMessage：AirdrophubMessage {公共字符串名称{GET; }}</p><p>   When deserializing the  connect key is used to lookup the right runtime type for the message - in this case  ConnectMessage is used. This lets us maintain our simple streaming signature using  IAsyncEnumerable&lt;AirDropHubMessage&gt; but allows us to pass any derived type to and from the connected parties.</p><p>   在使用Connect键来查找Connect键时，用于查找邮件的正确运行时类型 - 在这种情况下使用CONCHICMESSAGE。这使我们使用IASyncenuber＆lt; airdrophubmessage＆gt来维护我们的简单流签名。但允许我们将任何派生类型传递给连接的方。</p><p>  I mentioned above that our previous implementation of AirDrop’s  /Upload API just extracted files to the server’s file system. Now that we can relay things to a peer we can forward arrays of bytes representing chunks of a file to them directly, yay! Unfortunately the story doesn’t end there - if we connect to our SignalR server using a browser then our options for handling the array of bytes are somewhat limited - we need to construct a  Blob and once we have all the chunks we can use some creative hacks to get the browser to trigger a “download” to the user’s local machine. Except that we’ve already sent the bytes to the client so, in the case of large files, it’s quite possible that the  Blob is backed by memory or temporarily buffered somewhere else, likely with some kind of limits to prevent abuse.</p><p>  我提到的是，我们以前的AirDrop's / Upload API的实现只是将文件提取到服务器的文件系统。现在我们可以将事物转发给同行，我们可以直接向他们代表文件块的字节数阵列，即！不幸的是，这个故事没有结束那里 - 如果我们使用浏览器连接到我们的信号服务器服务器，那么我们处理字节数组的选项有点有限 - 我们需要构建一个Blob，一旦我们拥有所有块，我们就可以使用一些创意Hacks要获取浏览器触发“下载”到用户本地计算机。除了我们已经向客户发送了字节，否则在大文件的情况下，Blob通过内存支持或临时缓冲其他地方，可能有某种限制来防止滥用。</p><p> Instead I’ve added a  StaticFileProvider to the Kestrel instance spun up in the  AirDropAnywhere.Cli server instance that maps to an  uploads directory on the server. When we extract uploaded archives we generate a new directory here and new files are added to it. Once the archive is extracted we notify the client of each file that was extracted and its corresponding URL on the server - once the client has successfully downloaded all the files it needs then those files are removed from the server.</p><p> 相反，我向Kestrel实例旋转到AirDrodwhere.Cli Server实例中的Kestrel实例，它添加了一个staticfileprovider .cli服务器实例，该服务器实例将映射到服务器上的上载目录。当我们提取上传的存档时，我们将在此生成新目录，并将新文件添加到其中。提取存档后，我们通知客户端的每个文件提取，并在服务器上执行其对应的URL  - 一旦客户端成功下载了它所需的所有文件，那么从服务器中删除这些文件。</p><p> This allows us to stream the files directly to the client’s browser without any unnecessary buffering along the way - it’s a trade-off - we’re expecting the server to have storage space to extract any archives sent its way but we can rely on the client’s ability to download things directly rather than using semi-supported workarounds with  Blob and  File in the browser.</p><p> 这允许我们将文件直接将文件传输到客户端的浏览器，而无需沿途不必要的缓冲 - 它是一个权衡 - 我们期待服务器拥有存储空间来提取所有档案，但我们可以依赖客户端能够直接下载目标，而不是使用浏览器中的Blob和文件使用半支持的解决方法。 </p><p>  Now we have a (relatively) sane approach to peering we can implement our first consumer. This first consumer will run at the command line and it’ll perform the following steps:</p><p>现在我们有一个（相对）的理智方法来凝视我们可以实施我们的第一个消费者。第一个消费者将在命令行运行，它将执行以下步骤：</p><p> Connect to an AirDrop Anywhere server using SignalR and immediately send a  ConnectMessage containing the peer’s name. AirDrop will discover the peer via this announcement and call the  /Discover API over HTTPS.</p><p> 使用SignalR连接到AirDrop服务器，并立即发送包含对等名称的ConnectMessage。 AirDrop将通过此公告发现对等体，并通过HTTPS致电/发现API。</p><p> Wait for a  CanAcceptFileRequestMessage from the server. This is sent when a contact is tapped in the AirDrop UI, triggering a call to the  /Ask API over HTTPS. Once received, the CLI displays a prompt to the user asking if they want to accept the files being sent.</p><p> 等待来自服务器的CanaCceptFileRequestMessage。当联系人在AirDrop UI中删除联系人时，会发送此功能，触发通过HTTPS拨打/询问API。一旦收到，CLI会显示用户询问他们是否希望接受正在发送的文件的提示。</p><p> If they hit,  Yes then continue, otherwise go to 2. Either way, return the response as a  CanAcceptFileResponseMessage so the server knows to how to continue.</p><p> 如果它们击中，则为然后继续，否则转到2.无论哪种方式，将响应返回为canacceptfileresponsemessage，因此服务器知道如何继续。</p><p> For each file, receive a  FileUploadedRequestMessage and use the URL within it to download the file from the server.</p><p> 对于每个文件，接收FileUploadedRequestMessage并使用其中的URL从服务器下载文件。</p><p> All of this logic is wrapped up in   ClientCommand in the  AirDropAywhere.Cli project. This makes use of  Spectre.Console‘s wide array of formatting options to render the prompt and show output from the file download process.</p><p> 所有这些逻辑都在Airdropaywhere.Cli项目中在CliencMand中包装。这使得频谱.Console广泛的格式化选项，以呈现提示和从文件下载过程中显示输出。</p><p> There isn’t anything particularly “magic” in this implementation - it is a simple SignalR client that renders some UI and uses an  HttpClient to download files. The only quirks are ensuring that we ignore certificate validation errors when connecting over HTTPS for downloads or with SignalR - when running on a different machine the default ASP.N</p><p> 在此实现中没有特别的“魔法” - 它是一个简单的信号客户端，它呈现一些UI并使用HttpClient下载文件。唯一的怪癖是确保在通过HTTPS连接到下载或使用SignalR时忽略证书验证错误 - 在不同的计算机上运行默认ASP.N时 </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bakedbean.org.uk/posts/2021-06-airdrop-anywhere-part-4/">https://bakedbean.org.uk/posts/2021-06-airdrop-anywhere-part-4/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/making/">#making</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>