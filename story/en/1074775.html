<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>防锈1.59.0，带直列装配支架等。Rust 1.59.0 with inline assembly support etc.</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Rust 1.59.0 with inline assembly support etc.<br/>防锈1.59.0，带直列装配支架等。</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-25 08:30:00</div><div class="page_narrow text-break page_content"><p>The Rust team has published a new version of Rust, 1.59.0. Rust is a programminglanguage that is empowering everyone to build reliable and efficient software.</p><p>Rust团队发布了Rust的新版本1.59.0。Rust是一种编程语言，它使每个人都能够构建可靠高效的软件。</p><p>  Today&#39;s release falls on the day in which the world&#39;s attention is captured bythe sudden invasion of Ukraine by Putin&#39;s forces. Before going into the detailsof the new Rust release, we&#39;d like to state that we stand in solidarity with thepeople of Ukraine and express our support for all people affected by thisconflict.</p><p>今天&#39；在世界&#39；俄罗斯的注意力被普京突然入侵乌克兰所吸引&#39；美国军队。在讨论新防锈剂的细节之前，我们&#39；我谨声明，我们声援乌克兰人民，并对所有受这场冲突影响的人表示支持。</p><p>  If you have a previous version of Rust installed via rustup, you can get 1.59.0with:</p><p>如果您通过Rustop安装了Rust的早期版本，您可以通过以下方式获得1.59.0版本：</p><p>  If you don&#39;t have it already, you can  get  rustupfrom the appropriate page on our website, and check out the detailed release notes for 1.59.0 on GitHub.</p><p>如果你没有&#39；如果您还没有，您可以从我们网站上的相应页面获取RustUp，并在GitHub上查看1.59.0的详细发行说明。</p><p>   The Rust language now supports inline assembly. This enables many applicationsthat need very low-level control over their execution, or access tospecialized machine instructions.</p><p>Rust语言现在支持内联汇编。这使得许多应用程序需要对其执行进行非常低级的控制，或访问特定的机器指令。</p><p>  use std::arch::asm;// Multiply x by 6 using shifts and addslet mut x: u64 = 4;unsafe { asm!( &#34;mov {tmp}, {x}&#34;, &#34;shl {tmp}, 1&#34;, &#34;shl {x}, 2&#34;, &#34;add {x}, {tmp}&#34;, x = inout(reg) x, tmp = out(reg) _, );}assert_eq!(x, 4 * 6);</p><p>使用std:：arch:：asm；//使用移位和加法将x乘以6:u64=4；不安全的{asm！（&#34；mov{tmp}，{x}&#34；&#34；shl{tmp}，1&#34；&#34；shl{x}，2&#34；&#34；添加{x}，{tmp}&#34；，x=inout（reg）x，tmp=out（reg）#坚持！（x，4*6）；</p><p> The format string syntax used to name registers in the  asm! and  global_asm!macros is the same used in Rust  format strings, so it should feel quite familiarto Rust programmers.</p><p>asm中用于命名寄存器的格式字符串语法！还有全球运动！宏与Rust格式字符串中使用的宏相同，因此Rust程序员应该非常熟悉宏。</p><p> The assembly language and instructions available with inline assembly varyaccording to the target architecture. Today, the stable Rust compiler supportsinline assembly on the following architectures:</p><p>根据目标体系结构，内联汇编变量提供的汇编语言和指令。如今，稳定的Rust编译器支持以下体系结构上的在线组装：</p><p>  You can see more examples of inline assembly in  Rust By Example,and find more detailed documentation in the  reference.</p><p>您可以在Rust By Example中看到更多内联装配示例，并在参考资料中找到更详细的文档。</p><p>  You can now use tuple, slice, and struct patterns as the left-hand side of anassignment.</p><p>现在可以使用元组、切片和结构模式作为符号的左侧。</p><p> let (a, b, c, d, e);(a, b) = (1, 2);[c, .., d, _] = [1, 2, 3, 4, 5];Struct { e, .. } = Struct { e: 5, f: 3 };assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);</p><p>let（a，b，c，d，e）；（a，b）=（1，2）；[c，…，d，]=[1,2,3,4,5]；结构{e，…}=结构{e:5，f:3}；坚持！（[1,2,1,4,5]，[a，b，c，d，e]）；</p><p> This makes assignment more consistent with  let bindings, which have longsupported the same thing. Note that destructuring assignments with operatorssuch as  += are not allowed.</p><p>这使得赋值与let绑定更加一致，后者长期以来一直支持相同的东西。请注意，不允许使用运算符（如+=）来分解分配。</p><p>  Generic types can now specify default values for their const generics. Forexample, you can now write the following:</p><p>泛型类型现在可以为其常量泛型指定默认值。例如，您现在可以编写以下内容：</p><p> struct ArrayStorage&lt;T, const N: usize = 2&gt; { arr: [T; N],}impl&lt;T&gt; ArrayStorage&lt;T&gt; { fn new(a: T, b: T) -&gt; ArrayStorage&lt;T&gt; { ArrayStorage { arr: [a, b], } }}</p><p>结构阵列存储&lt；T、 常数N:usize=2&gt；{arr:[T；N]，}impl&lt；T&gt；ArrayStorage&lt；T&gt；{fn new（a:T，b:T）->ArrayStorage&lt；T&gt；{ArrayStorage{arr:[a，b]，}}}</p><p> Previously, type parameters were required to come before all const parameters.That restriction has been relaxed and you can now interleave them.</p><p>以前，类型参数必须位于所有常量参数之前。这一限制已经放宽，现在可以将它们交错。</p><p> fn cartesian_product&lt; T, const N: usize, U, const M: usize, V, F&gt;(a: [T; N], b: [U; M], f: F) -&gt; [[V; N]; M]where F: FnMut(&amp;T, &amp;U) -&gt; V{ // ...}</p><p>fn笛卡尔_积&lt；T、 常数N:usize，U，常数M:usize，V，F&gt；（a:[T；N]、b:[U；M]、f:f）——&gt；[V；N]；M] 其中F:FnMut（&amp；T，&amp；U）——&gt；V{/…}</p><p>  Sometimes bugs in the Rust compiler cause it to accept code that should nothave been accepted. An example of this was  borrows of packed structfields being allowed in safe code.</p><p>有时，Rust编译器中的错误会导致它接受本不应该被接受的代码。这方面的一个例子是在安全代码中允许借用压缩结构字段。</p><p> While this happens very rarely, it can be quite disruptive when a crate used byyour project has code that will no longer be allowed. In fact, you might notnotice until your project inexplicably stops building!</p><p>虽然这种情况很少发生，但当项目使用的板条箱中包含不再允许使用的代码时，这种情况可能会造成相当大的破坏。事实上，你可能不会注意到，直到你的项目莫名其妙地停止建设！</p><p> Cargo now shows you warnings when a dependency will be rejected by a futureversion of Rust. After running  cargo build or  cargo check, you might see:</p><p>Cargo现在会在依赖项被未来版本的Rust拒绝时向您显示警告。运行货物构建或货物检查后，您可能会看到：</p><p> warning: the following packages contain code that will be rejected by a future version of Rust: old_dep v0.1.0note: to see what the problems were, use the option `--future-incompat-report`, or run `cargo report future-incompatibilities --id 1`</p><p>警告：以下软件包包含的代码将被Rust的未来版本拒绝：old_dep v0。1.0注意：要查看问题所在，请使用选项“--future Compatibility report”，或运行“cargo report future Compatibilities--id 1”`</p><p> You can run the  cargo report command mentioned in the warning to see a fullreport of the code that will be rejected. This gives you time to upgrade yourdependency before it breaks your build.</p><p>您可以运行警告中提到的cargo report命令，查看将被拒绝的代码的完整报告。这让你有时间在依赖关系破坏你的构建之前升级它。</p><p>  It&#39;s often useful to strip unnecessary information like debuginfo from binariesyou distribute, making them smaller.</p><p>它&#39；从您分发的二进制文件中删除不必要的信息（如debuginfo）通常很有用，从而使它们变得更小。</p><p> While it has always been possible to do this manually after the binary iscreated, cargo and rustc now support stripping when the binary is linked. Toenable this, add the following to your  Cargo.toml:</p><p>虽然在创建二进制文件后一直可以手动执行此操作，但cargo和rustc现在在链接二进制文件时支持剥离。要启用此功能，请将以下内容添加到您的货物中。汤姆：</p><p>  This causes debuginfo to be stripped from release binaries. You can also supply &#34;symbols&#34; or just  true to strip all symbol information where supported.</p><p>这会导致debuginfo从发行版二进制文件中剥离。您还可以提供&#34；符号&#34；或者仅为true，以在支持的位置删除所有符号信息。</p><p> The standard library typically ships with debug symbols and line-leveldebuginfo, so Rust binaries built without debug symbols enabled still includethe debug information from the standard library by default. Using the  stripoption allows you to remove this extra information, producing smaller Rustbinaries.</p><p>标准库通常附带调试符号和行级别的DebugInfo，因此默认情况下，未启用调试符号的Rust二进制文件仍然包含标准库中的调试信息。使用stripoption可以删除这些额外信息，从而生成更小的二进制文件。</p><p>   The 1.59.0 release disables incremental by default (unless explicitly asked forby via an environment variable:  RUSTC_FORCE_INCREMENTAL=1). This mitigatesthe effects of a known bug,  #94124, which can cause deserialization errors (and panics) during compilationwith incremental compilation turned on.</p><p>1.59.0版本默认禁用增量（除非通过环境变量明确要求：RUSTC_FORCE_incremental=1）。这减轻了已知错误#94124的影响，该错误可能会在增量编译打开时的编译过程中导致反序列化错误（和恐慌）。</p><p> The specific fix for  #94124 has landed and is currently in the 1.60 beta,which will ship in six weeks. We are not presently aware of other issues thatwould encourage a decision to disable incremental in 1.60 stable, and if nonearise it is likely that 1.60 stable will re-enable incremental compilationagain. Incremental compilation remains on by default in the beta and nightlychannels.</p><p>#94124的具体补丁已经登陆，目前处于1.60测试版，将在六周后发布。我们目前还不知道会鼓励决定在1.60 stable中禁用增量编译的其他问题，如果没有出现，1.60 stable很可能会再次启用增量编译。默认情况下，beta和nightlychannels中的增量编译保持打开状态。</p><p> As always, we encourage users to test on the nightly and beta channels andreport issues you find: particularly for incremental bugs, this is the best wayto ensure the Rust team can judge whether there is breakage and the number ofusers it affects.</p><p>一如既往，我们鼓励用户在夜间和beta频道上进行测试，并报告您发现的问题：尤其是对于增量bug，这是确保Rust团队能够判断是否存在破损及其影响的用户数量的最佳方法。</p><p>       There are other changes in the Rust 1.59.0 release. Check out what changed in Rust, Cargo,and  Clippy.</p><p>Rust 1.59.0版本还有其他变化。看看锈迹、货物和Clippy发生了什么变化。</p><p>  Many people came together to create Rust 1.59.0.We couldn&#39;t have done it without all of you. Thanks!</p><p>许多人聚集在一起创造了Rust 1.59.0。我们不能&#39；没有你们所有人我做不到。谢谢</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/装配/">#装配</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/assembly/">#assembly</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>