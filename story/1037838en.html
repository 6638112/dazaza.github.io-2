<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在Apple Silicon上构建x86_64 Docker容器 Building x86_64 Docker containers on Apple Silicon</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Building x86_64 Docker containers on Apple Silicon<br/>在Apple Silicon上构建x86_64 Docker容器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-05 08:05:27</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/706ae3dab4ae4c26646c568f83376abd.png"><img src="http://img2.diglog.com/img/2020/12/706ae3dab4ae4c26646c568f83376abd.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>I recently bought a new M1 Macbook Pro. My old one, a mid-2012 Retina, recently took its final breath, so there was no time to wait. For developers, the M1 is definitely not ready, but I decided to live with a few months of difficult transition rather than buy something that would soon be outdated.</p><p>我最近购买了新的M1 Macbook Pro。我的旧车是2012年中的Retina，最近呼吸了最后一口气，因此没有时间等待。对于开发人员来说，M1肯定还没有准备好，但是我决定忍受几个月的困难过渡，而不是购买很快就会过时的东西。</p><p> One of the major components that at the time   of writing don’t work is  Docker, although it’s  apparently close. For many of us, having Docker work is critical to our workflow, and I wanted to see if I could make that happen before Docker is officially ready. Also, just because Docker is released for the M1 doesn’t mean we can use containers meant to run on  x86_64 seamlessly. The last part of this article is likely to be relevant for a good while, and understanding how emulation will support my work in the future is useful.</p><p> Docker在撰写本文时不起作用的主要组件之一是Docker，尽管它似乎很接近。对于我们许多人来说，拥有Docker工作对我们的工作流程至关重要，我想看看能否在Docker正式就绪之前实现这一目标。另外，仅因为Docker是为M1发布的，并不意味着我们可以使用可以在x86_64上无缝运行的容器。本文的最后一部分可能会涉及很长一段时间，因此了解仿真如何在将来支持我的工作将很有用。</p><p>  I’ll also note that my approach is unapologetically purist . We didn’t buy a laptop with a fancy new architecture to have it polluted by binaries from a world we left behind. Aside from what’s running inside your containers, and the Docker client, everything is running on the M1 without Rosetta 2.</p><p>  我还要指出，我的方法绝对是纯粹的。我们并没有购买具有新颖架构的笔记本电脑，以免被我们遗忘的世界中的二进制文件污染。除了容器中运行的内容以及Docker客户端之外，其他所有内容都在没有Rosetta 2的M1上运行。</p><p>  Install  Docker for Mac. It’s going to fail if you start it, but that’s fine. You now have the command line tools necessary, and they work. That’s it, you’re done.</p><p>  安装Mac的Docker。如果您启动它，它将失败，但这很好。现在，您有了必要的命令行工具，并且它们可以工作。就是这样，您完成了。</p><p>  Docker runs fine on other ARM-based systems, such as Ubuntu Focal. That’s what I’ll use here.</p><p>  Docker在其他基于ARM的系统（例如Ubuntu Focal）上运行良好。这就是我在这里使用的。</p><p>   There are several small projects that wrap the new virtualisation framework in  Big Sur. I landed on   vftool. Why? Because it turned out to be easy to avoid having a full XCode install to compile and run it, which is an overhead I’d like to avoid.</p><p>   有几个小项目在Big Sur中包装了新的虚拟化框架。我登陆了vftool。为什么？因为事实证明，避免完全安装XCode来编译和运行它很容易，所以我想避免这种开销。</p><p> First, we want a folder to keep all our stuff in. Make sure you have the XCode command line tools available, and then download and compile  vftool .</p><p> 首先，我们需要一个文件夹来保存所有内容。确保您具有可用的XCode命令行工具，然后下载并编译vftool。 </p><p> $ mkdir ubuntu-docker-m1 $ cd ubuntu-docker-m1 $ xcode-select --install &lt;Follow the on-screen instructions&gt; $ git clone  https://github.com/evansm7/vftool.git Cloning into &#39;vftool&#39;... &lt;...&gt; $ clang -framework Foundation -framework Virtualization vftool/vftool/main.m -o vftool/vftool.bin $ file vftool/vftool.bin vftool/vftool.bin: Mach-O 64-bit executable arm64</p><p>$ mkdir ubuntu-docker-m1 $ cd ubuntu-docker-m1 $ xcode-select --install＆lt;按照屏幕上的说明＆gt; $ git clone https://github.com/evansm7/vftool.git克隆到＆＃39; vftool＆＃39; ...＆lt; ...＆gt; $ clang -framework基础-framework虚拟化vftool / vftool / main.m -o vftool / vftool.bin $文件vftool / vftool.bin vftool / vftool.bin：Mach-O 64位可执行文件arm64</p><p> Almost there, but not quite. We have  vftool installed, but if you run it with a kernel at this point, you’ll get an error:</p><p> 快要到了，但是不完全是。我们已经安装了vftool，但是如果此时使用内核运行它，则会出现错误：</p><p> Configuration vaildation failure! Error Domain=VZErrorDomain Code=2 “Virtualization requires the “com.apple.security.virtualization” entitlement” UserInfo={NSDebugDescription=Virtualization requires the “com.apple.security.virtualization” entitlement}</p><p> 配置验证失败！错误域= VZErrorDomain代码= 2“虚拟化需要“ com.apple.security.virtualization”授权” UserInfo = {NSDebugDescription =虚拟化需要“ com.apple.security.virtualization”授权}</p><p> To give it the entitlement, we need to sign the compiled binary. For that, you need a self-signed certificate. Open Keychain Access and use the Certificate Assistant to create one:</p><p> 为了赋予它权利，我们需要对编译后的二进制文件进行签名。为此，您需要一个自签名证书。打开钥匙串访问并使用证书助手创建一个：</p><p>  Clicking that will open a dialog. Set the certificate type to Code Signing, copy whatever is in the Name field, and create it.</p><p>  单击将打开一个对话框。将证书类型设置为“代码签名”，复制“名称”字段中的内容，然后创建它。</p><p>    You can run whatever Linux distribution you want, but I chose to run Ubuntu Focal’s cloud images (thanks,  droidix). We need a kernel, the initrd, and the disk image itself. We also need to decompress the kernel and the disk image.</p><p>    您可以运行所需的任何Linux发行版，但是我选择运行Ubuntu Focal的云映像（感谢droidix）。我们需要一个内核，一个initrd和磁盘映像本身。我们还需要解压缩内核和磁盘映像。</p><p>  We also want to resize the disk image, otherwise we’ll run out of space. This would be easy to do with  qemu-img , but it doesn’t compile natively on M1 with Homebrew. As I wrote earlier, this is a purist approach, so we’ll just use  dd . It’s hacky, but it works. Let’s give it, say, roughly 20 gigs. (We’ll resize the actual partition later.)</p><p>  我们还希望调整磁盘映像的大小，否则空间将用完。使用qemu-img可以很容易地做到这一点，但是它不能在带有Homebrew的M1上本地编译。如我先前所写，这是一种纯粹的方法，因此我们将仅使用dd。 hacky，但是可以用。让我们给它大约20个演出。 （我们稍后将调整实际分区的大小。） </p><p> $ ls -lh vm/focal-server-cloudimg-arm64.img -rw-r--r-- 1 chris staff 1.3G 4 Dec 17:02 vm/focal-server-cloudimg-arm64.img $ dd if=/dev/zero of=vm/focal-server-cloudimg-arm64.img seek=20000000 obs=1024 count=0 0+0 records in 0+0 records out 0 bytes transferred in 0.000011 secs (0 bytes/sec) $ ls -lh vm/focal-server-cloudimg-arm64.img -rw-r--r-- 1 chris staff 19G 4 Dec 17:03 vm/focal-server-cloudimg-arm64.img</p><p>$ ls -lh vm / focal-server-cloudimg-arm64.img -rw-r--r-- 1 chris人员1.3G 4 Dec 12:17 vm / focal-server-cloudimg-arm64.img $ dd if = / dev / zero of = vm / focal-server-cloudimg-arm64.img seek = 20000000 obs = 1024 count = 0 0 + 0记录在0 + 0记录中输出0个字节，以0.000011秒（0字节/秒）传输$ ls- lh vm / focal-server-cloudimg-arm64.img -rw-r--r-- 1 chris员工19G 4 Dec 17:03 vm / focal-server-cloudimg-arm64.img</p><p> Perfect. Now, let’s run this thing, but without specifying the root file system for now, so we can make some changes.</p><p> 完善。现在，让我们运行该程序，但现在无需指定根文件系统，因此我们可以进行一些更改。</p><p>  Run that, and note the TTY it’s connected to, which in this case for me was  /dev/ttys009 . Open a second terminal window and connect to it.</p><p>  运行该命令，并注意它所连接的TTY，在本例中为/ dev / ttys009。打开第二个终端窗口并连接到它。</p><p>  Copy and paste the following (again, with thanks to  droidix). This will change the root password to  root , and set up SSH and networking.</p><p>  复制并粘贴以下内容（再次感谢droidix）。这会将root密码更改为root，并设置SSH和网络。</p><p> mkdir /mnt mount /dev/vda /mnt chroot /mnt  touch /etc/cloud/cloud-init.disabled  echo &#39;root:root&#39; | chpasswd  ssh-keygen -f /etc/ssh/ssh_host_rsa_key -N &#39;&#39; -t rsa ssh-keygen -f /etc/ssh/ssh_host_dsa_key -N &#39;&#39; -t dsa ssh-keygen -f /etc/ssh/ssh_host_ed25519_key -N &#39;&#39; -t ed25519  cat &lt;&lt;EOF &gt; /etc/netplan/01-dhcp.yaml  network:  renderer: networkd  ethernets:  enp0s1:  dhcp4: true  version: 2 EOF</p><p> mkdir / mnt挂载/ dev / vda / mnt chroot / mnt touch /etc/cloud/cloud-init.disabled echo＆＃39; root：root＆＃39; | chpasswd ssh-keygen -f / etc / ssh / ssh_host_rsa_key -N＆＃39;＆＃39; -t rsa ssh-keygen -f / etc / ssh / ssh_host_dsa_key -N＆＃39;＆＃39; -t dsa ssh-keygen -f / etc / ssh / ssh_host_ed25519_key -N＆＃39;＆＃39; -t ed25519 cat＆lt;＆lt;＆lt; EOF＆gt; /etc/netplan/01-dhcp.yaml网络：渲染器：联网以太网：enp0s1：dhcp4：真实版本：2 EOF</p><p> Optionally, while you’re at it, add your SSH key for ease of access later.</p><p> （可选）在使用时添加您的SSH密钥，以便以后访问。</p><p>  We’re done here, so let’s make that known to the VM.</p><p>  我们已经完成了，所以让虚拟机知道这一点。 </p><p>    This time, run the VM with a root. I’ve also kicked up its allocated memory to two gigs for the moment, which seems to work fine for the purposes I’ve put it through so far. Change the  -m flag to whatever suits you.</p><p>这次，使用root用户运行VM。我还暂时将其分配的内存提高到了两个演出，这对于我到目前为止的目的来说似乎还不错。将-m标志更改为适合您的内容。</p><p>  Again, note the device, and use  screen to connect to it like above. You should be met with an Ubuntu login prompt, for which both the username and password is  root . If you set up your SSH key in the previous step, you can type  hostname -I to get the IP address of your virtual machine, and ssh into it with the root user. This allows you to detach  screen (hit Ctrl+A then D) if you find that annoying to deal with — the VM will happily live on without it attached. Either way, we now have Ubuntu ARM running in a virtual machine on M1.</p><p>  再次，注意该设备，然后像上面一样使用屏幕连接到该设备。应该会遇到一个Ubuntu登录提示符，其用户名和密码均为root。如果在上一步中设置了SSH密钥，则可以键入hostname -I来获取虚拟机的IP地址，然后以root用户身份将其SSH到其中。如果您发现要处理的烦人操作，这使您可以分离屏幕（先按Ctrl + A再按D）– VM将在不连接的情况下愉快地运行。无论哪种方式，我们现在都可以在M1的虚拟机上运行Ubuntu ARM。</p><p> # uname -a Linux ubuntu 5.4.0-56-generic #62-Ubuntu SMP Mon Nov 23 19:17:58 UTC 2020 aarch64 aarch64 aarch64 GNU/Linux</p><p> ＃uname -a Linux ubuntu 5.4.0-56-generic＃62-Ubuntu SMP Mon Nov 23 19:17:58 UTC 2020 aarch64 aarch64 aarch64 GNU / Linux</p><p> Remember I mentioned we need to resize the filesystem? Let’s get that done now.</p><p> 还记得我提到过我们需要调整文件系统的大小吗？让我们立即完成。</p><p> # resize2fs /dev/vda resize2fs 1.45.5 (07-Jan-2020) Filesystem at /dev/vda is mounted on /; on-line resizing required old_desc_blocks = 1, new_desc_blocks = 3 The filesystem on /dev/vda is now 5000000 (4k) blocks long.</p><p> ＃resize2fs / dev / vda resize2fs 1.45.5（2020年1月7日）/ dev / vda的文件系统安装在/;在线调整大小所需的old_desc_blocks = 1，new_desc_blocks = 3现在，/ dev / vda上的文件系统的长度为5000000（4k）个块。</p><p>   Now, from inside the VM, we want to set up the Docker daemon. Docker has  pretty good installation instructions, so you should read those. If you don’t want to do that, just do the following:</p><p>   现在，我们要在VM内部设置Docker守护程序。 Docker有相当不错的安装说明，因此您应该阅读这些说明。如果您不想这样做，请执行以下操作：</p><p> # apt-get update # apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common # curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - # add-apt-repository &#34;deb [arch=arm64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&#34; # apt-get update # apt-get install docker-ce docker-ce-cli containerd.io</p><p> ＃apt-get更新＃apt-get安装apt-transport-https ca证书curl gnupg-agent software-properties-common＃curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add-＃添加-apt-repository＆＃34; deb [arch = arm64] https://download.docker.com/linux/ubuntu $（lsb_release -cs）stable＆＃34; ＃apt-get更新＃apt-get安装docker-ce docker-ce-cli containerd.io </p><p> Note: At this point, my VM and my VPN (Mullvad) were not happy about each other’s presence, and the VM could not reach the internet unless I disconnected the VPN. Let me know if you find a solution.</p><p>注意：在这一点上，我的VM和VPN（Mullvad）对彼此的存在不满意，并且除非断开VPN的连接，否则VM无法访问Internet。让我知道您是否找到解决方案。</p><p> At this point, Docker is up and running. The installation suggests you run the  hello-world image, which you can do now if you want to.</p><p> 至此，Docker已启动并运行。安装建议您运行hello-world映像，您现在可以根据需要执行此操作。</p><p>  Now, let’s set up the Docker daemon to accept connections from the outside world. The instructions are  here, but again, you can follow my instructions if you’re lazy.</p><p>  现在，让我们设置Docker守护程序以接受来自外部世界的连接。说明在这里，但是如果您懒惰，也可以按照我的说明进行操作。</p><p> # mkdir -p /etc/systemd/system/docker.service.d/ # cat &lt;&lt;EOF &gt; /etc/systemd/system/docker.service.d/override.conf [Service] ExecStart= ExecStart=/usr/bin/dockerd EOF # cat &lt;&lt;EOF &gt; /etc/docker/daemon.json { &#34;hosts&#34;: [&#34;unix:///var/run/docker.sock&#34;, &#34;tcp://0.0.0.0:2375&#34;] } EOF # systemctl daemon-reload # systemctl restart docker.service</p><p> ＃mkdir -p /etc/systemd/system/docker.service.d/＃cat＆lt;＆lt; EOF＆gt; /etc/systemd/system/docker.service.d/override.conf [Service] ExecStart = ExecStart = / usr / bin / dockerd EOF＃cat＆lt;＆lt;＆lt;＆quot; EOF＆gt; /etc/docker/daemon.json {＆＃34; hosts＆＃34 ;: [＆＃34; unix：///var/run/docker.sock&#34 ;,＆＃34; tcp：//0.0.0.0 ：2375＆＃34;]} EOF＃systemctl守护进程重新加载＃systemctl重新启动docker.service</p><p>  # lsof -i | grep dockerd dockerd 5794 root 7u IPv6 38573 0t0 TCP *:2375 (LISTEN)</p><p>  ＃lsof -i | grep dockerd dockerd 5794根7u IPv6 38573 0t0 TCP *：2375（LISTEN）</p><p> The Docker daemon is set up and running. Make sure you get the IP address of the VM with  hostname -I, and let’s move on to the client.</p><p> Docker守护程序已设置并运行。确保获得主机名为-I的VM的IP地址，然后转到客户端。</p><p>  Now to the promised land. Make sure you have a terminal window in the VM (denoted with  #) and in macOS (denoted with  $ ) handy. First, make sure your Docker client knows where to find your server, replacing the IP address below with whatever you got from the VM.</p><p>  现在到应许之地。确保在VM（以＃表示）和macOS（以$表示）中都有方便的终端窗口。首先，确保您的Docker客户端知道在哪里可以找到您的服务器，将下面的IP地址替换为从VM获得的任何IP地址。 </p><p>  You can verify the connection by checking that the  hello-world image used above pops up.</p><p>您可以通过检查上面使用的hello-world图像弹出来验证连接。</p><p>  You can stop here if you just want to build images for ARM. Congratulations, you’ve done it. If Docker for Mac is updated for M1 in two days, you’ll probably feel like you just wasted a lot of time. If you want more, let’s venture on. It should be useful even after Docker is updated.</p><p>  如果您只想为ARM构建映像，则可以在此处停止。恭喜，您已经完成了。如果Docker for Mac在两天内更新了M1，您可能会觉得自己浪费了很多时间。如果您想要更多，那就冒险吧。即使在更新Docker之后，它也应该很有用。</p><p>  Buildx is an experimental feature in Docker. To enable experimental features in the client, we need to set the  experimental flag to  enabled in Docker’s configuration. If you haven’t made any changes to your Docker configuration, just run the following line. If you have, do it manually, or at least absolve me of any and all responsibility for mucking it up.</p><p>  Buildx是Docker中的一项实验性功能。要在客户端中启用实验性功能，我们需要在Docker的配置中将实验性标志设置为enabled。如果您尚未对Docker配置进行任何更改，请运行以下行。如果有的话，请手动进行，或者至少免除我承担任何将其分解的责任。</p><p>    $ mkdir container $ cd container $ cat &lt;&lt;EOF &gt; Dockerfile FROM python:3.9 WORKDIR /app COPY app.py . RUN pip install fastapi uvicorn EXPOSE 8000 CMD uvicorn --host 0.0.0.0 app:app EOF $ cat &lt;&lt;EOF &gt; app.py from fastapi import FastAPI app = FastAPI()  @app.get(&#34;/&#34;) def root():  return {&#34;message&#34;: &#34;Hello World&#34;} EOF</p><p>    $ mkdir容器$ cd容器$ cat＆lt;＆lt; EOF＆gt;来自python：3.9 WORKDIR / app COPY app.py的Dockerfile。运行pip install fastapi uvicorn EXPOSE 8000 CMD uvicorn --host 0.0.0.0 app：app EOF $ cat＆lt;＆lt;＆lt;＆lt;＆quot; EOF＆gt;从fastapi导入app.py FastAPI app = FastAPI（）@ app.get（＆＃34; /＆＃34;）def root（）：返回{＆＃34; message＆＃34 ;:＆＃34; Hello World＆＃ 34;} EOF</p><p> Let’s build and run that for  arm to see it running. You can open it in the browser on port  8000 with the IP address you got above.</p><p> 让我们来构建并运行该程序，以供其查看。您可以使用上面获得的IP地址在端口8000的浏览器中打开它。</p><p> $ docker buildx build --platform=linux/arm64 -t testimage:arm .  $ docker run -p 8000:8000 testimage:arm INFO: Started server process [6] INFO: Waiting for application startup. INFO: Application startup complete. INFO: Uvicorn running on  http://0.0.0.0:8000 (Press CTRL+C to quit)</p><p> $ docker buildx build --platform = linux / arm64 -t testimage：arm。 $ docker run -p 8000：8000 testimage：arm信息：服务器进程已启动[6]信息：等待应用程序启动。信息：应用程序启动完成。信息：在http://0.0.0.0:8000上运行的Uvicorn（按CTRL + C退出）</p><p> Note: The container did not quit gracefully sometimes. If that happens to you, go to the VM terminal window you have open, and type   docker kill $(docker ps -q)  , which kills all running containers.</p><p> 注意：有时容器不能正常退出。如果发生这种情况，请转到打开的VM终端窗口，然后键入docker kill $（docker ps -q），这将杀死所有正在运行的容器。 </p><p> If you try to build it for  x86_64, things don’t go as well:</p><p>如果您尝试将其构建为x86_64，则效果会有所不同：</p><p> $ docker buildx build --platform=linux/amd64 -t testimage:x86_64 . &lt;...&gt; failed to solve: rpc error: code = Unknown desc = failed to solve with frontend dockerfile.v0: failed to load LLB: runtime execution on platform linux/amd64 not supported</p><p> $ docker buildx build --platform = linux / amd64 -t testimage：x86_64。 ＆lt; ...＆gt;解决失败：rpc错误：代码=未知desc =使用前端dockerfile.v0无法解决：加载LLB失败：不支持平台linux / amd64上的运行时执行</p><p>  What we need is to emulate  x86_64 instructions so we can get a container built. Artur Klaser has an  article on getting this up and running for z computers building for  arm, but we want the opposite. We need to install a couple of things to make this work. Let’s turn back to the VM to get that running. This could take a while, so grab a drink while you’re at it.</p><p>  我们需要模拟x86_64指令，以便我们可以构建一个容器。 Artur Klaser上有一篇文章，介绍了如何在为手臂构建的z计算机上启动并运行它，但我们希望相反。我们需要安装一些东西才能使它工作。让我们回到虚拟机上运行它。这可能需要一段时间，因此请在喝时喝一杯。</p><p>  We also need to recreate the builder so  buildx understands that it has new platforms to target, and then use that one as our default:</p><p>  我们还需要重新创建该生成器，以便buildx知道它具有要定位的新平台，然后将其用作我们的默认平台：</p><p> $ docker buildx create --name builder $ docker buildx inspect builder --bootstrap &lt;...&gt; Platforms: linux/arm64, linux/amd64, linux/riscv64, linux/ppc64le, linux/s390x, linux/386 $ docker buildx use builder</p><p> $ docker buildx创建--name生成器$ docker buildx检查生成器--bootstrap＆lt; ...＆gt;平台：linux / arm64，linux / amd64，linux / riscv64，linux / ppc64le，linux / s390x，linux / 386 $ docker buildx use builder</p><p> That looks pretty good! Let’s try it out. You’ll probably notice that this is a bit slower than the first run, due to emulation. The  --load option below makes sure the image doesn’t just get discarded.</p><p> 看起来不错！让我们尝试一下。您可能会注意到，由于仿真，这比第一次运行要慢一些。下面的--load选项可确保图像不会被丢弃。</p><p>    And we’re done! This only works because the base image is available for multiple architectures, but many popular Docker images are. You’ve now got two images that built for  x86_64 and  arm respectively, and both run in your virtual machine — albeit one with emulation. If you run the newest image normally and visit the app in the browser, it works just fine.</p><p>    我们完成了！这仅起作用，因为基本映像可用于多种体系结构，但许多流行的Docker映像均可用。现在，您已经获得了两个分别针对x86_64和arm构建的映像，并且它们都在虚拟机中运行-尽管其中一个具有仿真功能。如果您正常运行最新图像并在浏览器中访问该应用程序，则可以正常运行。 </p><p>  I’m somewhat in awe of the amount of technology that lies beneath making this happen. We’ve got a brand new chip in the M1, containerisation, emulation, virtualisation — the amount of developer hours that have gone into making something like this work is astounding.</p><p>我对实现这一目标的技术深表敬畏。我们在M1中采用了全新的芯片，包括容器化，仿真和虚拟化，而花费在开发人员身上的时间却令人震惊。</p><p> There are still going to be some quirks in this setup.  qemu does not work perfectly, and most of its use in Docker seems to be from people on x86 architectures building for ARM, so any bugs the other way are likely to just be popping up now that M1s are being distributed. But if you’re building images that use interpreted code, with few or no compiled dependencies, this should work just fine! Adrian Mouat has a  blog post on the Docker Blog that explains further, and has some helpful alternatives to explore, including cross-compilation.</p><p> 在此设置中仍然会有一些怪癖。 qemu不能很好地工作，它在Docker中的大部分用途似乎来自为ARM构建的x86架构上的人们，因此，由于正在分发M1，因此可能会弹出其他错误。但是，如果您要构建使用解释性代码的图像，而编译后的依赖性很少甚至没有，那么这应该可以正常工作！ Adrian Mouat在Docker Blog上有一篇博客文章，对它进行了进一步说明，并提供了一些有用的替代方法，包括交叉编译。</p><p> PS: A much easier solution to this is to run an x86 virtual machine on the free tier of a cloud service of your choice. To do that,   install Docker , configure your daemon to   receive connections from the outside , and set   DOCKER_HOST  in your environment appropriately. No other options are required, as the machine you’re building on doesn’t know any better.</p><p> PS：一个更简单的解决方案是在您选择的云服务的免费层上运行x86虚拟机。为此，请安装Docker，将守护程序配置为从外部接收连接，并在您的环境中适当设置DOCKER_HOST。无需其他选择，因为您所构建的机器不会更好。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://ctolsen.medium.com/building-x86-64-docker-containers-on-apple-silicon-a6d868a18f37">https://ctolsen.medium.com/building-x86-64-docker-containers-on-apple-silicon-a6d868a18f37</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/docker/">#docker</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/silicon/">#silicon</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1037795.html"><img src="http://img2.diglog.com/img/2020/12/thumb_abadca5fdadfba28e35d76d0dfc9e7ee.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037795.html">史蒂夫·沃兹尼亚克（Steve Wozniak）与史蒂夫·乔布斯（Steve Jobs）共同创立苹果45年后，又成立了另一家公司 </a></div><span class="my_story_list_date">2020-12-5 4:59</span></div><div class="col-sm"><div><a target="_blank" href="/story/1037717.html"><img src="http://img2.diglog.com/img/2020/12/thumb_0f6e752d49e77a75fa4e2c66cf0a7b27.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037717.html">Apple的Screen Recognition是iOS14中的计算机视觉系统，对正在使用的应用程序的图像进行了培训，为盲人用户在屏幕上标记了UI元素 </a></div><span class="my_story_list_date">2020-12-4 22:57</span></div><div class="col-sm"><div><a target="_blank" href="/story/1037679.html"><img src="http://img2.diglog.com/img/2020/12/thumb_5594fb3a7534addecd8405c3b6d53cbe.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037679.html">苹果的MagSafe Duo充电器终于出现在在线商店中 </a></div><span class="my_story_list_date">2020-12-4 22:29</span></div><div class="col-sm"><div><a target="_blank" href="/story/1037650.html"><img src="http://img2.diglog.com/img/2020/12/thumb_1394300f6c3bbb5f1ca5985f5a01ce7f.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037650.html">开发人员现在可以注册苹果的“小型企业计划”，以降低App Store的费用 </a></div><span class="my_story_list_date">2020-12-4 22:12</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>