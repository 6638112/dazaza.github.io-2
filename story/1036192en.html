<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>可视解释SQL的递归Recursion in SQL Explained Visually</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Recursion in SQL Explained Visually<br/>可视解释SQL的递归</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-24 06:18:20</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/6eef9d2b6fe852a92f0be7e0c9e8e2b3.png"><img src="http://img2.diglog.com/img/2020/11/6eef9d2b6fe852a92f0be7e0c9e8e2b3.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Recursion in SQL? But why? Oh, there are many uses for that. It’s common to store hierarchical data   in SQL and recursive queries are convenient way to extract information from such graphs. Organizational structure, application menu structure, a set of tasks with sub-tasks in the project, links between web pages, breakdown of an equipment module into parts and sub-parts are examples of the hierarchical data. The post will not go into great details of those many use cases rather look onto two toy examples to understand the concept - simplest possible case of recursion on numbers and querying data from family tree.</p><p>在SQL递归？但为什么？哦，有很多用途。在SQL中通常存储分层数据，而递归查询是从此类图表中提取信息的便捷方法。组织结构，应用程序菜单结构，项目中带有子任务的一组任务，网页之间的链接，将设备模块分解为多个部分和子部分的内容就是分层数据的示例。这篇文章不会详细介绍许多用例，而是看两个玩具示例来理解这个概念-最简单的数字递归和从族谱中查询数据的案例。</p><p> Lets think about queries as a function. In a sense that a function takes an input and produces an output. Queries operate on relations or one could say tables. We will denote those as Rn. Here is a picture of a query. It takes three relations R1, R2, R3 and produces an output R. Simple enough.</p><p> 让我们考虑将查询作为函数。从某种意义上说，一个函数接受输入并产生输出。查询对关系进行操作，或者可以说表。我们将其表示为Rn。这是查询的图片。它具有三个关系R1，R2，R3，并产生输出R。足够简单。</p><p>  Query  (SELECT 1 AS n) now have a name —  R. We can refer to that name sometime later. Here  R is a single row, single column table containing number 1. The result of the whole expression is number 2.</p><p>  查询（SELECT 1 AS n）现在有一个名称-R。我们可以稍后再使用该名称。这里R是包含数字1的单行单列表。整个表达式的结果是数字2。</p><p>   For the recursion to work we need to start with something and decide when the recursion should stop. To achieve this, usually recursive  with statement has following form.</p><p>   为了使递归正常工作，我们需要从一些事情开始，并决定何时应停止递归。为了实现这一点，通常使用语句的递归具有以下形式。</p><p>  Important to note that base query doesn’t involve R, but recursive query references R. From the first look it seems like infinite loop, to compute R we need compute R. But here is a catch. R actually don’t reference itself, it just references previous result and when previous result is empty table, recursion stops. Actually it could help to thing of it as an iteration rather then recursion!</p><p>  重要的是要注意，基本查询不涉及R，但是递归查询引用R。从最初的样子看，似乎是无限循环，要计算R，我们需要计算R。但这很重要。 R实际上并不引用自身，它仅引用先前的结果，并且当先前的结果为空表时，递归将停止。实际上，它可以将其作为迭代而不是递归来帮助！</p><p> Here’s what is happening: base query executed first, taking whatever it needs to compute the result R0. Second recursive query is executed taking R0 as input, that is R references R0 in the recursive query when first executed. Recursive query produces the result R1 and that is what R will reference to at the next invocation. And so on until recursive query returns empty result. At that point all intermediate results are combined together.</p><p> 这是发生了什么：首先执行基本查询，并采用所需的任何方法来计算结果R0。以R0作为输入执行第二个递归查询，即R在第一次执行时在递归查询中引用R0。递归查询产生结果R1，这就是R在下一次调用时将引用的结果。依此类推，直到递归查询返回空结果。那时所有中间结果都合并在一起。</p><p>     Base query returns number  1 , recursive query takes it under the  countUp name and produces number  2, which is the input for the next recursive call. When recursive query returns empty table ( n &gt;= 3), the results from the calls are stacked together.</p><p>     基本查询返回数字1，递归查询将其以countUp名称命名并产生数字2，这是下一个递归调用的输入。当递归查询返回空表（n> = 3）时，调用结果将堆叠在一起。</p><p>  Watch out, counting up like that can only go that far. There is a limit for recursion. It defaults to 100, but could be extended with  MAXRECURSION option. Practically, it could be a bad idea to crank recursion limit up. Graphs might have cycles and limited recursion depth can be a good defense mechanism to stop poorly behaving query.</p><p>提防，这样算数只能走那么远。递归是有限制的。它的默认值为100，但可以使用MAXRECURSION选项进行扩展。实际上，提高递归限制可能不是一个好主意。图可能具有循环，并且有限的递归深度可能是阻止行为不佳的查询的良好防御机制。</p><p>     Base query finds Frank’s parent — Mary, recursive query takes this result under the  Ancestor name and finds parents of Mary, which are Dave and Eve and this continues until we can’t find any parents anymore.</p><p>     基本查询会找到Frank的父母-Mary，递归查询会以祖先的名字获取此结果，并找到Mary的父母Dave和Eve，一直到我们找不到任何父母为止。</p><p>   Now this tree traversal query could be the basis to augment the query with some other information of interest. For example, having a birth year in the table we can calculate how old the parent was when the child was born. Next query do exactly that, together with showing lineages. To do that it traverses the tree from top to bottom.  parentAge is zero in the first row because we don’t know when Alice was born from the data we have.</p><p>   现在，此树遍历查询可以成为用其他一些感兴趣的信息扩展查询的基础。例如，表中有出生年份，我们可以计算出孩子出生时父母的年龄。下一个查询完全可以做到这一点，并显示沿袭。为此，它从上到下遍历树。 parentAge在第一行中为零，因为我们无法从现有数据中得知爱丽丝何时出生。</p><p>  Take away — recursive query references the result of base query or previous invocation of recursive query. Chain stops when recursive query returns empty table.</p><p>  带走—递归查询引用了基础查询或递归查询的先前调用的结果。当递归查询返回空表时，链停止。</p><p> In the follow-up post we’ll take an algebraic view on SQL recursion and will look into recursive stored procedures.</p><p> 在后续文章中，我们将对SQL递归进行代数分析，并研究递归存储过程。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://denis-lukichev.medium.com/recursion-in-sql-explained-graphically-679f6a0f143b">https://denis-lukichev.medium.com/recursion-in-sql-explained-graphically-679f6a0f143b</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/递归/">#递归</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解释/">#解释</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sql/">#sql</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>