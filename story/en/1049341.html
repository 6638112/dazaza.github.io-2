<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>简而言之，Linux功能 Linux Capabilities in a Nutshell</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Linux Capabilities in a Nutshell<br/>简而言之，Linux功能 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-25 18:21:36</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/dbfe33dd2e22d977f42fb9753f23eea2.png"><img src="http://img2.diglog.com/img/2021/2/dbfe33dd2e22d977f42fb9753f23eea2.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Capabilities are being used more and more, mainly thanks to SystemD, Docker and orchestrators like Kubernetes. But I think the documentation is a bit hard to grasp and I found some parts of capabilities implementation confusing so I decided to condense my current knowledge into a shorter article.</p><p>功能的使用越来越多，这主要归功于SystemD，Docker和Kubernetes等编排器。但是我认为文档有点难掌握，并且发现功能实现的某些部分令人困惑，因此我决定将我的当前知识浓缩为一篇较短的文章。</p><p>  The most important reference for capabilities is up-to-date man page  capabilities(7). But that doesn’t provide an easy to read introduction.</p><p>  有关功能的最重要参考是最新的手册页功能（7）。但这并没有提供易于阅读的介绍。</p><p>  Permissions of regular users are very limited, while permissions of “root” user are very powerful. But processes running under “root” often don’t require full root capabilities.</p><p>  普通用户的权限非常有限，而“ root”用户的权限非常强大。但是在“ root”下运行的进程通常不需要完整的root功能。</p><p> To help reduce “root” user power, POSIX capabilities provides a way to restrict groups of privileged system operations a process and its children are allowed to do. They basically divide full “root” privilege into a set of distinct privileges. The idea of capabilities was described in POSIX 1003.1e draft that was withdrawn in 1997.</p><p> 为了帮助降低“ root”用户的权限，POSIX功能提供了一种方法来限制进程及其子级可以执行的特权系统操作组。他们基本上将完整的“ root”特权划分为一组不同的特权。在1997年撤消的POSIX 1003.1e草案中描述了功能的概念。</p><p> Each Linux process (task) has  five 64-bit numbers (sets) holding capability bits (used to be 32-bit before Linux 2.6.25) which can be inspected by reading /proc/&lt;pid&gt;/status</p><p> 每个Linux进程（任务）具有五个具有保持能力的64位数字（组）（在Linux 2.6.25之前为32位），可以通过读取/ proc /＆lt; pid＆gt; / status进行检查。</p><p>  These numbers (here displayed as hex digits) are acting as a bitmap encoding a set of capabilities. Full names are:</p><p>  这些数字（此处显示为十六进制数字）充当对一组功能进行编码的位图。全名是：</p><p> Bounding set – prior to Linux 2.6.25, the bounding set was a system-wide attribute shared by all threads, probably meant to describe a set beyond which capabilities cannot grow. Currently it is per-task set. It is a part of execve transformation logic (more later) and also limits what a process can set to its inheritable set using capset().</p><p> 边界集–在Linux 2.6.25之前，边界集是所有线程共享的系统范围的属性，可能意味着描述无法扩展功能的集合。当前，它是按任务设置的。它是execve转换逻辑的一部分（稍后会介绍），并且还限制了使用capset（）将进程可以设置为其可继承集的内容。 </p><p> Ambient set (since Linux 4.3) – added to give capabilities to non-0 user easily, without using setuid or file capabilities (more later).</p><p>环境集（自Linux 4.3起）–已添加，可轻松为非0用户提供功能，而无需使用setuid或文件功能（稍后会介绍）。</p><p> If a task asks to perform a privileged operation (like binding on ports &lt; 1024), the kernel checks Effective bounding set to see if  CAP_NET_BIND_SERVICE is set. If it is, it continues. Otherwise, it rejects the operation with EPERM (operation not permitted). These CAP_ defines in the kernel source are numbered sequentially so CAP_NET_BIND_SERVICE being 10 means a bit 1&lt;&lt;10 = 0x400 (that is the ‘4’ hex digit in my previous example).</p><p> 如果任务要求执行特权操作（例如，对端口<1024进行绑定），则内核会检查有效边界集，以查看是否设置了CAP_NET_BIND_SERVICE。如果是，它将继续。否则，它将拒绝使用EPERM进行的操作（不允许进行操作）。内核源中的这些CAP_定义是按顺序编号的，因此CAP_NET_BIND_SERVICE为10意味着位1 ＜＜ 10 = 0x400（在我之前的示例中为“ 4”十六进制数字）。</p><p> The full human readable list of currently-defined capabilities can be found in your up-to-date manpage  capabilities(7) (the one here is for reference only).</p><p> 您可以在最新的手册页功能（7）中找到当前定义功能的完整人类可读列表（此处仅供参考）。</p><p> Additionally there is a library libcap to make capabilities management and inspection easier. In addition to  library API, the package includes  capsh utility which, among other things, allows printing its capabilities.</p><p> 此外，还有一个库libcap使功能管理和检查更加容易。除了库API外，该软件包还包括capsh实用程序，该实用程序除其他功能外，还可以打印其功能。</p><p> # capsh --printCurrent: = cap_setgid,cap_setuid,cap_net_bind_service+eipBounding set =cap_setgid,cap_setuid,cap_net_bind_serviceAmbient set =Securebits: 00/0x0/1&#39;b0 secure-noroot: no (unlocked) secure-no-suid-fixup: no (unlocked) secure-keep-caps: no (unlocked) secure-no-ambient-raise: no (unlocked)uid=0(root)gid=0(root)groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),20(dialout),26(tape),27(video)</p><p> ＃capsh --printCurrent：= cap_setgid，cap_setuid，cap_net_bind_service + eipBounding set = cap_setgid，cap_setuid，cap_net_bind_serviceAmbient set = Securebits：00 / 0x0 / 1＆＃39; b0 secure-noroot：no（unlocked）secure-no-suid-fixup：否（未锁定）安全保持上限：否（未锁定）安全无环境提升：否（未锁定）uid = 0（root）gid = 0（root）groups = 0（root），1（bin）， 2（守护程序），3（sys），4（adm），6（磁盘），10（滚轮），11（软盘），20（拨号），26（磁带），27（视频）</p><p>  Current – displays effective, inheritable and permitted capabilities of capsh process in   cap_to_text(3)  format. Again, it displays it in cap_to_text format which lists capabilities basically as capability[,capability…]+(e|i|p) groups, where ‘e’ means effective, ‘i’ inheritable and ‘p’ permitted. The list is not separated by ‘,’ as you would guess (cap_setgid+eip,cap_setuid+eip). The ‘,’ separates capabilities in a single +… (action) group. The actual list of action groups is then separated by spaces. So another example with two action groups would be “= cap_sys_chroot+ep cap_net_bind_service+eip”. And also these two action groups “= cap_net_bind_service+e cap_net_bind_service+ip” would encode the same meaning as a single “cap_net_bind_service+eip”.</p><p>  当前-以cap_to_text（3）格式显示capsh进程的有效，可继承和允许的功能。同样，它以cap_to_text格式显示，基本上将功能列为功能[，capability ...] +（e | i | p）组，其中“ e”表示有效，“ i”可继承，“ p”被允许。如您所料（cap_setgid + eip，cap_setuid + eip），列表之间没有以“”分隔。 “，”将功能分成一个+…（动作）组。然后，将实际的操作组列表用空格分隔。因此，具有两个操作组的另一个示例是“ = cap_sys_chroot + ep cap_net_bind_service + eip”。而且，这两个操作组“ = cap_net_bind_service + e cap_net_bind_service + ip”的编码含义与单个“ cap_net_bind_service + eip”相同。</p><p> Bounding set/Ambient set. To make things even more confusing, these two lines contain just a list of capabilities set in those sets, separated by spaces. No cap_to_text format is used here because it is not listing permitted, effective, inheritable sets together but just a single (bounding/ambient) set.</p><p> 边界集/环境集。为了使事情更加混乱，这两行仅包含这些集合中的一系列功能，并以空格分隔。这里不使用cap_to_text格式，因为它没有一起列出允许的，有效的，可继承的集，而仅列出了一个（边界/环境）集。 </p><p> Securebits: displays task’s  securebits integer in as decimal/hex/fancy-verilog-convention-for-binary-strings (yes, everyone would expect it here and it’s totally clear by ‘b because every sysadmin programs its own FPGAs and ASICs). The state of securebits follows. The actual bits are defined as SECBIT_* in  securebits.h and also described in  capabilities(7).</p><p>Securebits：以十进制/十六进制/ fancy-verilog-convention-for-binary字符串的形式显示任务的securebits整数（是的，每个人都希望在这里看到它，并且用“ b完全清楚”，因为每个sysadmin都编写自己的FPGA和ASIC）。安全位的状态如下。实际位在securebits.h中定义为SECBIT_ *，并在capabilities（7）中进行了描述。</p><p> The tool lacks the one important state and that is the “ NoNewPrivs” which can be also seen by inspecting /proc/&lt;pid&gt;/status. That is described in  prctl(2) only, even though it directly affects capabilities when used in conjunction with file capabilities (more later). NoNewPrivs is described as “ With no_new_privs set to 1, execve(2) promises not to grant privileges to do anything that could not have been done without the execve(2) call (for example, rendering the set-user-ID and set-group-ID mode bits, and file capabilities non-functional). Once set, this the no_new_privs attribute cannot be unset. The setting of this attribute is inherited by children created by fork(2) and clone(2), and preserved across execve(2).“. This is the flag which Kubernetes sets to 1 when allowPrivilegeEscalation is set to false in pod’s securityContext.</p><p> 该工具缺少一个重要状态，即“ NoNewPrivs”，也可以通过检查/ proc /＆lt; pid＆gt; /状态来查看。仅在prctl（2）中对此进行了描述，即使它与文件功能结合使用时会直接影响功能（稍后会介绍）。 NoNewPrivs被描述为“ no_new_privs设置为1，execve（2）承诺不授予特权以执行没有execve（2）调用无法完成的任何操作（例如，呈现set-user-ID和set-组ID模式位，文件功能不起作用）。设置后，就不能取消设置此no_new_privs属性。该属性的设置由fork（2）和clone（2）创建的子代继承，并保留在execve（2）中。”这是在pod的securityContext中将allowPrivilegeEscalation设置为false时Kubernetes设置为1的标志。</p><p> When a process starts a new process by doing execve(2), capabilities are transformed to the child using the formula mentioned in  capabilities(7):</p><p> 当一个进程通过执行execve（2）启动一个新进程时，将使用capabilities（7）中提到的公式将能力转换为子代：</p><p> P&#39;(ambient) = (file is privileged) ? 0 : P(ambient)P&#39;(permitted) = (P(inheritable) &amp; F(inheritable)) | (F(permitted) &amp; P(bounding)) | P&#39;(ambient)P&#39;(effective) = F(effective) ? P&#39;(permitted) : P&#39;(ambient)P&#39;(inheritable) = P(inheritable) [i.e., unchanged]P&#39;(bounding) = P(bounding) [i.e., unchanged]where: P() denotes the value of a thread capability set before the execve(2) P&#39;() denotes the value of a thread capability set after the execve(2) F() denotes a file capability set</p><p> P＆＃39;（环境）=（文件具有特权）？ 0：P（环境）P＆＃39;（允许）=（P（可继承）＆F（可继承））| （F（允许）＆P（边界））| P＆（环境）P＆（有效）= F（有效） P＆＃39;（允许）：P＆＃39;（环境）P＆＃39;（可继承）= P（可继承）[即不变] P＆＃39;（边界）= P（可边界）[即不变] ：P（）表示在execve（2）之前的线程能力集的值P＆＃39;（）表示在execve（2）之后的线程能力集的值F（）表示文件能力的集</p><p> These rules describe action taken for every bit in ambient/permitted/effective/inheritable/bounding sets. It uses standard C syntax (&amp; for logic AND, | for logic OR). P’ is the child process, P is the current process calling execve(2). F are so called “file capabilities” of the file being execve’d.</p><p> 这些规则描述了对环境/许可/有效/可继承/边界集中的每一位所采取的操作。它使用标准C语法（＆amp;用于逻辑AND，| |用于逻辑OR）。 P’是子进程，P是当前调用execve（2）的进程。 F就是被执行文件的所谓“文件功能”。</p><p> Additionaly, a process can programmatically change its inheritable, permitted and effective sets using libpcap any time according to these rules:</p><p> 另外，进程可以根据以下规则随时使用libpcap以编程方式更改其可继承集，允许集和有效集：</p><p> Unless the caller have the CAP_SETPCAP, the new  inheritable set must be a subset of  P(inheritable) &amp; P(permitted)</p><p> 除非调用者具有CAP_SETPCAP，否则新的可继承集必须是P（heritable）＆amp; P的子集。 P（允许） </p><p> (since Linux 2.6.25) The new  inheritable set must be a subset of  P(inheritable) &amp; P(bounding)</p><p>（从Linux 2.6.25开始）新的可继承集必须是P（可继承）＆amp;的子集。 P（有界）</p><p>  Sometimes a user with a reduced set of capabilities needs to run a binary which requires more capabilities. Previously, this was achieved by setuid binary (chmod +s ./executable). Such a binary, if owned by root, would assign full root privileges to it when executed by any user.</p><p>  有时，功能集减少的用户需要运行需要更多功能的二进制文件。以前，这是通过setuid二进制文件（chmod + s ./executable）实现的。如果这样的二进制文件由root拥有，则在由任何用户执行时都将为其分配完全root特权。</p><p> That gives too many privileges to the binary, so POSIX capabilities implemented a concept called “file capabilities”. They are stored as a  extended file attribute called “security.capability” so you need a capable filesystem (ext*, XFS, Raiserfs, Brtfs, overlay2, …). For a process to write to this attribute, CAP_SETFCAP capability is needed (be in process’ effective set).</p><p> 这给了二进制文件太多的特权，因此POSIX功能实现了一个称为“文件功能”的概念。它们存储为名为“ security.capability”的扩展文件属性，因此您需要功能强大的文件系统（ext *，XFS，Raiserfs，Brtfs，overlay2等）。要使进程写入该属性，需要CAP_SETFCAP功能（在进程的有效集中）。</p><p> $ getfattr -m - -d `which ping`# file: usr/bin/pingsecurity.capability=0sAQAAAgAgAAAAAAAAAAAAAAAAAAA=$ getcap `which ping` /usr/bin/ping = cap_net_raw+ep</p><p> $ getfattr -m--d`ping'＃文件：usr / bin / pingsecurity.capability = 0sAQAAAgAgAAAAAAAAAAAAAAAAAAAA = $ getcap`which ping` / usr / bin / ping = cap_net_raw + ep</p><p>  Of course, life is not simple, so is not the implementation of capabilities and there are several special cases described in  capabilities(7) man page. Probably the most important are:</p><p>  当然，生活并不简单，功能的实​​现也不是那么简单，capabilities（7）手册页中描述了几种特殊情况。可能最重要的是：</p><p> setuid file bit and file capabilities are ignored if NoNewPrivs is set or filesystem is mounted nosuid or the process calling execve is being ptraced. The file capabilities are also ignored when the kernel is booted with  no_file_caps.</p><p> 如果设置了NoNewPrivs或安装了文件系统nosuid或正在跟踪调用execve的进程，则会忽略setuid文件位和文件功能。使用no_file_caps引导内核时，文件功能也将被忽略。</p><p> Capability-dumb binary is a binary converted from setuid to file capabilities without changing its code. Such binaries are often converted by setting +ep capability on them like “setcap cap_net_bind_service+ep ./binary”. The important part is “e”, effective. Upon execve, this capability is added to both permitted and effective so the executable is ready to use the privileged operation. In contrast  capability-smart binary which uses libpcap or similar, can use  cap_set_proc(3) (or  capset) to set “effective” or “inheritable” bits at any point, as long as that capability is already in the “permitted” set. So “setcap cap_net_bind_service+p ./binary” would be enough for a capability-smart binary as it will be able to set the effective bit itself before calling the privileged operation. See my  example code.</p><p> Capability-dumb二进制文件是将setuid转换为文件功能的二进制文件，而无需更改其代码。此类二进制文件通常通过在其上设置+ ep功能来转换，例如“ setcap cap_net_bind_service + ep ./binary”。重要的部分是有效的“ e”。执行后，此功能将同时添加到允许的和有效的，以便可执行文件可以使用特权操作。相反，使用libpcap或类似功能的功能智能二进制文件可以在任何时候使用cap_set_proc（3）（或capset）来设置“有效”或“可继承”位，只要该功能已在“允许”设置中即可。因此，“ setcap cap_net_bind_service + p ./binary”对于功能智能的二进制文件就足够了，因为它可以在调用特权操作之前自行设置有效位。参见我的示例代码。 </p><p> setuid-root binaries continue to work, giving all privileges of root when run by a non-root user. Unless they have file capabilities set, in which case only those are granted. It is also possible to create a setuid binary with empty file capability set, making it execute as 0, though without any capabilities. There are special cases for root user running setuid-root binary and various securebits are set (consult the man).</p><p>setuid-root二进制文件继续工作，当由非root用户运行时，会赋予root所有特权。除非设置了文件功能，否则将仅授予这些功能。尽管没有任何功能，也可以使用空文件功能集创建setuid二进制文件，使其执行为0。在某些特殊情况下，root用户运行setuid-root二进制文件，并且设置了各种安全位（请咨询man）。</p><p> The bounding set masks the file permitted capabilities, but not the inheritable capabilities – remember  P&#39;(permitted) = F(permitted) &amp; P(bounding). If a thread maintains a  capability in its inheritable set that is not in its bounding set, then it  can still gain that capability in its permitted set by executing a file that has the capability in its inheritable set – remember  P&#39;(permitted) = P(inheritable) &amp; F(inheritable).</p><p> 边界集会屏蔽文件允许的功能，但不会屏蔽可继承的功能-请记住P＆＃39;（permitted）= F（permitted）＆amp; P（边界）。如果线程在其可继承集合中维护的功能不在其边界集中，那么它仍然可以通过执行一个在其可继承集合中具有该功能的文件来在其允许的集合中获得该功能–记住P＆＃39;（允许） = P（可继承）＆amp; F（可继承）。</p><p> Executing a program that changes UID or GID due to the set-user-ID or set-group-ID bits or executing a program that has any file capabilities set will  clear the ambient set. Capabilities are  added to ambient set using PR_CAP_AMBIENT  prctl. Such capability must already be present in both the  permitted and the inheritable sets of the process.</p><p> 执行由于设置用户ID或设置组ID位而更改UID或GID的程序，或者执行具有任何文件功能集的程序，将会清除环境设置。使用PR_CAP_AMBIENT prctl将功能添加到环境设置。这种功能必须已经存在于流程的允许和可继承集合中。</p><p> If a process with  non-0 UID performs an execve(2) then any capabilities that are present in its  permitted and effective sets will be  cleared.</p><p> 如果具有非0 UID的进程执行execve（2），则将清除其允许和有效集中存在的所有功能。</p><p> Unless SECBIT_KEEP_CAPS (or more broader SECBIT_NO_SETUID_FIXUP) is set,  changing UID from 0 to non-0 clears all capabilities from permitted, effective, and ambient sets.</p><p> 除非设置了SECBIT_KEEP_CAPS（或更广泛的SECBIT_NO_SETUID_FIXUP），否则将UID从0更改为非0会从允许的，有效的和环境的设置中清除所有功能。</p><p>    …it simply means it tried to listen on port 80 as an unprivileged (non-0) user and it doesn’t have CAP_NET_BIND_SERVICE in its effective capability set. To gain such capability, one has to use xattr file capabilities and set (using setcap) nginx file capability set to at least cap_net_bind_service+ie. This file capability will be &amp;ed with inherited set (set together with bounding set by pod’s securityContext/capabilities/add/NET_BIND_SERVICE), making it into the permitted set as well. Leading to the final result =cap_net_bind_service+pie effectively.</p><p>    …这只是意味着它试图以非特权（非0）用户身份监听端口80，并且其有效功能集中没有CAP_NET_BIND_SERVICE。要获得这种功能，必须使用xattr文件功能并将nginx文件功能设置（至少使用cap_net_bind_service + ie）（使用setcap）。此文件功能将与继承的集（由pod的securityContext / capabilities / add / NET_BIND_SERVICE设置的设置以及边界设置）一起进行扩展，并使其也成为允许的设置。有效地导致最终结果= cap_net_bind_service + pie。</p><p> That all works as long as securityContext/allowPrivilegeEscalation is true and your docker/rkt storage driver (see docker info) supports xattrs.</p><p> 只要securityContext / allowPrivilegeEscalation为true并且您的docker / rkt存储驱动程序（请参阅docker信息）支持xattrs，那么一切就可以正常工作。 </p><p> If the nginx was a capability-smart binary, cap_net_bind_service+i file capability would be enough. It could then use libcap to extend the capability from permitted to effective set. Resulting in the =cap_net_bind_service+pie as well.</p><p>如果nginx是功能智能二进制文件，那么cap_net_bind_service + i文件功能就足够了。然后，它可以使用libcap将功能从允许集扩展到有效集。也会导致= cap_net_bind_service + pie。</p><p> Other than using file xattrs, the only way to achieve cap_net_bind_service in a non-root container would be to let Docker set the ambient capabilities. But as of 4/2019, that is  not yet implemented</p><p> 除了使用文件xattrs之外，在非根容器中实现cap_net_bind_service的唯一方法是让Docker设置环境功能。但截至4/2019，尚未实施</p><p>  Here is  the example code to use libcap to add cap_net_bind_service to the effective set. That requires the cap_net_bind_service+p file capability set on the binary.  To compile and run it: $ gcc -lcap captest.c -o captest $ ./captest Current process capabilities (+set): = cap_set_proc: Operation not permitted  After adding file capability: $ sudo setcap cap_net_bind_service+p ./captest $ ./captest  Current process capabilities (+set): = cap_net_bind_service+p bind successful! :)</p><p>  这是使用libcap将cap_net_bind_service添加到有效集中的示例代码。这需要在二进制文件上设置cap_net_bind_service + p文件功能。要编译并运行它：$ gcc -lcap captest.c -o captest $ ./captest当前进程功能（+设置）：= cap_set_proc：不允许操作添加文件功能之后：$ sudo setcap cap_net_bind_service + p ./captest $。 / captest当前进程功能（+ set）：= cap_net_bind_service + p绑定成功！ :)</p><p>  There is also  a nice diagram made by H. Plötz which summarizes relations between thread’s set, binary’s set and those applied to execve’d child.   Credit for the image goes to H. Plötz.</p><p>  H.Plötz还制作了一个漂亮的图表，总结了线程集，二进制集和应用于被执行子级的集之间的关系。图片来源归功于H.Plötz。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://k3a.me/linux-capabilities-in-a-nutshell/">https://k3a.me/linux-capabilities-in-a-nutshell/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/功能/">#功能</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>