<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用旧便携式路由器制作Wi-Fi串行控制台适配器 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">使用旧便携式路由器制作Wi-Fi串行控制台适配器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-03 23:05:00</div><div class="page_narrow text-break page_content"><p>串行控制台是与嵌入式Linux系统通信最重要的方式之一。多年来我已经使用了很多USB串行适配器，但它们似乎都有两个难以克服的主要缺点：</p><p> 它们没有电隔离。每当目标板通电时，总会有一个小的机会，因为接地循环干扰导致电源浪涌发生，这导致我的连接在上电时被中断：</p><p>  当我可以重新连接我的终端软件（在这种情况下麦克皮摩），我已经错过了引导加载程序打印的很多关键消息。这使得诊断和调试引导程序相关的问题非常不愉快。要使事情变得更糟，应该糟糕的事情发生在我的电路板上，并且将高电压发送到TX / RX引脚，它可能会返回到我的电脑并摧毁我的PCH，因为EHCI / XHCI控制器通常在现在的PCH中集成在PCH中。</p><p> UART电缆长度限制使得难以在凌乱的桌面上使用，作为USB集线器或至少需要一个延长电缆，进一步有助于杂乱，并且裸PCB具有意外短短的风险其他金属工具如果不小心。</p><p> 在与某些网络工程师交谈时，我发现有些人拥有Wi-Fi或基于BLE的无线控制台适配器，这让他们可以无线访问RS-232串行控制台。一些研究后来，一系列称为Airconsole的产品来自CloudStore Limited的兴趣。从它的外观，他们的大部分Wi-Fi的选项看起来非常类似于由HAME制造的一系列较旧的“3G路由器”产品。迷你模型几乎与MPR-A5相同，STD / Pro看起来几乎与MPR-A1相同，并且XL几乎与MPR-A2相同。这些HAME模型后来被其他制造商克隆，然后作为通用产品销售，他们仍然可以在eBay和AliExpress等地方找到。</p><p> 通过了解这些信息，我认为我更容易制作自己的无线串行控制台适配器，其中一些旧的便携式路由器。对我来说，没有必要的蓝牙连接或智能手机应用程序，我想要的只是我可以在本地连接的东西，让我通过安全连接与串行控制台进行交互。运输安全性是非常理想的，因为在明文中传输的登录凭据非常不受欢迎，即使在我自己的LAN上也是如此。</p><p> 在一些考虑之后，我在SSH会话上决定在SSH会话上运行Picocom，在电池供电的OpenWRT设备上是最容易为我实施的。 SSH是我的最佳选择，因为与传统的基于PKI的TLS / HTTPS设置相比，“首次使用的信任”设计具有更低的设置开销，同时仍保持安全。 OpenWRT提供了一个易于使用的配置Web界面，用于设置Wi-Fi连接，具有（主要）最新的用户空间软件，并且几乎是唯一只有在这些路由器上工作的Linux发行版。 </p><p>以下是一些在我的研究中考虑的替代方案和想法，以及为什么他们未选择他们的项目：</p><p> ESP32-Serial-Bridge：类似于上面的项目，但它仅是透明的TCP。缺乏运输安全性仍然是一名巨大的困境。</p><p> CONSRV：GO二进制文件是静态链接的，对于可用的存储空间量极为有限，加上另一个SSH服务器，而OpenWRT已经通过OpenWrt提供了非常冗余的。</p><p> 基于蓝牙的解决方案具有非常有限的范围，它们通常更难以一般工作。</p><p> 专有的433MHz / 2.4GHz关闭架子串行桥通常具有固定的比特率并缺乏适当的运输加密。</p><p> 虽然不是无线的，但如果需要电隔离，则为ADUM3201等数字隔离器可广泛可用。此解决方案的问题现在是八根线，而不是典型的三个线，而是从两侧的VCC进行数字隔离器正常运行。</p><p>  随着上下文，我需要一些硬件升级，以便能够将现代开放式置于这些设备上。 TP-Link TL-MR11U仅具有4MB的闪光灯和32MB的DRAM。虽然32MB足以用于我要运行的内容，但是4MB不足以存储所需的软件了。 HAME MPR-A1仅具有4MB的NOR闪存和16MB的DRAM，这两者都没有足够的任何我需要的东西。 </p><p>MPR-A1和MPR-A2几乎是相同的设备，除了具有较少的存储，存储器和较小的电池。事实上，如果您升级其NOR闪存和DRAM，A2的OpenWRT将在A1上工作。我将占8MB，也不是32MB的DRAM来匹配MPR-A2。拆卸MPR-A1相当简单，因此在拆除过程中没有拍摄照片。</p><p>  我刚刚碰巧有一个MPR-A2克隆，所以我以为我也会把这两个PCB放在一起。看到克隆在某些地方选择更便宜的零件来削减成本很有意思。我不会在克隆上工作，因为它已经拥有8MB，也不是闪光和32MB的DRAM。</p><p>  根据RT5350F的数据表，DRAM配置在EEPROM中设置，或者通过两个引导引脚外部配置。在MPR-A1的情况下，它通过这两个引导引脚配置。不幸的是，这个SOC无法正确地址址遍布一个64MB DRAM芯片（仅为32MB * 2），因此32MB就像它一样好。</p><p>    对于MR11U，升级更容易，因为Bootloader可以自动检测DRAM配置，并且没有引导引脚才能担心。 SoC的数据表表示最大支持的闪光灯大小为16MB，最大支持的DRAM尺寸为64MB，因此这就是我投入的。</p><p>   我不会在这里越过设置过程，Wiki做了一个非常好的工作解释。在克隆源后，我做了以下内容来构建我的固件图片：</p><p> ＃查看v19.07.7分支$ git checkout v19.07.7＃干净，更新和强制安装所有包饲料＃-f是必需的，因为某些包赢得了＆＃39; t显示，因为它们包含可能＃覆盖内置的文件软件包，此行为通常默认允许默认为$脚本/饲料清洁＆amp;＆amp;脚本/饲料更新-a＆amp;＆amp;脚本/ riote install-af</p><p>   这是用于升级的MPR-A1的配置。由于我借用MPR-A2借用配置，因此不需要对源代码的进一步更改，因为所输入的新闪存匹配MPR-A2的容量。 DRAM的更改将由引导加载程序拾取并通过新的引导配置传递到内核。在默认值之上，只有ECC和DropBear中的压缩支持已启用，以及一些USB串行驱动程序，皮密组，Shadow-Utils（因为需要创建单独的用户）和LUCI（Web配置界面）。 </p><p>CONFIG_TARGET_ramips = yCONFIG_TARGET_ramips_rt305x = yCONFIG_TARGET_ramips_rt305x_DEVICE_mpr-A2 = yCONFIG_DEVEL = yCONFIG_CCACHE = Y＃启用ECC和压缩支持dropbearCONFIG_DROPBEAR_ECC = yCONFIG_DROPBEAR_ECC_FULL = yCONFIG_DROPBEAR_ZLIB = Y＃使luciCONFIG_PACKAGE_luci = Y＃USB串行driversCONFIG_PACKAGE_kmod-USB-ACM = yCONFIG_PACKAGE_kmod-USB串行= yCONFIG_PACKAGE_kmod-USB -serial-ch341 = yconfig_package_kmod-usb-serial-cp210x = yconfig_package_kmod-usb-serial-ftdi = yconfig_package_kmod-usb-serial-pl2303 = y＃终端softwareconfig_package_picocom = y #entrame shadow_utils config_package_shadow-utils = y</p><p> 在源树的根目录中写入这些到.config后，只需运行defconfig将告诉构建系统自动解析依赖关系并完成配置文件。</p><p> $ make defconfig＃下载所有必需的源归档$ make下载-j10＃编译图像，以高效的值运行，避免在系统$ your-n 19 make -j $（nproc）上停止丢失其他应用程序</p><p> 不幸的是，构建很快失败了。运行make v = s -j1显示出源自build_dir / host / mklibs-0.1.35的问题，其Makefile是工具/ mklibs / makefile。</p><p> 在从elf_data.hpp：24中包含的文件中，从elf.cpp：21：elf.hpp：52：56：错误：ISO C ++ 17不允许动态异常规格52 | const section＆amp; get_section（unsigned int i）const trave（std :: out_of_range）{return * sections.at（i）; }; | ^ ~~~~ elf.hpp：62：47：错误：ISO C ++ 17不允许动态异常规格62 |静态文件*打开（const char * filename）抛出（std :: bad_alloc，std :: runtime_error）; | ^ ~~~~ elf.hpp：65：38：错误：ISO C ++ 17不允许动态异常规格65 |文件（uint8_t * mem，size_t len）ownow（std :: bad_alloc）：mem（mem），len（len）{} | ^ ~~~~ elf.hpp：68：52：错误：ISO C ++ 17不允许动态异常规格68 |静态文件* Open_Class（UINT8_T *，size_t）抛出（std :: bad_alloc，std :: runtime_error）; | ^ ~~~~ elf.hpp：131：55：错误：ISO C ++ 17不允许动态异常规格131 | std :: string get_string（uint32_t offset）const trave（std :: bad_alloc）| ^ ~~~~ elf.hpp：266：39：错误：ISO C ++ 17不允许动态异常规格266 | std :: string get_version（）const trave（std :: bad_alloc）; | ^ ~~~~ elf.hpp：267：44：错误：ISO C ++ 17不允许动态异常规格267 | std :: string get_version_file（）const trave（std :: bad_alloc）; | ^ ~~~~ elf.hpp：269：44：错误：ISO C ++ 17不允许动态异常规格269 | std :: string get_name_version（）const trave（std :: bad_alloc）; | ^ ~~~~ elf.hpp：308：29：错误：ISO C ++ 17不允许动态异常规格308 | Version_requirement（）掷（std :: bad_alloc）; | ^ ~~~~ ----------狙击---------制作[7]：*** [makefile：382：elf.o]错误1</p><p> 我检查了上游makefile在21.02上的样子，似乎host_cppflags + = -std = gnu ++ 98需要在我的makefile中设置。进一步的检查表明，0.1.35版本甚至不再存在于Debian的服务器上，因此我升级了版本号，存档扩展（.xz而不是.gz）以及对应于V0.1.44的散列。</p><p> Diff --git A / Tools / MKLibs / Makefile B / Tools / MKLIBS / Makefile索引507C2FD394..48B1EACE40 100644 --- A / Tools / MKLIBS / Makefile +++ B / Tools / Mklibs / makefile @@ -7,17 +7,18 @@包括$（topdir）/rules.mk pkg_name：= mklibs -pkg_version：= 0.1.35 + pkg_version：= 0.1.44 -pkg_source：= $​​（pkg_name）_ $（pkg_version）.tar.gz + PKG_SOURCE：= $（程序包名称）_ $（PKG_VERSION）.tar.xz PKG_SOURCE_URL：= HTTP：//ftp.de.debian.org/debian/pool/main/m/mklibs/ -PKG_HASH：= ccb1023dc1729c5a37ca6c3eca8e4bac3491116763c8820dfce8eea4845c8567 + PKG_HASH： = 3af0b6bd35e5b6fc58d8b68827fbae2ff6b7e20dd2b238ccb9b49d84722066c2 host_fixup：= autoreconf包括$（include_dir）/ host-build.mk host_cflags + = -i $（curdir）/ compnety + host_cppflags + = -std = gnu ++ 98定义主机/安装$（install_bin）\ </p><p>在删除build_dir / host / mklibs-0.1.35并重新运行构建过程之后，所有内容都在此时工作，并且在Bin / targets / RAMIPS / RT305x / OpenWrips-RT305x-MPR-A2中生成Sysupgrade映像。 squashfs-sysupgrade.bin。我现在将其放在一边并编制TP-Link设备的图像。</p><p>   对于TP-LINK TL-MR11U，需要对源的一点修改。升级的DRAM不需要任何更改，因为它由引导加载程序自动检测到，然后传递到内核，但对于闪存大小，我需要更改此设备的构建目标以确保选择16MB闪存布局。对于旧的AR71xx目标，它与更改哪个宏此设备的定义点一样简单。我的硬件版本是v2，但V2定义点到v1，所以它是我需要更改的v1。</p><p> diff --git a / target / linux / ar71xx /图像/ tiny -tp-link.mk b / target / linux / ar71xx / image / tiny -tp-link.mk索引9612694469..a38df7f5af 100644 --- A /目标/linux/ar71xxx/image/tiny-tp-link.mk +++ b / target / linux / ar71xx / image / tiny-tp-link.mk @@ -13,7 +13,7 @@emef target_devices + = TL-MR10U-V1定义设备/ TL-MR11U-V1  -  $（设备/ TPLINK-4MLZMA）+ $（设备/ TPLINK-16MLZMA）DEVIETLE：= TP-LINK TL-MR11U v1 device_packages：= kmod-usb-core kmod -usb2 kmod-usb-lettrig-usbport boardname：= tl-mr11u</p><p> 这对AR71XX目标非常重要，比以前的设备更重要，这是斜坡的，因为我将详细说明下面的固件拼接部分。</p><p>   CONFIG_TARGET_ar71xx = yCONFIG_TARGET_ar71xx_tiny = yCONFIG_TARGET_ar71xx_tiny_DEVICE_tl-mr11u-V2 = yCONFIG_DEVEL = yCONFIG_CCACHE = Y＃启用ECC和dropbearCONFIG_DROPBEAR_ECC = yCONFIG_DROPBEAR_ECC_FULL = yCONFIG_DROPBEAR_ZLIB = Y＃压缩支持使luciCONFIG_PACKAGE_luci = Y＃USB串行driversCONFIG_PACKAGE_kmod-USB-ACM = yCONFIG_PACKAGE_kmod-USB串行= yCONFIG_PACKAGE_kmod -usb-serial-ch341 = yconfig_package_kmod-usb-serial-cp210x = yconfig_package_kmod-usb-serial-ftdi = yconfig_package_kmod-usb-serial-pl2303 = y＃终端softwareconfig_package_picocom = y #entraph_picocom = y #entraph_p_utils config_package_shadow-utils = y</p><p>  ＃完整配置$ make defconfig #sind culiant构建artifacts $ make clean＃下载所有所需的源归档$ make下载-j10＃编译图像，以高良好的值运行，以避免在系统上停止其他应用程序$ nice-n 19 make -j $（nproc）</p><p>   首先，我从设备起飞的两个芯片都与我的SPI闪存程序员和FlashROM倾倒。这里使用的Flash程序员是一个很好的开源项目：STM32-VSerprog。存储库具有硬件和固件设计。这可以比基于CH341的程序员更快地阅读和写入芯片，并且很容易组装。 </p><p>这两个设备都是MIPS，但这几乎是相似之处结束的地方。这两个设备的固件设置完全不同，因此需要两种不同的Appaoches将事物拼接在一起并返回到新的或闪存。</p><p> 一般来说，像这样的无线路由器/接入点类型嵌入式Linux系统将有几个分区：</p><p> 叠加（保存用户配置的位置，并在只读rootfs的顶部安装为叠加</p><p> 值得注意的是，必须保留无线校准数据，因为这是基于单板的唯一。这就是为什么交叉闪烁的其他人的完整闪存转储通常不是一个好主意，因为你最终会有了subpar rf性能和错误的mac地址，更不用说可能违反fcc（或本地等效的）法规，以及为什么它始终建议在与任何设备进行修改之前，闪烁的完整图像备份。</p><p>  首先，我需要根据分区表将股票固件转储转储到单个分区图像以便稍后使用。这可以简单地使用dd = a1_full_dump.bin = $ partition_name bs = 1 count = $ size_in_bytes skip = $ start_offset_in_bytes，或者只是在十六进制编辑器中选择，复制和粘贴数据。</p><p> 分区{Compatible =＆＃34;固定分区＆＃34 ;; ＃地址 - 单元格=＆lt; 1＆gt ;; ＃尺寸 - 单元=＆lt; 1＆gt;; [电子邮件受保护] {label =＆＃34; U-Boot＆＃34 ;; reg =＆lt; 0x0 0x30000＆gt ;;只读; }; [电子邮件受保护] {label =＆＃34; U-Boot-Env＆＃34 ;; reg =＆lt; 0x30000 0x10000＆gt ;;只读; };工厂：[电子邮件受保护] {label =＆＃34;工厂＆＃34 ;; reg =＆lt; 0x40000 0x10000＆gt ;;只读; }; [电子邮件受保护] {兼容=＆＃34; Denx，Uimage＆＃34 ;;标签=＆＃34;固件＆＃34 ;; reg =＆lt; 0x50000 0x3b0000＆gt ;; };</p><p> 对于此SoC，根据旧论坛帖子，还需要使用修改的引导加载程序来利用32MB的DRAM。 </p><p>因此，总的来说，原始闪光图像所需的两个分区将是U-Boot-Env和工厂。 U-Boot-Env包含引导加载程序的配置，即我不需要修改，出厂是Ralink（和MediaTek MIPS）设备的传统无线电校准数据和MAC地址存储分区。</p><p> 由构建系统生成的sysupgrade图像实际上是一个完整的UIMAGE直接由引导加载程序引导，rootfs squashfs映像在它之后附加。所有我需要做的就是将此写入闪光灯0x50000。此Sysupgrade文件确实有一些尾随元数据，但是当覆盖分区自动重新格式化第一引导时，这些将自动删除，因此可以安全地忽略它。</p><p> $文件箱/目标/ rt305x / openwrips-rt305x-mpr-a2-scashfs-sysupgrade.binbin / targets / ry305x / openwrt-rt305x-mpr-a2-squish-rt305x-mpr-a2-scarashfs-sysupgrade.bin：u-启动遗留UIMage，Linux内核图像，Linux / MIPS，OS内核图像（LZMA），1280356字节，12月15日15:22:37 2021，装载地址：0x80000000，入口点：0x80000000，标题CRC：0x2D529961，数据CRC： 0x804d50b5.</p><p> 现在我拥有所有数据，是时候重建一个可引导的全闪光图像了。虽然在GUI十六进制编辑器中可以更方便地做，但如果使用DD完成，请更容易解释发生的事情。 MPR-A2的固件分区为0x7b0000，大小而不是0x3b0000，但否则它们具有相同的闪存布局。</p><p> ＃拍摄可以使用32MB DRAM的修改后的引导加载程序二进制文件，并使用0xFF生成填充到0x30000的填充。$ FILE =＆＃34; Uboot256.img＆＃34; dd if = / dev / zero bs = 1 count = $（（0x30000  -  $（stat -format =％s $ file）））| tr \\ 000 \\ 377＆gt; U-Boot_Padding91104 + 0记录In91104 + 0记录输出91104字节（91 kB，89个Kib）复制，0.0971852 s，937 kb / s＃与u-boot映像$ cat Uboot256.img U-boot_padding＆gt; U-Boot_Partition＃串联U-Boot Partiton（现在使用正确的大小），U-Boot环境变量将无线校准数据置于铭牌。$ CAT U-Boot_Partition U-Boot-Env Factory＆Gt; Header＃生成填充有0xFF的填充，以将Frimware Partiton填充到正确的大小$ File =＆＃34; OpenWrt-Ramips-RT305x-MPR-A2-Squashfs-sysupgrade.bin＆＃34; dd if = / dev / zero bs = 1 count = $（（0x7b0000  -  $（stat -format =％s $ file））| tr \\ 000 \\ 377＆gt; Firmware_Padding3865866 + 0记录In3865866 + 0记录摘录3865866字节（3.9 MB，3.7 MIB）复制，1.49983 S，2.6 MB / s＃与Sysupgrade Image连接到填充$ CAT OpenWrips-RT305x-MPR-A2-Squashfs-Sysupgrade .bin firmware_padding＆gt; Firmware_Partiton＃将所有内容连接在一起$ cat header firmware_padding＆gt; full.bin＃将组装的全部图像写入新的flash芯片$ flashrom -p serprog：dev = / dev / ttyacm1：400000000 -W full.bin</p><p> 用芯片写入，它焊接回电路板。清理板后，它已启动，系统按预期提出。大约需要3分钟才能完全初始化JFFS2叠加，因为它需要擦除覆盖分区中的所有内容。随后的正常靴子需要大约1分钟，同时有点慢，方便的仍然是可接受的权衡。</p><p> [78.870911] JFFS2_SCAN_ERASEBLOCK（）：在0x0中找到的文件系统标记的结束[78.926935] JFFS2_BUILD_FILESYSTEM（）：解锁MTD设备......完成了[78.927077]所做的。[78.94362] JFFS2_BUILD_FILESYSTEM（）：在结束标记后删除所有块...... [80.627250] BR-LAN：端口1（eth0）进入阻塞状态[80.652812] BR-LAN：端口1（eth0）输入禁用状态[80.663982]设备eth0进入混杂模式[80.838653] BR-LAN：端口1（eth0）进入阻塞状态[80.849204] BR-LAN：110.860561] IPv6：ADDRCONF（NETDEV_UP）：BR-LAN未准备好[82.058579] IPv6：ADDRCONF（NETDEV_CHANGE）：BR-LAN：BR-LAN： Link已完成[177.313272] [177.317307] JFFS2：注意：（1135）JFFS2_BUILD_XATTR_SUBSYSTEM：完整的构建XATTR子系统，XDATUM（未选中，0 Orphan）和XREF（0死，0 Orphan的0）的0. [177.746829 [177.746829 [177.746829 ] overlayfs：上部FS不支持TMPFile。 </p><p>该设备需要不同的方法。 由于工厂引导加载程序可以自动检测所投入的64MB的DRAM，我可以简单地  ...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://sagacioussuricata.com/posts/openwrt-serial-bridge/">https://sagacioussuricata.com/posts/openwrt-serial-bridge/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/控制台/">#控制台</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/wi/">#wi</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/设备/">#设备</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1062227.html"><img src="http://img2.diglog.com/img/2021/5/thumb_675931475d4d8a0437acdaac197b5861.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1062227.html">Valve的Gabe Newell提示模糊的控制台计划“今年” </a></div><span class="my_story_list_date">2021-5-13 0:12</span></div><div class="col-sm"><div><a target="_blank" href="/story/1058766.html"><img src="http://img2.diglog.com/img/2021/4/thumb_86af476ac4a374947b81c06976eb2529.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1058766.html">NPD：PlayStation 5的前5个月是美国控制台发射的最佳 </a></div><span class="my_story_list_date">2021-4-16 23:51</span></div><div class="col-sm"><div><a target="_blank" href="/story/1044332.html"><img src="http://img2.diglog.com/img/2021/1/thumb_af0e4171281a62d2704e77e8237a236b.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1044332.html">我首选的.NET控制台堆栈 </a></div><span class="my_story_list_date">2021-1-16 0:28</span></div><div class="col-sm"><div><a target="_blank" href="/story/1040760.html"><img src="http://img2.diglog.com/img/2020/12/thumb_412903ab5e56b72e6856860be440e66b.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1040760.html">PC引擎/ TurboGrafx-16架构–实用分析 </a></div><span class="my_story_list_date">2020-12-20 0:44</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>