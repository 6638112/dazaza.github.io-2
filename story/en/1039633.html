<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>指针很复杂II，或者：我们需要更好的语言规范 Pointers Are Complicated II, or: We need better language specs</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Pointers Are Complicated II, or: We need better language specs<br/>指针很复杂II，或者：我们需要更好的语言规范 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-15 02:10:37</div><div class="page_narrow text-break page_content"><p>Some time ago, I wrote a blog post about how  there’s more to a pointer than meets the eye.One key point I was trying to make is that</p><p>前段时间，我写了一篇博客文章，内容是关于指针的更多内容。</p><p> just because two pointers point to the same address, does not mean they are equal in the sense that they can be used interchangeably.</p><p> 仅仅因为两个指针指向同一个地址，并不意味着它们在可以互换使用的意义上是相等的。</p><p> This “extra information” that distinguishes different pointers to the same address is typically called   provenance.This post is another attempt to convince you that provenance is “real”, by telling a cautionary tale of what can go wrong when provenance is not considered sufficiently carefully in an optimizing compiler.The post is self-contained; I am not assuming that you have read the first one.There is also a larger message here about how we could prevent such issues from coming up in the future by spending more effort on the specification of compiler IRs.</p><p> 这种区别于同一地址的不同指针的“额外信息”通常称为“出处”。这是另一种尝试，通过讲述一个警告性故事，即当未充分考虑出处时会出问题的原因，从而使您确信该出处是“真实的”该帖子是独立的;我并不是以为您已经阅读了第一篇。这里还有一个更大的信息，关于如何通过在编译器IR的规范上花费更多的精力来防止将来出现此类问题。</p><p> Below, I will show a series of three compiler transformations that each seem “intuitively justified”, but when taken together they lead to a clearly incorrect result.I will use LLVM for these examples, but the goal is not to pick on LLVM—other compilers suffer from similar issues.The goal is to convince you that to build a correct compiler for languages permitting unsafe pointer manipulation such as C, C++, or Rust,we need to take IR semantics (and specifically provenance) more seriously.I use LLVM for the examples because it is particularly easy to study with its single, extensively-documented IR that a lot of infrastructure evolved around.Let’s get started!</p><p> 下面，我将展示一系列三个编译器转换，每个转换看起来都“直观上是合理的”，但是将它们组合在一起会导致明显不正确的结果。我将在这些示例中使用LLVM，但目标不是选择LLVM，而是其他编译器也遇到类似的问题。我们的目标是说服您，为允许进行不安全指针操作的语言（例如C，C ++或Rust）构建正确的编译器，我们需要更加认真地对待IR语义（尤其是出处）。我使用LLVM以这些示例为例，因为使用它的单一且详细记录的IR可以轻松地研究许多基础设施的发展，因此让我们开始吧！</p><p>  As a warm-up, I will give a simple example showing that compiler IRs such as LLVM IR need a precise (and precisely documented) semantics.If you are already familiar with the idea of treating compiler IRs as proper programming languages in their own right, or if you are just here for the pointers and their provenance, you can skip to the next section.</p><p>  作为热身，我将举一个简单的示例，说明诸如LLVM IR之类的编译器IR需要精确的（并有精确记录的）语义。如果您已经熟悉将编译器IR视为本身就是正确的编程语言的想法， ，或者如果您只是在这里查看指针及其来源，则可以跳到下一部分。</p><p> Consider the following simple (and contrived, for the sake of this example) piece of C code computing  n * (i+j):</p><p> 考虑以下简单（为方便起见，人为设计）的C代码计算n *（i + j）：</p><p> int  sum_up ( int  i ,  int  j ,  unsigned  int  n )  {  int  result  =  0 ;  while  ( n  &gt;  0 )  {  result  +=  i  +  j ;  n  -=  1 ;  }  return  result ; }</p><p> int sum_up（int i，int j，unsigned int n）{int result = 0;而（n> 0）{结果+ = i + j; n-= 1;返回结果; } </p><p> One transformation the compiler might want to do is to move the addition  i+j out of the loop, to avoid computing the sum each time around the loop (this is called “loop-invariant code motion”  1):</p><p>编译器可能想要进行的一种转换是将加法运算i + j移出循环，以避免每次绕循环计算总和（这称为“循环不变代码运动” 1）：</p><p> int  sum_up ( int  i ,  int  j ,  unsigned  int  n )  {  // optimized version  int  result  =  0 ;  int  s  =  i  +  j ;  while  ( n  &gt;  0 )  {  result  +=  s ;  n  -=  1 ;  }  return  result ; }</p><p> int sum_up（int i，int j，unsigned int n）{//优化版本int result = 0;整数s = i + j;而（n> 0）{结果+ = s; n-= 1;返回结果; }</p><p> However, that transformation is actually incorrect.If we imagine a caller using this function as  sum_up(INT_MAX, 1, 0), then this is a perfectly correct way to call  sum_up: the loop is never entered, so the overflowing addition  INT_MAX+1 is never performed.However, after the desired optimization, the program now causes a signed integer overflow, which is UB (Undefined Behavior) and thus May Never Happen!</p><p> 但是，这种转换实际上是不正确的。如果我们想象一个调用者将此函数用作sum_up（INT_MAX，1，0），则这是调用sum_up的一种完全正确的方法：永远不会进入循环，因此溢出的加法INT_MAX + 1但是，经过所需的优化后，该程序现在会导致有符号整数溢出，即UB（未定义行为），因此可能永远不会发生！</p><p> One might be tempted to ignore this problem because the UB on integer overflow is a compiler-only concept; every target supported by the compiler will do the obvious thing and just produce an overflowing result.However, there might be other compiler passes running after the optimization we are considering.One such pass might inline  sum_up, and another pass might notice the  INT_MAX+1 and replace it by  unreachable since UB code is “by definition” unreachable, and another pass might then just remove all our code since it is unreachable.Each of these passes has a good reason to exist (it can help real code become a lot faster or help prune dead code), but if we combine them all with loop-invariant code motion, the result is a disaster.</p><p> 人们可能很想忽略这个问题，因为整数溢出的UB是仅编译器的概念；编译器支持的每个目标都会做明显的事情，并且只会产生溢出结果，但是，在我们考虑优化之后可能还会运行其他编译器遍历，其中一个遍历可以内联sum_up，而另一个遍历可能会注意到INT_MAX + 1并将其替换为不可达，因为UB代码“按定义”不可达，然后另一遍可能会删除我们所有的代码，因为它不可达。这些遍历中的每一个都有一个充分的理由存在（它可以帮助真正的代码变得更快或帮助修剪死代码），但如果将它们与循环不变代码运动结合在一起，结果将是一场灾难。</p><p> One way (and the only systematic way I know) to avoid such problems is to make sure that we can justify the correctness of each optimization  in isolation.Each optimization must be  correct for any possible program, where  correct means that the optimized program must only “do things” that the original program could have done as well.(This is basically the “as-if” rule in the C standard, and is typically called “refinement” in the academic literature.)In particular, no optimization must ever introduce UB into a UB-free program.</p><p> 避免此类问题的一种方法（也是我所知道的唯一系统的方法）是确保我们可以孤立地证明每个优化的正确性。每个优化对于任何可能的程序都必须是正确的，其中正确意味着被优化的程序必须仅原始程序也可以做的“做某事”。（这基本上是C标准中的“假设”规则，在学术文献中通常称为“优化”。）尤其是，永远不必进行优化。将UB引入无UB程序中。</p><p> It may seem now that under this premise, it is impossible to perform the loop-invariant code motion we are considering.But that is not the case!So far, what we have seen is that the optimization is not  correct when being performed on a C program.But when LLVM performs these optimizations, it does not consider the program to be written in C—it considers the program to be written in LLVM IR, which has a different semantics than C.Specifically, the  LLVM LangRef says that signed integer overflow in LLVM IR yields a  poison value.It is not UB to produce  poison, it is just UB to use  poison in certain ways (the details of this do not matter here).In a call to the optimized  sum_up(INT_MAX, 1, 0), the  s variable introduced by loop-invariant code motion is unused, so the fact that its value is  poison does not matter!</p><p> 现在看来，在此前提下，不可能执行我们正在考虑的循环不变代码运动，但事实并非如此！到目前为止，我们所看到的是，优化是在对处理器执行的时候是不正确的C程序。但是当LLVM执行这些优化时，它不认为程序是用C编写的，而是认为程序是用LLVM IR编写的，它的语义与C有所不同。具体地说，LLVM LangRef表示带符号整数LLVM IR中的溢出会产生毒物值。不是UB产生毒物，只是以某种方式使用毒物的UB（此处的详细内容无关紧要）。在调用优化的sum_up（INT_MAX，1， 0），循环不变代码运动引入的s变量未使用，因此其值是有毒的事实无关紧要！</p><p> Due to this behavior of signed integer overflow, this case of loop-invariant code motion is  correct if we consider it as an optimization on programs that are written in LLVM IR.  2The “price” we pay for this is that replacing  INT_MAX+1 by  unreachable is not  correct in LLVM IR, since it is not UB.</p><p> 由于有符号整数溢出的这种行为，如果我们将其视为对LLVM IR编写的程序的优化，则这种循环不变代码运动的情况是正确的。 2为此，我们付出的“代价”是在LLVM IR中用不可达替换INT_MAX + 1是不正确的，因为它不是UB。 </p><p> The great thing about  correct optimizations is that we can combine any number of them in any order (such as inlining, replacing definite UB by  unreachable, and removing unreachable code), and we can be sure that the result obtained after all these optimizations is a correct compilation of our original program.(In the academic lingo, we would say that “refinement is transitive”.)</p><p>正确优化的妙处在于，我们可以按任意顺序组合任意数量的优化（例如，内联，用不可达代码替换确定的UB，以及删除不可达代码），并且我们可以确保所有这些优化之后获得的结果是正确地编写原始程序。（在学术术语中，我们会说“改进是可传递的”。）</p><p> However, to make the argument that an optimization is  correct, the exact semantics of LLVM IR (what the behavior of all possible programs is and when they have UB) needs to be documented.All involved optimizations need to exactly agree on what is and is not UB, to ensure that whatever code they produce will not be considered UB by a later optimization.This is exactly what we also expect from the specification of a programming language such as C, which is why I think we should consider compiler IRs as proper programming languages in their own right, and specify them with the same diligence as we would specify “normal” languages.  3Sure, no human is going to write many programs in LLVM IR, so their syntax barely matters, but clang and rustc produce LLVM IR programs all the time, and as we have seen understanding the exact rules governing the behavior of programs is crucial to ensuring that the optimizations LLVM performs do not change program behavior.</p><p> 但是，为了证明优化是正确的，需要记录LLVM IR的确切语义（所有可能的程序的行为以及当它们具有UB时的行为）。而不是UB，以确保它们产生的任何代码在以后的优化中都不会被视为UB。这正是我们对C等编程语言规范的期望，这就是为什么我认为我们应该将编译器IR视为适当的原因自行编程语言，并以与指定“常规”语言相同的努力来指定它们。 3当然，没有人会用LLVM IR编写许多程序，因此它们的语法几乎没有关系，但是clang和rustc始终会生成LLVM IR程序，而且正如我们所看到的那样，了解控制程序行为的确切规则对于确保LLVM执行的优化不会更改程序行为。</p><p> Take-away: If we want to be able to justify the correctness of a compiler in a modular way, considering only one optimization at a time, we need to perform these optimizations in an IR that has a precise specification of all aspects of program behavior, including UB.Then we can, for each optimization separately, consider the question: does the optimization ever change program behavior, and does it ever introduce UB into UB-free programs?For a  correct optimization, the answer to these questions is “no”.</p><p> 要点：如果我们希望能够以模块化的方式证明编译器的正确性，一次只考虑一次优化，那么我们需要在IR中执行这些优化，该IR必须对程序行为的各个方面进行精确说明（包括UB）。然后，我们可以针对每个优化分别考虑以下问题：优化是否会改变程序行为，是否将UB引入无UB程序中？对于正确的优化，这些问题的答案是“否”。 ”。</p><p>  With the warm-up done, we are now ready to consider some more tricky optimizations, which we will use to explore the question of how precise a language specification needs to be.We will look at three different optimizations LLVM can perform, and I will show that they  cannot all be correct since the first and last program we are considering actually have  different behavior.(More precisely: the last program has a possible behavior that was not possible for the first program.)This is only possible if at least one optimization changed program behavior in an incorrect way, but it is actually not entirely clear which optimization is the culprit.</p><p>  完成预热后，我们现在准备考虑一些更棘手的优化，我们将使用它们来探索语言规范需要达到的精确度的问题，我们将研究LLVM可以执行的三种不同的优化，我将表明由于我们正在考虑的第一个程序和最后一个程序实际上具有不同的行为，所以它们不可能都是正确的（更确切地说：最后一个程序具有第一个程序不可能的可能的行为）只有在至少一个优化以不正确的方式更改了程序行为，但是实际上并不清楚是哪个优化的罪魁祸首。</p><p> The sequence of examples is taken from  this talk by Chung-Kil Hur; it was discovered while working on a mathematically rigorous specification of LLVM.</p><p> 例子序列取材自Chung-Kil Hur的演讲。它是在研究严格的LLVM规范时发现的。</p><p>  char  p [ 1 ],  q [ 1 ]  =  { 0 }; uintptr_t  ip  =  ( uintptr_t )( p + 1 ); uintptr_t  iq  =  ( uintptr_t ) q ; if  ( iq  ==  ip )  {  * ( char * ) iq  =  10 ;  print ( q [ 0 ]); }</p><p>  字符p [1]，q [1] = {0}; uintptr_t ip =（uintptr_t）（p + 1）; uintptr_t iq =（uintptr_t）q;如果（iq == ip）{*（char *）iq = 10;打印（q [0]）; }</p><p> I am using C syntax here just as a convenient way to write programs in LLVM IR.</p><p> 我在这里使用C语法只是在LLVM IR中编写程序的一种便捷方式。 </p><p> This program has two possible behaviors: either  ip (the address one-past-the-end of  p) and  iq (the address of  q) are different, and nothing is printed.Or the two are equal, in which case the program will print “10” ( iq is the result of casting  q to an integer, so casting it back will yield the original pointer, or at least a pointer pointing to the same object / location in memory).</p><p>该程序有两种可能的行为：ip（p的地址的前一末尾）和iq（q的地址）不同，并且什么都不打印，或者两者相等，在这种情况下，程序将打印“ 10”（iq是将q强制转换为整数的结果，因此将其强制返回将产生原始指针，或至少指向内存中相同对象/位置的指针）。</p><p> The first “optimization” we will perform is to exploit that if we enter the  if body, we have  iq == ip, so we can replace all  iq by  ip.Subsequently the definition of  ip is inlined:</p><p> 我们将执行的第一个“优化”是利用如果我们输入if主体，则拥有iq == ip，因此我们可以将所有iq替换为ip。随后，ip的定义被内联：</p><p> char  p [ 1 ],  q [ 1 ]  =  { 0 }; uintptr_t  ip  =  ( uintptr_t )( p + 1 ); uintptr_t  iq  =  ( uintptr_t ) q ; if  ( iq  ==  ip )  {  * ( char * )( uintptr_t )( p + 1 )  =  10 ;  // &lt;- This line changed  print ( q [ 0 ]); }</p><p> 字符p [1]，q [1] = {0}; uintptr_t ip =（uintptr_t）（p + 1）; uintptr_t iq =（uintptr_t）q;如果（iq == ip）{*（char *）（uintptr_t）（p + 1）= 10; //＆lt;-此行更改了打印（q [0]）; }</p><p> The second optimization notices that we are taking a pointer  p+1, casting it to an integer, and casting it back, so we can remove the cast roundtrip:</p><p> 第二次优化注意到我们正在获取一个指针p + 1，将其强制转换为整数，然后将其强制返回，因此我们可以删除强制转换：</p><p> char  p [ 1 ],  q [ 1 ]  =  { 0 }; uintptr_t  ip  =  ( uintptr_t )( p + 1 ); uintptr_t  iq  =  ( uintptr_t ) q ; if  ( iq  ==  ip )  {  * ( p + 1 )  =  10 ;  // &lt;- This line changed  print ( q [ 0 ]); }</p><p> 字符p [1]，q [1] = {0}; uintptr_t ip =（uintptr_t）（p + 1）; uintptr_t iq =（uintptr_t）q;如果（iq == ip）{*（p + 1）= 10; //＆lt;-此行更改了打印（q [0]）; }</p><p> The final optimization notices that  q is never written to, so we can replace  q[0] by its initial value  0:</p><p> 最终的优化注意到q从未被写入，因此我们可以将q [0]替换为其初始值0：</p><p> char  p [ 1 ],  q [ 1 ]  =  { 0 }; uintptr_t  ip  =  ( uintptr_t )( p + 1 ); uintptr_t  iq  =  ( uintptr_t ) q ; if  ( iq  ==  ip )  {  * ( p + 1 )  =  10 ;  print ( 0 );  // &lt;- This line changed }</p><p> 字符p [1]，q [1] = {0}; uintptr_t ip =（uintptr_t）（p + 1）; uintptr_t iq =（uintptr_t）q;如果（iq == ip）{*（p + 1）= 10;打印（0）; //＆lt;-此行已更改} </p><p> However, this final program is different from the first one!Specifically, the final program will either print nothing or print “0”, while the original program  could never print “0”.This shows that the sequence of three optimizations we performed, as a whole, is  not correct.</p><p>但是，该最终程序与第一个程序不同！具体地说，最终程序将不打印任何内容或打印“ 0”，而原始程序则永远不会打印“ 0”。这表明我们执行了三个优化的顺序，如下所示：整体而言，是不正确的。</p><p>  Clearly, one of the three optimizations is incorrect in the sense that it introduced a change in program behavior.But which one is it?</p><p>  显然，这三种优化中的一种是不正确的，因为它引入了程序行为的改变，但是到底是哪一种呢？</p><p> In an ideal world, we would have a sufficiently precise semantics for LLVM IR that we would just have to read the docs (or, even better, run some Miri-like tool) to figure out the answer.However, describing language semantics at this level of precision is  hard, and full of trade-offs.The LLVM LangRef will not give us a clear answer here, and indeed obtaining a clear answer requires some decisions that have not been explicitly made yet.</p><p> 在理想的世界中，我们将为LLVM IR提供足够精确的语义，以至于只需阅读文档（或者更好的是运行一些类似于Miri的工具）即可找到答案，但是在此描述语言语义LLVM LangRef在这里不会给我们一个明确的答案，实际上要获得一个明确的答案需要做出一些尚未明确做出的决定。</p><p> To proceed, we will use the three optimizations that we considered above as cues: assuming that the optimization is correct for LLVM IR, what does that tell us about the semantics?</p><p> 继续进行，我们将使用上面作为提示考虑的三个优化：假设该优化对于LLVM IR是正确的，那么这对语义有何启示？</p><p> Let us start with the last optimization, where the  print argument is changed from  q[0] to  0.This optimization is based on alias analysis: q[0] gets initialized to  0 at the beginning of the program, and the only write between that initialization and the  print is to the pointer  p+1.Since  q and  p point to different local variables, a pointer derived from  p cannot alias  q[0], and hence we know that this write cannot affect the value stored at  q[0].</p><p> 让我们从最后一个优化开始，将print参数从q [0]更改为0。此优化基于别名分析：q [0]在程序开始时初始化为0，并且在因为q和p指向不同的局部变量，所以从p派生的指针不能别名q [0]，因此我们知道该写操作不会影响存储在q [ 0]。</p><p> Looking more closely, however, reveals that things are not quite so simple! p+1 is a one-past-the-end pointer, so it actually  can have the same address as  q[0](and, in fact, inside the conditional we know this to be the case).However, LLVM IR (just like C) does not permit memory accesses through one-past-the-end pointers.It makes a difference whether we use  p+1 or  q inside the  if, even though we know (in that branch) that both pointers point to the same memory location.This demonstrates that in LLVM IR, there is more to a pointer than just the address it points to—it also matters how this address was computed.This extra information is typically called  provenance.It is impossible to argue for the  correctness of the third optimization without acknowledging that provenance is a real part of the semantics of an LLVM IR program.In a flat memory model where pointers are just integers (such as most assembly languages), this optimization is simply wrong.</p><p> 然而，更仔细地观察发现，事情并不是那么简单！ p + 1是一个唯一的指针，因此它实际上可以具有与q [0]相同的地址（并且实际上，在条件内，我们知道是这样）。但是，LLVM IR（就像C）不允许通过过去的指针进行内存访问，即使我们知道（在那个分支中）两个指针都指向if，在if中使用p + 1或q也会有所不同。相同的内存位置。这表明在LLVM IR中，指向指针的不仅仅是指针指向的地址，这也关系到该地址的计算方式。这额外的信息通常称为出处。无法为正确性辩解在没有确认出处是LLVM IR程序语义的真正组成部分的情况下，在第三次优化中，在指针只是整数（例如大多数汇编语言）的平面内存模型中，这种优化是完全错误的。</p><p> Now that we know that provenance exists in pointers, we have to also consider what happens to provenance when a pointer gets cast to an integer and back.The second optimization gives us a clue into this aspect of LLVM IR semantics: casting a pointer to an integer and back is optimized away, which means that  integers have provenance.To see why, consider the two expressions  (char*)(uintptr_t)(p+1) and  (char*)(uintptr_t)q:if the optimization of removing pointer-integer-pointer roundtrips is correct, the first operation will output  p+1 and the second will output  q, which we just established are two different pointers (they differ in their provenance).The only way to explain this is to say that the input to the  (char*) cast is different, since the program state is otherwise identical in both cases.But we know that the integer values computed by  (uintptr_t)(p+1) and  (uintptr_t)q (i.e., the bit pattern as stored in some CPU register) are the same, and hence a difference can only arise if these integers consist of more than just this bit pattern—just like pointers, integers have provenance.</p><p> 既然我们知道指针中存在出处，那么我们还必须考虑当指针被强制转换为整数然后返回时会发生什么情况。第二种优化为我们提供了LLVM IR语义这一方面的线索：将指针强制转换为整数和back被优化掉了，这意味着整数具有出处。要了解原因，请考虑两个表达式（char *）（uintptr_t）（p + 1）和（char *）（uintptr_t）q：如果移除指针的优化-integer-pointer往返是正确的，第一个操作将输出p + 1，第二个操作将输出q，我们刚刚建立的是两个不同的指针（它们的来源不同）。唯一的解释方法是说（char *）类型转换的输入是不同的，因为在两种情况下程序状态都是相同的。但是我们知道由（uintptr_t）（p + 1）和（uintptr_t）q（即位模式）计算的整数值就像存储在某些CPU寄存器中一样），因此只能产生差异如果这些整数不仅仅包含该位模式，则就像指针一样，整数具有出处。 </p><p> Finally, let us consider the first optimization.Here, a successful equality test  iq == ip prompts the optimizer to replace one value by the other.This optimization demonstrates that  integers do not have provenance:the optimization is only correct if a successful run-time equality test implies that the two values are equivalent in the “Abstract Machine” that is used to describe the language semantics.But this means that the Abstract Machine version of this value cannot have any “funny” extra parts that are not represented at run-time.Of course, provenance is exactly such a “funny” extra part.A different way to phrase the same argument is to say that this optimization is correct only if  iq == ip evaluating to  true implies that both values have the same “Abstract Machine” representation, so if that representation involves provenance, both values must have the same provenance.This would be a possible definition of  == in LLVM IR, but only in principle—in practice this means the LLVM backends have to compile  == in a way that pointer provenance is taken into account, which of course is impossible.</p><p>最后，让我们考虑第一个优化。在这里，成功的相等性测试iq == ip会提示优化器将一个值替换为另一个值。此优化表明整数不具有出处：该优化仅在成功运行时才正确-时间相等性测试意味着这两个值在用于描述语言语义的“抽象机”中是等效的。但这意味着该值的抽象机版本不能包含运行时未表示的任何“有趣”多余部分时间。当然，出处就是这样一个“有趣的”额外部分。用不同的方式表达同一论点的方法是说，只有当iq == ip评估为true时，这种优化才是正确的，这意味着两个值具有相同的“ “抽象机器”表示形式，因此，如果该表示形式包含出处，则两个值必须具有相同的出处。这可能是LLVM IR中==的定义，但仅在原则上—实际上，这意味着LLVM ba ckends必须以考虑指针出处的方式编译==，这当然是不可能的。</p><p> Take-away:By considering each of these three optimizations in terms of what they tell us about the semantics of LLVM IR, we learned that pointers have provenance, that integers remember the provenance of the pointer they come from in case of a pointer-to-integer cast, and that integers do not have provenance.This is a contradiction, and this contradiction explains why we saw incorrect compilation results when applying all three optimizations to the same program.</p><p> 总结：通过就LLVM IR的语义告诉我们这三个优化中的每一个，我们了解到指针具有出处，在记住指向指针的情况下，整数记住它们来自的指针的出处-integer强制转换，并且整数不具有出处。这是一个矛盾，这个矛盾解释了为什么在将所有三个优化应用于同一程序时我们看到不正确的编译结果。</p><p>  To fix the problem, we will have to declare one of the three optimizations incorrect and stop performing it.Speaking in terms of the LLVM IR semantics, this corresponds to deciding whether pointers and/or integers have provenance:</p><p>  为了解决这个问题，我们必须声明三个优化之一不正确并停止执行它。就LLVM IR语义而言，这相当于确定指针和/或整数是否具有出处：</p><p> We could say pointers have provenance but integers do not, which invalidates the second optimization.</p><p> 我们可以说指针具有出处，而整数则没有，这会使第二个优化无效。</p><p> In my opinion, the first and last options are not tenable.Removing provenance altogether kills all but the most simple alias analyses.  4On the other hand, declaring that integers have provenance does not just disable the first optimization in the chain shown above, it also disables common arithmetic optimizations such as  x - x being equivalent to  0.Even achieving commutativity and associativity of  + becomes non-trivial once integers have provenance.</p><p> 在我看来，第一个和最后一个选项是站不住脚的。除去起源，除了最简单的别名分析外，其他所有分析都被杀死了。 4另一方面，声明整数具有出处不仅会禁用上面显示的链中的第一个优化，而且还会禁用常见的算术优化，例如x-x等于0。一旦整数具有出处。</p><p> So, I think that the issue should be resolved by saying that pointers have provenance but integers do not, which means that it is the second optimization that is wrong.This also corresponds to  what has been recently proposed to the C standard committee.That’s why  LLVM bug #34548 says that optimizing away pointer-integer-pointer roundtrips is incorrect, and LLVM should stop doing this in the general case.There might still be special cases where this can be done, but figuring out the limits of this requires a more precise description of LLVM IR semantics such as what we proposed  in this paper.</p><p> 因此，我认为应该通过说指针具有起源而不是整数来解决该问题，这意味着第二个优化是错误的，这也与最近向C标准委员会提出的建议相对应。 LLVM错误＃34548说优化指针整数指针往返是不正确的，在一般情况下LLVM应该停止这样做，在某些特殊情况下仍然可以这样做，但要弄清楚这的局限性还需要更多LLVM IR语义的精确描述，例如我们在本文中提出的内容。</p><p> But ultimately, it will be up to the LLVM community to make this decision.All I can say for sure is that they have to make a choice, because the status quo of doing all three of these optimizations leads to incorrect compilation results.</p><p> 但是最终，将由LLVM社区来决定。我可以肯定地说的是，他们必须做出选择，因为执行这三种优化的现状都会导致错误的编译结果。 </p><p>  What did we learn?First of all, pointers are complicated.Precisely describing their semantics in a way that is consistent with common alias analyses requires adding a notion of “provenance”.In a language such as Java or ML where pointers are opaque types whose representation cannot be observed, this is actually fairly easy to do.But in a language such as Rust, C, or C++ that supports pointer-integer casts, the introduction of provenance poses some really tricky questions, and at least one of the commonly performed optimizations in this space has to give.</p><p>我们学到了什么？首先，指针很复杂。要以与通用别名分析一致的方式精确描述其语义，就需要添加“源”的概念。在Java或ML之类的语言中，指针是不透明的类型，其指针无法观察到表示形式，这实际上是很容易做到的。但是在诸如Rust，C或C ++之类的语言中，该语言支持指针整数类型转换，出处的引入提出了一些非常棘手的问题，并且至少是一个经常执行的问题。这个空间的优化必须给予。</p><p> We also learned that LLVM has a bug, but that was  not the point of this blog post.The GCC developers  made exactly the same mistake, and I got word that MSVC and ICC have the same issue (though I do not know how to verify this).And I cannot blame them; the way compiler development typically works, I think bugs like this are inevitable: when exactly UB arises in an IR is often only loosely specified, in many cases “by omission” (where cases not covered in the spec are implicitly UB), so evaluating whether some optimization is  correct in the sense defined above can be very tricky or even impossible.Pointer provenance is just a particularly good (and subtle) example.For another example, see  §2.3 of this paper (Figure 3 contains the code) which shows how a sequence of two optimizations can lead to a miscompilation, where the first optimization is  correct under the LLVM concurrency model, and the second optimization is  correct under the C++11 concurrency model—but there is no concurrency model under which  both optimizations are correct, so each compiler (or rather, each compiler IR) needs to pick one or the other.Finally, this  paper on  undef and  poison gives examples for optimizations that are broken by the presence of  undef in LLVM, and describes some of the trade-offs that arise when defining the semantics of  poison.Again miscompilations arise because the consequence of a statement in one place of the specification ( undef picks a fresh value at each use) are not considered elsewhere (testing an integer for equality with zero dos not imply it is zero; it could also be  undef).</p><p> 我们还了解到LLVM有一个错误，但这不是本文的重点.GCC开发人员犯了完全相同的错误，我得知MSVC和ICC存在相同的问题（尽管我不知道如何验证我不能责怪他们;我认为这样的错误是不可避免的：在IR中出现准确的UB时，通常只是松散地指定，在许多情况下是“忽略”（在规范中未包括的情况是UB隐含的），因此评估在上面定义的意义上某些优化是否正确可能非常棘手甚至是不可能的。指针出处只是一个特别好的（且微妙的）示例。有关另一个示例，请参见本文的第2.3节（图3包含代码），其中显示了两种优化的序列如何导致编译错误，其中第一种优化在LLVM并发模型下是正确的，第二种优化在C ++ 11并发模型下是正确的，但是没有并发模型可以同时进行这两种优化是正确的，因此每个编译器（或更确切地说，每个编译器IR）都需要选择一个。最后，有关undef和中毒的论文提供了一些优化示例，这些优化被L中存在undef破坏了LVM，并描述了定义有毒的语义时出现的一些折衷;再次出现错误编译是因为在规范的某个地方声明的结果（每次使用undef都会获取新的值）并未在其他地方考虑（测试）等于零的等值整数并不意味着它为零；也可能是undef）。</p><p> Which brings me to my main conclusion for this post: to avoid the problem of incompatible optimizations, I think we need to take compiler IRs more serious as programming languages in their own right, and give them a precise specification—including all the UB.Now, you may object by saying that LLVM has an  extensive LangRef, and still, by reading the LLVM specification one could convince oneself that each of the three optimizations above is correct, which as we have seen is contradictory.What is missing? Do we need a formal mathematical definition to avoid such ambiguities?I do not think so; I think there is something simpler that will already help a lot.The source of the contradiction is that some parts of the specification  implicitly assume that pointers have provenance, which is easy to forget when considering other operations.That’s why I think it is very important to make such assumptions more explicit: the specification should  explicitly describe the information that “makes up” a value, which will include things like provenance and  whether the value is (wholly or partially) initialized.  5This information needs to be extensive enough such that a hypothetical interpreter can use it to detect all the UB.Doing so makes it obvious</p><p> 这使我得出本文的主要结论：为避免不兼容的优化问题，我认为我们需要更认真地考虑编译器IR作为编程语言本身的重要性，并为它们提供精确的规范-包括所有UB。 ，您可能会说LLVM具有广泛的LangRef来表示反对，但通过阅读LLVM规范，您仍然可以使自己相信上述三个优化中的每一个都是正确的，正如我们所看到的，这是矛盾的。我们是否需要一个正式的数学定义来避免此类歧义？我认为有一些简单的方法已经可以帮上大忙了。矛盾的根源是规范的某些部分隐含地认为指针具有出处，这在考虑其他操作时很容易忘记，这就是为什么我认为它非常重要为了使这些假设更加明确：规范应明确描述“构成”值的信息，其中包括诸如出处以及是否（完全或部分）初始化该值。 5此信息需要足够广泛，以使假设的解释器可以使用它来检测所有UB。</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.ralfj.de/blog/2020/12/14/provenance.html">https://www.ralfj.de/blog/2020/12/14/provenance.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ii/">#ii</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/优化/">#优化</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>