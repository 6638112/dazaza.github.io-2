<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Pl / PgSQL计算新的Postgres列 Using Pl/PgSQL to Calculate New Postgres Columns</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Using Pl/PgSQL to Calculate New Postgres Columns<br/>使用Pl / PgSQL计算新的Postgres列 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-13 06:12:25</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/7bc898a7bef958dede117786164215ed.jpg"><img src="http://img2.diglog.com/img/2020/12/7bc898a7bef958dede117786164215ed.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In our last blog post on  using Postgres for statistics, I covered some of the decisions on how to handle calculated columns in  PostgreSQL. I chose to go with adding extra columns to the same table and inserting the calculated values into these new columns. Today’s post is going to cover how to implement this solution using  Pl/pgSQL.</p><p>在上一篇有关使用Postgres进行统计的博客文章中，我介绍了有关如何处理PostgreSQL中计算列的一些决策。我选择在同一张表中添加额外的列，然后将计算出的值插入这些新列中。今天的帖子将介绍如何使用Pl / pgSQL实现此解决方案。</p><p>  I bet your first question is going to be: Why did you choose to do this in Pl/pgSQL rather than just some quick editor work?</p><p>  我敢打赌，您的第一个问题将是：为什么选择在Pl / pgSQL中执行此操作，而不仅仅是一些快速的编辑器工作？</p><p> I actually started with handcrafting all the data definition language ( DDL) and SQL statements and quickly changed my mind. Just to remind you, here are all the explanatory columns we have in our fire dataset:</p><p> 我实际上是从手工制作所有数据定义语言（DDL）和SQL语句开始的，然后迅速改变了主意。提醒您，以下是我们的火灾数据集中所有的说明性列：</p><p>    Hasfire is the variable we are trying  to predict (the occurrence of a fire) and all the other columns are the potential explanatory variables.</p><p>    Hasfire是我们试图预测的变量（发生火灾），其他所有列都是潜在的解释变量。</p><p>   Not only would I have to make 9 new table columns but also 9 different INSERT formula columns. All that is a great opportunity to put a typo in a column name or a formula. It is also a lot of  copy and pasting.</p><p>   我不仅需要创建9个新表列，而且还要创建9个不同的INSERT公式列。所有这些都是在列名或公式中输入错字的绝佳机会。它也很多复制和粘贴。</p><p> Calculating Z-scores is a standard step in many data science workflows. By writing a Pl/pgSQL function, I could simply repeat calculating columns in any new analysis by using the function. It would also be available to other data scientists to use as well.</p><p> 计算Z分数是许多数据科学工作流程中的标准步骤。通过编写Pl / pgSQL函数，我可以使用该函数在任何新的分析中简单地重复计算列。其他数据科学家也可以使用它。</p><p> I need to learn more Pl/pgSQL and this seemed like an interesting problem. The function was going to have to run some DDL and some SQL.</p><p> 我需要学习更多的Pl / pgSQL，这似乎是一个有趣的问题。该功能将必须运行一些DDL和一些SQL。 </p><p>  As mentioned above, I wanted the function to be generic so I could re-use it in other places. I also decided that it would be best to retain the original column name in the calculated column name. Finally, I wanted to handle all the columns at once, not a function for a single column at a time.</p><p>如上所述，我希望该函数具有通用性，以便可以在其他地方重用它。我还决定最好将原始列名保留在计算出的列名中。最后，我想一次处理所有列，而不是一次处理单个列的函数。</p><p>  With these constraints in mind, I came up with a function that accomplishes all 3 goals. To see the entire function, it&#39;s  on github, but for the blog post I am going to break it down into sections.</p><p>  考虑到这些限制，我想出了一个可以实现所有3个目标的功能。要查看整个功能，它在github上，但是对于博客文章，我将其分为几部分。</p><p>   CREATE OR REPLACE FUNCTION final.initial_center_standardize(schema_name  TEXT, table_name  TEXT, prefix  TEXT, column_names  TEXT[], pkey  TEXT)  RETURNS TEXT as</p><p>   创建或替换功能final.initial_center_standardize（schema_name TEXT，table_name TEXT，前缀TEXT，column_names TEXT []，pkey TEXT）将TEXT返回为</p><p>  The beginning of the statement is just normal SQL to create a new function. Notice I am actually creating this function inside the schema name “final”. The first two parameters get the schema and table name for the table where we are going to add the columns.</p><p>  该语句的开头只是创建新函数的普通SQL。注意，我实际上是在架构名称“ final”内部创建此函数。前两个参数获取要在其中添加列的表的模式和表名。</p><p> The next parameter is going to be the prefix for the new calculated column name. The next parameter is an array of text values (which is a data type in PostgreSQL). The array contains the name of all the columns for which we want Z-scores. Finally, we need the name of the primary key column for one of the queries used in the function.</p><p> 下一个参数将是新计算出的列名称的前缀。下一个参数是文本值数组（PostgreSQL中的数据类型）。该数组包含我们想要Z分数的所有列的名称。最后，对于该函数中使用的查询之一，我们需要主键列的名称。</p><p> I just return a text field because none of this work will return any data values, but I like to show the caller if the call worked. I usually return “done” or “finished” for success and “error” with some text explaining what went wrong.</p><p> 我只是返回一个文本字段，因为任何一项工作都不会返回任何数据值，但是我想向调用方显示调用是否有效。为了获得成功和“错误”，我通常会返回“完成”或“完成”，并附上一些解释错误原因的文字。</p><p> Just to be clear, for those new to Pl/pgSQL programming, I did not come up with this signature at the beginning. Some of the needed parameters only became apparent as I built the rest of the function.</p><p> 需要明确的是，对于那些对Pl / pgSQL编程不熟悉的人，我一开始并没有提出这个签名。当我构建其余函数时，一些所需的参数才变得显而易见。 </p><p>  With the signature done, we first declare some variables we will need later in the function. Pl/pgSQL  requires you to pre-declare any variables you use in a block.</p><p>完成签名后，我们首先声明一些稍后在函数中需要的变量。 Pl / pgSQL要求您预先声明在块中使用的任何变量。</p><p> The next step is to create a   foreach loop to give us access to each individual element in the array of column names we passed in.</p><p> 下一步是创建一个foreach循环，使我们可以访问传入的列名数组中的每个单独元素。</p><p>  Like a normal looping and  iterator pattern, this code will extract the first element in the array and give that element the name ‘col’ in the body of the loop. It will continue to iterate through array elements until there are no more elements in the array. This is perfect for our work, each column is going to get the same treatment.</p><p>  像普通的循环和迭代器模式一样，此代码将提取数组中的第一个元素，并在循环体中为该元素命名为“ col”。它将继续遍历数组元素，直到数组中没有更多元素为止。这对我们的工作而言是完美的，每个专栏都将获得相同的待遇。</p><p>  Next our code takes on the task of creating the new column to hold the Z-score. First we create the new column name and storing it in a variable:</p><p>  接下来，我们的代码承担创建新列以保存Z分数的任务。首先，我们创建新的列名并将其存储在变量中：</p><p>  We take the prefix passed in and concatenate it ( &#39;||&#39; in SQL) to the original column name. I like using the same prefix before each column because it makes it clearer which columns are the raw columns and which have the Z-score.</p><p>  我们采用传入的前缀并将其（在SQL中为＆＃39; ||＆＃39;）连接到原始列名。我喜欢在每列之前使用相同的前缀，因为这样可以更清楚地知道哪些列是原始列，哪些具有Z分数。</p><p> Now we do our actual SQL to create the new column in the same table:</p><p> 现在，我们执行实际的SQL以在同一表中创建新列：</p><p>  Normally Pl/pgSQL will cache the query plan for a SQL statement. In our case, this statement is going to change each time we run through the loop, making our query dynamic. For dynamic queries you use  EXECUTE to tell the PostgreSQL query planner not to cache the query.</p><p>  通常，Pl / pgSQL将为SQL语句缓存查询计划。在我们的例子中，每次运行循环时，此语句都会更改，从而使查询动态化。对于动态查询，可以使用EXECUTE告诉PostgreSQL查询计划者不要缓存查询。 </p><p> To make sure we do SQL safe variable substitution, we use the  FORMAT command. The ‘%I’ in the SQL statement indicates we need this value to be treated like a SQL identifier (i.e. put “ around a capitalized table name or escape an ‘ in a string value). This is the same behavior as the   quote_ident command.</p><p>为了确保执行SQL安全变量替换，我们使用FORMAT命令。 SQL语句中的“％I”表示我们需要将此值像SQL标识符一样对待（即，在大写的表名前后加上“，或在字符串值中转义为”）。这与quote_ident命令的行为相同。</p><p> Then, by default, the parameters are substituted into the string in the order they appear at the end of the FORMAT command. So if:</p><p> 然后，默认情况下，参数以它们在FORMAT命令末尾出现的顺序替换为字符串。因此，如果：</p><p>    In the specific case of our example we can get away with making every column NUMERIC because Z-scores are always a decimal number regardless of the number type of the input. And with that, we have created our new column in the table.</p><p>    在本例的特定情况下，我们可以避免将每一列都设为NUMERIC，因为Z分数始终是一个十进制数字，而与输入的数字类型无关。这样，我们在表中创建了新列。</p><p>  We have a new column but there is no data in it. Let’s solve that now. Here is the statement I used to calculate the Z-score for the new column (formatted for readability):</p><p>  我们有一个新列，但其中没有数据。现在解决这个问题。这是我用来计算新列的Z得分（为便于阅读而设置）的语句：</p><p> EXECUTE FORMAT(  &#39; WITH summary  AS (  SELECT AVG( %1$I)  AS avg,  STDDEV( %1$I)  AS stddev  FROM  %3$I.%4$I), &#39;  ||  &#39;final_select  AS ( SELECT  %5$I, ( %1$I - avg)/stddev  AS centered  FROM  %3$I.%4$I  CROSS JOIN summary) &#39;  ||   UPDATE  %3$I.%4$I  SET  %2$I = final_select.centered  FROM final_select  WHERE final_select. %5$I =  %3$I.%4$I.%5$I &#39;, col, new_col_name, schema_name, table_name, pkey);</p><p> 执行格式（＆＃39;带有摘要AS（选择AVG（％1 $ I）AS平均，STDDEV（％1 $ I）AS stddev从％3 $ I.％4 $ I），＆＃39; ||＆ ＃39; final_select AS（选择％5 $ I，（％1 $ I-avg）/ stddev AS以％3 $ I.％4 $ I CROSS JOIN摘要为中心）＆＃39; ||更新％3 $ I。 ％4 $ I SET％2 $ I = final_select.centered from final_select WHERE final_select。％5 $ I =％3 $ I.％4 $ I.％5 $ I＆＃39;，col，new_col_name，schema_name，table_name， pkey）;</p><p>  Again we use the EXECUTE FORMAT so the planner doesn’t cache the query and we pass in new variables with each iteration of the loop. The actual SQL has two  CTEs to calculate the Z-score and then an UPDATE statement to insert the Z-score into the right table and column.</p><p>  再次，我们使用EXECUTE FORMAT，这样计划者就不会缓存查询，并且在每次循环迭代时都传入新变量。实际的SQL有两个CTE计算Z分数，然后有一个UPDATE语句将Z分数插入到正确的表和列中。</p><p> Because we are reusing parameters in the SQL, we have to use a slightly different syntax for the variable substitution (highlighted in  orange). Now we have variables like %1$I rather than just %I. This new notation means take the first parameter from all the parameters passed in to  FORMAT. If we had written the query the previous way, we would have passed in the same parameters multiple times in the function call. This numbered reference to parameter format is much cleaner.</p><p> 因为我们正在SQL中重用参数，所以必须对变量替换使用稍微不同的语法（以橙色突出显示）。现在我们有了像％1 $ I这样的变量，而不仅仅是％I。这种新的表示法是从传递给FORMAT的所有参数中选取第一个参数。如果我们以前面的方式编写了查询，那么我们将在函数调用中多次传递相同的参数。这种对参数格式的编号引用更加简洁。 </p><p> The first CTE ( summary) calculates the average and standard deviation for the current column in the loop. We take those values and use them in the second CTE ( final_select). By using the CROSS JOIN in this query we can use the avg and stddev in the Z-score calculation for each row in the data set. The final query is just updating the new column table with the Z-score where pkey in the final_select matches the pkey of the table.</p><p>第一个CTE（摘要）计算循环中当前列的平均值和标准偏差。我们将这些值用于第二个CTE（final_select）。通过在查询中使用CROSS JOIN，我们可以在Z分数计算中为数据集中的每一行使用avg和stddev。最终查询只是使用Z分数更新新的列表，其中final_select中的pkey与表的pkey相匹配。</p><p>  The creation of a new column and populating the values continues for each item in the iteration loop. We terminate the loop with the END LOOP statement. We then return ‘done’ to the SQL call that used the function. Again, I like returning this string because it allows the function user to know if the function actually finished, or it is taking a long time. You could change this to return NULL if you want.</p><p>  对于迭代循环中的每个项目，将继续创建新列并填充值。我们使用END LOOP语句终止循环。然后，我们将“ done”返回给使用该函数的SQL调用。同样，我喜欢返回此字符串，因为它使函数用户可以知道函数是否真正完成或花费了很长时间。您可以根据需要将其更改为返回NULL。</p><p>  There you have it, my cool little function. I know it may have looked complicated at first glance, but now that we are finished you can see there are only 2 SQL lines to carry out all our work. Think of how much copy and pasting this saved!</p><p>  有了，我很酷的小功能。我知道乍看起来可能看起来很复杂，但是现在我们已经完成了，您可以看到只有2条SQL行可以完成所有工作。考虑一下此副本可以节省多少并粘贴！</p><p> The other big benefit is now I can reuse this function in any database in the future. I can control access to it by using schema permissions. As a matter of fact, I could add this function as part of a template. Then every database created in our hypothetical data science PostgreSQL cluster would have access to this function. I could give data scientists with permission to make this call and quickly calculate Z-scores without even having to know all the Pl/pgSQL.</p><p> 另一个很大的好处是现在我可以将来在任何数据库中重用此功能。我可以通过使用架构权限来控制对其的访问。事实上，我可以将此功能添加为模板的一部分。这样，在我们假设的数据科学PostgreSQL集群中创建的每个数据库都可以使用此功能。我可以授权数据科学家进行此调用，并快速计算Z分数，而无需了解所有Pl / pgSQL。</p><p> Finally this example could easily be modified to create a new table with new columns for the Z-scores. It could also be quickly modified to use an auxiliary table where the average and standard deviation for each predictive variable is stored. This was one of the possible solutions I explained in the previous post that would probably help overall performance.</p><p> 最后，可以轻松地修改此示例，以使用Z分数的新列创建一个新表。也可以快速修改它以使用辅助表，其中存储每个预测变量的平均值和标准偏差。这是我在上一篇文章中解释的可能的解决方案之一，可能会改善整体性能。</p><p> I hope you learned something new in this post. Maybe you have already done some Pl/pgSQL to alter tables. What kind of use cases did you have? What are something of the interesting twists you uncovered. I would love to hear your thoughts, please sent them to the Crunchy Data  twitter account. Happy function writing!</p><p> 希望您在这篇文章中学到了新的东西。也许您已经完成了一些Pl / pgSQL来更改表。您有什么样的用例？您发现的有趣的曲折是什么？我希望听到您的想法，请将其发送到Crunchy Data Twitter帐户。函数编写愉快！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://info.crunchydata.com/blog/using-pl/pgsql-to-calculate-new-postgres-columns">https://info.crunchydata.com/blog/using-pl/pgsql-to-calculate-new-postgres-columns</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/pl/">#pl</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pgsql/">#pgsql</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>