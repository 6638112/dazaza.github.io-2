<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>数据日志是一种很好的授权语言吗？Is Datalog a good language for authorization?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Is Datalog a good language for authorization?<br/>数据日志是一种很好的授权语言吗？</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-20 11:51:52</div><div class="page_narrow text-break page_content"><p>Datalog is a logic programming language, based on Prolog, which is seeing something of a resurgence in interest in recent years. In particular,  several  recent  approaches to authorization (working out who can do what) have used Datalog as the logical basis for access control decisions. On the face of it, this seems like a perfect fit, and there’s a lot to recommend it. I myself have been a fan of Datalog since first coming across it at the start of my PhD studies back in 2003, and have even  written papers advocating for it. However, although I think it has a lot of benefits, I think there is some confusion about some of its complexity results that means it is not always as good a fit as you may be led to believe.</p><p>Datalog是一种基于Prolog的逻辑编程语言，近年来人们对Prolog的兴趣有所回升。特别是，最近的几种授权方法（确定谁可以做什么）使用数据日志作为访问控制决策的逻辑基础。从表面上看，这似乎是一个完美的适合，有很多建议。自从2003年我开始攻读博士学位时第一次接触到Datalog以来，我本人就是Datalog的粉丝，甚至写过倡导Datalog的论文。然而，尽管我认为它有很多好处，但我认为它的一些复杂结果令人困惑，这意味着它并不总是像你可能会相信的那样适合。</p><p>   Datalog is a cleaned up version of Prolog, created by the database community as an attempt to marry logic programming techniques with relational databases to create deductive databases. I have a great deal of respect for the database community, and when they take an interest in a topic it’s almost always worth paying attention to the solutions they come up with. (See also  injection attacks on SQL, which they neatly solved with  parameterized queries — something web browsers have  still failed to solve convincingly). In this case, Datalog improved Prolog in several ways to make it useful as a database query language:</p><p>Datalog是Prolog的一个清理版本，由数据库社区创建，试图将逻辑编程技术与关系数据库结合起来，创建演绎数据库。我非常尊重数据库社区，当他们对某个主题感兴趣时，他们提出的解决方案几乎总是值得关注的。（另请参见对SQL的注入攻击，他们通过参数化查询巧妙地解决了这一问题——web浏览器仍然未能令人信服地解决这一问题）。在本例中，Datalog以几种方式改进了Prolog，使其成为一种有用的数据库查询语言：</p><p> Removing all the  non-logical operators, such as the dreaded “cut” and I/O “predicates”, which destroy the logical purity of Prolog.</p><p>删除所有非逻辑运算符，例如可怕的“cut”和I/O“谓词”，它们破坏了Prolog的逻辑纯度。</p><p>  Discarding Prolog’s top-to-bottom backtracking execution strategy, where the order of rules in a program (or conditions in a rule) can drastically alter the correctness, performance or even termination of a query. In Datalog, the meaning and efficiency of a program is the same no matter what order the rules appear in.</p><p>放弃Prolog自上而下的回溯执行策略，即程序中规则的顺序（或规则中的条件）可以极大地改变查询的正确性、性能甚至终止。在数据日志中，无论规则以何种顺序出现，程序的意义和效率都是相同的。</p><p> Datalog allows you to write nice logical rules, such as the following classic definition of an ancestor as being the transitive closure of a parent relation:</p><p>Datalog允许您编写良好的逻辑规则，例如以下经典的祖先定义，即父关系的传递闭包：</p><p>  If you’re not familiar with Prolog syntax, then this says that a person is an ancestor of someone if they are their parent (the first rule), or if they are the parent of someone else who is an ancestor of them. This is a pretty basic (and dull) example, and not many people have a need for ancestral access control, but it hopefully gives you an idea of the power of Datalog for succinctly expressing relationships between objects.</p><p>如果您不熟悉Prolog语法，那么这意味着如果某人是他们的父母（第一条规则），或者如果某人是他们祖先的其他人的父母，那么某人就是他们的祖先。这是一个非常基本（而且枯燥）的例子，没有多少人需要祖传的访问控制，但它有望让您了解数据日志在简洁地表达对象之间关系方面的强大功能。</p><p>  Declarative rule-based approaches to authorization are attractive because they allow you to neatly separate such rules from the business logic of your application (or that’s what people hope, at least). Datalog is a particularly nice approach to this, because the rules are very expressive and concise, and also because it provides some useful features. For example, suppose we defined a set of rules to determine if a particular user should have access to a particular resource:</p><p>基于规则的声明式授权方法很有吸引力，因为它们允许您将此类规则与应用程序的业务逻辑巧妙地分开（至少人们希望如此）。数据日志是实现这一点的一种特别好的方法，因为规则非常具有表现力和简洁性，还因为它提供了一些有用的功能。例如，假设我们定义了一组规则来确定特定用户是否应该访问特定资源：</p><p> allow(Operation, Resource, User) if … % Example - allow a user to update any resource they own: allow(update, Resource, User) if  owner(Resource, User).</p><p>允许（操作、资源、用户）如果…%示例-允许用户更新他们拥有的任何资源：允许（更新、资源、用户）如果所有者（资源、用户）。</p><p> We can call this to check if a particular request should be allowed —  allow(update, “/users/alice”, bob)? — but we can also ask more general queries, such as: which user’s can update Alice’s profile:  allow(update, “/users/alice”, User)? Here  User with a capital letter is a variable and the interpreter will tell us all possible instantiations of that variable (all users) for which the query is true: i.e., who can update that resource. Likewise, we can query the same rules to see all resources that Bob can access, and all operations he can perform on them. These are incredibly useful features to have in an authorization system when you want to review who has access to what.</p><p>我们可以调用它来检查是否应该允许特定的请求-allow（update，“/users/alice”，bob）？-但我们也可以询问更一般的查询，例如：哪个用户可以更新Alice的个人资料：允许（update，“/users/Alice”，user）？在这里，带大写字母的用户是一个变量，解释器将告诉我们该变量（所有用户）的所有可能实例化，即谁可以更新该资源。同样，我们可以查询相同的规则，以查看Bob可以访问的所有资源，以及他可以对这些资源执行的所有操作。当你想查看谁有权访问什么时，这些是授权系统中非常有用的功能。</p><p>  One of the most misunderstood parts of Datalog refers to its  time complexity: how long it takes to answer a query as the “size” of that query grows. You will often see statements that Datalog queries are guaranteed to terminate in “polynomial time” (as opposed to exponential time). This is true, but only when taken in a very narrow sense.</p><p>数据日志中最容易被误解的部分之一是它的时间复杂性：随着查询“大小”的增长，回答查询需要多长时间。您经常会看到数据日志查询保证在“多项式时间”（而不是指数时间）内终止的语句。这是真的，但只有在狭义上才能理解。</p><p> First of all, we have to ask “polynomial in what variable?” When we talk about Datalog having polynomial time complexity, we are referring to its  data complexity. That is, if we fix a given program (set of rules), how does the time needed to answer a query change as the size of the database of facts increases? In SQL terms, consider the program to be our SQL query (or views) and we’re asking how much longer that query takes to run as our tables get bigger. This is the primary complexity measure that most people care about when talking about databases, and indeed in this case Datalog has polynomial time complexity.</p><p>首先，我们要问“多项式在什么变量中？”当我们谈论具有多项式时间复杂性的数据日志时，我们指的是它的数据复杂性。也就是说，如果我们修复了一个给定的程序（一组规则），那么随着事实数据库的增加，回答查询所需的时间会发生怎样的变化？在SQL术语中，考虑程序是我们的SQL查询（或视图），并且我们询问查询在我们的表变大时运行多长时间。这是大多数人在谈论数据库时关心的主要复杂性度量，实际上，在这种情况下，数据日志具有多项式时间复杂性。</p><p> But is this the appropriate measure of complexity for authorization? In this case I would argue that the situation is almost entirely reversed. In a typical authorization scenario, the data is largely of fixed size: the specific resource being accessed is known and the user has already been identified by authentication, so we don’t need to look at a whole tables of data. On the other hand, there can be very large numbers of authorization rules that have to be considered to make that decision. So the size of data is fixed, but the number of rules is variable. In this case, the appropriate complexity measure is known as  program complexity and the bad news is that D atalog has exponential program complexity!</p><p>但这是授权复杂性的适当衡量标准吗？在这种情况下，我认为情况几乎完全相反。在典型的授权场景中，数据的大小基本上是固定的：被访问的特定资源是已知的，用户已经通过身份验证被识别，因此我们不需要查看整个数据表。另一方面，在做出决策时，可能需要考虑大量授权规则。因此，数据的大小是固定的，但规则的数量是可变的。在这种情况下，适当的复杂性度量称为程序复杂性，坏消息是D atalog具有指数级的程序复杂性！</p><p> The other factor we need to consider is that the polynomial data complexity of Datalog is based on the most basic form, which doesn’t have function symbols (ie datatypes like lists) or arithmetic. Once you start adding such features (which almost all real-world Datalogs do), the data complexity inevitably goes up.</p><p>我们需要考虑的另一个因素是DATALOG的多项式数据复杂度是基于最基本的形式，它不具有函数符号（如列表之类的数据类型）或算术。一旦你开始添加这样的特性（几乎所有现实世界的数据日志都会这样做），数据的复杂性不可避免地会增加。</p><p>  The exponential program complexity of Datalog is well-known, and it has not escaped academic treatments of Datalog for authorization. An influential paper in this regard is “ Datalog with Constraints: A Foundation for Trust Management Languages”, which has been referenced by the developers of  Biscuit. This paper shows how to build a powerful authorization logic by extending Datalog. But the actual authorization system they build in that paper is based on a system called RT, which is much closer to a  description logic than Datalog. They then translate this more restricted language (which has polynomial program complexity) into their Datalog variant, which is something  some description logic reasoners also do.</p><p>数据日志的指数级程序复杂性是众所周知的，它并没有逃脱学术界对数据日志的授权处理。这方面的一篇有影响力的论文是“DATACORE与约束：信任管理语言的基础”，这已经被饼干开发者所引用。本文展示了如何通过扩展数据日志来构建强大的授权逻辑。但他们在那篇论文中构建的实际授权系统是基于一个名为RT的系统，它比数据日志更接近描述逻辑。然后，他们将这种更受限制的语言（具有多项式程序复杂性）转换为他们的数据日志变体，这也是一些描述逻辑推理者所做的。</p><p> Description logics share some of the good properties of Datalog, and there has been a lot of research into description logic variants with a  range of time complexities. So that is certainly one alternative formalism to look at if you are interested in logical approaches to authorization.</p><p>描述逻辑共享数据日志的一些良好特性，并且对具有一系列时间复杂性的描述逻辑变体进行了大量研究。如果你对授权的逻辑方法感兴趣的话，这当然是另一种形式主义。</p><p> On the other extreme, we are now seeing approaches like  Google Zanzibar, which apparently scales to trillions of ACL entries and uses a very minimal language to define relationships between roles (such as that all editors of a document are also viewers). Again, to my eyes this looks like a (very restricted) description logic to me, albeit one with a very large-scale implementation!</p><p>在另一个极端，我们现在看到了谷歌桑给巴尔（Google Zanzibar）这样的方法，它显然可以扩展到数万亿个ACL条目，并使用一种非常简单的语言来定义角色之间的关系（例如，文档的所有编辑也都是查看者）。同样，在我看来，这看起来像是一个（非常有限的）描述逻辑，尽管它有一个非常大规模的实现！</p><p> On the other hand, this same reasoning that description logics (can) have better worst-case time complexity than Datalog led me to base my PhD thesis on them, which was a decision I frequently regretted. The trade-off for those tighter complexity bounds is a much less expressive language, and I frequently ran into concepts that were hard or impossible to express in description logic but would’ve been simple in Datalog. (There are much more expressive description logics too, but I still find them hard to work with).</p><p>另一方面，描述逻辑（can）比数据日志具有更好的最坏情况时间复杂度这一同样的推理促使我将我的博士论文建立在它们之上，这是我经常后悔的决定。对于那些更严格的复杂度界限，取舍是一种表达能力要低得多的语言，我经常遇到一些概念，这些概念在描述逻辑中很难或不可能表达，但在数据日志中很简单。（也有更具表现力的描述逻辑，但我仍然发现它们很难使用）。</p><p>  Ultimately, I think logic-based approaches to defining authorization policies are an excellent idea. As an example of that approach, Datalog is still an excellent choice. But I wouldn’t say it is uniquely effective in this area. Some of the extensions applied to Datalog in practice push it more towards a full-blown Prolog, and I wouldn’t be surprised if some of these are accidentally Turing-complete. This is not a bad thing: pure Prolog (without the cruft) is also an excellent language, and if you’re not accepting user-defined policies then you can avoid pathological performance cases.</p><p>最终，我认为基于逻辑的方法来定义授权策略是一个很好的想法。作为这种方法的一个例子，数据日志仍然是一个很好的选择。但我不会说它在这方面是唯一有效的。在实践中，应用于数据日志的一些扩展将其推向了一个完整的Prolog，如果其中一些扩展意外地图灵完成，我也不会感到惊讶。这并不是一件坏事：纯Prolog（不带粗枝大叶）也是一种优秀的语言，如果你不接受用户定义的策略，那么你可以避免病态的性能案例。</p><p> On the other hand, if you want to scale to very large numbers of entities with only very simple rules then some of the lighter-weight description logic dialects are, IMO, an excellent fit. Just be aware of the expressiveness trade-off. There’s an enormous tree of logics out there, no need to get hung up on just one branch.</p><p>另一方面，如果你想用非常简单的规则扩展到大量的实体，那么在我看来，一些轻量级的描述逻辑方言非常适合。只是要注意表达能力的权衡。那里有一棵巨大的逻辑树，不需要只挂在一个分支上。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/good/">#good</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>