<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>1000层死亡：Java过度抽象的危险（2017） Death by 1000 layers: the perils of over-abstraction in Java (2017)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Death by 1000 layers: the perils of over-abstraction in Java (2017)<br/>1000层死亡：Java过度抽象的危险（2017） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-14 22:00:20</div><div class="page_narrow text-break page_content"><p>Recognizing good object-oriented code scales better, the truant officers at Sun Microsystems dictated that nothing in Java should roam the halls or hang out at the mall but should instead stay sealed in a class. Methods replaced functions. Fields replaced global variables. Java elevates object orientation to something of a fetish.</p><p>Sun Microsystems的逃学人员认识到良好的面向对象代码可以更好地伸缩，因此指出Java中的任何内容都不应漫游大厅或在购物中心里闲逛，而应该封闭在教室中。方法代替了功能。字段替换了全局变量。 Java将面向对象提升为一种恋物癖。</p><p> Unfortunately Java’s structure seduces the unwary programmer into excessive abstraction. Between demanding a class for everything and enforcing all types at compile time, it encourages you to lay down layer after layer of formalism in class and interface declarations.</p><p> 不幸的是，Java的结构吸引了粗心的程序员过度抽象。在要求所有内容都使用一个类与在编译时强制使用所有类型之间，它鼓励您在类和接口声明中逐层放下形式主义。</p><p> You’re tempted, or perhaps worn down, to imagine the result a tasty baklava of order and adaptability. Every new abstraction layer is an asset, a joint at which you’ll be able to pivot your code in the future. Any one class you turn into two, you imagine vaguely, will pay off someday in better reusability or fewer bugs. Routinely hiding your fields behind getters and setters will give you degrees of freedom to change them out in the future.</p><p> 您会被诱惑，甚至疲惫不堪，以为结果可口可笑，有序有序，适应能力强。每个新的抽象层都是一种资产，这是未来的枢纽，您可以在该枢纽上使用您的代码。您大概会想像，将任何一门课程变成两门课程，总有一天会以更好的可重用性或更少的错误获得回报。将您的字段常规地隐藏在getter和setter后面，将为您提供自由度，以便将来将其更改。</p><p> However, with those design principles, you’re heading for trouble. If you never meet an abstraction you don’t like, over time your logic will get atomized into a fine mist of tiny classes and methods, none of which individually does anything. You’ll find the code impossible to follow. Debugging it or even reading through it will involve pogo-sticking up and down 15 stack frames, over and over again, trying to understand the logic, until dizziness overcomes you and you forget why you started. Only project veterans will really understand how all the pieces fit together.</p><p> 但是，按照这些设计原则，您会遇到麻烦。如果您从未遇到自己不喜欢的抽象，随着时间的流逝，您的逻辑将被细化成细小的类和方法的薄雾，而这些类和方法中的任何一个都不单独做任何事情。您将发现无法遵循的代码。对其进行调试甚至是通读都涉及一次又一次地上下推15个堆栈帧，试图理解逻辑，直到头晕可以克服并且忘记了为什么开始。只有经验丰富的项目专家才能真正理解所有内容如何组合在一起。</p><p>  The new features people ask for never seem to line up with the layers in your code.</p><p>  人们要求的新功能似乎从未与您的代码中的各层保持一致。</p><p> You can’t just swap this implementation for that one, you have to change six different modules at once and patch around some unfortunate external dependencies. And although you’re ready to reimplement employee.getEmployeeID() in an eyeblink, no one ever asks for that.</p><p> 您不仅可以将这种实现换成那个实现，还必须立即更改六个不同的模块，并修补一些不幸的外部依赖项。而且，尽管您已经准备好在眨眼之间重新实现employee.getEmployeeID（），但没人会要求这样做。</p><p> Your code base will earn a reputation for being difficult to work with and impervious to refactoring, because any given class is pinned down, Gulliver-like, by an army of Lilliputian dependencies. You and your teammates will dread having to touch it and talk dreamily about the Big Rewrite you never seem to have time for.</p><p> 您的代码库将因难以使用且不受重构而赢得声誉，因为任何给定的类都像Lulputian依赖军一样固定在Gulliver上。您和您的队友将不得不触摸它，而梦talk以求地谈论您似乎没有时间进行的“大重写”。 </p><p> Are you suffering from Thousand Layer Syndrome today? Or showing early symptoms? Look around your code. Do you see 2- and 3-line methods by the screenful? Classes that hold data but don’t own any decisions, like a C struct? Interfaces with only one implementation? How about bewildering class names? If you can’t figure out what the ParameterInfoBuilderWrapper is supposed to do, or how it differs from the ParameterInfoBuilder, the disease may be advancing on you.</p><p>您今天患有千层综合症吗？还是表现出早期症状？看看你的代码。您是否通过筛选看到了2行和3行方法？保存数据但不拥有任何决策的类，例如C结构？与仅一种实现的接口？令人困惑的类名如何？如果您无法确定ParameterInfoBuilderWrapper应该做什么，或与ParameterInfoBuilder有何不同，则可能是您的疾病正在恶化。</p><p> But fear not. Even if you’re suffering an advanced case, your condition is treatable.</p><p> 但是不要担心。即使您的病情较重，您的病也可以治愈。</p><p> First, forget about the Big Rewrite. A rewrite is a risky gambit that can take a lot longer than you think and make the rest of the company feel like your hostages in the meantime. And if your current version accreted too many layers, your next version will likely do the same, unless you and your team first master a better approach to design. So don’t wait for the Big Rewrite, start improving both your code and your team incrementally.</p><p> 首先，忘记大重写。重写是一个冒险的秘诀，它可能花费比您想象的更长的时间，并使公司的其他部分同时成为您的人质。而且，如果当前版本增加了太多层次，那么除非您和您的团队首先掌握了更好的设计方法，否则下一个版本可能会执行相同的操作。因此，不要等到“大改写”，开始逐步改进代码和团队。</p><p>   Computers do this thing, then they do that thing, then sometimes some other thing. High-level languages and object-oriented design are fanfare and pageantry distracting from our fundamentally humble jobs: pecking out if-then statements.</p><p>   计算机先做这件事，然后再做那件事，然后再做其他事情。高级语言和面向对象的设计大张旗鼓和专心致志，从我们根本不起眼的工作中分心：选择if-then语句。</p><p> Procedural logic should therefore take center stage in your code. Good Java should resemble C. A method should have a clear, nontrivial job to do, and it should show its work. You should be able to read a method from top to bottom and understand how it does its job without chasing into implementations of 20 other methods.</p><p> 因此，过程逻辑应在代码中占据中心位置。好的Java应该类似于C。方法应该有一个清晰，平凡的工作，并且应该显示其工作。您应该能够从上至下阅读一种方法，并了解其工作原理，而无需研究其他20种方法的实现。</p><p> Likewise a class should have some meat on its bones and take on some real work. A well-considered class should own an interesting decision and the data needed to make it, not just one or the other. It should be easy to name, ideally with a noun that corresponds to something in the real world with a lifecycle of its own. If you’re struggling to think up a name that distinguishes this class from that, you’re probably rolling too many layers. And it should have a testable surface. Give the class a finite job to do, independent of its peers, and write tests to ensure it does it.</p><p> 同样，一个班级应该有一些肉，并从事一些实际的工作。一个经过深思熟虑的类应该拥有一个有趣的决定以及做出该决定所需的数据，而不仅仅是一个或另一个。它应该易于命名，理想情况下是使用一个名词，该名词对应于具有生命周期的现实世界中的某物。如果您在努力想出一个区别于此类的名称，则可能是滚动了太多层。并且它应该具有可测试的表面。给班级一个有限的工作，独立于同级同学，并编写测试以确保做到这一点。</p><p> Third, start an exercise routine. Extend your index finger in front of you, then bend it down on your Delete key, then bring it back up. Excellent. Do a single rep on every checkin. Flatten two two-line methods into one. Find a tiny class to delete. Scrap needless getters and setters. You’re not a Victorian lady covering her ankles; join those swinging Pythonistas and let your fields hang out.</p><p> 第三，开始锻炼程序。将食指向前方伸出，然后将其向下弯曲至Delete键，然后再将其抬起。优秀的。每次签到都要进行一次代表。将两个两行方法拼合为一个。找到一个要删除的小类。废除不必要的吸气剂和吸气剂。您不是维多利亚时代的女士，她的脚踝都遮住了她；加入那些摇摆不定的Pythonistas，让您的领域闲逛。 </p><p> Put every interface and protected method to the test: “do we need multiple implementations of this today?” If voices in your head plead “but we might want to…,” remain calm and drive them away with the Extreme Programming chant: “It won’t be needed. It won’t be needed. It won’t be needed.” Future proof your code by making it short, clear, and well-tested, not by gambling on your clairvoyance.</p><p>对每个接口和受保护的方法进行测试：“我们今天需要这种方法的多个实现吗？”如果您头脑中的声音恳求“但我们可能希望……”，请保持镇定，并用“极端编程”的歌声驱赶他们：“不需要。不需要。不需要。”通过使代码简短，清晰和经过良好测试来证明您的代码的未来，而不是赌博千里眼。</p><p> Finally, recruit your colleagues to the cause, because you’re all in this together. Challenge each other in code reviews. Could this method be named more clearly? Is it obvious what this class represents? Does this code serve today’s real use cases or tomorrow’s hypothetical ones? Will next summer’s intern understand this routine right away?</p><p> 最后，招募您的同事，因为你们在一起。在代码审查中互相挑战。可以更清楚地命名此方法吗？这堂课代表什么很明显？该代码是否可用于今天的实际用例或明天的假设用例？明年夏天的实习生会立即理解这一惯例吗？</p><p> Design is an art. You can read the advice in this sermon, then read a book that will tell you just the opposite. What’s important is to hone your own sense of craftsmanship. Read those books. Experiment. Debate. The investment will more than pay off in productivity gains and incrementally improving code. You’ll have your thousand layers down to a manageable few before you know it, you’ll enjoy your improved velocity, and you’ll be smiling down on a codebase you’re proud of.</p><p> 设计是一门艺术。您可以阅读本讲章中的建议，然后再读一本书，告诉您正好相反。重要的是要磨练自己的技艺。读那些书。实验。辩论。这项投资将不仅仅可以提高生产力，还可以逐步改进代码。在不知不觉中，您将拥有数千层，只有几层可以管理，您将享受不断提高的速度，并且在自豪的代码库中笑逐颜开。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.quantcast.com/blog/death-by-1000-layers-the-perils-of-over-abstraction-in-java/">https://www.quantcast.com/blog/death-by-1000-layers-the-perils-of-over-abstraction-in-java/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/perils/">#perils</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>