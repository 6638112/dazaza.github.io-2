<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Toit编程语言 The Toit Programming Language</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Toit Programming Language<br/>Toit编程语言 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-07 11:27:30</div><div class="page_narrow text-break page_content"><p>This quickstart guide is inspired by  Ruby in Twenty Minutes. It makes the assumption that you already have  Toit installed on your machine.</p><p>此QuickStart指南由Ruby在二十分钟内启发。它假设您已经在计算机上安装了待机。</p><p> Toit is an object-oriented programming language for the internet of things. The Toit language has the following desirable properties:</p><p> Toit是一种面向对象的编程语言，用于物联网。 Toit语言具有以下理想的属性：</p><p>    A local installation of Toit comes with support for running small programs directly from the command line. If you put the following code in a file called  hello.toit</p><p>    本地安装Toit伴随着直接从命令行运行小程序的支持。如果您将以下代码放在名为hello.toit的文件中</p><p>    What just happened? The  toit command line tool read your source code ( hello.toit) and started running it from the  main method that you defined. The  main method consists of all the indented statements just below the method declaration line  main:. Toit is indentation-based like Python, so the spaces you add to your programs are significant.</p><p>    刚才发生了什么？ Toit命令行工具读取您的源代码（hello.toit），并开始从您定义的主要方法运行它。主要方法包括在方法声明行主要下面的所有缩进陈述： Toit是基于Python的缩进，所以您添加到程序的空格很大。</p><p> Once the program ran, it printed  Hello World! in your terminal. This is because the only statement in  hello.toit is a method call, where you invoke the  log method with a single argument, which is the string to be logged (in this case, printed to the terminal). If you wanted to output more than one line from your program, you could update it to:</p><p> 一旦程序运行，它将打印你好世界！在你的终端里。这是因为hello.toit中唯一的语句是一种方法调用，在其中使用单个参数调用日志方法，它是要记录的字符串（在这种情况下，打印到终端）。如果您希望从程序中输出多行，您可以将其更新为：</p><p>     What if you want to say &#34;Hello&#34; a lot without getting your fingers all tired? You should define another method:</p><p>     如果你想说＆＃34;你好＆＃34;很多没有让你的手指都累了？您应该定义另一个方法：</p><p>    Calling a method in Toit is as simple as mentioning its name. If the method doesn’t take arguments that’s all you need.</p><p>    调用anit中的方法与提及其名称一样简单。如果该方法不采用任何您需要的参数。 </p><p> What if we want to say hello to one person, and not the whole world? Just redefine hi to take a name as an argument.</p><p>如果我们想向一个人打招呼，而不是全世界的话怎么办？只是重新定义嗨，以姓名为论据。</p><p>  This way,  hi is a method that takes a single argument. We can use that from  main:</p><p>  这样，嗨是一种采用单个参数的方法。我们可以从主要的使用：</p><p>     What’s the  $name bit? That’s Toit&#39;s way of inserting something into a string. It is called  string interpolation. The bit after the  $ is turned into a string (if it isn’t one already) and then substituted into the outer string at that point. You can also use this to make sure that someone’s name is properly trimmed so leading and trailing whitespace is ignored:</p><p>     什么是$名称位？这是一个and＃39;在字符串中插入某物的方式。它被称为字符串插值。 $后将$ in the string（如果它不是一个），然后替换为此点的外弦。您还可以使用它来确保某人的名称已正确修剪，因此忽略了导致和尾随空格：</p><p>  This way, we call the  trim method on the  name string before we insert it into the outer string. If we call  hi &#34; Lars &#34; we still get the familiar greeting  Hello Lars! and not  Hello Lars !. You can add parentheses around the  name.trim expression in the string to make it clearer which parts belong to the outer string:</p><p>  这样，我们在将其插入外部字符串之前调用名称字符串上的TRIM方法。如果我们打电话给Hi＆＃34; Lars＆＃34;我们仍然得到熟悉的问候你好lars！而且不是hello lars！。您可以在字符串中的名称中添加括号。在字符串中的表达式表达式，以使其更清晰地属于外部字符串的部分：</p><p>  Maybe you already spotted that we went ahead and added one other trick to the code above? We added a default value for the  name parameter, so if the name isn’t supplied when you call  hi, we use the default name &#34;World&#34;. Now we can try:</p><p>  也许你已经发现了我们前进，并在上面的代码中添加了一个其他诀窍？我们为名称参数添加了一个默认值，因此如果在您调用HI时未提供姓名，我们使用默认名称＆＃34;世界＆＃34;现在我们可以尝试：</p><p>     What if we want a real greeter around, one that remembers your name and welcomes you and treats you with respect. You might want to use an object for that. Let’s create a  Greeter class:</p><p>     如果我们想要一个真正的问候人，那么一个记得你的名字，并欢迎你并尊重你。您可能希望为此使用对象。让我们创建一个问候课：</p><p> class Greeter: name := null constructor .name = &#34;World&#34;: say_hi: log &#34;Hi $name.trim!&#34; say_bye: log &#34;Bye $name.trim, come back soon.&#34;</p><p> Class Chender：name：= null构造函数.name =＆＃34;世界＆＃34 ;: say_hi：log＆＃34;嗨$ name.trim！＆＃34; say_bye：log＆＃34;再见$ name.trim，很快回来。＆＃34; </p><p> The new keyword here is  class. This defines a new class called  Greeter and a bunch of methods for that class. Pay special attention to the method  constructor. There is nothing after the  : and the  constructor method isn’t followed by any indented lines, so the constructor has no statements in it:</p><p>这里的新关键字是类。这定义了一个名为Chender的新类以及该类的一系列方法。特别注意方法构造函数。在：and构造函数方法之后没有任何缩进线路，因此构造函数没有陈述：</p><p>  This is a constructor and it defines how you can construct objects from the class. It says the class  Greeter takes a single argument ( name), but the  . prefix to the  .name parameter actually tells us that the name is immediately stored as a field on  Greeter objects. The field is defined just above the constructor with the  := syntax.</p><p>  这是一个构造函数，它定义了如何从类构造对象。它说，班级问候人员采用单个参数（姓名），但是。对.name参数的前缀实际上告诉我们名称立即存储为问候语对象的字段。该字段的定义在构造函数之上，使用：=语法。</p><p> The field parameter  .name still has a default value, so if we don’t pass a name, the  Greeter will greet the world.</p><p> 字段参数.Name仍然存在默认值，因此如果我们不通过名称，问候会迎接世界。</p><p> The  say_hi and  say_bye methods are introduced on the next two lines. The methods both have a single statement in them, so we can keep them on one line each. The  say_hi and  say_bye method both use the  name field from the object they are called on. You can refer to fields in the class of a method simply by mentioning them ( name).</p><p> 在接下来的两条线上引入了Say_hi和Say_Bye方法。这些方法都有一个单一的语句，所以我们可以将它们保持在一行上。 say_hi和say_bye方法都使用它们调用的对象中的名称字段。只需提及它们（名称）即可在方法的类中引用字段。</p><p>    We create an object simply by mentioning the constructor,  Greeter. The greeter object remembers the name and uses it for the two separate greetings. If we run this, we get the following output:</p><p>    我们简单地通过提及构造函数，问候语来创建一个对象。问候对象记得名称并为两个单独的问候语使用它。如果我们运行此操作，我们会得到以下输出：</p><p>  If you want to get the name from a greeter, you can ask a greeter by calling the  name method on it:</p><p>  如果您想从问候获取名称，可以通过调用它的名称方法来询问问候语：</p><p>  This would show  How are you Helena ?. Almost neat, right? Unfortunately, the name isn’t trimmed like we expected. Let’s fix that!</p><p>  这将显示你的海伦娜如何？。几乎整齐，对吧？不幸的是，这个名字并没有像我们预期的那样修剪。让我们解决这个问题！ </p><p>  As you have just seen, a field on an object introduces a method with the same name. If you wanted to hide a field from the outside world, you could make it private. By convention, methods and fields that end with an underscore ( _) are private and not supposed to be touched from the outside:</p><p>正如您刚才所见，对象上的字段介绍具有相同名称的方法。如果你想隐藏来自外界的领域，你可以让它私下。按照约定，以下划线（_）结尾的方法和字段是私有的，不应该从外部触摸：</p><p>  This removes the  name method from greeters, but if we really want to allow accessing the name from the outside, we could reintroduce a getter with the same meaning as before.</p><p>  这删除了来自问候人员的名称方法，但如果我们真的想要从外部访问名称，我们可以重新引入与以前相同的含义的吸气剂。</p><p> class Greeter: name_ := null constructor .name_ = &#34;World&#34;: name: return name_ say_hi: log &#34;Hi $name_.trim!&#34; say_bye: log &#34;Bye $name_.trim, come back soon.&#34;</p><p> Class Chender：name_：= null构造函数.name_ =＆＃34;世界＆＃34;：name：return name_ say_hi：log＆＃34;嗨$ name_.trim！＆＃34; say_bye：log＆＃34; bye $ name_.trim很快回来。＆＃34;</p><p> Here we use the new keyword  return to specify the value a method returns. We could make it slightly more interesting and trim it in the process:</p><p> 在这里，我们使用新的关键字返回指定方法返回的值。我们可以使其在过程中稍微有趣并修剪它：</p><p>  In this way, access to the name from the outside also gets the trimming and we can avoid repeating the call to  trim:</p><p>  通过这种方式，访问外部的名称也得到了修剪，我们可以避免重复调整调整：</p><p> class Greeter: name_ := null constructor .name_ = &#34;World&#34;: name: return name_.trim say_hi: log &#34;Hi $name!&#34; say_bye: log &#34;Bye $name, come back soon.&#34;</p><p> Class Chender：name_：= null构造函数.name_ =＆＃34;世界＆＃34;：respend name_.trim say_hi：log＆＃34;嗨$名称！＆＃34; Say_Bye：log＆＃34;再见，很快回来。＆＃34;</p><p>   and you should see  How are you Erik?. Inside  main, we store the greeter in a local variable ( greeter) so we can keep referring to the same object. You can think of it as a way to give a specific object a name that is only valid and useful inside the  main method.</p><p>   你应该看看你是如何erik的？在主要内部，我们将发祝器存储在局部变量（问候语）中，以便我们能够继续引用相同的对象。您可以将其视为一种为特定对象提供仅在主要方法内有效和有用的名称的方法。 </p><p> Just like introducing a member variable, we can use the  := syntax in methods and functions like  main to introduce local variables.</p><p>就像引入成员变量一样，我们可以在方法中使用：=语法和函数，如主介绍局部变量。</p><p>  This greeter isn’t all that interesting though, it can only deal with one person at a time. What if we had some kind of MegaGreeter that could either greet the world, one person, or a whole list of people? Let’s try to build that. We will start with a class definition:</p><p>  这个问候者并不是那么有趣，它只能一次处理一个人。如果我们有某种巨大的兆头，可以迎接世界，一个人或整个人名单？让我们试着建立这一点。我们将从班级定义开始：</p><p>  So MegaGreeter objects have a list of  names. The  names field is initialized to the empty list ( []). The body of the  MegaGreeter constructor adds the given  name argument to the end of the list of names. Notice that this is different than using a  .name parameter that automatically assigns to the field called  name. Mega greeters don&#39;t have a single name and no  name field, so here the  name is just an ordinary parameter that we can use in the body of the constructor. All in all, this code:</p><p>  所以Megagreeter对象有一个名称列表。名称字段初始化为空列表（[]）。 Megagreeter构造函数的正文将给定名称参数添加到名称列表的末尾。请注意，这与使用自动分配给名为name的字段的.name参数不同。 Mega Breeters Don＆＃39; t有一个单个名称和没有名称字段，所以这里的名称只是我们可以在构造函数的正文中使用的普通参数。总而言之，这段代码：</p><p>     // Greeter that says hi to everybody.class MegaGreeter: names := [] constructor name = &#34;World&#34;: names.add name say_hi: // Greet everyone individually! names.do: log &#34;Hello $it!&#34; say_bye: everyone := names.join &#34;, &#34; log &#34;Bye $everyone, come back soon.&#34;main: greeter := MegaGreeter greeter.say_hi greeter.say_bye greeter.names.add &#34;Lars&#34; greeter.names.add &#34;Kasper&#34; greeter.names.add &#34;Rikke&#34; greeter.say_hi greeter.say_bye</p><p>     //给每个人都说嗨的问候人.Class Megagreeter：名称：= []构造函数名称=＆＃34;世界＆＃34 ;: names.add名称say_hi：//单独迎接每个人！ names.do：log＆＃34; hello $ wit！＆＃34; Say_Bye：Everyal：= names.join＆＃34 ;,＆＃34; Log＆＃34;再见，每个人都会回来。 greeter.names.add＆＃34;卡斯珀＆＃34; greeter.names.add＆＃34; rikke＆＃34; Greeter.say_hi greeter.say_bye.</p><p>  $ toit execute hello.toitHello World!Bye World, come back soon.Hello World!Hello Lars!Hello Kasper!Hello Rikke!Bye World, Lars, Kasper, Rikke, come back soon.</p><p>  $ toit执行hello.toithello世界！再见世界，很快回来.Hello World！你好Lars！你好Kasper！你好rikke！再见世界，Lars，Kasper，Rikke很快回来。</p><p>   Not everything in your source files is meant to be run by the Toit compiler. Sometimes, it is nice just to add comments that explain interesting things related to your code. In the example in the last section, there were a few single line comments:</p><p>   不是源文件中的所有内容都意味着Toit编译器运行。有时，只要添加解释与您的代码有关的有趣事物的评论很好。在最后一节中的示例中，有几个单行评论：</p><p>  Such comments start with  // and tell the system to ignore the rest of the line.</p><p>  此类评论从//开始，并告诉系统忽略其余行。 </p><p> You have already seen the use of indentation to give hierarchical structure to your code. The general structure is that after a  : you can have a single construct if it fits on one line:</p><p>您已经看到使用缩进来为您的代码提供分层结构。一般结构是之后：如果它适合一行，可以拥有一个构造：</p><p>  or you can add a newline after the  : and let the following lines that are indented relative to the outer construct be a sequence of inner constructs:</p><p>  或者您可以在以下方式添加换行符：并让相对于外部构造缩进的以下行是一系列内部构造：</p><p>  For methods, we often refer to the inner constructs as the statements of a method or the body of a method. The preferred indentation for inner constructs is two spaces.</p><p>  对于方法，我们经常将内部构建体称为方法或方法的身体的陈述。内部构建体的优选压痕是两个空间。</p><p> For a class, everything that is indented under the class declaration line belongs to the class. We call such things class members:</p><p> 对于一个类，在类声明行下缩进的所有内容都属于该类。我们称之为课程成员：</p><p>  For methods in a class, the statements in them are nested one level further (two spaces) than the class members:</p><p>  对于类中的方法，它们中的语句进一步嵌套（两个空格），而不是类成员：</p><p> Class MegaGreeter: // class members start // ... say_hi: // method body start // ... // method body end // ... // class members end</p><p> 类Megagreeter：//类成员start // ... say_hi：//方法body start // ... //方法正端// ... //类成员结束</p><p>   Let’s return to the  MegaGreeter example and take a look at another place where constructs are block structured. In the  say_hi method, we want to call  log for every single name in the  names list. We can do this by calling  names.do and provide the list of statements we want to run for each element using block structure:</p><p>   让我们返回Megagreeter示例，并查看构造结构块的另一个地方。在May_hi方法中，我们要在名称列表中调用日志。我们可以通过调用names.do来完成此操作，并提供我们希望使用块结构为每个元素运行的语句列表： </p><p>  Here the statement is on a single line, so there is no need to use indentation. When using  names.do, a method available on all lists, the special variable  it contains the individual elements from the list in turn. If there are 5 elements in the  names list, we will call  log 5 times producing 5 separate lines of output.</p><p>在这里，该声明在单行上，因此无需使用缩进。使用名称时，可以在所有列表中提供的方法，它包含从列表中包含单个元素的特殊变量。如果名称列表中有5个元素，我们将调用log 5次产生5行输出行。</p><p> You can play with the methods on list by modifying and running the sample below:</p><p> 您可以通过修改和运行下面的示例来使用列表中的方法：</p><p> main: list := [ &#34;Horse&#34;, &#34;Fish&#34;, &#34;Radish&#34;, &#34;Baboon&#34; ] log &#34;There are $(list.size) elements in the list&#34; log &#34;Here they are:&#34; list.do: log &#34;Element = $it&#34; log &#34;Here they are (sorted):&#34; list.sort list.do: log &#34;Element = $it&#34;</p><p> 主题：列表：= [＆＃34;马＆＃34 ;,＃34;鱼＆＃34 ;,＃34;萝卜＆＃34 ;,＆＃34;狒狒＆＃34; ]日志＆＃34;列表中有$（list.size）元素＆＃34; log＆＃34;他们在这里：＆＃34; list.do：log＆＃34;元素= $＆＃34; log＆＃34;他们在这里（分类）：＆＃34; list.sort list.do：log＆＃34;元素= $＆＃34;</p><p> One of the methods on lists that is very useful when constructing strings is  join. It produces a string from a list of strings by joining the parts and adding a separator between them. We use this in the  MegaGreeter example to produce a single comma-separated list of names for the single line output of  say_bye:</p><p> 在构建字符串时非常有用的列表的方法之一是加入。它通过加入部分并在它们之间添加分隔符来生成字符串列表中的字符串。我们在Megagreeter示例中使用它来生成单行输出的单个逗号分隔的名称列表：</p><p>   Perhaps you don’t always want to say &#34;Hello&#34;, so you add an argument with a default value to the  say_hi method:</p><p>   也许你并不总是想说＆＃34;你好＆＃34 ;,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,</p><p>    Which produces the output: However, at the calling site it may not be clear what the argument &#34;Kaixo&#34; is for. We can make it clearer with a named argument:</p><p>    它产生输出：但是，在呼叫网站上可能不清楚参数＆＃34; kaixo＆＃34;是的。我们可以使用名为Arguit清单更清楚：</p><p>        fib n: if n &lt;= 1: return n return (fib n-1) + (fib n-2)main: log &#34;The 10th Fibonnaci number is $(fib 10)&#34;</p><p>        fib n：如果n＆lt; = 1：返回n返回（fib n-1）+（fib n-2）主：log＆＃34;第10个fibonnaci号码是$（fib 10）＆＃34; </p><p> This defines a top-level function called  fib that is not a member of any class. (We already saw  main, which is a top level function with a special name.)</p><p>这定义了一个名为fib的顶级函数，这不是任何类的成员。 （我们已经看到了主要的，这是一个特殊名称的顶级函数。）</p><p> The  fib function is recursive, calling itself, and also makes use of a few new features. The  if statement is well known from other languages. In Toit it works by taking an expression and conditionally evaluating a block. Like other blocks we could have used indentation to group multiple lines.</p><p> FIB功能是递归，调用自身，也使用一些新功能。 IF语句是从其他语言中众所周知的。通过拍摄表达和有条件地评估块来工作。与其他块一样，我们可以使用缩进到组多行。</p><p> Toit also has the usual array of infix operators,  +,  -,  *,  /,  % etc. and the relational operators  &lt;,  &lt;=,  &gt;,  &gt;=,  == and  !=. The operators have higher precedence than function arguments, so we had to group the calls in parentheses to get the desired behavior. The high precedence is what makes the arguments for the recursive invocation of  fib work. We could have spaced it more conventionally and got the same effect: fib n: if n &lt;= 1: return n return (fib n - 1) + (fib n - 2)</p><p> Toit还具有通常的infix运算符阵列，+， - ，*，/，％等，以及关系算子＆lt; =，＆gt;＆gt; =，==和！=。操作员优先于函数参数更高，因此我们必须在括号中对呼叫进行分组以获得所需的行为。高优先级是对递归调用FIB工作的论据。我们可以传统地将其间隔开，并有相同的效果：FIB N：如果n＆lt; = 1：返回n返回（fib n  -  1）+（fib n  -  2）</p><p>  This is a terribly slow way to calculate a Fibonnaci number though, and we could do it with a simple loop:</p><p>  这是计算fibonnaci的非常缓慢的方式，我们可以用一个简单的循环做到这一点：</p><p> fib2 n: s1 := 0 s2 := 1 n.repeat: s3 := s1 + s2 s1 = s2 s2 = s3 return s1</p><p> FIB2 N：S1：= 0 S2：= 1 n.repeat：S3：= S1 + S2 S1 = S2 S2 = S3返回S1</p><p> Here we are using the  repeat method on numbers, which runs a block a given number of times. Like for the  do method, there&#39;s a  magic variable,  it that gives the iteration number:</p><p> 在这里，我们正在使用数字的重复方法，该方法运行给定次数的块。喜欢做方法，有一个魔法变量，它给出了迭代号码：</p><p>  The  repeat method is simple and efficient, but sometimes we need something more flexible, and for that we have the well-known  while and  for statements:</p><p>  重复方法简单而有效，但有时我们需要更灵活的东西，为此我们有众所周知的次数和陈述： </p><p> // Prints the odd numbers less than n.print_odd_numbers n: for i := 1; i &lt; n; i += 2: log i// Returns if the Collatz conjecture is true.collatz n: while n &gt; 1: if n % 2 == 0: n = n / 2 else: n = n * 3 + 1</p><p>//打印小于n.print_odd_numbers n的奇数：i：= 1;我＆lt; n; i + = 2：如果Collat​​z猜想是真的，则返回log i //返回.collat​​z n：n＆gt; 1：如果n％2 == 0：n = n / 2其他：n = n * 3 + 1</p><p>   class MegaGreeter: names := [] titles := {:} constructor: add name title: names.add name titles[name] = title say_hi: // Greet everyone individually! names.do: log &#34;Hello, $titles[it] $it!&#34;main: greeter := MegaGreeter greeter.add &#34;Lars&#34; &#34;Mr.&#34; greeter.add &#34;Rikke&#34; &#34;Dr.&#34; greeter.add &#34;Günter&#34; &#34;Herr Professor Doktor Doktor&#34; greeter.say_hi</p><p>   Class Megagreeter：名称：= []标题：= {：}构造函数：添加名称标题：names.add名称标题[name] = title say_hi：//单独迎接每个人！名称.Do：log＆＃34;你好，$ titles [它] $它！＆＃34;主要：问候：= megagreeter greeter.add＆＃34; lars＆＃34; ＆＃34;先生。＆＃34; Greeter.add＆＃34; rikke＆＃34; ＆＃34;博士。＆＃34; Greeter.add＆＃34;Günter＆＃34; ＆＃34;赫尔教授Doktor Doktor＆＃34; Greeter.say_hi.</p><p> Here we use a hashmap to store the appropriate title for each name. The empty map is given by  {:} and we use  [] to access the values for each key. The empty set is  {} and we already met the empty list,  []. The lookup syntax  [] also works on lists, so instead of the &#39;do&#39; method we could have used:</p><p> 在这里，我们使用HashMap来为每个名称存储适当的标题。空映射由{：}和我们使用[]来访问每个键的值。空集是{}，我们已经遇到了空列表[]。查找语法[]还在列表上工作，所以而不是＆＃39;做＆＃39;我们可以使用的方法：</p><p>    // Print the numbers from 1 to 10, one per line.10.repeat: log it + 1// Print the elements in my_list, one per line.my_list.do: log it</p><p>    //按1到10的数字，每行一个数字.10.repeat：log it + 1 //打印每行的元素.my_list.do：log it</p><p> Syntactically they look like they are built in to the language like  if and  for, but they are actually perfectly normal methods on the List and Integer classes:</p><p> 在句子上，它们看起来像是那样的语言，如果和为此，它们实际上是在列表和整数类上的完美正常方法：</p><p> class List: // ... do [block]: size.repeat: block.call this[it]class Integer: // ... repeat [block]: for i := 0; i &lt; this; i++: block.call i</p><p> 类列表：// ... Do [块]：size.repeat：block.call这个[它]类整数：// ...重复[块]：对于i：= 0;我＆lt;这; i ++：block.call我</p><p> They are making use of a feature called blocks. These are snippets of code that can be passed down the stack as arguments to methods and functions. At the call site we precede the block with a colon, &#39; :&#39;, and at the function definition we surround the parameter name with square brackets, &#39; []&#39;. Often, there is one block parameter, it is in the final position and it is called  block.</p><p> 它们正在使用称为块的功能。这些是代码的片段，可以将堆栈传递为方法和函数的参数。在呼叫网站，我们在块中与冒号，＆＃39; ：＆＃39;，并且在函数定义，我们将参数名称与方括号，＆＃39围绕; []＆＃39;通常，有一个块参数，它处于最终位置，它被称为块。 </p><p>  A block can return a value each time it is run. This is used for example in the  filter method on lists.</p><p>每次运行时，块都可以返回值。这例如在列表上的滤波器方法中使用。</p><p> // Takes a list of words, and returns a new list with only the// words that are 5 characters or fewer.short_words words: return words.filter: it.size &lt;= 5</p><p> //获取一个单词列表，只返回一个只有5个字符或更少字符的//单词的新列表：返回lock.filter：it.size＆lt; = 5</p><p> The  filter method calls the block,  it.size &lt;= 5 for each element in the original list, and returns a new list containing only the short words.</p><p> 筛选方法在原始列表中的每个元素调用块，et.size＆lt; = 5，并返回仅包含短字的新列表。</p><p> Note that there is no  return statement in the block. A block will return the value of the last statement to the place where it was invoked with  block.call. In this case there is only one statement, which is the boolean expression  it.size &lt;= 5.</p><p> 请注意，块中没有返回语句。一个块将返回最后一个语句的值，以通过block.call调用它。在这种情况下，只有一个语句，这是it.size＆lt; = 5的boolean表达式。</p><p> If you use the  return keyword in a block then it returns from the syntactic function or method in which it is written. Usually this will behave as you would expect:</p><p> 如果在块中使用return关键字，则它从写入的语法函数或方法返回它。通常这会表现得像你的期望：</p><p> wheres_walter list: list.do: if it.starts_with &#34;Walter &#34;: return it return nullmain: log (wheres_walter [&#34;Ib Michael&#34;, &#34;Walter White&#34;, &#34;Marie Curie&#34;])</p><p> wheres_walter列表：list.do：如果它是.starts_with＆＃34; walter＆＃34 ;:返回它返回nullmain：log（wheres_walter [＆＃34; ib michael＆＃34;＆＃34; walter white＆＃34 ;, ＆＃34;玛丽居里＆＃34;]）</p><p> The  return keyword is inside a block that is passed to the  do method. When the name that starts with  &#34;Walter &#34; is found we immediately return the full name from the  wheres_walter function without continuing to iterate over the list.</p><p> return关键字在传递给do方法的块中。当以＆＃34开头的名称;沃尔特＆＃34;发现我们立即从wheres_walter函数返回全名，而无需继续迭代列表。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://docs.toit.io/language/language/">https://docs.toit.io/language/language/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/toit/">#toit</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/方法/">#方法</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>