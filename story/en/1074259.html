<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Java中的并发性——我提出了一个我觉得舒服的设计Concurrency in Java – I came up with a design I feel comfortable with</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Concurrency in Java – I came up with a design I feel comfortable with<br/>Java中的并发性——我提出了一个我觉得舒服的设计</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-20 18:03:19</div><div class="page_narrow text-break page_content"><p>After years of dabbling with  threads,  Callables and  Executor Pools, finally an easy way to setup concurrent tasks</p><p>经过多年对线程、可调用函数和执行器池的研究，终于找到了一种设置并发任务的简单方法</p><p> The problem: having a task to execute concurrently, but keeping the code free from Callables and other thread logic</p><p>问题是：有一个并发执行的任务，但要保证代码不受可调用和其他线程逻辑的影响</p><p> For many years, I have worked at making some parts of my code execute in a concurrent way. Pair-wise computations on vectors, text mining ops on thousands on tweets, simple checks and operations on nodes and edges in a network, etc.</p><p>多年来，我一直致力于让代码的某些部分以并发方式执行。向量的成对计算，推文上数千条的文本挖掘操作，网络中节点和边缘的简单检查和操作，等等。</p><p>  isolate in a separate class the part of the code that can be executed concurrently: that will be the task.</p><p>将代码中可以并发执行的部分隔离在一个单独的类中：这就是任务。</p><p>  make this class implement the  Runnable interface, or more probably the  Callable interface as it allows to return an object.</p><p>让这个类实现可运行接口，或者更可能是可调用接口，因为它允许返回一个对象。</p><p>  in the main part of the code, setup an  Executor service. Instantiate all the tasks and submit these to the executor.</p><p>在代码的主要部分，设置Executor服务。实例化所有任务并将其提交给执行者。</p><p> I suppose there is nothing wrong with this. In practice, it didn’t work for me. The reason is fundamentally that:</p><p>我想这没什么错。实际上，这对我不起作用。根本原因在于：</p><p> setting the task as a  Runnable or  Callable, even if that is pretty easy and lightweight, specializes the code for this use case. If I want to re-use the code in another context that requires the logic to run with different interfaces, or refactor the task because the code logic has grown in complexity, these interfaces I had added for concurrency become boilerplate. I’m like “oh, I had added that  Callable way of running the code for this particular project, but in this other project that’s just a thing in my way. I’ll have to remove it.” So in practice, when I developped some concurrent code, I ended up giving up on it soon to work unencumbered.</p><p>将任务设置为可运行的或可调用的，即使这非常简单和轻量级，也会专门处理此用例的代码。如果我想在另一个上下文中重复使用代码，而这个上下文要求逻辑以不同的接口运行，或者因为代码逻辑的复杂性增加而重构任务，那么我为并发性添加的这些接口将成为样板。我会说：“哦，我添加了一种可调用的方式来运行这个特定项目的代码，但在另一个项目中，这只是我的一种方式。我必须删除它。”所以在实践中，当我开发一些并发代码时，我很快就放弃了它，开始了无障碍的工作。</p><p>  Setting up the  Executor /  Future logic on the main side of the code base is harder than it seems. There are so many variations on these APIs that it is a big effort each time to remember and identify how the thing should be set up. That is because multithreading and concurrency is low level, and one could be tempted to says that “there is a library that wraps this up for you”. But I would really avoid relying on libraries for concurrency, they are probably super big and too wide in scope for what I want to do.</p><p>在代码库的主端设置Executor/Future逻辑比看起来更难。这些API上有太多的变体，因此每次都需要花费大量精力来记住和确定应该如何设置。这是因为多线程和并发是低级的，有人可能会说“有一个库为您打包了这个”。但我真的会避免依赖库来实现并发性，它们可能非常大，而且对于我想要做的事情来说范围太广。</p><p>  It doesn’t involve clever nor sophisticated tricks, so don’t expect a big “wow”. It is all in simplicity and robustness, and made very easy since Java 11’s HttpClient.</p><p>它不涉及聪明或复杂的技巧，所以不要期待一个大“哇”。它具有简单性和健壮性，并且自Java11的HttpClient以来变得非常简单。</p><p> The solution: putting the task behind a REST API and calling it with Java 11’s HttpClient asynch requests</p><p>解决方案是：将任务放在REST API后面，并使用Java 11的HttpClient异步请求调用它</p><p>  in the main code base, calling each task with Java 11’s HttpClient, using the asynch feature.  That’s where concurrency kicks in!!</p><p>在主代码库中，使用Java11的HttpClient调用每个任务，使用异步特性。这就是并发性的作用所在！！</p><p>  The use case consists in performing sentiment analysis on thousands of tweets. Instead of doing it sequentially, this can be done in a concurrent way.</p><p>用例包括对数千条推文进行情绪分析。与其按顺序进行，还可以同时进行。</p><p> Input: each line of text (each tweet) is stored as a  String with an  Integer which is a unique identifier, in the form of an object  Map&lt;Integer, String&gt; mapOfLines.</p><p>输入：每行文本（每条推文）以对象映射的形式存储为一个字符串，带有一个唯一标识符的整数&lt；整数，字符串&gt；地图。</p><p>  Output: each line of text, its unique identifier, and the sentiment that was found, is stored in a  Document object, itself stored in a object  ConcurrentHashMap&lt;Integer, Document&gt; tempResults. The Map has to be a ConcurrentHashMap as it will be written to by many threads.</p><p>输出：每一行文本、其唯一标识符和找到的情绪都存储在一个文档对象中，其本身存储在一个对象ConcurrentHashMap中&lt；整数，文档&gt；临时结果。该映射必须是ConcurrentHashMap，因为它将由多个线程写入。</p><p>  String  selectedLanguage  =  &#34;en&#34; ; Map &lt; Integer ,  String &gt;  mapOfLines  =  new  HashMap (); mapOfLines . put ( 0 ,  &#34;This is a test. Concurrency is amazing!&#34; ); mapOfLines . put ( 1 ,  &#34;This is a test. Concurrency is hard!&#34; ); ConcurrentHashMap &lt; Integer ,  Document &gt;  tempResults  =  new  ConcurrentHashMap (); HttpRequest  request ; HttpClient  client  =  HttpClient . newHttpClient (); Set &lt; CompletableFuture &gt;  futures  =  new  HashSet ();			 // this is a convenient class I designed to clock time, available here https://github.com/seinecle/Utils			 Clock  clock  =  new  Clock ( &#34;clocking the concurrent task&#34; ); try  {	 for  ( Map . Entry &lt; Integer ,  String &gt;  entry  :  mapOfLines . entrySet ())  {			 Document  doc  =  new  Document ();		 doc . setText ( entry . getValue ());		 doc . setId ( entry . getKey ());		 doc . setSentiment ( Category . _10 );		 URI  uri  =  new  URI ( &#34;http://localhost:45/api/sentimentForAText/&#34; 		 +  selectedLanguage		 +  &#34;?id=&#34;		 +  doc . getId () 		 +  &#34;&amp;text=&#34; 		 +  URLEncoder . encode ( entry . getValue (),  StandardCharsets . UTF_8 . toString ()));		 request  =  HttpRequest . newBuilder ()				 . uri ( uri )				 . build ();		 CompletableFuture &lt; Void &gt;  future  =  client . sendAsync ( request ,  HttpResponse . BodyHandlers . ofString ())		 . thenAccept ( resp  -&gt;  {			 String  body  =  resp . body ();			 // the task returns a JSON Object, for convenience of handling						 // as you see below, it is very easy and convenient to define operations			 // on the body (here, a String) returned by each concurrent task 						 JsonReader  jsonReader  =  Json . createReader ( new  StringReader ( body ));			 JsonObject  jsonObject  =  jsonReader . readObject ();			 Document  docReturn  =  new  Document ();			 if  ( jsonObject  !=  null  &amp;&amp;  ! jsonObject . isEmpty ())  {				 String  key  =  jsonObject . keySet (). iterator (). next ();				 docReturn . setId ( Integer . valueOf ( key ));				 docReturn . setText ( mapOfLines . get ( Integer . valueOf ( key )));				 // Category._11 is the label for &#34;positive sentiment&#34; 				 if  ( jsonObject . getString ( key ). equals ( Category . _11 . toString ()))  {					 docReturn . setSentiment ( Categories . Category . _11 );				 }				 // Category._12 is the label for &#34;negative sentiment&#34; 				 if  ( jsonObject . getString ( key ). equals ( Category . _12 . toString ()))  {					 docReturn . setSentiment ( Categories . Category . _12 );				 }								 tempResults . put ( Integer . valueOf ( key ),  docReturn );			 }		 }		 );		 futures . add ( future );	 }	 CompletableFuture &lt; Void &gt;  combinedFuture  =  CompletableFuture . allOf ( futures . toArray (( new  CompletableFuture [ 0 ])));	 combinedFuture . join ();		 // tempResults ready to be use further in the code! }  catch  ( URISyntaxException  exception )  {	 System . out . println ( &#34;URI syntax exception&#34; +  exception ); }  catch  ( UnsupportedEncodingException  ex )  {	 System . out . println ( &#34;Encoding exception: &#34; +  ex ); } clock . closeAndPrintClock ();</p><p>字符串selectedLanguage=&#34；嗯&#34；地图&lt；整数，字符串&gt；mapOfLines=newhashmap（）；地图。这是一个测试。并发性是惊人的！&#34；）；地图。put（1，&#34；这是一个测试。并发性很难！&#34；）；ConcurrentHashMap&lt；整数，文档&gt；tempResults=new ConcurrentHashMap（）；HttpRequest请求；HttpClient=HttpClient。newHttpClient（）；设置&lt；完全未来&gt；futures=newhashset（）；//这是我为计时而设计的一门方便的课程，在这里可以买到https://github.com/seinecle/Utils时钟时钟=新时钟（&#34；为并发任务计时&#34；）；尝试{for（Map.Entry&lt；Integer，String&gt；Entry:mapOfLines.entrySet（））{Document doc=new Document（）；doc.setText（Entry.getValue（））；doc.setId（Entry.getKey（））；doc.setsential（Category.10）；URI URI=new URI（&#34；http://localhost:45/api/sentimentForAText/&#34; +选择的语言+&#34；？id=&#34；+博士。getId（）+&#34&amp；text=&#34；+URL编码器。encode（entry.getValue（），StandardCharset）。UTF_8。toString（））；request=HttpRequest。newBuilder（）。uri（uri）。构建（）；完整的未来&lt；Void&gt；未来=客户。sendAsync（request，HttpResponse.BodyHandlers.ofString（））。然后accept（resp-&gt；{String body=resp.body（）；//任务返回一个JSON对象，为了便于处理//如下所示，在每个并发任务JsonReader JsonReader=JSON.createReader返回的体（这里是一个字符串）上定义操作//非常简单方便（新StringReader（正文））；JsonObject=jsonReader。readObject（）；Document docReturn=新文档（）；if（jsonObject！=null&amp；！jsonObject.isEmpty（））{String key=jsonObject.keySet（）.iterator（）.next（）；docReturn.setId（Integer.valueOf（key））；docReturn.setText（mapOfLines.get（Integer.valueOf（key））；//Category._11是#34；积极情绪&#34；if的标签（jsonObject.getString（键）。equals（Category.Category.toString（））{docReturn.setSenition（Categories.Category._11）；}//Category_12是&#34的标签；负面情绪&#34；if（jsonObject.getString（键）。等于（Category.Category.toString（））{docReturn.setSetEntity（Categories.Category.toString）}tempResults。put（Integer.valueOf（key），docReturn）；			 }		 }		 );期货添加（未来）；}可完成的未来&lt；Void&gt；combinedFuture=可完成的未来。allOf（futures.toArray（（新的CompletableFuture[0]））；结合未来。加入（）；//tempResults准备好在代码中进一步使用了！}catch（URISyntaxException异常）{System.out.println（&#34；URI语法异常&#34；+异常）；}catch（UnsupportedEncodingException ex）{System.out.println（&#34；编码异常：&#34；+ex）}时钟closeAndPrintClock（）；</p><p>  The task is behind a simple REST API, using the super lightweight Javalin framework (but any other REST framework would work). This code resides in a separate Java SE project, which compiles in a jar that I can deploy anywhere and separately from the main code base:</p><p>这项任务的背后是一个简单的REST API，使用超轻量级的Javalin框架（但任何其他REST框架都可以）。这段代码驻留在一个单独的Java SE项目中，该项目编译在一个jar中，我可以将其部署在任何地方，并与主代码库分开：</p><p> public  class  APIController  {  /** * @param args the command line arguments */  public  static  void  main ( String []  args )  {  Javalin  app  =  Javalin . create (). start ( 45 );  System . out . println ( &#34;running the api&#34; );		 // initialization of objects for sentiment analysis, just once when deploying the jar.	 // each call to the API will find these objects ready to use, that speeds things up.	 // this sentiment analyis tool is free and open source at: https://github.com/seinecle/umigon-core	 UmigonController  umigonController  =  new  UmigonController ();  ClassifierMachineOneDocument  classifierOneDocEN  =  new  ClassifierMachineOneDocument ( umigonController . getSemanticsEN ());  ClassifierMachineOneDocument  classifierOneDocFR  =  new  ClassifierMachineOneDocument ( umigonController . getSemanticsFR ());  app . get ( &#34;/api/sentimentForAText/{lang}&#34; ,  ctx  -&gt;  {  JsonObjectBuilder  objectBuilder  =  Json . createObjectBuilder ();	  String  text  =  ctx . queryParam ( &#34;text&#34; );  String  id  =  ctx . queryParam ( &#34;id&#34; );  if  ( id  ==  null ){  id  =  UUID . randomUUID (). toString (). substring ( 0 ,  10 );  }  if  ( text  ==  null )  {  objectBuilder . add ( id ,  &#34;text parameter was absent&#34; );  JsonObject  jsonObject  =  objectBuilder . build ();  ctx . result ( jsonObject . toString ()). status ( HttpCode . BAD_REQUEST );  }  else  {  String  lang  =  ctx . pathParam ( &#34;lang&#34; );  Document  doc  =  new  Document ();  doc . setText ( text );  switch  ( lang )  {  case  &#34;en&#34; :  doc  =  classifierOneDocEN . call ( doc );  break ;  case  &#34;fr&#34; :  doc  =  classifierOneDocFR . call ( doc );  break ;  default :  objectBuilder . add ( &#34;-99&#34; ,  &#34;wrong param for lang - lang not supported&#34; );  JsonObject  jsonObject  =  objectBuilder . build ();  ctx . result ( jsonObject . toString ()). status ( HttpCode . BAD_REQUEST );  }  objectBuilder . add ( id ,  doc . getSentiment (). toString ());  JsonObject  jsonObject  =  objectBuilder . build ();  ctx . result ( jsonObject . toString ()). status ( HttpCode . OK );  }  }  );  }</p><p>公共类APIController{/***@param args命令行参数*/public static void main（String[]args）{Javalin app=Javalin.create（）.start（45）；System.out.println（&#34；运行api&#34；）；//用于情绪分析的对象初始化，在部署jar时只需初始化一次。//每次调用API都会发现这些对象可以使用，这会加快速度。//这是一个免费的开源工具：https://github.com/seinecle/umigon-coreUmigonController UmigonController=新的UmigonController（）；ClassifierMachineDocument classifierOneDocEN=新的ClassifierMachineDocument（umigonController.getSemanticsEN（））；ClassifierMachineDocument classifierOneDocFR=新的ClassifierMachineDocument（umigonController.getSemanticsFR（））；应用程序。get（&#34；/api/MONTUREFORATEXT/{lang}&#34；，ctx-&gt；{JsonObjectBuilder objectBuilder=Json.createObjectBuilder（）；String text=ctx.queryParam（&#34；text&#34；）；字符串id=ctx。queryParam（&#34；id&#34；）；如果（id==null）{id=UUID.randomUUID（）.toString（）.substring（0,10）；}如果（text==null）{objectBuilder.add（id，&#34；文本参数不存在&#34；）；JsonObject JsonObject=objectBuilder。构建（）；ctx。结果（jsonObject.toString（））。状态（HttpCode.BAD_请求）；}else{String lang=ctx.pathParam（&#34；lang&#34；）；Document doc=新文档（）；医生。setText（文本）；switch（lang）{case&#34；en&#34；：doc=classifiedocen.call（doc）；break；case&#34；fr&#34；：doc=classifiedornedocr.call（doc）；break；默认值：objectBuilder.add（&#34；-99&#34；&#34；lang lang-lang的参数错误，不支持&#34；）；JsonObject JsonObject=objectBuilder。构建（）；ctx。结果（jsonObject.toString（））。状态（HttpCode.BAD_请求）；}objectBuilder。添加（id，doc.gettouction（）。toString（））；JsonObject JsonObject=objectBuilder。构建（）；ctx。结果（jsonObject.toString（））。状态（HttpCode.OK）；}}}</p><p>  Looking at the code above, I realize that the reaction might be whaaaat but this code is actually much more complex than using an  ExecutorService etc! Well, let’s examine the pros and cons:</p><p>看看上面的代码，我意识到反应可能是Whaaat，但这段代码实际上比使用ExecutorService等要复杂得多！好吧，让我们来分析一下利弊：</p><p>  the task is completely free from the concurrency logic. No  Callable nor  Runnable. That frees your mind!</p><p>该任务完全没有并发逻辑。不可调用也不可运行。那会解放你的思想！</p><p>  it follows that the task is completely reusable and can be refactored without a consequence on the logic of concurrency, from the perspective of the main code base. Huge bonus, as you don’t want to be disturbed, when working on the logic of your code, by problems of making the code “concurrent compatible”.</p><p>因此，从主代码库的角度来看，任务是完全可重用的，并且可以在不影响并发逻辑的情况下进行重构。这是一个巨大的好处，因为在处理代码的逻辑时，您不想因为使代码“并发兼容”的问题而受到干扰。</p><p>  the encapsulation behind a REST API is a bonus:  the codebase for the task is the same across interfaces. In practice, the sentiment analyis task is carried out by the same code on the web app interface and the API, visible here: https://nocodefunctions.com/umigon/sentiment_analysis_tool.html</p><p>REST API背后的封装是一个好处：任务的代码库在接口之间是相同的。实际上，情绪分析任务由web应用程序界面和API上的相同代码执行，如下所示：https://nocodefunctions.com/umigon/sentiment_analysis_tool.html</p><p>  the task is offloaded from the main codebase, and that helps make things more organized</p><p>任务从主代码库中卸载，这有助于使事情更有条理</p><p>  calling the concurrent tasks from the main codebase is  relatively simple. Not need to instantiate or fiddle with an  Executor, as it comes already bundled in the HttpClient. But it can be taylored if needed.</p><p>从主代码库调用并发任务相对简单。不需要实例化或摆弄执行器，因为它已经捆绑在HttpClient中。但如果需要的话，它可以是泰勒色的。</p><p>  using json to carry the response of the task back to the main code base makes things brittle. I might need to change the Json format on the REST API side, and forget to update the way the  JSON Object is read on the main code base.</p><p>使用json将任务的响应带回主代码库会让事情变得脆弱。我可能需要更改REST API端的Json格式，忘记更新在主代码库中读取Json对象的方式。</p><p>  Speed: on a multi-core machine, execution times are 4x to 6x faster than a sequential execution.</p><p>速度：在多核机器上，执行时间比顺序执行快4到6倍。</p><p>  Limits:  Local vs remote: the gains of concurrency as shown above are achieved when the REST API sits on the same machine as the main code base. When I tried the mix (main code base on local laptop x REST API on a distante server), the code was just suuuuper slow. I didn’t investigate why.</p><p>限制：本地与远程：当REST API与主代码库位于同一台机器上时，可以获得如上所示的并发性。当我尝试混合时（主代码基于远程服务器上的本地膝上型电脑x REST API），代码的速度非常慢。我没有调查原因。</p><p>  When the REST API is on a Windows Machine, there is a maximum limit of connections. Hitting this limit causes an exception. Weird! So make sure to host your REST API on linux.</p><p>当REST API在Windows计算机上时，连接有一个最大限制。达到此限制会导致异常。奇怪的因此，请确保在linux上托管REST API。</p><p>  I will progressively refactor all the functions on  nocodefunctions.com to adopt this design. At the moment (Feb 19, 2022), only  sentiment analysis on the  test version of the site has been implemented. As a result, analyzing 6,000 tweets take just 10 seconds now (600 tweets per second!), versus ~ one minute before.</p><p>我将逐步重构nocodefunctions上的所有函数。com来采用这种设计。目前（2022年2月19日），只对网站的测试版本进行了情绪分析。因此，现在分析6000条推文只需10秒钟（每秒600条推文！），一分钟前。</p><p> I arrived at this solution after reading many blog posts by professional Java developers and StackOverflow Q&amp;As. I thank all these contributors, and I hope this new blog post will be of help to the next person researching these topics.</p><p>在阅读了专业Java开发人员和StackOverflow Q&amp；像我感谢所有的贡献者，我希望这篇新的博文能对下一个研究这些话题的人有所帮助。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>