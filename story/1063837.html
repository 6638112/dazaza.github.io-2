<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>OOP的重复死亡 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">OOP的重复死亡 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-06 18:05:48</div><div class="page_narrow text-break page_content"><p>自从六十年代晚期成立以来，面向对象的编程哈斯普及我们的行业。当前主流编程语言支持OOP -Except也许C，并且它不再是那个主流。最多的是我亲自遇到的主要程序员往往会划分世界：</p><p>   另一方面，尽管经历了严重的突变，但Oopis仍然受到知识渊博的人（包括你真正）的强烈批评。更糟糕的是，游戏行业似乎击败了它。视频游戏是仿真，一个核心利基ofoop。那个＆＃39; s什么是以后的命名。如果它＆＃39;甚至那份工作的工具也是......</p><p>  哦。正确的。我＆＃39; m＆＃34; OOP＆＃34;到处，我不知道它意味着什么。谢天谢地，Deborah J. Armstrong Madea调查人们如何使用这个词（Orienteddevelopment的夸克），并提出了8个基本构建块。</p><p>  以简化形式的讨论表达现实的抽象，以便我们可以看到常见。</p><p>  封装数据和行为在对象中定义了来自其他一切的对象，保护对象的内部陈述。</p><p> 继承允许将一个类的属性和方法粘在另一个现有类上。</p><p> 对象一个个人，可识别的项目，真正的orabstract，其中包含有关其操作的自身和对齐的信息。 </p><p>现在我理解为什么没有人同意OO的意思：很少有非对象语言支持上述所有语言，而另一个语言支持上述一些语言。考虑：</p><p> Java Don＆＃39; t真正支持消息。您可以调用课程的方法，但那些与普通函数调用一样同步。</p><p>   通过各种编程语言，OO或不支持封装。抽象甚至更无处不在。</p><p> 看着大局，我可以看到对象方向不是Aparadigm，而是一套机械师我们可以樱桃挑选。然而，我们继续将它视为统一的概念。</p><p> 我认为这就是为什么＆＃34; OOP＆＃34;幸存下来。如果没有肯定的成就，每个人都可以达成一致，它的意思是因为我们改变了我们的编程实践时，它的意义不断变化。</p><p>  （注意：以下＆＃34;死亡＆＃34;只是以粗糙的时间顺序排列，并且通常描述普及的缓慢下降，而不是野蛮的活动。想到COBOL。这门语言是长期的死亡，但今年的语言仍然是剧本。）</p><p>   实际上我组成了这个词和＃34;面向对象的＆＃34 ;,我可以告诉你IDID没有C ++。 </p><p>一段时间，＆＃34;面向对象＆＃34;大多是幻灯行。我们将鸟瞰为第一个面向对象的语言，但艾伦凯发明了这个术语，而Smalltalk虽然受到Simula的启发，但被要求。它有一些LISP根，一切都是一个物体，包括类和消息。</p><p> 然后C ++在C环境中有效地移植了Simula。在Process中，它强调了短期效率，并阻止了许多事情（原始类型，类，方法......）是对象。课程Weremostly摘要数据类型具有继承和多态性。许多Objects通过Offullic数据成员或Getters和Setters直接可操纵。</p><p> 然后java来了。它被呈现为＆＃34;更容易C ++＆＃34;同样的语法，类似的抽象，垃圾收集......在那点SmallTalk Warkardly使用了更多，＆＃34; OOP＆＃34;基本上意味着Java和C ++。</p><p>   当我第一次教授OOP时，大约2004年，Java已经成为了一种语言。尽管在iwas教授Java之前已经发表了10年，但设计模式书尚未接受老师。较旧的似乎被困在遗产中的心态。我有我的动物，形状和每天的份额。我出来的愿景很简单：</p><p>  那时＆＃39;那时是微妙的时间。我们有一种语言TOLEARN，一个项目完成，当然还有其余的。一位老师突然出现：</p><p>  等一下。遗产是OOP＆＃39; s旗舰。我们应该彻底阻止它吗？脆弱的基础？好的，你赢了。继承Isevil，另一种老师是愚蠢的 - 没有时间的微妙，记住？争论很引人注目。</p><p> 变化是剧烈的。之前，我们有大型继承层次结构，课程大多是现实世界的实体，以及看起来像＆＃34的围绕的分离;狗课是负责狗＆＃34;现在我们有利于构成，并将关注的关注分开，而不仅仅是实体。模型视图控制器托特恩，尽管比Java大，但是一个很好的例子：从甚至单一实体的互动中显示出来的差异：我们不会有一只狗。我们有一个狗的型号，狗的形象，狗的可行区域...... </p><p>这是第二个死亡。棺材很快，被java＆＃39;泛型：突然们几乎不需要对象。</p><p>  即使是第二个死亡，＆＃34; OOP＆＃34;仍然主要是java和c ++。（和c＃。）实践变化了很多;语言，不是那么多。</p><p> 同时，脚本语言正在上升。 Python，Ruby，JavaScript ......没有静态键入，并且JavaScript并在＆＃39; t即使是课程。 ＆＃34; OOP＆＃34;刚得更多包容性。你将在那些语言中找到的代码和普通也完全不同。</p><p> 例如，通过这些动态语言的用户发明了（更新：Moder：Modented）的更新。最重要的是通过方式补偿动态型系统的跳柄，顺便说一下：如果没有静止的静态类型系统，无需免费提供，需要检查yousassuptions是可怕的。测试可以提供这些检查。</p><p> 现在＆＃34; OOP＆＃34;太稀释了，意味着什么。作为＃34; Objoreriented＆＃34;这么少地告诉我关于我可能也是臭味的语言。</p><p>   它已经变得毫无意义，＆＃34; OOP＆＃34;还在周围。实践吸引力超越了识别，但以某种方式幸存下来。</p><p>  有几个原因。 Bjarne Stroustrup自己说C ++不是面向对象的。 Lambdas无处不在，包括C ++和Java。并行呼吁更好的方式划线状态，哪个OOP当前提供。一些核心oop（GUI，仿真），正在开始获得有吸引力的替代品。而且，游戏行业正在慢慢走开。 </p><p>一个简单的概念的两个花梢词。 Lambda只是一个函数的界面， - 相同的方式42是一个数字的字面描述。与他们一起，您不再需要命名everysingle函数。关闭是一种实现策略。基本上包含一段代码和一块数据的对象.TOWETHER，lambdas和封闭物可以使功能＆＃34;第一类＆＃34 ;: accan通过整数来传递和操纵。</p><p> 在基本级别，关闭和对象非常接近。从流行的角度来看，一流的功能不是oo atall：他们来自功能编程。然而，他们管理每一个主流oop语言。</p><p> 这是对OOP的严重打击。如果关闭/对象二元性并没有DIDN＆＃39; Tprevent关闭甚至Java甚至java，我们可以确保有影响的人承认OOP并不总是合适的。真的。它易于支付给＆＃34的唇部服务;作业的最佳工具和＃34;但是决定OOP是我们正在做的任何事情的最佳工具。镜子，他们进一步走了。</p><p> 这可能不足以杀死＆＃34; oop＆＃34;但是。 λ和封堵功能可以联合选择，好像他们是面向对象的allalong。我看到它用参数多态性发生了。很多，它得到了一个新的名字，甚至成为OOP的重要特征，具体取决于你问道。</p><p>  典型的OOP程序也是必要的程序。虽然它倾向于隐藏在封装地毯下。在多线程上的背景下，这迅速成为噩梦。现在，您的Object可以随时中断，并要求在自己身上运行ConcurrentWrites。因此，线程安全的重要性，锁的Propermanagement ......</p><p> 有一种更简单的方法：Don＆＃39; t突变状态。始终构建换下，永远不要扔掉任何东西。然后让您的智能指针oryour垃圾收集器照顾不可达的参考。</p><p> 这消除了我们的大部分并发性相关问题。当然，您需要在某些时候需要副作用，但它们总是可以隔离孤立的TOSMALL部分程序。 </p><p>另一方面，禁止变形状态和其他这样的Sideefefects而不改变其他任何东西是瘫痪。你需要一个新的一袋技巧。持久性数据结构，所以youdon＆＃39; t必须复制整个应用程序的状态，以便每次更新。标准高阶函数，如地图，折叠和过滤器，因此您对大多数伪装的替代方案有替代，而循环则不借入递归核选择。代数数据类型，因此您可以在不诉诸驯化异常的情况下，具有comail的功能。 Monads，所以你可以链接这样的计算，而不是在else的表达式的烦人的链条......</p><p> 您可以看到这将在哪里：没有变形状态，PullTowards功能编程很难抵抗。它需要时间，但我认为OOP无法生存。甚至甚至actor模型都会闪耀。虽然演员与对象非常相似，但他们不像自己那样。 OOP可能会活下去，但＆＃34; OOP＆＃34;会死。</p><p>  到目前为止，我们可以说OOP并不是那么糟糕。当然，曝光的新功能，面临新的障碍，但这并不是那么n; tonvalidate核心的想法。要做到这一点，你需要击败自己的游戏。猜猜，实体系统正在做什么。他们在游戏行业的主流意识，我希望他们最终以某种形式侵入GUI编程。</p><p> 如此完全被遗弃的问题＆＃39; t只是意味着条件。它会将OOP标记为错误。也许不是我们可以避免的人：我们不得不尝试。但仍然是一个错误。</p><p> 返回当继承层次都是愤怒时，大多数游戏都在游戏对象的大分类上徘徊。像这样：</p><p> 对象/ \ small，不完整，/ \完全组成静态\继承层次结构/ \移动/ \ | \ / loot | \ clutter |.敌人平台</p><p> 这种设计的主要问题是它的不灵活性。怎么样的移动？看不见的敌人？等等。我们可以通过对游戏设计的修补程序来调整层次结构，但涉及的TheChanges很重。游戏可以＆＃39; t有：截止日期aretight，但我们需要实验并回溯以使它们更好。 </p><p>我们需要更灵活的东西。一个解决方案是将GameObjects视为组件的累积。这样，您可以轻松静态战利品和动态战利品。它们都是渲染和可赢的，但其中只有一个动画。</p><p> 问题是，如何将这些组件添加在一起？ OneLyolatult是使用Mixins。这给了我们一些灵活性，但我们可以进一步走。请参阅，Mixins仍将Checonent的数据绑定到处理它的代码。但是当您想到它时，一些数据，如对象的位置，对Severalsystems（渲染，碰撞检测，AI ...）有用。</p><p> 显而易见的解决方案是分离代码和数据。让组件仅仅是数据，并具有单独的处理器映射到它们上。这为您提供了一种类似的数据库 - 类似的系统：您的游戏数据基本上是agiant表，每种类型组件的列，以及每个GameObject的一行。然后处理器查询相关列。</p><p> 这种数据和代码的分离具有许多优点。 Forinstance，它可以轻松地将性能敏感的性能从其余部分分开。这让您可以写下您的大部分游戏逻辑脚本语言，并将其视为普通数据 - 纯纹理和网格。在释放它之前，您的游戏现在更容易修改，更容易换后。</p><p> 然而，足够了ECS倡导。我的观点是，这个architecture不能被误认为是oop味道。它将Codeand数据分开，并与对象很好地＆＃39;它的成长性只能意味着oop正在被驱逐出其两种双胞不平的巨头。如果OOP不是它设计的作业的最佳工具，那么它是最适合任何东西的最佳工具吗？</p><p> 您可以认为OOP仍然可以通过图形用户界面来保存，但是＆＃39; t指望它：实体系统可以适应该上下文，还有其他有希望的解决方案。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://loup-vaillant.fr/articles/deaths-of-oop">https://loup-vaillant.fr/articles/deaths-of-oop</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/oop/">#oop</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/deaths/">#deaths</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>