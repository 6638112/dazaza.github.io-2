<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>不符合语法</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">不符合语法</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-24 19:20:38</div><div class="page_narrow text-break page_content"><p>This post introduces ungrammars: a new formalism for describing concrete syntax trees.The ideas behind ungrammar are simple, and are move valuable than a specific implementation.Nonetheless, an implementation is available here:</p><p>这篇文章介绍了无文法：一种描述具体语法树的新形式主义。无文法背后的思想很简单，而且比具体的实现更有价值。尽管如此，这里提供了一个实现：</p><p>     Ungrammar describes concrete syntax tree — a set of data types (or a set of trees, if you will).</p><p>非语法描述具体的语法树 - 一组数据类型(或者，如果您愿意，也可以是一组树)。</p><p> So, what exactly does “describing syntax trees” mean and why is it useful?When writing an IDE, one of the core data structure is the concrete syntax tree.It is a full-fidelity tree which represents the original source code in detail, including parenthesis, comments, and whitespace.CSTs are used for initial analysis of the language.They are also a vocabulary type for refactors.Although the ultimate result of a refactor is a text diff, tree modification is a more convenient internal representation.</p><p>那么，“描述语法树”到底是什么意思？它为什么有用？在编写IDE时，核心数据结构之一是具体的语法树。它是一棵全保真的树，详细地表示原始源代码，包括括号、注释和空格。CST用于语言的初始分析。它们也是重构的词汇表类型。虽然重构的最终结果是文本差异，但树修改是一种更方便的内部表示。</p><p>  At the lowest level, the CST is typically unityped: there’s some  Node superclass, which has a collection of  Node children and an optional  Node parent.On top of this raw layer, a more AST-like API is provided:  Struct has a  .name() and a list of  .fields(), etc.This typed API is huge!For rust-analyzer, it is comprised of more than 130  types!And it is also more detailed than a typical AST:  Struct also has  .l_curly() and  .r_curly().</p><p>在最低层，cst通常是unityped的：有一些Node超类，它有一个Node子节点集合和一个可选的Node父节点。在这个原始层的顶部，提供了一个更类似AST的API：struct有一个.name()和一个.field()列表，等等。这个类型化的API很大！对于锈检分析器，它由130多个类型组成！而且它也比典型的AST更详细：struct还有.l_curly()和.r_curly()。</p><p> What’s worse, this API changes a lot, especially at the beginning.You may start with nesting  .fields() directly under the  Struct, but then introduce a  StructFields node for everything between the curly braces to share the code with enum variants.</p><p>更糟糕的是，这个API改变了很多，特别是在一开始，您可以从直接嵌套在Struct下面的.field()开始，然后为花括号之间的所有内容引入一个StructFields节点，以便与枚举变体共享代码。</p><p> In short, writing this by hand sucks :-)Ungrammar is a notation to concisely describe the structure of the syntax tree, which can be used by a code generator to build an API in the target language.If you’ve heard about  ASDL, ungrammar is ASDL for concrete syntax trees.For rust-analyzer’s case, that means taking the following input:</p><p>简而言之，用手写这篇文章很糟糕：-)非语法是一种简明地描述语法树结构的符号，代码生成器可以使用它来用目标语言构建API。如果你听说过ASDL，那么对于具体的语法树，非语法就是ASDL。对于RUST分析器的情况，这意味着接受以下输入：</p><p>   impl  ast :: AttrsOwner  for  Module  {} impl  ast :: VisibilityOwner  for  Module  {} impl  ast :: NameOwner  for  Module  {} impl  Module  {  pub  fn  mod_token ( &amp; self )  -&gt;  Option &lt; SyntaxToken &gt;  {  ...  }  pub  fn  item_list ( &amp; self )  -&gt;  Option &lt; ItemList &gt;  {  ...  }  pub  fn  semicolon_token ( &amp; self )  -&gt;  Option &lt; SyntaxToken &gt;  {  ...  } }</p><p>Implast：：AttrsOwner for Module{}Impast：：VisibilityOwner for Module{}Implast：：NameOwner for Module{}Impll Module{pub FN mod_Token(&amp；self)-&gt；option&lt；SyntaxToken&&gt;；{...}pub FN Item_List(&amp；self)-&lt；option&lt；ItemList&gt；{...}pub FN分号_Token(&amp；self)-&gt；option&lt；SyntaxToken&gt；{...}}。</p><p> In typical parser generators, something similar can be achieved by generating  both the parser and the syntax tree from the same grammar.This works to some extent, but has an inherent problem that the shape of the tree you want for the programmatic API, and the shape of the grammar you need to implement the parser are often different.“Technical” transformations like left-recursion elimination don’t affect the language described by the grammar, but completely change the shape of the parse tree.In contrast, ungrammar focuses solely on the second task, which radically reduces the complexity of the grammar.In rust-analyzer, it is paired with a hand-written parser.</p><p>在典型的解析器生成器中，可以通过从相同的语法生成解析器和语法树来实现类似的功能。这在某种程度上是有效的，但是存在一个固有的问题，即您想要用于编程API的树的形状和实现解析器所需的语法的形状通常是不同的。像左递归消除这样的“技术”转换不影响语法描述的语言，但是完全改变了解析树的形状。相反，非语法只关注第二个任务，这从根本上降低了语法的复杂性。在锈蚀分析器中，它与手写的解析器配对。</p><p> Treated as an ordinary (context free) grammar, ungrammar describes a superset of the language.For example, for programmatic API it might be convenient to treat commas in comma-separate lists as a part of the list element(rust-analyzer doesn’t do this yet, but it should).This leads to the following ungrammar, which obviously doesn’t treat commas precisely:</p><p>非语法被视为普通(上下文无关)语法，它描述了语言的超集。例如，对于编程API，将逗号分隔的列表中的逗号作为列表元素的一部分来处理可能很方便(rust分析器还没有这样做，但它应该这样做)。这会导致以下非语法，这显然不能准确地处理逗号：</p><p>  Similarly, ungrammar defines binary and unary expressions, but doesn’t specify their relative precedence and associativity.</p><p>同样，非语法定义了二元和一元表达式，但没有指定它们的相对优先级和结合性。</p><p> An interesting side-effect is that the resulting grammars turn out to be pretty human readable.For example, a full production ready Rust grammar takes about 600 short lines:</p><p>一个有趣的副作用是，最终得到的语法非常便于人类阅读。例如，一个完整的可用于生产的Rust语法需要大约600行短行：</p><p> Now that we’ve answered the “why” question, let’s look at how ungrammar works.</p><p>现在我们已经回答了“为什么”这个问题，让我们来看看非语法是如何起作用的。</p><p> Like grammars, ungrammars operate with a set of terminals and non-terminals.Terminals are atomic indivisible tokens, like keyword  fn or a semicolon  ;.Non-terminals are composite internal nodes consisting of other nodes and tokens.</p><p>与语法一样，非文法使用一组终端和非终端进行操作。终端是原子上不可分割的标记，如关键字fn或分号；非终端是由其他节点和标记组成的复合内部节点。</p><p> Tokens (terminals) are spelled using single quotes:  &#39;+&#39;,  &#39;fn&#39;,  &#39;ident&#39;,  &#39;int_number&#39;.Tokens are defined outside of an ungrammar, and don’t need to be declared to use them.By convention, keywords and punctuation are represented using themselves, other tokens use lower_snake_case.Because ungrammar describes trees, it uses parser tokens rather then lexer tokens.What this means is that context-sensitive keywords like  default are recognized as separate tokens ( &#39;default&#39;).The same goes for composite tokens like  &#39;&lt;&lt;&#39;.</p><p>令牌(终端)使用单引号进行拼写：&#39；+&#39；，&#39；fn&#39；，&#39；ident&#39；，&#39；int_number&#39；。令牌在非语法之外定义，不需要声明即可使用Them.按照惯例，关键字和标点符号使用自身表示，而其他令牌使用LOWER_VOKEN_CASE。由于非语法描述树，因此它使用解析器令牌而不是词法分析器令牌。这意味着上下文相关关键字(&#39；)被识别为单独的令牌(&#39；默认值)。对于像&#39；&lt；&lt；&#39；这样的复合令牌也是如此。</p><p> Nodes (non-terminals) are defined within the grammar by associating node name and a rule.The ungrammar itself is a set of node definitions.By convention, nodes are named using UpperCamelCase.Each node must be defined exactly once.Rules are regular expressions over the set of tokens and nodes.</p><p>节点(非终端)在语法中通过关联节点名称和规则来定义。非语法本身是一组节点定义。按照惯例，节点使用UpperCamelCase命名。每个节点必须精确定义一次。规则是一组记号和节点上的正则表达式。</p><p>  Grammar = Node*Node = name:&#39;ident&#39; &#39;=&#39; RuleRule = &#39;ident&#39; // Alphabetic identifier| &#39;token_ident&#39; // Single quoted string| Rule* // Concatenation| Rule (&#39;|&#39; Rule)* // Alternation| Rule &#39;?&#39; // Zero or one repetition| Rule &#39;*&#39; // Klenee star| &#39;(&#39; Rule &#39;)&#39; // Grouping| label:&#39;ident&#39; &#39;:&#39; Rule // Labeled rule</p><p>语法=节点*节点=名称：&#39；ident&#39；&#39；RuleRule=&#39；ident&#39；//字母标识符|&#39；Token_ident&#39；//单引号字符串|Rule*//串联|Rule(&#39；|&#39；Rule)*//交替|Rule&#39；？&#39；//零或一次重复|Rule&#39；*&#39；//Klenee star|&#39；(&#39；Rule&#39；)&#39；//分组|标签：&#39；ident&#39；&#39；：&#39；规则//标签规则</p><p> The only unusual thing are optional labels.By default, the names in the generated code are derived automatically from the type, but a label can be used as an override, or if there’s an ambiguity:</p><p>唯一不寻常的是可选标签。默认情况下，生成的代码中的名称是自动从类型派生的，但是标签可以用作覆盖，或者如果有歧义：</p><p>   Ungrammar doesn’t specify any particular way to lower rules to syntax node definitions.It’s up to the generator to pattern-match rules to target language constructs: Java would use inheritance, Rust enums and TypeScript — union types.The generator can accept only a subset of all possible rules.An example of restriction might be: “Alternation ( |) is only allowed at the top level. Alternatives must be other nodes”.With this restriction, an alternative can be lowered to an interface definition with a number of subclasses.</p><p>非语法没有指定任何特定的方式来降低语法节点定义的规则。它取决于生成器将规则与目标语言构造进行模式匹配：JAVA将使用继承、RUST枚举和TypeScript - 联合类型。生成器只能接受所有可能规则的子集。限制的一个例子可能是：“只允许在顶层使用替换(|)。备选方案必须是其他节点“。有了这个限制，备选方案可以降低为具有多个子类的接口定义。</p><p> The  ungrammar crate provides a Rust API for parsing ungrammars, use it if your code generator is implemented in Rust.Alternatively,   ungrammar2json binary converts ungrammar syntax into equivalent JSON.For an example of generator, take a look at   gen_syntax in rst-analyzer.</p><p>Ungramar2json二进制代码将非语法语法转换成等价的JSON。有关生成器的示例，请查看rst分析器中的gen_SYNTANGLING。(非语法生成器提供了Rust API，如果您的代码生成器是在Rust中实现的，请使用它。或者，ungramar2json二进制将非语法语法转换为等价的JSON。</p><p> The  Node and  Token terminology is inherited from  rowan, rust-analyzer’s syntax library.A better choice would be  Tree and  Token, as nodes contain other nodes and  are trees.</p><p>Node和Token术语继承自Rowan，Ruust分析器的语法库，更好的选择是Tree和Token，因为节点包含其他节点并且是树。</p><p> Always single-quoting terminals is a nice concrete syntax for grammars.Some parser generators I’ve worked with required only some terminals to be quoted, which, without knowing the rules by heart, reduced readability.Similarly, spelling  PLUS instead of  &#39;+&#39; is not very readable.</p><p>始终使用单引号终端是一种很好的具体语法。我使用过的一些解析器生成器只需要引用一些终端，这在没有记住规则的情况下降低了可读性。同样，拼写加号而不是&#39；+&#39；也不是很好读。</p><p> “Recursive regular expressions” feels like a convenient syntax for CFGs.Not restricting right-hand-side to be a flat list of alternatives, using  () for grouping and allowing basic conveniences like  * and  ? subjectively makes the resulting grammars quiet readable.The catch is that one needs union types and anonymous records to faithfully lower arbitrary regex-represented rule.Placing restrictions into the specific generator, rather then the base language, feels like a better division of responsibility.</p><p>“递归正则表达式”感觉像是一种方便的CFG语法，不会将右侧限制为备选方案的平面列表，而是使用()进行分组，并允许使用*和？主观上使生成的语法更具可读性。问题是需要联合类型和匿名记录来忠实地降低任意正则表达式表示的规则。将限制放在特定生成器而不是基础语言中，感觉更好地划分了责任。</p><p> By quoting terminals, using punctuation ( : = () | * ?) for syntax and completely avoiding keywords, ungrammar avoids clashes between names of productions and the syntax of ungrammar itself.</p><p>通过引用终端，使用标点符号(：=()|*？)。对于语法和完全避免的关键字，非语法避免了产生式名称和非语法本身的语法之间的冲突。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://rust-analyzer.github.io//blog/2020/10/24/introducing-ungrammar.html">https://rust-analyzer.github.io//blog/2020/10/24/introducing-ungrammar.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/符合/">#符合</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/ungrammar/">#ungrammar</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语法/">#语法</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>