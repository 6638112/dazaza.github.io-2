<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>市长：库伯内斯闪电般的存储</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">市长：库伯内斯闪电般的存储</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-07 11:24:31</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/2b68fb108ec7394a82f58146265ceca9.png"><img src="http://img2.diglog.com/img/2020/11/2b68fb108ec7394a82f58146265ceca9.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>At MayaData we like new tech. Tech that makes our databases perform better. Tech like  lockless ring buffers,  NVMe-oF, and  Kubernetes. In this blog post we’re going to see those technologies at work to give us awesome block storage performance with flexibility and simple operations.</p><p>在MayaData，我们喜欢新技术。让我们的数据库运行得更好的技术。无锁环形缓冲器、NVMe-of和Kubernetes等技术。在这篇博客文章中，我们将看到这些技术正在发挥作用，它们以灵活和简单的操作为我们提供了令人惊叹的块存储性能。</p><p>  Mayastor is new tech, it’s fast, and it’s based on  SPDK. Why is SPDK exciting? It’s a new generation in storage software, designed for super high speed low latency  NVMe devices. I’ll save you the scrolling and just tell you I believe Mayastor was able to max out the practical throughput of the nvme device I used for my benchmark, allowing for multiple high performance (20kqps+) database instances on a single node. Perfect for a database farm in Kubernetes</p><p>Mayastor是一种新技术，速度很快，而且是基于SPDK的。为什么SPDK令人兴奋？这是新一代存储软件，专为超高速低延迟NVMe设备设计。我只想告诉您，我相信Mayastor能够最大限度地提高我在基准测试中使用的NVMe设备的实际吞吐量，从而在单个节点上支持多个高性能(20kqps+)数据库实例。非常适合于Kubernetes的数据库场。</p><p>  Open source relational databases are a staple component for app developers. People use them all the time for all kinds of software projects. It’s easy to build relationships between different groups of data, the syntax is well known, and they’ve been around for as long as modern computing.  When a dev wants a relational database to hack on, odds are good that it’s going to be  Postgres or  MySQL. They’re Free. They’re open source. They’ve both been quite stable for a long time, and they both run in Kubernetes just great.  The good folks at Percona make containerized, production ready versions of these databases, and we’re going to use their  Percona Distribution for MySQL for the following tests.</p><p>开源关系数据库是应用程序开发人员的主要组件。人们总是在各种软件项目中使用它们。在不同的数据组之间建立关系很容易，语法是众所周知的，而且随着现代计算的发展，它们已经存在了很长时间。当开发人员想要入侵关系数据库时，很可能是Postgres或MySQL。他们是免费的。它们是开源的。它们都已经相当稳定很长一段时间了，而且它们都能在Kubernetes上运行得很好。如果Percona的好员工制作这些数据库的容器化的、可生产的版本，我们将使用他们的Percona发行版MySQL来进行下面的测试。</p><p>  So what is the difficulty with running relational databases, or databases in general, inside of Kubernetes?  Given all the features of Kubernetes for managing highly available application deployments: Automation with control, Common declarative configuration interface, and build-in observability, one would think Databases are the application to deploy to it.</p><p>那么，在Kubernetes中运行关系数据库或一般数据库有什么困难呢？考虑到Kubernetes用于管理高可用性应用程序部署的所有功能：带控制的自动化、通用声明性配置接口和内置可观察性，人们会认为数据库就是要部署到它上的应用程序。</p><p>   The trick is, databases are notoriously disk intensive and latency sensitive. The reason this has an impact on your Kubernetes deployments is that storage support in stock settings and untuned K8s clusters is rudimentary at best. That’s created a number of projects that are out to provide for storage in K8s projects, including, of course, the popular OpenEBS project.</p><p>诀窍在于，数据库是出了名的磁盘密集型和延迟敏感型数据库。这对您的Kubernetes部署有影响的原因是，库存设置和未调优的K8S集群中的存储支持充其量是最基本的。这就创建了许多项目，用于在K8S项目中提供存储，当然，包括流行的OpenEBS项目。</p><p>  In this post I’m going to investigate the newest of the storage engines that comprise the data plane for OpenEBS. As a challenge, I’d like to be able to achieve 20,000 queries per second out of a MySQL database using this storage engine for block storage underneath.</p><p>在这篇文章中，我将研究构成OpenEBS数据平面的最新存储引擎。作为一项挑战，我希望能够在MySQL数据库中实现每秒20,000个查询，并在底层使用此存储引擎进行块存储。</p><p> Now, getting to 20kqps could be easy with the right dataset. But I want to achieve this with data that’s significantly larger than available RAM. In that scenario, 20kqps is pretty fast (as you can see below by the disk traffic and cpu load it generates).</p><p>现在，有了正确的数据集，达到20kqps可能很容易。但我希望使用比可用RAM大得多的数据来实现这一点。在这种情况下，20kqps是相当快的(从它产生的磁盘流量和CPU负载可以看出)。</p><p> There are a number of great options available for deploying MySQL in Kubernetes, but for this test we really just want a good, high performance database to start with. I won’t really need fancy DBaaS functionality, an operator to take care of backups, or anything of the sort. We’ll start from scratch with Percona’s MySQL container, and build a little deployment manifest for it. Now, maybe you’re thinking: “don’t you mean a stateful set?” But no, we’re going to use a deployment for this. Simple and easy to configure alongside of Container Attached Storage.</p><p>在Kubernetes中部署MySQL有很多很好的选择，但是对于这个测试，我们真正想要的只是一个好的、高性能的数据库。我真的不需要花哨的DBaaS功能，也不需要操作员来管理备份，或者任何类似的东西。我们将从Percona的MySQL容器开始，并为其构建一个小的部署清单。现在，也许你在想：“你的意思不是一个有状态的集合吗？”但不是的，我们要用部署的方式来解决这个问题。除了容器连接存储外，还可以简单方便地进行配置。</p><p> The deployment pictured references an external volume, vol2. Now we could create a PV for this on the local system, but then if our MySQL instance gets scheduled on a different machine, the storage won’t be present.</p><p>图中的部署引用了外部卷vol2。现在，我们可以在本地系统上为此创建一个PV，但是如果我们的MySQL实例被安排在另一台机器上，存储将不存在。</p><p>   Mayastor is the latest storage engine for OpenEBS and MayaData’s Kubera offering. Mayastor represents the state-of-the-art in feature-rich storage for Linux systems. Mayastor creates virtual volumes that are backed by fast NVMe disks, and exports those volumes over the super-fast NVMf protocol. It’s a fresh implementation of the Container Attached Storage model. By  CAS, I mean it’s purpose built for the multi-tenant distributed world of the cloud. CAS means each workload gets its own storage system, with knobs for tuning and everything. The beauty of the CAS architecture is that it decouples your apps from their storage. You can attach to a disk locally or via NVMf or iSCSI.</p><p>Mayastor是OpenEBS和MayaData的Kubera产品的最新存储引擎。Mayastor代表了Linux系统功能丰富存储领域的最先进技术。Mayastor创建由快速NVMe磁盘支持的虚拟卷，并通过超高速NVMf协议导出这些卷。它是容器附加存储模型的全新实现。所谓CAS，我的意思是它是专门为云的多租户分布式世界而构建的。CAS意味着每个工作负载都有自己的存储系统，有用于调优的旋钮等等。CAS架构的美妙之处在于，它将您的应用程序与其存储分离。您可以在本地连接到磁盘，也可以通过NVMf或iSCSI连接到磁盘。</p><p> Mayastor is CAS and it is purpose built to support cloud native workloads at speed with very little overhead. At MayaData we wrote it in Rust; we worked with Intel to implement new breakthrough technology called SPDK; made it easy to use with Kubernetes and possible to use with anything; and open-sourced it because, well, it improves the state of the art of storage in k8s and community always wins (eventually).</p><p>Mayastor是CAS，旨在以极小的开销快速支持云本地工作负载。在MayaData，我们用Rust编写了它；我们与Intel合作实现了名为SPDK的新的突破性技术；使其易于与Kubernetes一起使用，并可以与任何东西一起使用；并将其开源，因为它提高了K8中存储的技术水平，并且社区总是(最终)取胜。</p><p> If you’d like to set up Mayastor on a new or existing cluster, have a look at:  https://mayastor.gitbook.io/introduction/</p><p>如果您想在新的或现有的集群上设置Mayastor，请查看：https://mayastor.gitbook.io/introduction/。</p><p>  The first thing I want to do is get an idea of how many queries per second (QPS) at which the DB maxes out. My suspicion at the outset is that the limiter for QPS is typically storage latency. We can deploy our Mayastor pool and storage class manifests in a small test cluster just to make sure they’re working as expected, and then tune our test to drive the DB as hard as we can. Performance characteristics of databases are very much tied to the specifics of the workload and table structure. So the first challenge here is to sort out what kind of workload is going to exercise the disk effectively.</p><p>我想做的第一件事是了解数据库每秒最多处理多少个查询(QPS)。我从一开始就怀疑QPS的限制因素通常是存储延迟。我们可以在一个小型测试集群中部署Mayastor池和存储类清单，以确保它们按预期工作，然后调优我们的测试以尽可能地驱动数据库。数据库的性能特征与工作负载和表结构的细节密切相关。因此，这里的第一个挑战是找出哪种工作负载将有效地运行磁盘。</p><p> Sysbench is a great tool for exercising various aspects of Linux systems, and it includes some database tests we can use to get some baselines.  https://github.com/akopytov/sysbench is where you can find it. We can put it in a container and point that mysql OLTP test right at our database service.</p><p>Sysbench是一个很好的工具，可以用来测试Linux系统的各个方面，它包含了一些数据库测试，我们可以用它来获得一些基准。你可以在https://github.com/akopytov/sysbench找到它。我们可以将其放入容器中，然后将MySQL OLTP测试直接指向我们的数据库服务。</p><p> After a little bit of experimentation with sysbench options to set different values for the table size, number of tables, etc., I arrived at very stable results on a small cluster in AWS using m5ad.xlarge nodes. I’ve settled on 10 threads and 10 tables, with 10M rows in each table. With no additional tuning on MySQL, sysbench settles into about 4300 queries per second with an average latency at 46ms. Pretty good for a small cloud setup.</p><p>在使用sysbench选项为表大小、表数等设置了不同的值之后，我在使用m5ad.xLarge节点的AWS中的一个小集群上得到了非常稳定的结果。我已经确定了10个线程和10个表，每个表中有10M行。在没有对MySQL进行额外调整的情况下，sysbench每秒可以处理大约4300个查询，平均延迟为46ms。对于小型云设置来说，这相当不错。</p><p> With that as a baseline, let’s see how much we can get out of it on a larger system. Intel makes high core-count cpus and very fast Optane NVMe devices, and they’ve generously allowed us to use their benchmarking labs for a little while for some database testing. Without going into too much hardware geekery, we have three 96 core boxes running at 2.2Ghz with more RAM than I need and 100Gb networking to string them together. Each box has a small Optane NVMe device, and this single little drive is capable of at least 400k iops and 1.7GB/s through an ext4 filesystem. That’s fast. The published specs for this device are a little bit higher (about 500k iops and 2GB/s) but we’ll take this to be peak perf for our purposes.</p><p>以此为基准，让我们看看在一个更大的系统上我们可以从中获益多少。英特尔制造高核处理器和非常快的Optane NVMe设备，他们慷慨地允许我们使用他们的基准实验室一段时间进行一些数据库测试。我们没有太多的硬件极客，我们有三个运行在2.2 GHz的96个核心盒，比我需要的更多的RAM和100 Gb的网络将它们串在一起。每个盒都有一个小型Optane NVMe设备，这个小型驱动器通过ext4文件系统至少能够支持400k IOPS和1.7 GB/s。真快啊。发布的这款设备的规格稍高一些(约500K IOPS和2 Gb/s)，但出于我们的目的，我们认为这是最高性能。</p><p>  For the first test, just to characterize the setup, I threw 80 or so cores at the database, and ran sysbench against it with a whole lot of threads. Like 300.</p><p>在第一个测试中，为了描述设置的特点，我在数据库中投入了大约80个内核，并使用大量线程在数据库上运行sysbench。大概300个。</p><p> I started with a smaller table size just to save a little time on the load phase.  It took a few iterations to get the test to run – adjustments to  max_connections. The smaller table size means it might fit into memory, but it’ll test our test framework quickly.  Sure enough, running our OLTP test gets us close to 100k queries per second. But, there’s no real disk activity. We need more data in order to test the underlying disks.</p><p>我从一个较小的表开始，只是为了在加载阶段节省一点时间。我花了几次迭代才让测试运行-调整到max_Connections。较小的表大小意味着它可能可以装入内存，但它将快速测试我们的测试框架。果然，运行我们的OLTP测试将使我们接近每秒10万次查询。但是，没有真正的磁盘活动。我们需要更多数据来测试底层磁盘。</p><p> I cranked up the table size to 20,000,000 rows per table, tuned Mayastor to use three of the cores on each box, and started tuning the test to get max queries per second out of it. Three tables seem to be enough to overflow the 8G of RAM we have allocated to the container. Now when I check the disk stats on the node, there’s plenty of storage traffic. Still less than a gigabyte per second though. The system settles down into a comfortably speedy 30kqps or thereabouts, with disk throughput right around 700MB/s and a latency right around 50ms per query. Curiously the database is using about 8 cores. Clearly we don’t need to allocate all 80.</p><p>我将表的大小提高到每个表20,000,000行，调优Mayastor以在每个表上使用三个内核，并开始调优测试以获得每秒的最大查询数。三个表似乎足以溢出我们分配给容器的8G内存。现在，当我检查节点上的磁盘统计数据时，会发现有大量的存储流量。但仍然不到每秒一千兆字节。该系统的速度稳定在30kqps左右，磁盘吞吐量约为700MB/s，每次查询的延迟约为50ms。奇怪的是，该数据库使用了大约8个内核。显然，我们不需要分配全部80个。</p><p> We’ve seen more than 700MB/s out of the storage already from our synthetic tests. That’s pretty far off of the peak measured perf of 1.7GB/s.</p><p>在我们的合成测试中，我们已经看到超过700MB/s的存储速度。这与1.7 Gb/s的峰值测试性能相差甚远。</p><p>  Sure enough, this system is fast enough to host two high performance relational database instances on the same nvme drive, with cpu to spare.  If only I had another one of those NVMe drives in this box….</p><p>果然，这个系统足够快，可以在同一个NVMe驱动器上托管两个高性能的关系数据库实例，并且有备用的cpu。如果我在这个盒子…中有另一个NVMe驱动器就好了。。</p><p>  That’s about 1.1GB/s, with 52k IOPs. Not bad. We might even be able to fit a third in if we’re willing to sacrifice a little bit of speed across all the instances.</p><p>这大约是1.1 GB/秒，52K IOPS。还不错。如果我们愿意在所有情况下牺牲一点速度，我们甚至可以容纳三分之一的人。</p><p> There’s more work to be done to characterize database workloads like this one. There’s also an opportunity to investigate why the database scales up to 20-30k IOPs but leaves some storage and system resources available.</p><p>要描述这样的数据库工作负载，还有更多的工作要做。还有机会调查为什么数据库可扩展到20-30K IOPS，但仍有一些存储和系统资源可用。</p><p> Perhaps most importantly – Maystor provides a complete abstraction for kubernetes volumes, and allows for replicating to multiple nodes, snapshotting volumes, encrypting traffic, and generally everything you’ve come to expect from enterprise storage.  Mayastor is showing the promise here of LocalPV like performance – at least maxing out the capabilities of our DB as configured – while also providing the ease of use and ability to add resilience.</p><p>也许最重要的是-Maystor为Kubernetes卷提供了一个完整的抽象，并允许复制到多个节点、为卷拍摄快照、加密流量，以及您通常希望从企业存储中获得的一切。Maystor在这里展示了LocalPV类性能的前景-至少使我们的数据库的功能达到了最大配置-同时还提供了易用性和增加弹性的能力。</p><p> Lastly, if you are interested in Percona and OpenEBS, there are a lot of blogs from the OpenEBS community and a recent one by the CTO of Percona on the use of OpenEBS LocalPV as their preferred LocalPV solution here:   https://www.percona.com/blog/2020/10/01/deploying-percona-kubernetes-operators-with-openebs-local-storage/</p><p>最后，如果你对Percona和OpenEBS感兴趣，这里有很多OpenEBS社区的博客，还有Percona的首席技术官最近写的一篇关于使用OpenEBS LocalPV作为他们首选的LocalPV解决方案的博客：https://www.percona.com/blog/2020/10/01/deploying-percona-kubernetes-operators-with-openebs-local-storage/。</p><p> The  Percona Community Forum,  OpenEBS, and  Data on Kubernetes  communities are increasingly overlapping and I hope and expect this write up will result in yet more collaboration. Come check out Check out  Mayastor on your own and let us know how Mayastor works for your use case in the comments below!</p><p>Percona社区论坛、OpenEBS和Kubernetes社区的数据越来越重叠，我希望并期待这篇文章能带来更多的合作。快来看看，自己来看看Mayastor，在下面的评论中让我们知道Mayastor是如何为您的用例工作的！</p><p> Brian Matheson has spent twenty years doing things like supporting developers, tuning networks, and writing tools. A serial entrepreneur with an intense customer focus, Brian has helped a number of startups in a technical capacity. You can read more of Brian’s blog posts at  https://blog.mayadata.io/author/brian-matheson.</p><p>布莱恩·马西森花了二十年的时间做一些事情，比如支持开发人员、调优网络和编写工具。作为一名专注于客户的连续创业者，布莱恩曾在技术方面帮助过多家初创企业。你可以在https://blog.mayadata.io/author/brian-matheson.上阅读更多布莱恩的博客文章</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.percona.com/community-blog/2020/10/23/mayastor-lightning-fast-storage-for-kubernetes/">https://www.percona.com/community-blog/2020/10/23/mayastor-lightning-fast-storage-for-kubernetes/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/库伯/">#库伯</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lightning/">#lightning</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据库/">#数据库</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>