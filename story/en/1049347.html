<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>实施“延期” Implementing "defer"</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Implementing "defer"<br/>实施“延期” </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-25 19:41:37</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/0ea0cf1e436ebbe178eac8ed6b6e16bf.png"><img src="http://img2.diglog.com/img/2021/2/0ea0cf1e436ebbe178eac8ed6b6e16bf.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The  defer statement is going mainstream. Go has it&#39;s own special defer which only fires on function end, otherwise  defer has consistent &#34;execute at scope end&#34; semantics. Swift,  Zig, Jai,  Nim and  Odin all use defer in this manner.  The problems with implementing  defer is similar to implementing destructors for stack allocated objects in C++, although the presence of virtual functions complicates things.  I couldn&#39;t find anyone describing how  defer is done in other compilers so when working on a version of it for  C2 I had to make it up as I went along.  For posterity&#39;s sake I thought it might be interesting to do a writeup on how defer was implemented.     First up there are lots of different possible rules to adapt defer to. The original draft of this article would handle  goto  across defers. C2 retains  goto, and for a long time, so did  C3 – so this was important to make the article complete. However  goto adds much complexity to defer which made the article both much longer and harder to follow.  For that reason we&#39;ll limit ourselves to  return,  continue,  break plus labelled versions of the latter. If there is interest I can go into details on how to add defer for  goto in another article.     The first issue in  defer is the early exit:     Every  return needs to inline the defer at the end, so this is lowered to:      For  break and  continue this is handled similar to  return but only part of the defers may be inlined at the point of the  break:   void  test () {  defer  printf ( &#34;A&#34; );  while  ( true )  {  defer  printf ( &#34;B&#34; );  {  defer  printf ( &#34;C&#34; );  if  ( rand ()  %  2  ==  0 )  break ;  }  } }</p><p>延迟声明已成为主流。 Go有它自己的特殊延迟，该延迟仅在功能端触发，否则延迟在范围端执行一致。语义。 Swift，Zig，Jai，Nim和Odin都以这种方式使用defer。尽管虚拟函数的存在使事情变得复杂，但实现延迟的问题类似于在C ++中为堆栈分配的对象实现析构函数。我找不到任何人描述延迟在其他编译器中是如何完成的，因此在为C2开发它的一个版本时，我必须随身携带它。出于后人的缘故，我认为撰写延迟的实现方式可能很有趣。首先，有许多不同的可能规则要适应延迟。本文的原始草案将处理所有延迟的goto。 C2保留了goto，C3保留了很长时间，因此这对于使文章完整很重要。但是goto推迟了很多工作，使文章既长又难于理解。因此，我们将限制自己返回，继续，中断以及后者的标记版本。如果有兴趣，我可以在另一篇文章中详细介绍如何为goto添加defer。延期的第一个问题是提早退出：每个退货都需要在末尾内联延期，因此降低为：对于中断和继续，此处理与回程类似，但是只有部分延期会在退货点处被内联。中断：void test（）{延迟printf（＆＃34; A＆＃34;）; while（true）{延迟printf（＆＃34; B＆＃34;）; {延迟printf（＆＃34; C＆＃34;）; if（rand（）％2 == 0）中断; }}}</p><p>  And the inlined version:   void  test () {  while  ( true )  {  {  if  ( rand ()  %  2  ==  0 )  {  printf ( &#34;C&#34; );  printf ( &#34;B&#34; );  break ;  }  printf ( &#34;C&#34; );  }  printf ( &#34;B&#34; );  }  printf ( &#34;A&#34; ); }</p><p>  以及内联版本：void test（）{while（true）{{if（rand（）％2 == 0）{printf（＆＃34; C＆＃34;）; printf（＆＃34; B＆＃34;）;休息 ; } printf（＆＃34; C＆＃34;）; } printf（＆＃34; B＆＃34;）; } printf（＆＃34; A＆＃34;）; }</p><p>  We also have the labelled version of  break. (I&#39;ll stick to the java-style labelled break syntax here, even though C3 has a different variant)   void  test () {  defer  printf ( &#34;A&#34; );  FOO :  while  ( true )  {  defer  printf ( &#34;B&#34; );  while  ( true )  {  defer  printf ( &#34;C&#34; );  if  ( rand ()  %  2  ==  0 )  break  FOO ;  }  } }</p><p>  我们也有标记的break版本。 （即使C3具有不同的变体，我也会在这里坚持使用Java样式标记的break语法）void test（）{defer printf（＆＃34; A＆＃34;）; FOO：while（true）{延迟printf（＆＃34; B＆＃34;）; while（true）{延迟printf（＆＃34; C＆＃34;）; if（rand（）％2 == 0）打破FOO; }}}</p><p>  This is again lowered to:   void  test () {  FOO :  while  ( true )  {  while  ( true )  {  if  ( rand ()  %  2  ==  0 )  {  printf ( &#34;C&#34; );  printf ( &#34;B&#34; );  break  FOO ;  }  printf ( &#34;C&#34; );  }  printf ( &#34;B&#34; );  }  printf ( &#34;A&#34; ); }</p><p>  再次降低为：void test（）{FOO：while（true）{while（true）{if（rand（）％2 == 0）{printf（＆＃34; C＆＃34;）; printf（＆＃34; B＆＃34;）;打破FOO; } printf（＆＃34; C＆＃34;）; } printf（＆＃34; B＆＃34;）; } printf（＆＃34; A＆＃34;）; }</p><p>  So as we see it&#39;s sufficient to keep a list of the defers and then inline the defer statements in reverse order where we encounter a  break,  continue or  return.     So now we&#39;ve listed all the things we need to solve. How do we put it together? Here&#39;s the algorithm I used:           This results in us being able to use each defer as the top of a linked list:   current_defer ↓  current_defer-&gt;prev_defer ↓  current_defer-&gt;prev_defer-&gt;prev_defer ↓  NULL  Codegen is now easy.  We introduce a helper function to inline defers:   void  codegen_defers ( Defer  * current ,  Defer  * last ) {  while  ( current_defer  !=  last )  {  codegen ( current_defer );  current_defer  =  current_defer -&gt; prev_defer ;  } }</p><p>  因此，正如我们所见，足以保留一个延迟列表，然后在遇到中断，继续或返回时以相反的顺序内嵌延迟语句。因此，现在我们列出了需要解决的所有问题。我们如何将它们放在一起？这是我使用的算法：这样，我们就可以将每个defer用作链接列表的顶部：简单。我们引入了一个辅助函数来内联延迟：void codegen_defers（Defer * current，Defer * last）{while（current_defer！= last）{codegen（current_defer）; current_defer = current_defer-＆gt; prev_defer; }}</p><p>         Ok, so now we&#39;re done? Not quite, if we want to go beyond C syntax. We can imagine something looking a bit like this:     In this case we actually have two scopes: one inner scope (between  {}) and the outer one that starts in the conditional.  The principle is the same so we can reuse the same solution as above, but it&#39;s worth taking note of this case.     We have other questions to answer as well. What does this code do:     Some people have suggested that this should be treated as:     I am strongly against that idea, as it would mean that compound statements suddenly have a different meaning than regular statements.    Another interesting thing one can do with defer is the idea that a function may contain an implicit `defer` that is added to the scope which invokes it.  Odin has that feature using &#34;deferred attributes&#34; (see further down from  this link). This is simple to tie into the defer machinery.    Handling  goto with defers is a bit more complicated as one need to conditionally invoke defers:   void  test ( int  x ) {  if  ( x  &gt;  0 )  goto  FOO ;  // When is this called?  defer  printf ( &#34;A&#34; );  FOO :  printf ( &#34;B&#34; ); }</p><p>         好吧，现在我们完成了吗？如果我们想超越C语法，则可能不完全。我们可以想象一下看起来像这样：在这种情况下，我们实际上有两个作用域：一个内部作用域（在{}之间）和一个在条件条件下开始的外部作用域。原理是相同的，因此我们可以重复使用与上述相同的解决方案，但是值得注意这种情况。我们还有其他问题要回答。该代码的作用：有人建议将其视为：我强烈反对该想法，因为这将意味着复合语句突然不同于常规语句。延迟可以做的另一件有趣的事情是，一个函数可能包含一个隐式的“延迟”，这个延迟被添加到调用它的作用域中。 Odin使用“延迟属性”具有此功能。 （请参阅此链接的进一步内容）。这很容易与延迟机械配合使用。使用延迟处理goto有点复杂，因为需要有条件地调用延迟：void test（int x）{if（x＆gt; 0）goto FOO; //什么时候调用？延迟printf（＆＃34; A＆＃34;）; FOO：printf（＆＃34; B＆＃34;）; }</p><p>  The lowered code needs to look like this:   void  test ( int  x ) {  bool  _defer_1  =  false ;  if  ( x  &gt;  0 )  goto  FOO ;  _defer_1  =  true ;  FOO :  printf ( &#34;B&#34; );  if  ( _defer_1 )  {  printf ( &#34;A&#34; );  } }</p><p>  降低的代码应如下所示：void test（int x）{bool _defer_1 = false;如果（x> 0）转到FOO; _defer_1 = true; FOO：printf（＆＃34; B＆＃34;）;如果（_defer_1）{printf（＆＃34; A＆＃34;）; }} </p><p>  Since B can jump  into scopes as well as out of scopes, this adds another dimension to the analysis. The solution is not  hard but definitely not as straightforward as the structured jumps of  break and  continue  Non-local jumps of  setjmp are not possible to handle at all.    Go has a different style of defer. Go&#39;s defers actually store the defer code like a closure that is queued and invoked  at function end rather than at scope end. This means a defer actually needs to allocate memory for itself. A loop like this:     Would queue up all the defers generated in the loop in a long list and release them at function end. If the `defer` is releasing something limited like db connections then this is a bad idea. For various &#34;gotchas&#34; in Go due to this style of defer, see  this.  While Go defers work nicely with exceptions and `goto`, it has quite a bit of quirks as well as the need to reserve memory to store the defers.    Sometimes one would prefer for defers to only occur on error:   File  * getAndCheckFile () {  File  * f  =  getFile ();  if  ( ! f )  return  NULL ;  // We want to close if we return with error.  defer  close ( f );  if  ( ! fileIsValid ( f ))  return  NuLL ;  if  ( readHeader ( f )  !=  0xdeadbeef )  return  NULL ;  // oops, we will be closing f!  return  f ; }</p><p>由于B可以跳入范围，也可以跳出范围，因此这为分析增加了另一个维度。解决方案并不困难，但绝对不能像break和continue的结构化跳转那样简单，根本无法处理setjmp的非本地跳转。 Go的延迟方式有所不同。 Go的延迟实际上将延迟代码存储为像闭包那样在函数端而不是作用域端排队和调用的闭包。这意味着延迟实际上需要为其分配内存。这样的循环：将循环中生成的所有延迟排入长列表，并在函数末尾释放它们。如果`defer`释放了一些限制，例如数据库连接，那么这是个坏主意。对于各种＆＃34; gotcha＆＃34;在Go中，由于这种延迟样式，请参见此内容。尽管Go延迟程序可以很好地与异常和`goto`配合使用，但它有很多怪癖，也需要保留内存来存储延迟程序。有时，人们宁愿延迟仅在错误时发生：File * getAndCheckFile（）{File * f = getFile（）;如果（！f）返回NULL; //如果返回错误，我们想关闭。延迟关闭（f）;如果（！fileIsValid（f））返回NuLL;如果（readHeader（f）！= 0xdeadbeef）返回NULL; //哎呀，我们将关闭f！返回f; }</p><p>  For this reason Zig introduces  errdefer, and C3 has  defer catch /  defer try statements.    As an alternative (and complement) to special forms of defer is being able to  cancel defers. So far I&#39;ve only seen this functionality on defer implemented as RAII. Theoretically it could look something like:   File  * getAndCheckFile () {  File  * f  =  getFile ();  if  ( ! f )  return  NULL ;  FOO :  defer  close ( f );  if  ( ! fileIsValid ( f ))  return  NuLL ;  if  ( readHeader ( f )  !=  0xdeadbeef )  return  NULL ;  undefer  FOO ;  return  f ; }</p><p>  因此，Zig引入了errdefer，而C3则延迟了catch / defer try语句。作为特殊形式的延期的替代（和补充），可以取消延期。到目前为止，我只看到延迟实现为RAII的此功能。从理论上讲，它可能类似于：File * getAndCheckFile（）{File * f = getFile（）;如果（！f）返回NULL; FOO：延迟关闭（f）;如果（！fileIsValid（f））返回NuLL;如果（readHeader（f）！= 0xdeadbeef）返回NULL;延期FOO;返回f; }</p><p>     Defer is useful functionality for languages that lack both  finally and RAII. With structured jumps it is straightforward to implement with zero overhead.</p><p>     对于缺少final和RAII的语言，Defer是有用的功能。通过结构化跳转，可以轻松实现零开销的实现。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://c3.handmade.network/blogs/p/7641-implementing_defer">https://c3.handmade.network/blogs/p/7641-implementing_defer</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/实施/">#实施</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/延迟/">#延迟</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>