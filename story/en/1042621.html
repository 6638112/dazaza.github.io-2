<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>超级日志 HyperLogLog</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">HyperLogLog<br/>超级日志 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-31 21:11:35</div><div class="page_narrow text-break page_content"><p>Jump to navigation  Jump to search  HyperLogLog is an algorithm for the  count-distinct problem, approximating the number of distinct elements in a  multiset.  [1] Calculating the  exact  cardinality of a multiset requires an amount of memory proportional to the cardinality, which is impractical for very large data sets. Probabilistic cardinality estimators, such as the HyperLogLog algorithm, use significantly less memory than this, at the cost of obtaining only an approximation of the cardinality. The HyperLogLog algorithm is able to estimate cardinalities of &gt; 10 9 with a typical accuracy (standard error) of 2%, using 1.5 kB of memory.  [1] HyperLogLog is an extension of the earlier LogLog algorithm,  [2] itself deriving from the 1984  Flajolet–Martin algorithm.  [3]</p><p>跳转至导航跳转至搜索HyperLogLog是一种用于计数差异问题的算法，它近似于多集合中不同元素的数量。 [1]计算多集的确切基数需要与基数成比例的内存量，这对于非常大的数据集而言是不切实际的。概率基数估计器（例如HyperLogLog算法）使用的内存明显少于此，以仅获得基数近似值为代价。 HyperLogLog算法能够估算的基数。 10 9的典型精度（标准误）为2％，使用1.5 kB内存。 [1] HyperLogLog是早期LogLog算法的扩展，[2]本身是从1984 Flajolet-Martin算法衍生而来的。 [3]</p><p>   In the original paper by Flajolet  et al.  [1] and in related literature on the  count-distinct problem, the term &#34;cardinality&#34; is used to mean the number of distinct elements in a data stream with repeated elements. However in the theory of  multisets the term refers to the sum of multiplicities of each member of a multiset. This article chooses to use Flajolet&#39;s definition for consistency with the sources.</p><p>   在Flajolet等人的原始论文中。 [1]以及在有关计数区别问题的相关文献中，术语“基数”用于表示具有重复元素的数据流中不同元素的数量。但是，在多集理论中，该术语是指多集的每个成员的重数之和。本文选择使用Flajolet的定义来与源保持一致。</p><p>   The basis of the HyperLogLog algorithm is the observation that the cardinality of a multiset of uniformly distributed random numbers can be estimated by calculating the maximum number of leading zeros in the binary representation of each number in the set. If the maximum number of leading zeros observed is  n, an estimate for the number of distinct elements in the set is 2  n.  [1]</p><p>   HyperLogLog算法的基础是观察到，可以通过计算集合中每个数字的二进制表示形式中的前导零的最大数量，来估计均匀分布的随机数的多集的基数。如果观察到的前导零的最大数量为n，则该集合中不同元素的数量估计为2 n。 [1]</p><p> In the HyperLogLog algorithm, a  hash function is applied to each element in the original multiset to obtain a multiset of uniformly distributed random numbers with the same cardinality as the original multiset. The cardinality of this randomly distributed set can then be estimated using the algorithm above.</p><p> 在HyperLogLog算法中，将哈希函数应用于原始多集中的每个元素，以获得基数与原始多集相同的均匀分布的随机数的多集。然后可以使用上面的算法来估计此随机分布集的基数。</p><p> The simple estimate of cardinality obtained using the algorithm above has the disadvantage of a large  variance. In the HyperLogLog algorithm, the variance is minimised by splitting the multiset into numerous subsets, calculating the maximum number of leading zeros in the numbers in each of these subsets, and using a  harmonic mean to combine these estimates for each subset into an estimate of the cardinality of the whole set.  [4]</p><p> 使用上述算法获得的基数的简单估计具有方差大的缺点。在HyperLogLog算法中，通过将多集分成多个子集，计算这些子集中的每个子集中的数字中的前导零的最大数量，并使用调和平均值将每个子集的这些估计合并为整个集合的基数。 [4]</p><p>  The HyperLogLog has three main operations:  add to add a new element to the set,  count to obtain the cardinality of the set and  merge to obtain the union of two sets. Some derived operations can be computed using the  Inclusion–exclusion principle like the  cardinality of the intersection or the  cardinality of the difference between two HyperLogLogs combining the merge and count operations.</p><p>  HyperLogLog具有三个主要操作：添加以向集合中添加新元素，计数以获取集合的基数，合并以获取两个集合的并集。可以使用包含-排除原理来计算某些派生运算，例如相交的基数或合并合并和计数运算的两个HyperLogLogs之间的差的基数。</p><p> The data of the HyperLogLog is stored in an array  M of counters called registers with size  m that are set to 0 in their initial state.</p><p> HyperLogLog的数据存储在一个称为计数器的计数器数组M中，该计数器的大小为m，它们在初始状态下设置为0。 </p><p>  The add operation consists of computing the hash of the input data  v with a hash function  h, getting the first  b bits (where  b is              log    2    ⁡  (  m  )    {\textstyle \log _{2}(m)}  ), and adding 1 to them to obtain the address of the register to modify. With the remaining bits compute            ρ  (  w  )    {\textstyle \rho (w)}   which returns the position of the leftmost 1. The new value of the register will be the maximum between the current value of the register and            ρ  (  w  )    {\textstyle \rho (w)}  .</p><p>加法操作包括使用哈希函数h计算输入数据v的哈希，获取前b位（其中b是log 2⁡（m）{\ textstyle \ log _ {2}（m）}），以及给它们加1，以获得要修改的寄存器的地址。用剩余的位计算ρ（w）{\ textstyle \ rho（w）}，该函数返回最左边1的位置。寄存器的新值将是寄存器的当前值和ρ（w）{之间的最大值\ textstyle \ rho（w）}。</p><p> x       :=  h  (  v  )        j       :=  1  +  ⟨    x    1      x    2    .  .  .    x    b      ⟩    2          w       :=    x    b  +  1      x    b  +  2    .  .  .        M  [  j  ]       :=  max  (  M  [  j  ]  ,  ρ  (  w  )  )        {\displaystyle {\begin{aligned}x&amp;:=h(v)\\j&amp;:=1+\langle x_{1}x_{2}...x_{b}\rangle _{2}\\w&amp;:=x_{b+1}x_{b+2}...\\M[j]&amp;:=\max(M[j],\rho (w))\\\end{aligned}}}</p><p> x：= h（v）j：= 1 + x 1 x 2。 。 。 x b 2 w：= x b + 1 x b + 2。 。 。 M [j]：= max（M [j]，ρ（w））{\ displaystyle {\ begin {aligned} x＆amp;：= h（v）\\ j＆amp;：= 1+ \ langle x_ {1} x_ {2} ... x_ {b} \ rangle _ {2} \\ w＆amp;：= x_ {b + 1} x_ {b + 2} ... \\ M [j]＆amp;：= \ max（ M [j]，\ rho（w））\\\ end {aligned}}}</p><p>  The count algorithm consists in computing the harmonic mean of the  m registers, and using a constant to derive an estimate            E    {\textstyle E}   of the count:</p><p>  计数算法包括计算m个寄存器的谐波平均值，并使用一个常数来得出计数的估计值E {\ textstyle E}：</p><p> Z  =      (      ∑    j  =  1     m        2    −  M  [  j  ]           )      −  1      {\displaystyle Z={\Bigg (}\sum _{j=1}^{m}{2^{-M[j]}}{\Bigg )}^{-1}}</p><p> Z =（∑ j = 1 m 2 − M [j]）− 1 {\ displaystyle Z = {\ Bigg（} \ sum _ {j = 1} ^ {m} {2 ^ {-M [j]}}} {\ Bigg）} ^ {-1}}</p><p> α    m    =      (    m    ∫    0     ∞        (      log    2    ⁡    (        2  +  u     1  +  u     )    )     m      d  u   )     −  1      {\displaystyle \alpha _{m}=\left(m\int _{0}^{\infty }\left(\log _{2}\left({\frac {2+u}{1+u}}\right)\right)^{m}\,du\right)^{-1}}</p><p> αm =（m∫0∞（log 2⁡（2 + u 1 + u））mdu）− 1 {\ displaystyle \ alpha _ {m} = \ left（m \ int _ {0} ^ {\ infty} \ left（\ log _ {2} \ left（{\ frac {2 + u} {1 + u}} \ right）\ right）^ {m} \，du \ right）^ {-1}}</p><p>  The intuition is that  n being the unknown cardinality of  M, each subset              M    j      {\textstyle M_{j}}   will have            n    /   m    {\textstyle n/m}   elements. Then              max    x  ∈    M    j      ρ  (  x  )    {\textstyle \max _{x\in M_{j}}\rho (x)}   should be close to              log    2    ⁡  (  n    /   m  )    {\textstyle \log _{2}(n/m)}  . The harmonic mean of 2 to these quantities is            m  Z    {\textstyle mZ}   which should be near            n    /   m    {\textstyle n/m}  . Thus,              m    2    Z    {\textstyle m^{2}Z}   should be  n approximately.</p><p>  直觉是n是M的未知基数，每个子集M j {\ textstyle M_ {j}}将具有n / m {\ textstyle n / m}个元素。那么max x∈M jρ（x）{\ textstyle \ max _ {x \ in M_ {j}} \ rho（x）}应该接近log 2⁡（n / m）{\ textstyle \ log _ { 2}（n / m）}。这些数量的2的谐波均值是m Z {\ textstyle mZ}，应该接近n / m {\ textstyle n / m}。因此，m 2 Z {\ textstyle m ^ {2} Z}应该近似为n。</p><p> Finally, the constant              α    m      {\textstyle \alpha _{m}}   is introduced to correct a systematic multiplicative bias present in              m    2    Z    {\textstyle m^{2}Z}   due to hash collisions.</p><p> 最后，引入常数αm {\ textstyle \ alpha _ {m}}来纠正由于哈希冲突而在m 2 Z {\ textstyle m ^ {2} Z}中存在的系统性乘法偏差。 </p><p>  The constant              α    m      {\textstyle \alpha _{m}}   is not simple to calculate, and can be approximated with the formula  [1]</p><p>常数αm {\ textstyle \ alpha _ {m}}不容易计算，可以用公式[1]近似。</p><p> α    m    ≈      {        m  =  16     0.673        m  =  32     0.697        m  =  64     0.709        m  ≥  128         0.7213    1  +      1.079  m                {\displaystyle \alpha _{m}\approx {\begin{cases}m=16&amp;0.673\\m=32&amp;0.697\\m=64&amp;0.709\\m\geq 128&amp;{\frac {0.7213}{1+{\frac {1.079}{m}}}}\end{cases}}}</p><p> αm≈{m = 16 0.673 m = 32 0.697 m = 64 0.709 m≥128 0.7213 1 + 1.079 m {\ displaystyle \ alpha _ {m} \ approx {\ begin {cases} m = 16＆amp; 0.673 \\ m = 32＆amp; 0.697 \\ m = 64＆amp; 0.709 \\ m \ geq 128＆amp; {\ frac {0.7213} {1 + {\ frac {1.079} {m}}}} \ end {cases}}}</p><p> The HyperLogLog technique, though, is biased for small cardinalities below a threshold of                5  2    m    {\textstyle {\frac {5}{2}}m}  . The original paper proposes using a different algorithm for small cardinalities known as Linear Counting.  [5] In the case where the estimate provided above is less than the threshold            E  &lt;      5  2    m    {\textstyle E&lt;{\frac {5}{2}}m}  , the alternative calculation can be used:</p><p> 不过，HyperLogLog技术偏向于阈值低于5 2 m {\ textstyle {\ frac {5} {2}} m}的小基数。原始论文提出对小基数使用另一种算法，即线性计数。 [5]在以上提供的估计小于阈值E ＜的情况下。 5 2 m {\ textstyle E＆lt; {\ frac {5} {2}} m}，可以使用替代计算：</p><p> If            V  =  0    {\textstyle V=0}  , use the standard HyperLogLog estimator            E    {\textstyle E}   above.</p><p> 如果V = 0 {\ textstyle V = 0}，请使用上面的标准HyperLogLog估计器E {\ textstyle E}。</p><p> Otherwise, use Linear Counting:              E    ⋆    =  m  log  ⁡    (      m  V    )     {\textstyle E^{\star }=m\log \left({\frac {m}{V}}\right)}</p><p> 否则，请使用线性计数：E⋆= m log⁡（m V）{\ textstyle E ^ {\ star} = m \ log \ left（{\ frac {m} {V}} \ right）}</p><p> Additionally, for very large cardinalities approaching the limit of the size of the registers (           E  &gt;        2    32    30      {\textstyle E&gt;{\frac {2^{32}}{30}}}   for 32-bit registers), the cardinality can be estimated with:</p><p> 另外，对于非常大的基数接近寄存器大小的限制（对于32位寄存器，E> 2 32 30 {\ textstyle E＆{{frac {2 ^ {32}} {30}}}），基数可以通过以下方式估算：</p><p> E    ⋆    =  −    2    32    log  ⁡    (    1  −      E    2    32       )     {\displaystyle E^{\star }=-2^{32}\log \left(1-{\frac {E}{2^{32}}}\right)}</p><p> E⋆= − 2 32 log⁡（1 − E 2 32）{\ displaystyle E ^ {\ star} =-2 ^ {32} \ log \ left（1-{\ frac {E} {2 ^ {32} }}\对）} </p><p> With the above corrections for lower and upper bounds, the error can be estimated as            σ  =  1.04    /       m      {\textstyle \sigma =1.04/{\sqrt {m}}}  .</p><p>通过对上下限进行上述校正，可以将错误估计为σ= 1.04 / m {\ textstyle \ sigma = 1.04 / {\ sqrt {m}}}。</p><p>  The merge operation for two HLLs (           h  l    l    1    ,  h  l    l    2      {\textstyle hll_{1},hll_{2}}  ) consists in obtaining the maximum for each pair of registers            j  :  1..  m    {\textstyle j:1..m}</p><p>  两个HLL（hll 1，hll 2 {\ textstyle hll_ {1}，hll_ {2}}）的合并操作包括获得每对寄存器j：1.的最大值。m {\ textstyle j：1 .. m}</p><p> h  l    l    u  n  i  o  n    [  j  ]  =  max  (  h  l    l    1    [  j  ]  ,  h  l    l    2    [  j  ]  )    {\displaystyle hll_{union}[j]=\max(hll_{1}[j],hll_{2}[j])}</p><p> h l l u n i o n [j] = max（h l l 1 [j]，h l l 2 [j]）{\ displaystyle hll_ {union} [j] = \ max（hll_ {1} [j]，hll_ {2} [j]）}</p><p>  To analyze the complexity, the data streaming            (  ϵ  ,  δ  )    {\displaystyle (\epsilon ,\delta )}   model  [6] is used, which analyzes the space necessary to get a            1  ±  ϵ    {\displaystyle 1\pm \epsilon }   approximation with a fixed success probability            1  −  δ    {\displaystyle 1-\delta }  . The relative error of HLL is            1.04    /       m      {\displaystyle 1.04/{\sqrt {m}}}   and it needs            O  (    ϵ    −  2    log  ⁡  log  ⁡  n  +  log  ⁡  n  )    {\displaystyle O(\epsilon ^{-2}\log \log n+\log n)}   space, where  n is the set cardinality and  m is the number of registers (usually less than one byte size).</p><p>  为了分析复杂度，使用了数据流（ϵ，δ）{\ displaystyle（\ epsilon，\ delta）}模型[6]，该模型分析了获得1±ϵ {\ displaystyle 1 \ pm \ epsilon }具有固定成功概率1-δ的近似值{\ displaystyle 1- \ delta}。 HLL的相对误差为1.04 / m {\ displaystyle 1.04 / {\ sqrt {m}}}}，它需要O（ϵ − 2 log⁡log⁡n + log⁡n）{\ displaystyle O（\ epsilon ^ {- 2} \ log \ log n + \ log n）}空间，其中n是设置的基数，m是寄存器的数量（通常小于一个字节大小）。</p><p> The  add operation depends on the size of the output of the hash function. As this size is fixed, we can consider the running time for the add operation to be            O  (  1  )    {\displaystyle O(1)}  .</p><p> 加法操作取决于哈希函数输出的大小。由于此大小是固定的，因此我们可以考虑添加操作的运行时间为O（1）{\ displaystyle O（1）}。</p><p> The  count and  merge operations depend on the number of registers  m and have a theoretical cost of            O  (  m  )    {\displaystyle O(m)}  . In some implementations ( Redis)  [7] the number of registers is fixed and the cost is considered to be            O  (  1  )    {\displaystyle O(1)}   in the documentation.</p><p> 计数和合并操作取决于寄存器m的数量，其理论成本为O（m）{\ displaystyle O（m）}。在某些实现中（Redis）[7]，寄存器的数量是固定的，并且成本在文档中被认为是O（1）{\ displaystyle O（1）}。</p><p>  The HyperLogLog++ algorithm proposes several improvements in the HyperLogLog algorithm to reduce memory requirements and increase accuracy in some ranges of cardinalities:  [6]</p><p>  HyperLogLog ++算法对HyperLogLog算法提出了一些改进，以减少内存需求并在某些基数范围内提高准确性：[6] </p><p> 64-bit hash function is used instead of the 32 bits used in the original paper. This reduces the hash collisions for large cardinalities allowing to remove the large range correction.</p><p>使用64位哈希函数，而不是原始论文中使用的32位。这减少了大基数的哈希冲突，从而可以删除大范围校正。</p><p> Some bias is found for small cardinalities when switching from linear counting to the HLL counting. An empirical bias correction is proposed to mitigate the problem.</p><p> 从线性计数转换为HLL计数时，对于小的基数会发现一些偏差。提出了经验偏差校正以减轻该问题。</p><p> A sparse representation of the registers is proposed to reduce memory requirements for small cardinalities, which can be later transformed to a dense representation if the cardinality grows.</p><p> 提出了寄存器的稀疏表示以减少小基数的存储需求，如果基数增加，则可以稍后将其转换为密集表示。</p><p>  When the data arrives in a single stream, the Historic Inverse Probability or martingale estimator   [8]  [9]significantly improves the accuracy of the HLL sketch and uses 36% less memory to achieve a given error level. This estimator is provably optimal for any duplicate insensitive approximate distinct counting sketch on a single stream.</p><p>  当数据以单个流到达时，历史逆概率或mar估计器[8] [9]显着提高了HLL草图的准确性，并减少了36％的内存来实现给定的错误级别。对于单个流上的任何重复的不敏感的近似不同的计数草图，证明该估计器是最佳的。</p><p> The single stream scenario also leads to variants in the HLL sketch construction.HLL-TailCut+ uses 45% less memory than the original HLL sketch but at the cost of being dependent on the data insertion order and not being able to merge sketches.  [10]</p><p> 单流场景也会导致HLL草图构造的变体.HLL-TailCut +使用的内存比原始HLL草图少45％，但以依赖于数据插入顺序且无法合并草图为代价。 [10]</p><p>  ^     a     b     c     d     e   Flajolet, Philippe; Fusy, Éric; Gandouet, Olivier; Meunier, Frédéric (2007).  &#34;Hyperloglog: The analysis of a near-optimal cardinality estimation algorithm&#34;  (PDF).  Discrete Mathematics and Theoretical Computer Science Proceedings.  Nancy, France.  AH: 127–146.  CiteSeerX   10.1.1.76.4286 .</p><p>  ^ a b c d e Flajolet，菲利普；埃西里（Eric）Fusy；奥利维尔·甘杜埃（Gandouet）； Meunier，Frédéric（2007）。 ＆＃34;超日志：一种近似最佳基数估计算法的分析＆＃34; （PDF）。离散数学和理论计算机科学论文集。法国南希。 AH：127–146。 CiteSeerX 10.1.1.76.4286。</p><p> ^   Durand, M.; Flajolet, P. (2003).  &#34;LogLog counting of large cardinalities.&#34;  (PDF). In G. Di Battista and U. Zwick (ed.).  Lecture Notes in Computer Science. Annual European Symposium on Algorithms (ESA03).  2832. Springer. pp. 605–617.</p><p> ^ Durand，M .； Flajolet，P.（2003年）。 ＆＃34; Log记录大基数的日志。 （PDF）。在G. Di Battista和U. Zwick（编辑）中。计算机科学讲义。年度欧洲算法研讨会（ESA03）。 2832。施普林格。第605–617页。 </p><p> ^   Flajolet, Philippe; Martin, G. Nigel (1985).  &#34;Probabilistic counting algorithms for data base applications&#34;  (PDF).  Journal of Computer and System Sciences.  31 (2): 182–209.  doi: 10.1016/0022-0000(85)90041-8.</p><p>^ Flajolet，菲利普；马丁·G·奈杰尔（1985）。 ＆＃34;用于数据库应用程序的概率计数算法＆＃34; （PDF）。计算机与系统科学学报。 31（2）：182–209。 doi：10.1016 / 0022-0000（85）90041-8。</p><p> ^   S Heule, M Nunkesser, A Hall (2013).  &#34;HyperLogLog in Practice: Algorithmic Engineering of a State of The Art Cardinality Estimation Algorithm&#34;  (PDF). sec 4.  CS1 maint: uses authors parameter ( link)</p><p> ^ S Heule，M Nunkesser，大厅（2013）。 ＆＃34;实践中的HyperLogLog：最先进的基数估计算法的算法工程＆＃34; （PDF）。秒4. CS1维护：使用authors参数（链接）</p><p> ^   Whang, Kyu-Young; Vander-Zanden, Brad T; Taylor, Howard M (1990). &#34;A linear-time probabilistic counting algorithm for database applications&#34;.  ACM Transactions on Database Systems.  15 (2): 208–229.  doi: 10.1145/78922.78925.</p><p> ^ Whang，Kyu-Young;范德赞丹（Vander-Zanden），布拉德（Brad T）；泰勒，霍华德M（1990）。 ＆＃34;用于数据库应用程序的线性时间概率计数算法。数据库系统上的ACM事务。 15（2）：208–229。 doi：10.1145 / 78922.78925。</p><p>   ^   Cohen, E. (March 2015). &#34;All-distances sketches, revisited: HIP estimators for massive graphs analysis&#34;.  IEEE Transactions on Knowledge and Data Engineering.  27 (9): 2320–2334.  arXiv:  1306.3284.  doi: 10.1109/TKDE.2015.2411606.</p><p>   ^ Cohen，E.（2015年3月）。 ＆＃34;全程草图，再造：用于大量图形分析的HIP估计器。 IEEE知识和数据工程事务。 27（9）：2320–2334。 arXiv：1306.3284。 doi：10.1109 / TKDE.2015.2411606。</p><p> ^   Ting, D. (August 2014).  &#34;Streamed approximate counting of distinct elements: beating optimal batch methods&#34;.  Proceedings of the 20th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (KDD &#39;14): 442–451.  doi: 10.1145/2623330.2623669.  ISBN   9781450329569.</p><p> ^ Ting，D.（2014年8月）。 ＆＃34;流式处理不同元素的近似计数：击败最佳批处理方法。第20届ACM SIGKDD国际知识发现和数据挖掘会议论文集（KDD＆＃39; 14）：442–451。 doi：10.1145 / 2623330.2623669。 ISBN 9781450329569。</p><p> ^   Xiao, Q.; Zhou, Y.; Chen, S. (May 2017). &#34;Better with fewer bits: Improving the performance of cardinality estimation of large data streams&#34;.  IEEE INFOCOM 2017 - IEEE Conference on Computer Communications: 1–9.  doi: 10.1109/INFOCOM.2017.8057088.  ISBN   978-1-5090-5336-0.</p><p> ^Q。周Y； Chen，S.（2017年5月）。 ＆＃34;位数更少：提高大型数据流基数估计的性能。 IEEE INFOCOM 2017-IEEE计算机通信会议：1–9。 doi：10.1109 / INFOCOM.2017.8057088。 ISBN 978-1-5090-5336-0。</p><p> &#34;Probabilistic Data Structures for Web Analytics and Data Mining | Highly Scalable Blog&#34;. highlyscalable.wordpress.com. May 2012 .</p><p> ＆＃34;用于Web分析和数据挖掘的概率数据结构|高度可扩展的Blog＆＃34;。 highscalable.wordpress.com。 2012年5月。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://en.wikipedia.org/wiki/HyperLogLog">https://en.wikipedia.org/wiki/HyperLogLog</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/日志/">#日志</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/基数/">#基数</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>