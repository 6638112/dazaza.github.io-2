<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>解析，不进行类型检查Parse, Don’t Type-Check</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Parse, Don’t Type-Check<br/>解析，不进行类型检查</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-26 23:13:36</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/7cf484ceeae6bc7fc2161eddc603cd15.jpg"><img src="http://img2.diglog.com/img/2020/11/7cf484ceeae6bc7fc2161eddc603cd15.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>There’s a fantastic article from last year titled  Parse, don’t validate. I’d highly recommend it to any programmer (along with the more recent follow up  Names are not type safety). The basic idea is that there are two ways to check that some input to a function is valid:</p><p>去年有一篇很棒的文章，标题为Parse，请不要验证。我强烈推荐给任何程序员（以及最近的后续更新，名称不是类型安全的）。基本思想是有两种方法可以检查对函数的某些输入是否有效：</p><p> A  validator checks that the input is valid and throws an error if not. It doesn’t return anything. For example, checking that a list is not empty.</p><p> 验证器检查输入是否有效，如果无效，则引发错误。它不会返回任何东西。例如，检查列表是否为空。</p><p> A  parser does the same as a validator, but returns a more specific representation of the input that ensures that the required property is satisfied. For example, checking that a list is not empty and  returning a NonEmptyList type.</p><p> 解析器的作用与验证器相同，但是返回输入的更特定的表示形式，以确保满足所需的属性。例如，检查列表不为空，然后返回NonEmptyList类型。</p><p> The thesis of the article is that parsers are preferable to validators. If you’ve not read the original article, please do so – it’s very well written and makes the case much better than I can summarise it. The essential message is to  make illegal states unrepresentable. In the article, this is done by making use of the type system. This is a philosophy I entirely agree with, but I want to point out and expand upon one ironic aspect of the argument:</p><p> 本文的论点是解析器比验证器更可取。如果您还没有阅读原始文章，请这样做-它写得很好，并且比我可以总结的要好得多。基本信息是使非法国家无法代表。在本文中，这是通过使用类型系统来完成的。这是我完全同意的一种哲学，但我想指出并扩展论证的一个讽刺意味：</p><p>   A type checker, after all, takes as input an already parsed program representation and rejects it if it fails to type-check. It doesn’t return a more specific representation of the program. (Not to be confused with  type inference, which does return more information, but only about the types).</p><p>   毕竟，类型检查器将已经解析的程序表示形式作为输入，如果无法进行类型检查，则将其拒绝。它不会返回该程序的更具体的表示。 （不要与类型推断混淆，后者确实会返回更多信息，而只是返回有关类型的信息）。</p><p> So what would be the parser alternative to a type checker in a programming language? One approach would be to actually create a more specific grammar that eliminates illegal states. For example, if a given function requires a number that must be between one and five, then rather than having a generic syntax for function calls such as:</p><p> 那么用编程语言代替类型检查器的解析器将是什么呢？一种方法是实际上创建一种消除非法状态的更具体的语法。例如，如果给定的函数需要一个必须在1到5之间的数字，则不要对函数调用使用通用语法，例如：</p><p>   one_to_five ::= 1 | 2 | 3 | 4 | 5 fun_call ::= ‘lil_fac(‘ one_to_five ‘)’  | ... other function definitions ...</p><p>   one_to_five :: = 1 | 2 | 3 | 4 | 5 fun_call :: =‘lil_fac（‘one_to_five’）’| ...其他功能定义...</p><p> Creating such specific grammars is one approach to crafting   domain-specific languages (DSLs). And indeed, DSLs are a great way of ensuring that illegal states aren’t representable. Of course, this is not a scalable solution if you want to make a general-purpose language with user-defined functions.</p><p>创建此类特定的语法是一种制作域特定语言（DSL）的方法。确实，DSL是确保非法状态不可代表的好方法。当然，如果您想使用用户定义的函数来创建通用语言，则这不是可扩展的解决方案。</p><p> An alternative to having a very specific grammar is to instead  raise the level of abstraction, so that it is easier to avoid invalid states. For example, a common source of programming errors is out of bounds indexing into arrays. This occurs because the programming language only offers a primitive indexing operation:  a[x]. Here “x” is an integer but might be out of bounds, resulting in an exception or crash (if you’re lucky). One way we could prevent this would be to define a more specific type of “integers between zero and 12” so that the type system rejects any potentially invalid indexing operations, and then track this more precise type for each array — validation again.</p><p> 拥有非常具体的语法的另一种方法是提高抽象级别，从而更容易避免无效状态。例如，编程错误的一个常见来源是超出范围地索引到数组。发生这种情况是因为编程语言仅提供原始索引操作：a [x]。这里的“ x”是一个整数，但可能超出范围，从而导致异常或崩溃（如果幸运的话）。我们可以防止这种情况的一种方法是定义一个更具体的“ 0到12之间的整数”类型，以便类型系统拒绝任何可能无效的索引操作，然后为每个数组跟踪此更精确的类型-再次进行验证。</p><p> A different approach would be to notice that there are typically a few common ways that you want to use an array and provide specific abstractions in the language that capture those uses. For example, it’s very common to want to iterate through the array performing some kind of calculation. Rather than making everyone manually write out the for-loops for doing this — do arrays in this language start at 0 or 1? Do they stop at array.length or array.length – 1? Do array indexes have a specific type? — you could instead offer a general  fold (reduce) operation. Likewise, instead of making people write their own hashtables you could provide one built-in to the language itself. By providing better abstractions you make it less likely that programmers will hit illegal states.</p><p> 另一种方法是注意到，通常有几种常见的方法要使用数组，并以捕获这些用法的语言提供特定的抽象。例如，很常见的是要遍历数组以执行某种计算。而不是让每个人都手动为此写出for循环-这种语言的数组是从0还是1开始的？它们停在array.length还是array.length – 1？数组索引是否具有特定类型？ -您可以改为提供常规折叠（减少）操作。同样，与其让人们编写自己的哈希表，不如提供一种内置于该语言本身的表。通过提供更好的抽象，您可以减少程序员遇到非法状态的可能性。</p><p> You can then go further and  remove the more primitive operations, only allowing access to the higher level abstractions. Hopefully in 2020 most programmers would agree that removing goto statements in favour of higher level structured programming abstractions was a win, and the same can be true of other low-level constructs: nulls, raw memory pointers, etc.</p><p> 然后，您可以继续操作并删除更原始的操作，仅允许访问更高级别的抽象。希望在2020年，大多数程序员会同意，删除goto语句以支持更高层次的结构化编程抽象是一个胜利，其他低层构造（空值，原始内存指针等）也是如此。</p><p> In the world of computer security, there is a direct analogue of this discussion. The security model of most computer systems allows a separation between operations I  can (try to) perform and operations I am  allowed to perform: I can try and delete your website, but (hopefully) the request will be rejected as unauthorized. In contrast, in  object-capability systems my ability to even invoke such an operation depends upon me holding an unforgeable c apability granting me permission to perform it. It’s not possible to even attempt an operation that I am not allowed to perform. For example, in a REST API using  capability URIs, I cannot simply send a DELETE request to /users/alice, but instead need to send it to some unguessable random URI – if I don’t already have that URI then I can’t even begin to send the request. Object-capability security therefore aims to make  unauthorized states unrepresentable.</p><p> 在计算机安全领域，这种讨论是直接类似的。大多数计算机系统的安全模型都将我可以（尝试执行）的操作与我可以执行的操作分开：我可以尝试删除您的网站，但是（希望如此）该请求将被拒绝为未授权。相反，在对象能力系统中，我什至可以调用此类操作的能力取决于我是否拥有不可伪造的能力，以授予我执行该能力的权限。甚至无法尝试不允许执行的操作。例如，在使用功能URI的REST API中，我不能简单地将DELETE请求发送到/ users / alice，而是需要将其发送到一些无法猜测的随机URI –如果我还没有该URI，那么我就不能甚至开始发送请求。因此，对象能力安全性旨在使未经授权的状态无法表示。</p><p> Perhaps the most widely known embodiment of the object-capability paradigm is the  E programming language: a  dynamically-typed object-oriented programming language. Although now somewhat abandoned, it is a fascinating language with a lot of great ideas. E uses strong abstraction boundaries to ensure security. Be warned: the E website is a rabbit hole of incredible depth!</p><p> 也许对象能力范例的最广为人知的实施例是E编程语言：一种动态类型的面向对象的编程语言。尽管现在已被抛弃，但它是一种引人入胜的语言，其中包含许多很棒的想法。 E使用强大的抽象边界来确保安全性。警告：E网站是一个深度惊人的兔子洞！</p><p> In my twenties, I used to do a lot of programming in  Tcl. A language that most would agree is about as far removed from a modern statically typed programming language as you can get. (Often pointed out with something close to utter disgust). And yet the idea of making illegal states unrepresentable was entirely natural to myself and other Tcl programmers. I would frequently start a programming project by creating a  blank-slate interpreter, stripping out all the built-in language constructs ( loops, procedures, even  arithmetic), and then adding back in a carefully selected set of high-level domain-specific primitives. This DSL would then become the application’s configuration file, safe in the knowledge that illegal configurations cannot be expressed.</p><p> 在20年代，我曾经在Tcl中做过很多编程工作。大多数人都同意的一种语言与现代静态类型编程语言之间的距离要尽可能远。 （经常指出一些令人非常厌恶的东西）。然而，使非法状态无法代表的想法对我本人和其他Tcl程序员来说是完全自然的。我经常会通过创建一个空白面板的解释器，剥离所有内置的语言构造（循环，过程，甚至算术），然后重新添加经过精心选择的一组高级领域特定原语来开始一个编程项目。 。然后，该DSL将成为应用程序的配置文件，因为它知道无法表达非法配置，因此非常安全。</p><p> To summarise, my point is not that type systems are bad or that the original essay is flawed. On the contrary, I thank the flying spaghetti monster almost every day for the type system in my day job (and that is only Java’s tepid concoction), and I think the “parse, don’t validate” essay is excellent. But the last two decades have seen such advances in type systems and the adoption of typeful programming patterns that we are in danger of thinking that type systems are the only way of achieving correctness in software construction. They are a tremendously powerful tool, but more basic techniques of abstraction and information hiding can be just as powerful. The goal of making illegal states unrepresentable should be one of the defining goals of software engineering, but there are many valid ways to crack that nut.</p><p>总而言之，我的意思不是说类型系统很糟糕或者原始论文有缺陷。相反，我几乎每天都要感谢飞翔的意大利面条怪物在我的日常工作中使用类型系统（那只是Java的温和调剂），而且我认为“解析，不验证”的论文非常出色。但是在过去的二十年中，类型系统取得了如此大的进步，并且采用了有类型的编程模式，我们冒着以为类型系统是实现软件构造正确性的唯一途径的危险。它们是一种非常强大的工具，但是抽象和信息隐藏的更多基本技术也同样强大。使非法状态无法代表的目标应该是软件工程的定义目标之一，但是有很多有效的方法可以解决这个问题。</p><p> Shameless plug: I discuss capability URIs in depth in chapter 9 of  my book on API security, just published by Manning. I also discuss using types to enforce security properties in chapter 6.</p><p> 无耻的插件：我刚刚在Manning出版的关于API安全的书的第9章中深入讨论了功能URI。我还将在第6章中讨论使用类型强制实施安全性属性。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://neilmadden.blog/2020/11/25/parse-dont-type-check/">https://neilmadden.blog/2020/11/25/parse-dont-type-check/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/don/">#don</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>