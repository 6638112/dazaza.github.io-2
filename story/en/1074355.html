<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何优化Docker图像的安全性、大小和构建速度How to optimize the security, size and build speed of Docker images</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How to optimize the security, size and build speed of Docker images<br/>如何优化Docker图像的安全性、大小和构建速度</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-21 03:09:19</div><div class="page_narrow text-break page_content"><p>This article introduces 12 tips to optimize your Docker image security. For each tip, it explains the underlying attack vector, and one or more mitigation approaches. Tips include avoiding leaking of build secrets, running as non-root user, or how to make sure to use the most recent dependencies and updates.</p><p>本文介绍了12个优化Docker图像安全性的技巧。对于每个技巧，它解释了底层的攻击向量，以及一个或多个缓解方法。提示包括避免泄露构建机密、以非root用户身份运行，或者如何确保使用最新的依赖项和更新。</p><p>    This article is part of a multi-part series on working with Docker in an optimized way:</p><p>本文是关于以优化方式使用Docker的多部分系列文章的一部分：</p><p>  When you are new to Docker, you will most likely create  insecure Docker images that make it easy for attackers to take over the container, or possibly even the entire host, which then allows the attacker to infiltrate other infrastructure of your company.</p><p>当您刚接触Docker时，很可能会创建不安全的Docker映像，使攻击者很容易接管容器，甚至整个主机，从而允许攻击者渗透到公司的其他基础设施。</p><p> There are many different attack vectors that can be abused to take over your system, such as:</p><p>有许多不同的攻击载体可以被滥用来接管您的系统，例如：</p><p> The started application (specified in the  ENTRYPOINT of your  Dockerfile) runs as  root user. Consequently, once an attacker has exploited a vulnerability and gains shell access, they can take over the  host on which the Docker daemon is running.</p><p>已启动的应用程序（在Dockerfile的入口点中指定）以root用户身份运行。因此，一旦攻击者利用漏洞并获得shell访问权限，他们就可以接管运行Docker守护程序的主机。</p><p> Your image is based on an outdated and/or insecure  base image, which contains security exploits which are (now) well-known.</p><p>您的图像基于过时和/或不安全的基础图像，其中包含（现在）众所周知的安全漏洞。</p><p> Your image contains tools (such as  curl,  apt, etc.) that allow an attacker to load further malware into the container, once they have gained some kind of access.</p><p>您的图像中包含一些工具（如curl、apt等），一旦攻击者获得某种访问权限，攻击者就可以将更多恶意软件加载到容器中。</p><p> The following sections explain different approaches to optimize your image security. They are sorted by importance/impact, such that the more important ones are listed first.</p><p>以下各节介绍了优化图像安全性的不同方法。它们按重要性/影响进行排序，以便首先列出更重要的。</p><p>  Build secrets are credentials that are only needed while  building your Docker image (not at run-time). For instance, you might want to include a compiled version of some application into your image whose source code is closed-source, and its Git repo is access-protected. While building the image, you need to clone the Git repo (which requires the build secrets, e.g. SSH access keys to that repo), build the application from source, and then delete the sources (and secrets) again.</p><p>构建机密是仅在构建Docker映像时（而不是在运行时）才需要的凭据。例如，您可能希望在映像中包含某个应用程序的编译版本，该应用程序的源代码是封闭源代码，其Git repo受访问保护。在构建映像时，需要克隆Git repo（这需要构建机密，例如该repo的SSH访问密钥），从源代码构建应用程序，然后再次删除源代码（和机密）。</p><p> “Leaking” a build secret means that you accidentally baked such secrets into one of the layers of your image. This is bad, because  anyone who pulls your image can retrieve the credentials. The problem originates from the fact that Docker images are built layer by layer, in a purely  additive way.  Files you delete in a layer are only  marked as deleted, but can still be accessed by everyone pulling your image, using advanced tooling.</p><p>“泄露”构建秘密意味着你不小心将这些秘密烘焙到了图像的某个层中。这很糟糕，因为任何拉取您的图像的人都可以检索凭据。这个问题源于这样一个事实：Docker图像是以一种纯粹的加法方式逐层构建的。你在图层中删除的文件只会被标记为已删除，但通过使用高级工具，每个人都可以访问你的图像。</p><p>   Docker Multi-stage builds ( official docs) have many different use cases, e.g.  speeding up your image build, or  reducing the image size. Other articles of this series go into details regarding these other use cases. Anyways,  you can also multi-stage builds to avoid leaking build secrets, as follows:</p><p>Docker多阶段构建（官方文档）有许多不同的用例，例如加快图像构建或减小图像大小。本系列的其他文章详细介绍了这些其他用例。无论如何，您也可以通过多阶段构建来避免泄露构建机密，如下所示：</p><p> Create a stage #A into which you  COPY the credentials and use them to retrieve other artifacts (e.g. the Git repo of the above example),  and perform further steps with them (e.g. compiling an application).  The stage #A build  does contain the build secrets!</p><p>创建一个stage#a，将凭证复制到其中，并使用它们检索其他工件（例如上面示例中的Git repo），然后使用它们执行进一步的步骤（例如编译应用程序）。舞台#一个构建确实包含构建秘密！</p><p> Create a stage #B into which you copy only non-secret artefacts from stage #A, such as a compiled application.</p><p>创建一个stage#B，在其中只复制stage#a中的非机密人工制品，例如编译后的应用程序。</p><p>  If you use  docker build for building, there are multiple  backends that actually perform the build. The newer and faster backend is BuildKit, which you need to be explicitly enable on  Linux by setting the environment variable  DOCKER_BUILDKIT=1. Note that BuildKit is enabled by default on Docker for Desktop on Windows/macOS.</p><p>如果使用docker build进行构建，那么实际上会有多个后端执行构建。更新更快的后端是BuildKit，需要在Linux上通过设置环境变量DOCKER_BuildKit=1显式启用它。请注意，默认情况下，Windows/macOS上的Docker for Desktop会启用BuildKit。</p><p> As explained in the  docs here (read them for more details), the BuildKit build engine supports additional syntax in the  Dockerfile.  To use a build secret, put something like this in your  Dockerfile:</p><p>正如这里的文档中所解释的（阅读它们以了解更多细节），BuildKit构建引擎支持Dockerfile中的其他语法。要使用构建机密，请在Dockerfile中输入以下内容：</p><p>  This makes secrets available to the build container while that  RUN statement is executed, but does  not put the secret itself (here: the  /foobar folder)  into the built image.  You need to specify the path to the secret’s  source file/folder (located on the host) when running the  docker build command, e.g.   docker build  --secret id=mysecret,src=mysecret.txt -t sometag .</p><p>这使得在执行RUN语句时生成容器可以使用机密，但不会将机密本身（此处为/foobar文件夹）放入生成的映像中。运行docker build命令时，需要指定机密文件/文件夹（位于主机上）的路径，例如docker build--secret id=mysecret，src=mysecret。txt-t sometag。</p><p> There is one caveat, however:  you cannot build images that require secrets via  docker-compose up --build, because Docker-compose does not support the  --secret argument for building yet, see  GitHub issue. If you rely on docker-compose builds to work, use approach 1 (Multi-stage builds) instead.</p><p>但是，有一个警告：您不能通过docker compose up--build构建需要机密的图像，因为docker compose还不支持构建的--secret参数，请参阅GitHub问题。如果您依赖docker compose构建来工作，请使用方法1（多阶段构建）。</p><p> You should always build and push images in a  clean environment, e.g. a CI/CD pipeline, where the build agent clones your repository into a  new directory.</p><p>您应该始终在干净的环境中生成和推送映像，例如CI/CD管道，在该管道中，生成代理会将您的存储库克隆到一个新目录中。</p><p> The problem with using your  local development machine for building is that your local “working tree” of the Git repository might be  dirty. For instance, it might contain files with secrets that you need during development, e.g. access keys to staging or even production servers. If these files are not excluded via  .dockerignore, a statement such as “ COPY . .” in your  Dockerfile could accidentally lead to leaking these secrets into the final image.</p><p>使用本地开发机器进行构建的问题是，Git存储库的本地“工作树”可能是脏的。例如，它可能包含开发过程中需要的机密文件，例如登台服务器甚至生产服务器的访问密钥。如果这些文件未通过排除。dockerignore，一种声明，如“复制…”在Dockerfile中，可能会意外地导致这些秘密泄漏到最终图像中。</p><p>  By default, when someones runs your image via “ docker run &lt;more arguments&gt; yourImage:yourTag“, the container (and the programs you have in your  ENTRYPOINT /  CMD) runs as  root user (in the container and on the host). This gives an attacker, who gained shell access in your running container using some exploit, the following powers:</p><p>默认情况下，当有人通过“docker run&lt；more arguments&gt；yourImage:yourTag”运行映像时，容器（以及您在ENTRYPOINT/CMD中的程序）将以root用户身份运行（在容器中和主机上）。这为攻击者提供了以下能力，攻击者通过某种攻击获得了对正在运行的容器的shell访问权限：</p><p> Unrestricted write-access (due to being  root) to all those directories on the host that are explicitly mounted into the container.</p><p>对主机上显式装入容器的所有目录的无限制写访问（由于是根目录）。</p><p> Ability to do everything in the container that a Linux root user can do. For instance, an attacker could install additional tools they need to load even more malware, e.g. via  apt-get install (a non-root user could not do this).</p><p>能够在容器中完成Linux root用户可以完成的所有操作。例如，攻击者可以安装加载更多恶意软件所需的其他工具，例如通过apt get install（非root用户不能这样做）。</p><p> If the container of your image was started with  docker run  --privileged, the attacker can even take over the entire  host.</p><p>如果图像的容器是以docker run--privileged启动的，攻击者甚至可以接管整个主机。</p><p> To avoid this,  you should run your application as non-root user, that is, some user that you created during the  docker build process.  Place the following statements in your  Dockerfile somewhere (usually towards the end):</p><p>为了避免这种情况，您应该以非root用户的身份运行应用程序，即在docker构建过程中创建的某个用户。将以下语句放在Dockerfile中的某个位置（通常放在末尾）：</p><p> # Create a new user (including a home-directory, which is optional) RUN  useradd --create-home appuser # Switch to this user USER appuser</p><p>#创建新用户（包括主目录，这是可选的）运行useradd--Create home appuser#切换到此用户appuser</p><p> All commands in the  Dockerfile that come  after the    USER appuser  statement (e.g.  RUN,  CMD, or  ENTRYPOINT)  will be run with this user. There are a few caveats to be aware of:</p><p>Dockerfile中在用户appuser语句之后的所有命令（例如RUN、CMD或ENTRYPOINT）都将与此用户一起运行。有几点需要注意：</p><p> Files you copied into your image via  COPY (or files created by some  RUN commands)   before switching to the non-root user are owned by  root, and are consequently not  writable by your application running as non-root. To fix this problem, move the code that creates and switches to the non-root user closer to the beginning of the  Dockerfile.</p><p>在切换到非root用户之前，通过COPY（或某些运行命令创建的文件）复制到映像中的文件归root所有，因此无法由以非root用户身份运行的应用程序写入。要解决此问题，请将创建并切换到非root用户的代码移到Dockerfile开头附近。</p><p> Files that your program expects to be somewhere in the user’s  home directory (e.g.  ~/.cache) might now suddenly be missing from your app’s perspective, if these files were created at the beginning of the  Dockerfile, as  root user (being stored below  /root/ and not below  /home/appuser/).</p><p>如果这些文件是在Dockerfile的开头以root user（存储在/root/下面，而不是/home/appuser/下面）的身份创建的，那么从应用程序的角度来看，程序希望位于用户主目录（例如~/.cache）某处的文件现在可能突然丢失。</p><p> If your application listens to a TCP/UDP port, your app must use ports &gt; 1024. Ports &lt;= 1024 can only be used either as  root user, or with high Linux capabilities, which you should not give to your container just for that purpose.</p><p>如果应用程序侦听TCP/UDP端口，则应用程序必须使用端口&gt；1024.端口&lt；=1024只能作为根用户使用，或者具有较高的Linux功能，您不应该为了这个目的而将这些功能提供给容器。</p><p>  If you are using a base image that contains the entire toolset of a real Linux distribution (such as Debian, Ubuntu or alpine images),  including a  package manager, it is recommended to use that package manager to install all available package updates.</p><p>如果您使用的基本映像包含真实Linux发行版（如Debian、Ubuntu或alpine映像）的整个工具集，包括软件包管理器，建议使用该软件包管理器安装所有可用的软件包更新。</p><p> Base images are maintained by someone who configured scheduled CI/CD pipelines that build the base image and push it to Docker Hub in regular intervals. You have no control over this interval, and it often happens that security patches are available in the Linux distro’s  package registry (e.g. via  apt)  before that pipeline pushes an updated Docker image to Docker Hub. For instance, even if a base image is pushed once per  week, it could still happen that security updates are available a few  hours or days after the most recent image was published.</p><p>基本映像由配置计划CI/CD管道的人员维护，这些管道构建基本映像并定期将其推送到Docker Hub。您无法控制这个时间间隔，而且通常情况下，Linux发行版的软件包注册表（例如，通过apt）中有安全补丁，然后管道将更新的Docker映像推送到Docker Hub。例如，即使每周推送一次基本映像，也可能在最近的映像发布几小时或几天后才提供安全更新。</p><p> Therefore, it’s a good idea to always run package manager commands that update the local package database and install updates, in  unattended mode, which does not require user confirmation.  The command differs for each Linux distribution.</p><p>因此，最好总是在无人值守模式下运行包管理器命令，更新本地包数据库并安装更新，而无需用户确认。每个Linux发行版的命令都不同。</p><p> For instance,  for Ubuntu, Debian, or derivative distros, use   RUN apt-get update &amp;&amp; apt-get -y upgrade</p><p>例如，对于Ubuntu、Debian或衍生发行版，使用RUN-apt-get-update&amp&amp；apt-get-y升级</p><p> Another important detail is that you need to tell Docker (or whatever image build tool you use)  to refresh the base image. Otherwise,  if you reference a base image such as  python:3 (and Docker already has such a image in its  local image cache), Docker won’t even check whether a newer version of  python:3 exists on Docker Hub. To get rid of this behavior, you should use this command:</p><p>另一个重要的细节是，您需要告诉Docker（或您使用的任何图像构建工具）刷新基础图像。否则，如果引用python:3之类的基本映像（Docker在其本地映像缓存中已经有这样的映像），Docker甚至不会检查Docker Hub上是否存在python:3的更新版本。要消除此行为，应使用以下命令：</p><p>  This makes sure that Docker will pull updates of the image(s) mentioned in the  FROM statement(s) of your  Dockerfile, prior to building your image.</p><p>这可以确保Docker在构建您的映像之前，会从Dockerfile的FROM语句中获取映像的更新。</p><p> You should also be aware of Docker’s  layer caching mechanism, which causes your image to become stale, because the layer for the  RUN &lt;install apt/etc. updates&gt; command is cached, until the base image maintainer releases a new version of the base image. If you find out that the release frequency of base image is rather low (e.g. less often than a week),  it is a good idea to regularly (e.g. once per week)  rebuild your image with disabled layer caching. You can do so by running the following command:</p><p>您还应该了解Docker的层缓存机制，它会导致图像过时，因为运行的层&lt；安装apt/etc更新&gt；命令被缓存，直到基本映像维护程序发布新版本的基本映像。如果发现基本映像的发布频率很低（例如，不到一周），最好定期（例如，每周一次）使用禁用的层缓存重建映像。可以通过运行以下命令来执行此操作：</p><p>   The  software you write is based on  third party dependencies, meaning software made by other people. This includes:</p><p>您编写的软件基于第三方依赖关系，即由其他人制作的软件。这包括：</p><p> Third party software components you use as part of your application, e.g. installed via  pip/npm/gradle/apt/…</p><p>作为应用程序一部分使用的第三方软件组件，例如通过pip/npm/gradle/apt/安装的…</p><p> Once these dependencies become outdated in your image, this increases the attack surface again, because outdated dependencies often have exploitable security vulnerabilities.</p><p>一旦这些依赖项在图像中过时，就会再次增加攻击面，因为过时的依赖项通常具有可利用的安全漏洞。</p><p> You solve this problem by regularly using SCA tools (Software Composition Analysis), such as  Renovate Bot. These tools (semi-) automatically update your declared third party dependencies to their most recent version, e.g. in your  Dockerfile, Python’s  requirements.txt, NPM’s  packages.json, etc. You need to design your CI pipelines such that the change made by the SCA tool automatically triggers a re-build of your image.</p><p>您可以通过定期使用SCA工具（软件组合分析）来解决这个问题，例如RefresentBot。这些工具（半）自动将您声明的第三方依赖项更新为其最新版本，例如在Dockerfile中，Python的需求。txt，NPM的软件包。json等。您需要设计CI管道，以便SCA工具所做的更改自动触发映像的重新构建。</p><p> Such automatically-triggered image rebuilds are particularly useful for projects which are in maintenance-only mode, but where the code shall still be used in production by customers (who expect it to be secure). During the maintenance period, you are no longer developing new features, and no new images would be built, because there are no new commits (made by you) triggering new builds. However, the commits made by the SCA tool do trigger the image builds again.</p><p>这种自动触发的图像重建对于仅处于维护模式的项目尤其有用，但这些项目中的代码仍应由客户（他们希望代码是安全的）在生产中使用。在维护期间，您不再开发新功能，也不会生成新映像，因为没有新提交（由您进行）触发新生成。但是，SCA工具所做的提交确实会再次触发映像构建。</p><p>   Even if you implemented the above advice, such that your images always use the  latest third party dependencies, it can still be  insecure (e.g. if a dependency has become abandoned). In this context, “insecure” means that one (or more) of the dependencies have  known security vulnerabilities (registered in some CVE database).</p><p>即使您实现了上述建议，使您的图像始终使用最新的第三方依赖项，它仍然可能是不安全的（例如，如果依赖项已被放弃）。在这种情况下，“不安全”意味着一个（或多个）依赖项具有已知的安全漏洞（在某些CVE数据库中注册）。</p><p> For this reason,  there are various tools that you provide your Docker image, and they scan through all contained files to find such vulnerabilities. These tools come in two forms:</p><p>出于这个原因，您可以使用各种工具提供Docker映像，它们会扫描所有包含的文件以查找此类漏洞。这些工具有两种形式：</p><p> CLI tools that you explicitly invoke, e.g. in a CI pipeline, e.g.  Trivy (OSS which is very easy to use in a CI pipeline, see Trivy  docs),  Clair (OSS, but more complex to set up and use than Trivy), or  Snyk (integrated into the Docker CLI via “ docker scan“, see  cheat sheet, but there is only a  limited free plan!)</p><p>您明确调用的CLI工具，例如在CI管道中，例如Trivy（在CI管道中非常容易使用的OSS，请参阅Trivy docs）、Clair（OSS，但设置和使用起来比Trivy更复杂）或Snyk（通过“Docker scan”集成到Docker CLI中，请参阅备忘单，但只有有限的免费计划！）</p><p> Scanners integrated into the image registry that you push your image into, e.g. Harbor (which uses Clair or Trivy internally). There are also commercial offerings such as  Anchore.</p><p>扫描仪集成在图像注册表中，您可以将图像推入其中，例如Harbor（内部使用Clair或Trivy）。还有一些商业产品，如Anchore。</p><p> Because these scanners are generic and try to cover a broad range of package registries, they might not be particularly specialized for the programming language or package registries you use in your project. It can sometimes make sense to investigate which tools your programming language ecosystem offers. For instance, for Python there is the  safety tool which is specialized on Python packages.</p><p>因为这些扫描器是通用的，并且试图覆盖范围广泛的包注册中心，所以它们可能不会专门用于您在项目中使用的编程语言或包注册中心。有时，调查您的编程语言生态系统提供了哪些工具是有意义的。例如，对于Python，有一个专门针对Python包的安全工具。</p><p>  Sometimes problems arise from statements you place in your  Dockerfile, which are bad practice (without you realizing it). Use tools such as  checkov,  Conftest,  trivy, or  hadolint, which are linters for  Dockerfiles. To make the right choice for the tool,  review which  default rules/policies are shipped with it.  For instance,  hadolint offers many more rules than  checkov or  conftest, because it is specialized for  Dockerfiles. The tools also complement each other, therefore it does make sense to run multiple tools, e.g. hadolint and trivy, on your  Dockerfiles.  Be prepared, though, that you need to maintain “ignore files” where certain rules are ignored, e.g. due to false positives, or because you are deliberately breaking a rule.</p><p>有时，问题源于你在Dockerfile中的陈述，这是一种糟糕的做法（你没有意识到）。使用checkov、Conftest、trivy或hadolint等工具，它们是Dockerfiles的过梁。要为该工具做出正确的选择，请查看它附带了哪些默认规则/策略。例如，hadolint提供的规则比checkov或conftest多得多，因为它专门用于DockerFile。这些工具也相互补充，因此在Dockerfiles上运行多个工具（例如hadolint和trivy）是有意义的。不过，要做好准备，在某些规则被忽略的情况下，您需要维护“忽略文件”，例如，由于误报，或者因为您故意违反规则。</p><p>  To verify that base images you use are really built &amp; pushed by the company behind that image, you can use  Docker Content Trust (see  official docs). Simply set the  DOCKER_CONTENT_TRUST environment variable to  &#34;1&#34; while running  docker build. The Docker daemon will refuse pulling images that have not been signed by the publisher.</p><p>要验证您使用的基础图像是否真的构建了&amp；在这张图片背后的公司推动下，你可以使用Docker Content Trust（见官方文档）。只需将DOCKER_CONTENT_TRUST环境变量设置为&#34；1&#34; 在运行docker build时。Docker守护进程将拒绝提取未经发布者签名的图像。</p><p>  Security issues usually arise from issues with  other people’s code, that is, popular third party dependencies which are “lucrative” to hack because they are wide-spread. However,  sometimes it is  your own code that is to blame. For instance, you might have accidentally implemented SQL inject possibilities, stack overflow bugs, etc.</p><p>安全问题通常源于其他人的代码问题，也就是说，流行的第三方依赖关系，因为它们分布广泛，所以黑客“有利可图”。然而，有时是你自己的代码造成的。例如，您可能意外地实现了SQL注入可能性、堆栈溢出漏洞等。</p><p> To find those issues, there are so-called SAST tools (Static Application Security Testing). One the one hand, there are programming-language-specific tools (which you have to research individually), such as  bandit for Python, or  Checkstyle /  Spotbugs for Java.  On the other hand there are tool suites (some of which are non-free/commercial) that support  multiple programming languages and frameworks, such as  SonarQube (for which there is also the  SonarLint IDE plugin).  See  here for a list of SAST tools.</p><p>为了发现这些问题，有所谓的SAST工具（静态应用程序安全测试）。一方面，有一些特定于编程语言的工具（你必须单独研究），比如Python的bandit，或者Java的Checkstyle/Spotbugs。另一方面，还有支持多种编程语言和框架的工具套件（其中一些是非免费/商业的），比如SonarQube（SonarLint IDE插件也支持SonarQube）。请参见此处以获取SAST工具的列表。</p><p>  Continuous (automatic) scanning: you create a  CI job that scans your code on each push. This constantly keeps the security of your code on a high level, but you have to figure out how to ignore false positives (which is a continuous maintenance effort). If you use GitLab, you may also find GitLab’s free  SAST feature interesting.</p><p>连续（自动）扫描：创建一个CI作业，每次推送时扫描代码。这会不断地将代码的安全性保持在一个较高的水平上，但您必须弄清楚如何忽略误报（这是一项持续的维护工作）。如果您使用GitLab，您可能还会发现GitLab的免费SAST功能很有趣。</p><p> Occasional (manual) scanning: some security-minded member of your team runs the security check locally, e.g. once per month or before every release, and manually looks over the result.</p><p>偶尔（手动）扫描：团队中一些安全意识强的成员在本地运行安全检查，例如每月一次或每次发布前，并手动查看结果。</p><p>  The  docker-slim tool takes large Docker images, runs them temporarily, analyzes which files are really used in the temporary container, and then produces a new,  single-layer Docker image where all unused files have been removed. This has two benefits:</p><p>docker slim工具获取大型docker图像，临时运行它们，分析临时容器中真正使用的文件，然后生成一个新的单层docker图像，其中所有未使用的文件都已删除。这有两个好处：</p><p> The image becomes more secure, because tools are removed that are not needed (e.g.  curl, or the package manager)</p><p>图像变得更加安全，因为删除了不需要的工具（例如curl或package manager）</p><p>   The more software (e.g. CLI tools, etc.) is stored in an image, the larger the attack surface becomes. It’s good practice to use “minimal” images, which are as  small in size as possible (which is a good advantage anyway), and contain as few tools as possible.  Minimal images go even beyond what “size-optimized” images (such as   alpine or  &lt;something&gt;:&lt;version&gt;-slim, e.g.  python:3.8-slim) do: they come without any package manager. This makes it hard for an attacker to load additional tools.</p><p>图像中存储的软件（如CLI工具等）越多，攻击面就越大。使用“最小”图像是一种很好的做法，它的尺寸尽可能小（无论如何这是一个很好的优势），并且包含尽可能少的工具。最小图像甚至超出了“大小优化”图像（例如alpine或&lt；某物&gt；：&lt；版本&gt；-slim，例如python:3.8-slim）的功能：它们没有任何包管理器。这使得攻击者很难加载其他工具。</p><p> The most secure minimal base image is   SCRATCH, which contains absolutely nothing. Starting your  Dockerfile with   FROM SCRATCH is only feasible if you are placing self-contained binaries in the image, that have all dependencies (including C-runtimes) baked in.</p><p>最安全的最小基本映像是SCRATCH，它完全不包含任何内容。只有在映像中放置包含所有依赖项（包括C运行时）的自包含二进制文件时，才可以从头开始Dockerfile。</p><p> If  SCRATCH does not work for you, Google’s  distroless image can be a good alternative, especially if you are building applications for common programming languages, such as Python or Node.js, or need a minimal base image of  Debian.</p><p>如果SCRATCH不适用于您，那么Google的Distorless映像可能是一个不错的选择，尤其是当您正在为Python或Node等常见编程语言构建应用程序时。js，或者需要Debian的最小基本映像。</p><p>  Caveats of  distroless: Using the programming-language-specific images published by Google on   gcr.io is  not recommended, because there is only a  latest version tag, as well as tags for  major versions (e.g. “3” for python, or “12” for Node). You have no control over the specific language run-time versions (e.g. whether Python 3.8.3 or 3.8.4 etc. is used), which breaks the reproducibility of your image builds.</p><p>发布警告：使用谷歌在gcr上发布的特定于编程语言的图片。不建议使用io，因为只有最新版本的标签，以及主要版本的标签（例如，python为“3”，节点为“12”）。您无法控制特定语言的运行时版本（例如，是否使用Python 3.8.3或3.8.4等），这会破坏图像构建的再现性。</p><p> Customizing (and building your own) distroless images is quite involved: you need to get acquainted with the Bazel build system and build the images yourself Note: if the only customization you need is to run code as  non-root user, there is a  nonroot user by default in every distroless base image, see  here for details.</p><p>定制（并构建自己的）无发行版本映像非常复杂：您需要熟悉Bazel构建系统并自己构建映像注意：如果您需要的唯一定制是以非root用户的身份运行代码，那么默认情况下，每个无发行版本基映像中都有一个非root用户，请参见此处了解详细信息。</p><p> Caveats of minimal base images in general: Debugging containers using your minimal base images is tricky, because useful tools (such as  /bin/sh) are now missing For Docker, you can run a second debugging-container (that does have a shell and debugging tools, e.g.  alpine:latest) and make it share the  PID namespace of your minimal container, e.g. via  docker run -it --rm --pid=container:&lt;minimal-container-id&gt; --cap-add SYS_PTRACE alpine sh</p><p>一般来说，最小基本映像的警告：使用最小基本映像调试容器是很棘手的，因为Docker现在缺少有用的工具（例如/bin/sh），所以可以运行第二个调试容器（它确实有一个shell和调试工具，例如alpine:latest），并使其共享最小容器的PID命名空间，例如，通过docker run-it-rm-pid=container:&lt；最小容器id&gt--加帽系统</p><p>  A  trusted image is one that has been  audited by someone (either your own organization, or someone else), e.g. with a security level. This can be particularly important to regulated industries (banking, aerospace, etc.)  with high security requirements and regulations.</p><p>受信任映像是指已由某人（您自己的组织或其他人）审核的映像，例如具有安全级别的映像。这对于具有高安全要求和法规的受监管行业（银行业、航空航天等）尤其重要。</p><p> While the auditing could be done by yourself, by building trusted images yourself from scratch, this is discouraged, because you, the image builder, has to ensure that all auditing-related tasks are done and properly documented (e.g. documenting the list of packages in the image, executed CVE-checks and their results, etc.). This is a lot of work. Instead,  it is recommended to outsource this task, using  commercial “trusted registries”, which offer a selected set of trusted images, e.g.  RedHat’s Universal Base Images (UBI). RedHat’s UBIs are now also available on Docker Hub for free.</p><p>虽然审核可以由您自己完成，但不鼓励您自己从头开始构建受信任的映像，因为作为映像生成器，您必须确保完成所有与审核相关的任务并正确记录（例如，记录映像中的包列表、执行的CVE检查及其结果等）。这是很多工作。相反，建议使用商业“可信注册中心”将此任务外包，该注册中心提供一组选定的可信映像，例如RedHat的Universal Base images（UBI）。RedHat的UBI现在也可以在Docker Hub上免费获得。</p><p> Images hosted on Docker Hub are not audited. They are provided “as-is”. They might be insecure (even contain malware), and no one will notify you about it. Using an insecure base images from Docker Hub images will therefore also make  your image insecure.</p><p>Docker Hub上托管的图像未经审核。它们“按原样”提供。它们可能不安全（甚至包含恶意软件），没有人会通知你。因此，使用Docker Hub images中不安全的基础图像也会使您的图像不安全。</p><p> Also, you should not confuse auditing with Docker’s  content trust, mentioned above! Content trust only confirms the identity of the source (the image uploader), and does not state any facts about the image security.</p><p>此外，你不应该把审计和Docker的内容信任混为一谈，如上所述！内容信任仅确认源（图像上传者）的身份，不说明任何有关图像安全的事实。</p><p>  Linux  capabilities are a Linux kernel feature that allow you to control which kernel features an application may use. Examples are whether a process may send signals (e.g.  SIGKILL),  configure network interfaces, mount a disk, or debug processes. See  here for the complete list. In general, the fewer capabilities your application needs, the better.</p><p>Linux功能是一种Linux内核功能，允许您控制应用程序可能使用的内核功能。例如，进程是否可以发送信号（例如SIGKILL）、配置网络接口、装载磁盘或调试进程。完整列表请参见此处。一般来说，应用程序需要的功能越少越好。</p><p> Anyone who starts a container of your image can give (or take away) these capabilities, e.g. with a call such as “ docker run  --cap-drop=ALL &lt;image&gt;“.  By default, Docker drops all capabilities except for those  defined here. Your application might not need all of them.</p><p>任何启动图像容器的人都可以提供（或带走）这些功能，例如，通过调用“docker run--cap drop=ALL&lt；image&gt；”。默认情况下，Docker会删除除此处定义的功能之外的所有功能。您的应用程序可能不需要所有这些。</p><p> As a best practice, try starting a container of your image, dropping  all capabilities (using   --cap-drop=ALL)  and see whether it still works. If it does not, figure which capabilities are missing, whether you really need them, and if you do, document which capabilities your image needs (and why), which increases trust with whoever runs your image.</p><p>作为最佳实践，尝试启动映像容器，删除所有功能（使用--cap drop=all），然后看看它是否仍然有效。如果没有，请找出缺少哪些功能，您是否真的需要它们，如果确实需要，请记录您的映像需要哪些功能（以及为什么需要），这会增加运行映像的人的信任。</p><p>  Making your image secure is no walk in the park. It takes time to evaluate and implement each practice. The list in this article should save you time, because it already did the work of collecting and prioritizing the necessary steps.</p><p>让你的形象安全无需在公园里散步。评估和实施每项实践都需要时间。本文中的列表应该可以节省您的时间，因为它已经完成了收集必要步骤并确定其优先级的工作。</p><p> Fortunately, securing your application is an  iterative process. You can start small, and implement one step at a time. You do need buy-in from management, though. This is sometimes tricky, especially if your manager is resistant to advice, and if they tend</p><p>幸运的是，保护应用程序是一个迭代过程。你可以从小事做起，一步一个脚印地完成。不过，你确实需要得到管理层的认可。这有时很棘手，尤其是如果你的经理拒绝建议，并且他们倾向于</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/docker/">#docker</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/security/">#security</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>