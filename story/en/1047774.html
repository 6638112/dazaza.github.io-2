<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么Esbuild快速？ Why Is Esbuild Fast?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Why Is Esbuild Fast?<br/>为什么Esbuild快速？ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-17 18:25:39</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/7c1b43601da0c55ecb4628ac47d35cc8.png"><img src="http://img2.diglog.com/img/2021/2/7c1b43601da0c55ecb4628ac47d35cc8.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This is a collection of common questions about esbuild. You can also ask questions on the  GitHub issue tracker.</p><p>这是有关esbuild的常见问题的集合。您还可以在GitHub问题跟踪器上提问。</p><p>        Most other bundlers are written in JavaScript, but a command-line application is a worst-case performance situation for a JIT-compiled language. Every time you run your bundler, the JavaScript VM is seeing your bundler&#39;s code for the first time without any optimization hints. While esbuild is busy parsing your JavaScript, node is busy parsing your bundler&#39;s JavaScript. By the time node has finished parsing your bundler&#39;s code, esbuild might have already exited and your bundler hasn&#39;t even started bundling yet.</p><p>        其他大多数捆绑程序都是用JavaScript编写的，但是对于JIT编译的语言，命令行应用程序是最坏的性能情况。每次运行捆绑程序时，JavaScript VM都会首次看到捆绑程序的代码，而没有任何优化提示。 esbuild忙于解析JavaScript时，node忙于解析捆绑程序的JavaScript。到节点完成对捆绑程序代码的解析时，esbuild可能已经退出，并且捆绑程序甚至还没有开始捆绑。</p><p>  In addition, Go is designed from the core for parallelism while JavaScript is not. Go has shared memory between threads while JavaScript has to serialize data between threads. Both Go and JavaScript have parallel garbage collectors, but Go&#39;s heap is shared between all threads while JavaScript has a separate heap per JavaScript thread. This seems to cut the amount of parallelism that&#39;s possible with JavaScript worker threads in half  according to my testing, presumably since half of your CPU cores are busy collecting garbage for the other half.</p><p>  另外，Go是为并行性而设计的，而JavaScript不是。 Go在线程之间共享内存，而JavaScript必须在线程之间序列化数据。 Go和JavaScript都有并行的垃圾收集器，但是Go的堆在所有线程之间共享，而JavaScript每个JavaScript线程都有一个单独的堆。根据我的测试，这似乎将JavaScript工作者线程的并行能力减少了一半，这大概是因为您的CPU核心中有一半正忙于为另一半收集垃圾。</p><p> The algorithms inside esbuild are carefully designed to fully saturate all available CPU cores when possible. There are roughly three phases: parsing, linking, and code generation. Parsing and code generation are most of the work and are fully parallelizable (linking is an inherently serial task for the most part). Since all threads share memory, work can easily be shared when bundling different entry points that import the same JavaScript libraries. Most modern computers have many cores so parallelism is a big win.</p><p> esbuild中的算法经过精心设计，以尽可能使所有可用的CPU内核完全饱和。大致分为三个阶段：解析，链接和代码生成。解析和代码生成是大部分工作，并且可以完全并行化（链接在大多数情况下是固有的串行任务）。由于所有线程共享内存，因此当捆绑导入相同JavaScript库的不同入口点时，可以轻松地共享工作。大多数现代计算机具有许多内核，因此并行性是一个巨大的胜利。</p><p> There are a lot of performance benefits with writing everything yourself instead of using 3rd-party libraries. You can have performance in mind from the beginning, you can make sure everything uses consistent data structures to avoid expensive conversions, and you can make wide architectural changes whenever necessary. The drawback is of course that it&#39;s a lot of work.</p><p> 自行编写所有内容而不是使用3rd-party库，可以带来很多性能优势。您可以从一开始就牢记性能，可以确保一切都使用一致的数据结构来避免昂贵的转换，并且可以在必要时进行广泛的体系结构更改。缺点当然是很多工作。</p><p>  For example, many bundlers use the official TypeScript compiler as a parser. But it was built to serve the goals of the TypeScript compiler team and they do not have performance as a top priority. Their code makes pretty heavy use of  megamorphic object shapes and unnecessary  dynamic property accesses (both well-known JavaScript speed bumps). And the TypeScript parser appears to still run the type checker even when type checking is disabled. None of these are an issue with esbuild&#39;s custom TypeScript parser.</p><p>  例如，许多捆绑程序使用官方的TypeScript编译器作为解析器。但是，它是为实现TypeScript编译器团队的目标而构建的，它们没有将性能放在首位。他们的代码大量使用了巨形对象形状和不必要的动态属性访问（众所周知的JavaScript减速）。而且即使禁用类型检查，TypeScript解析器也似乎仍在运行类型检查器。这些都不是esbuild的自定义TypeScript解析器的问题。</p><p> Compilers are ideally mostly O(n) complexity in the length of the input. So if you are processing a lot of data, memory access speed is likely going to heavily affect performance. The fewer passes you have to make over your data (and also the fewer different representations you need to transform your data into), the faster your compiler will go.</p><p> 理想情况下，编译器在输入长度上的复杂度通常为O（n）。因此，如果您要处理大量数据，则内存访问速度可能会严重影响性能。您必须对数据进行的遍历次数越少（将数据转换成数据所需的不同表示形式也就越少），编译器就会越快。 </p><p>      This maximizes reuse of AST data while it&#39;s still hot in the CPU cache. Other bundlers do these steps in separate passes instead of interleaving them. They may also convert between data representations to glue multiple libraries together (e.g. string→TS→JS→string, then string→JS→older JS→string, then string→JS→minified JS→string) which uses more memory and slows things down.</p><p>当AST数据在CPU缓存中仍然很热时，这可以最大限度地重用AST数据。其他捆绑程序在单独的遍历中执行这些步骤，而不是对它们进行交织。它们还可以在数据表示之间进行转换，以将多个库粘合在一起（例如，字符串→TS→JS→字符串，然后字符串→JS→旧JS→字符串，然后字符串→JS→最小化JS→字符串），这会占用更多的内存并减慢速度。</p><p>  Another benefit of Go is that it can store things as compactly in memory, which enables it to use less memory and fit more in the CPU cache. All object fields have types and fields are packed tightly together so e.g. several boolean flags only take one byte each. Go also has value semantics and can embed one object directly in another so it comes &#34;for free&#34; without another allocation. JavaScript doesn&#39;t have these features and also has other drawbacks such as JIT overhead (e.g. hidden class slots) and inefficient representations (e.g. non-integer numbers are heap-allocated with pointers).</p><p>  Go的另一个好处是，它可以将内容紧凑地存储在内存中，这使其可以使用更少的内存并在CPU缓存中容纳更多内存。所有对象字段的类型和字段都紧密地包装在一起，例如几个布尔标志每个仅占用一个字节。 Go也具有值语义，可以将一个对象直接嵌入另一个对象，因此它是免费的。没有其他分配。 JavaScript不具有这些功能，还具有其他缺点，例如JIT开销（例如，隐藏的类槽）和低效的表示形式（例如，非整数与指针一起分配在堆中）。</p><p>  Each one of these factors is only a somewhat significant speedup, but together they can result in a bundler that is multiple orders of magnitude faster than other bundlers commonly in use today.</p><p>  这些因素中的每一个都只是某种程度的显着提速，但是它们一起可以使捆扎机比当今常用的其他捆扎机快多个数量级。</p><p>          This benchmark approximates a large JavaScript codebase by duplicating the  three.js library 10 times and building a single bundle from scratch, without any caches. The benchmark can be run with  make bench-three in the  esbuild repo.</p><p>          该基准测试通过将three.js库复制10次并从头开始构建单个捆绑包而没有任何缓存，从而近似了一个大型JavaScript代码库。可以在esbuild存储库中使用make Bench-3运行基准测试。</p><p>    Each time reported is the best of three runs. I&#39;m running esbuild with  --bundle  --minify  --sourcemap (the single-threaded version uses  GOMAXPROCS=1). I used the  rollup- plugin- terser plugin because Rollup itself doesn&#39;t support minification. Webpack uses  --mode= production  --devtool= sourcemap. Parcel uses the default options. Absolute speed is based on the total line count including comments and blank lines, which is currently 547,441. The tests were done on a 6-core 2019 MacBook Pro with 16gb of RAM.</p><p>    每次报告是三个运行中最好的一次。我正在使用--bundle --minify --sourcemap运行esbuild（单线程版本使用GOMAXPROCS = 1）。我使用了rollup-插件插件，因为Rollup本身不支持缩小。 Webpack使用--mode =生产--devtool =源映射。包裹使用默认选项。绝对速度基于总行数（包括注释和空白行），当前为547,441。测试是在配备16GB RAM的6核2019 MacBook Pro上完成的。</p><p>          This benchmark uses the  Rome build tool to approximate a large TypeScript codebase. All code must be combined into a single minified bundle with source maps and the resulting bundle must work correctly. The benchmark can be run with  make bench-rome in the  esbuild repo.</p><p>          该基准使用Rome构建工具来近似大型TypeScript代码库。必须将所有代码与源映射合并到一个缩小的捆绑包中，并且生成的捆绑包必须能够正常工作。可以在esbuild存储库中使用make bench-rome运行基准测试。</p><p>    Each time reported is the best of three runs. I&#39;m running esbuild with  --bundle  --minify  --sourcemap  --platform= node (the single-threaded version uses  GOMAXPROCS=1). Webpack uses  ts-loader with  transpileOnly:  true and  --mode= production  --devtool= sourcemap. Parcel 1 uses  --target  node --bundle- node- modules. Parcel 2 uses  &#34;engines&#34;:  &#34;node&#34; in  package.json and needs the  @parcel/ transformer- typescript- tsc transformer to be able to handle the TypeScript code used in the benchmark. Absolute speed is based on the total line count including comments and blank lines, which is currently 131,836. The tests were done on a 6-core 2019 MacBook Pro with 16gb of RAM.</p><p>    每次报告是三个运行中最好的一次。我正在使用--bundle --minify --sourcemap --platform =节点运行esbuild（单线程版本使用GOMAXPROCS = 1）。 Webpack将ts-loader与transpileOnly一起使用：true和--mode = production --devtool = sourcemap。宗地1使用--target node --bundle- node-模块。宗地2使用＆＃34; engines＆＃34 ;:＆＃34; node＆＃34;在package.json中，并且需要@ parcel / Translator- typescript- tsc转换器才能处理基准测试中使用的TypeScript代码。绝对速度基于总行数（包括注释和空白行），当前为131,836。测试是在配备16GB RAM的6核2019 MacBook Pro上完成的。 </p><p>  The results don&#39;t include Rollup because I couldn&#39;t get it to work. I tried  rollup- plugin- typescript,  @rollup/ plugin- typescript, and  @rollup/ plugin- sucrase and they all didn&#39;t work for different reasons relating to TypeScript compilation.</p><p>结果不包含汇总，因为我无法使其正常工作。我尝试了rollup-插件打字稿，@ rollup /插件打字稿和@ rollup /插件sucrase，但由于与TypeScript编译相关的不同原因，它们都没有起作用。</p><p>        These are potential future features but may not happen or may happen to a more limited extent:</p><p>        这些是未来的潜在功能，但可能不会发生或可能会在更有限的程度上发生：</p><p>    After that point, I will consider esbuild to be relatively complete. I&#39;m planning for esbuild to reach a mostly stable state and then stop accumulating more features. This will involve saying &#34;no&#34; to requests for adding major features to esbuild itself. I don&#39;t think esbuild should become an all-in-one solution for all frontend needs. In particular, I want to avoid the pain and problems of the &#34;webpack config&#34; model where the underlying tool is too flexible and usability suffers.</p><p>    在那之后，我将认为esbuild比较完整。我正在计划esbuild达到大致稳定的状态，然后停止累积更多功能。这将涉及说＆＃34; no＆＃34;要求向esbuild本身添加主要功能。我不认为esbuild应该成为满足所有前端需求的一体化解决方案。特别是，我想避免＆webpack配置＆＃34;带来的麻烦和问题。底层工具过于灵活且易用性受损的模型。</p><p>      I hope that the extensibility points I&#39;m adding to esbuild ( plugins and the  API) will make esbuild useful to include as part of more customized build workflows, but I&#39;m not intending or expecting these extensibility points to cover all use cases. If you have very custom requirements then you should be using other tools. I also hope esbuild inspires other build tools to dramatically improve performance by overhauling their implementations so that everyone can benefit, not just those that use esbuild.</p><p>      我希望我添加到esbuild（插件和API）中的可扩展性点将使esbuild有用，以作为更多自定义构建工作流的一部分包括在内，但是我不打算或期望这些可扩展性点能够覆盖所有用例。如果您有非常自定义的要求，则应使用其他工具。我也希望esbuild能够启发其他构建工具，通过彻底检查其实现来极大地提高性能，从而使每个人都能受益，而不仅仅是使用esbuild的那些。</p><p>  I am planning to continue to maintain everything in esbuild&#39;s existing scope even after esbuild reaches stability. This means implementing support for newly-released JavaScript and TypeScript syntax features, for example.</p><p>  我计划即使在esbuild达到稳定后，也将继续维护esbuild现有范围内的所有内容。例如，这意味着实现对新发布的JavaScript和TypeScript语法功能的支持。</p><p>    This project has not yet hit version 1.0.0 and is still in active development. That said, it is far beyond the alpha stage and is pretty stable. I think of it as a late-stage beta. For some early-adopters that means it&#39;s good enough to use for real things. Some other people think this means esbuild isn&#39;t ready yet. This section doesn&#39;t try to convince you either way. It just tries to give you enough information so you can decide for yourself whether you want to use esbuild as your bundler.</p><p>    该项目尚未达到1.0.0版本，仍在积极开发中。也就是说，它远远超出了alpha阶段，并且非常稳定。我认为这是后期测试版。对于一些早期采用者而言，这意味着它足以用于真实事物。其他人则认为这意味着esbuild尚未准备就绪。本节不会尝试用任何一种方法说服您。它只是试图为您提供足够的信息，以便您可以自己决定是否要将esbuild用作捆绑程序。</p><p>    Used by other projects  The API is already being used as a library within some other developer tools. For example,  Vite and  Snowpack are using esbuild&#39;s  transform API to transform TypeScript into JavaScript. And  Hugo is using esbuild&#39;s bundler to package JavaScript code during a build. I have also heard reports of others using it in production successfully, although I don&#39;t know the details. I intend to use esbuild in production myself once it has enough features but haven&#39;t done that yet.</p><p>    由其他项目使用该API已在某些其他开发人员工具中用作库。例如，Vite和Snowpack正在使用esbuild的转换API将TypeScript转换为JavaScript。 Hugo正在使用esbuild的捆绑程序在构建过程中打包JavaScript代码。我还听说过其他人成功在生产中使用它的报道，尽管我不知道细节。一旦具有足够的功能，我打算在生产环境中自己使用esbuild，但尚未完成。 </p><p> API stability  Even though esbuild&#39;s version is not yet 1.0.0, effort is still made to keep the API stable. Patch versions are intended for backwards-compatible changes and minor versions are intended for backwards-incompatible changes (as  recommended by npm). If you plan to use esbuild for something real, you should either pin the exact version (maximum safety) or pin the major and minor versions (only accept backwards-compatible upgrades).</p><p>API的稳定性即使esbuild的版本不是1.0.0，仍会努力保持API的稳定性。修补程序版本用于向后兼容的更改，次要版本用于向后不兼容的更改（由npm建议）。如果您打算将esbuild用于真实的东西，则应该固定确切的版本（最大安全性）或固定主要版本和次要版本（仅接受向后兼容的升级）。</p><p> Only one main developer  This tool is primarily built by  me. For some people this is fine, but for others this means esbuild is not a suitable tool for their organization. That&#39;s ok with me. I&#39;m building esbuild because I find it fun to build and because it&#39;s the tool I&#39;d want to use. I&#39;m sharing it with the world because there are others that want to use it too, because the feedback makes the tool itself better, and because I think it will inspire the ecosystem to make better tools.</p><p> 只有一个主要开发人员该工具主要由我构建。对于某些人来说，这很好，但是对于其他人，这意味着esbuild对于他们的组织而言不是合适的工具。我可以。我之所以建立esbuild是因为我发现它的构建很有趣，并且因为它是我想使用的工具。我之所以与全世界分享它，是因为还有其他人也想使用它，因为反馈使工具本身变得更好，并且因为我认为它将激发生态系统来制造更好的工具。</p><p> Not always open to scope expansion  I&#39;m not planning on including major features that I&#39;m not interested in building and/or maintaining. I also want to limit the project&#39;s scope so it doesn&#39;t get too complex and unwieldy, both from an architectural perspective, a testing and correctness perspective, and from a usability perspective. Think of esbuild as a &#34;linker&#34; for the web. It knows how to transform and bundle JavaScript and CSS. But the details of how your source code ends up as plain JavaScript or CSS may need to be 3rd-party code.</p><p> 我并不总是打算扩大范围，我不打算包括我不希望构建和/或维护的主要功能。从架构的角度，测试和正确性的角度以及从可用性的角度来看，我还想限制项目的范围，以免变得过于复杂和笨拙。将esbuild视为一个＆linker＆＃34;用于网络。它知道如何转换和捆绑JavaScript和CSS。但是，您的源代码如何以纯JavaScript或CSS结尾的详细信息可能需要是第三方代码。</p><p>  I&#39;m hoping that  plugins will allow the community to add major features (e.g. WebAssembly import) without needing to contribute to esbuild itself. However, not everything is exposed in the plugin API and it may be the case that it&#39;s not possible to add a particular feature to esbuild that you may want to add. This is intentional; esbuild is not meant to be an all-in-one solution for all frontend needs.</p><p>  我希望插件将使社区能够添加主要功能（例如WebAssembly导入），而无需为esbuild本身做出贡献。但是，并非插件API公开了所有内容，并且可能无法在esbuild中添加您想添加的特定功能。这是故意的； esbuild并不意味着它可以满足所有前端需求。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://esbuild.github.io/faq/#why-is-esbuild-fast">https://esbuild.github.io/faq/#why-is-esbuild-fast</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/esbuild/">#esbuild</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>