<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Postgres中具有pg_stat_statements的查询优化 Query Optimization in Postgres with pg_stat_statements</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Query Optimization in Postgres with pg_stat_statements<br/>Postgres中具有pg_stat_statements的查询优化 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-20 04:54:45</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/0c0ce2c24a757510874fc26a144605b6.jpg"><img src="http://img2.diglog.com/img/2021/2/0c0ce2c24a757510874fc26a144605b6.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>&#34;I want to work on optimizing all my queries all day long because it will definitely be worth the time and effort,&#34; is a statement that has hopefully never been said. So when it comes to query optimizing, how should you pick your battles? Luckily, in PostgreSQL we have a way to take a system-wide look at database queries:</p><p>＆＃34;我想整天优化所有查询，因为这绝对值得您花时间和精力，＆＃34;希望从未有人说过这句话。因此，当涉及到查询优化时，您应该如何选择战斗？幸运的是，在PostgreSQL中，我们有一种方法可以在系统范围内查看数据库查询：</p><p>   pg_stat_statements is an extension that has been around in PostgreSQL since version 8.4. It&#39;s evolved over the years (notably since 9.2) to become such a helpful tool. So we thought now would be as good a time as any to highlight it here on our Crunchy blog.</p><p>   pg_stat_statements是自8.4版本以来在PostgreSQL中一直存在的扩展。经过数年的发展（特别是从9.2版开始），它已成为一种有用的工具。因此，我们认为现在和在Crunchy博客上突出显示它一样好。</p><p> You can technically set Postgres to log all calls made to the database, but if you&#39;re interested in something that gives you more of an overview, pg_stat_statements gives you easy access to query statistics. It doesn&#39;t prevent  runaway queries from bogging down your system, but it could be a simple yet important addition to your Postgres performance toolkit. You don&#39;t need to be an expert to start using and getting value out of this extension. Let&#39;s it a quick spin.</p><p> 从技术上讲，您可以将Postgres设置为记录对数据库的所有调用，但是如果您对可以为您提供更多概述的内容感兴趣，则pg_stat_statements可以使您轻松访问查询统计信息。它不会阻止失控的查询使您的系统陷入瘫痪，但这可能是对Postgres性能工具包的简单而重要的补充。您无需成为专家即可开始使用此扩展并从中获得价值。让我们快速旋转一下。</p><p>  pg_stat_statements is included in the  contrib module, so it ships with standard Postgres, but might not be automatically enabled:</p><p>  pg_stat_statements包含在contrib模块中，因此它与标准Postgres一起提供，但可能不会自动启用：</p><p> If you&#39;re using a managed Postgres system such as   Crunchy Bridge, pg_stat_statements may have already been added in postgresql.conf. (Tip: run  SHOW shared_preload_libraries; to check.) In that case you can skip to the next step.</p><p> 如果您使用的是诸如Crunchy Bridge之类的Postgres托管系统，则pg_stat_statements可能已经添加到postgresql.conf中。 （提示：运行SHOW shared_preload_libraries;进行检查。）在这种情况下，您可以跳到下一步。</p><p> Log back in to Postgres. In the database which you want to access pg_stat_statements, run:</p><p> 重新登录到Postgres。在要访问pg_stat_statements的数据库中，运行：</p><p> And that&#39;s it, you can start using it. You do need to enable the extension in each database where you want to access it, but pg_stat_statements actually tracks across all databases in that same server from the start.</p><p> 就是这样，您可以开始使用它了。您确实需要在要访问扩展名的每个数据库中启用扩展名，但是pg_stat_statements实际上从一开始就跟踪同一台服务器中的所有数据库。 </p><p>  pg_stat_statements gives us a view that contains aggregated query statistics. I&#39;m using a Crunchy Bridge instance running PG 13, and here&#39;s the result when describing the view:</p><p>pg_stat_statements给我们一个包含聚合查询统计信息的视图。我使用的是运行PG 13的Crunchy Bridge实例，这是描述视图时的结果：</p><p> \d pg_stat_statements  View &#34;public.pg_stat_statements&#34; Column | Type | Collation | Nullable | Default---------------------+------------------+-----------+----------+--------- userid | oid | | | dbid | oid | | | queryid | bigint | | | query | text | | | plans | bigint | | | total_plan_time | double precision | | | min_plan_time | double precision | | | max_plan_time | double precision | | | mean_plan_time | double precision | | | stddev_plan_time | double precision | | | calls | bigint | | | total_exec_time | double precision | | | min_exec_time | double precision | | | max_exec_time | double precision | | | mean_exec_time | double precision | | | stddev_exec_time | double precision | | | rows | bigint | | | ... blk_read_time | double precision | | | blk_write_time | double precision | | | wal_records | bigint | | | wal_fpi | bigint | | | wal_bytes | numeric | | |</p><p> \ d pg_stat_statements视图＆＃34; public.pg_stat_statements＆＃34;专栏类型整理|可空|默认值---------------------- + ------------------ + -------- --- + ---------- + --------- userid | oid | | | dbid | oid | | | queryid | bigint | | |查询|文字| | |计划| bigint | | | total_plan_time |双精度| | | min_plan_time |双精度| | | max_plan_time |双精度| | | mean_plan_time |双精度| | | stddev_plan_time |双精度| | |电话| bigint | | | total_exec_time |双精度| | | min_exec_time |双精度| | | max_exec_time |双精度| | | mean_exec_time |双精度| | | stddev_exec_time |双精度| | |行| bigint | | | ... blk_read_time |双精度| | | blk_write_time |双精度| | | wal_records | bigint | | | wal_fpi | bigint | | | wal_bytes |数字| | |</p><p> We&#39;ll revisit a few of these attributes in just a bit, but for now let&#39;s just dive in. I spun up a new Crunchy Bridge cluster, and since pg_stat_statements has already been added, all I really needed to do was to run CREATE EXTENSION. We can then query against the pg_stat_statements view, just like so:</p><p> 我们将稍后重新介绍其中的一些属性，但现在让我们开始学习。我创建了一个新的Crunchy Bridge集群，并且由于已经添加了pg_stat_statements，因此我真正需要做的只是要做的就是运行CREATE EXTENSION。然后我们可以查询pg_stat_statements视图，就像这样：</p><p>    SELECT (total_exec_time / 1000 / 60) as total_min, mean_exec_time as avg_ms, calls, query FROM pg_stat_statements ORDER BY 1 DESC LIMIT 500;</p><p>    SELECT（total_exec_time / 1000/60）作为total_min，mean_exec_time作为avg_ms，调用，从pg_stat_statements查询ORDER BY 1 DESC LIMIT 500；</p><p> total_exec_time and  mean_exec_time are in milliseconds, and calls is the number of times the query has been run.  min_exec_time,  max_exec_time, and  stddev_exec_time are available as well. You could also look at the total number of cumulative rows returned by the query. There&#39;s many different ways you could slice and dice the information from pg_stat_statements.</p><p> total_exec_time和mean_exec_time以毫秒为单位，并且call是查询已运行的次数。 min_exec_time，max_exec_time和stddev_exec_time也可用。您还可以查看查询返回的累积行总数。您可以通过多种方法将pg_stat_statements中的信息切成薄片并将其切成小块。</p><p> You may have noticed that stats on query planning are included in addition to just execution. These are new additions as of PG 13, and could provide some more helpful insights (for example, where planning is taking significantly longer compared to execution).</p><p> 您可能已经注意到，除了执行之外，还包括查询计划的统计信息。这些是PG 13的新增功能，可以提供更多有用的见解（例如，与执行相比，计划花费的时间明显更长）。</p><p> In case you were wondering if pg_stat_statements also records queries issued against the view itself: yes, by default it does.</p><p> 如果您想知道pg_stat_statements是否还记录针对视图本身发出的查询：是的，默认情况下会记录该查询。 </p><p>  You could also do a   manual reset, which flushes out the statistics gathered so far:</p><p>您还可以进行手动重置，以清除到目前为止收集的统计信息：</p><p>  It can make sense to do this after you&#39;ve carried out some tuning on your end, such as adding an index. Or, you may have made some changes to the database schema. Either way, even if you do periodic resets you should still be able to make comparisons across time by taking snapshots of the view, for example by saving the query output.</p><p>  在您最终进行了一些调整（例如添加索引）之后，可以这样做。或者，您可能已对数据库架构进行了一些更改。无论哪种方式，即使您进行了定期重置，您也仍然可以通过拍摄视图快照（例如保存查询输出）来跨时间进行比较。</p><p>   CREATE TABLE payment ( id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, date timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP, type TEXT NOT NULL CHECK (type in (&#39;Event&#39;, &#39;Package&#39;)), status TEXT CHECK (status in (&#39;Waive&#39;, &#39;Refund&#39;)), client_id INTEGER NOT NULL REFERENCES client(id), event_id INTEGER REFERENCES event(id), amount NUMERIC(8,2) NOT NULL, balance NUMERIC(8,2) NOT NULL);INSERT INTO payment (date, type, client_id, event_id, amount, balance) VALUES (&#39;2020-01-10 13:00 PST&#39;, &#39;Event&#39;, 1, 4, 20.00, 0.00);</p><p>   创建表付款（由默认身份标识生成的ID整数主键，日期时间戳记非空默认时间CURRENT_TIMESTAMP，类型为文本非空检查（类型为（＆＃39; Event＆＃39 ;,＆＃39; Package＆＃39;））， status TEXT CHECK（（（Waive＆＃39;，＆＃39; Refund＆＃39;）中的状态）），client_id INTEGER NOT NULL REFERENCES client（id），event_id INTEGER REFERENCES event（id），金额NUMERIC（8， 2）NOT NULL，余额NUMERIC（8,2）NOT NULL）；在付款中插入（日期，类型，client_id，event_id，金额，余额）值（＆＃39; 2020-01-10 13:00 PST＆＃39; ，＆＃39; Event＆＃39;，1、4、20.00、0.00）；</p><p>  -[ RECORD 12 ]---------------------------------------------------------------------total_min | 0.00022264500000000002avg_ms | 13.3587calls | 1query | CREATE TABLE payment (id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, date timestamptz NOT NULL DEFAULT CURRENT_TIMESTAMP, type TEXT NOT NULL CHECK (type in (&#39;Event&#39;, &#39;Package&#39;)), status TEXT CHECK (status in (&#39;Waive&#39;, &#39;Refund&#39;)), client_id INTEGER NOT NULL REFERENCES client(id), event_id INTEGER REFERENCES event(id), amount NUMERIC(8,2) NOT NULL, balance NUMERIC(8,2) NOT NULL)...-[ RECORD 50 ]---------------------------------------------------------------------total_min | 6.687333333333334e-05avg_ms | 4.0124calls | 1query | INSERT INTO payment (date, type, client_id, event_id, amount, balance) VALUES ($1, $2, $3, $4, $5, $6)</p><p>  -[记录12] --------------------------------------------- ------------------------ total_min | 0.00022264500000000002avg_ms | 13.3587个呼叫| 1查询|创建表付款（由默认身份标识生成的ID整数主键，日期时间戳记非空缺省时间CURRENT_TIMESTAMP，类型为文本非空检查（类型为（＆＃39; Event＆＃39 ;，＆＃39; Package＆＃39;））， status TEXT CHECK（（（Waive＆＃39;，＆＃39; Refund＆＃39;）中的状态）），client_id INTEGER NOT NULL REFERENCES client（id），event_id INTEGER REFERENCES event（id），金额NUMERIC（8， 2）NOT NULL，余额NUMERIC（8,2）NOT NULL）...- [RECORD 50] --------------------------- ------------------------------------------ total_min | 6.687333333333334e-05avg_ms | 4.0124电话| 1查询|插入付款（日期，类型，client_id，event_id，金额，余额）VALUES（$ 1，$ 2，$ 3，$ 4，$ 5，$ 6）</p><p> Notice the difference? The CREATE TABLE query is saved &#34;as-is,&#34; but the INSERT has the literal values stripped out and replaced by parameter symbols ( $1 etc). (You may also see this being referred to as the &#34; normalized form&#34; of the query.) That allows  semantically equivalent queries to be evaluated in the aggregate. That is, if I were to run another insert into the payment table with the same syntax, we do want to consider it to be the same operation, but don&#39;t necessarily care that we may be inserting different values.</p><p> 注意区别吗？ CREATE TABLE查询按原样保存，＆＃34;但是INSERT删除了文字值，并替换为参数符号（$ 1等）。 （您可能还会看到这被称为查询的“规范化形式”。）这允许在集合中评估语义上等效的查询。也就是说，如果我要使用相同的语法在付款表中运行另一个插入，我们确实希望将其视为相同的操作，但是不必担心我们会插入不同的值。</p><p>  A tip from my colleague Greg Smith: if you want to use the block read and write time (blk_read_time and blk_write_time) statistics, you also need to turn on the  track_io_timing parameter in postgresql.conf. That&#39;s recommended if you want all the features pg_stat_statements can deliver. It&#39;s disabled by default because timing things is very slow on some systems.</p><p>  我的同事Greg Smith的提示：如果要使用块的读写时间（blk_read_time和blk_write_time）统计信息，则还需要打开postgresql.conf中的track_io_timing参数。如果您希望pg_stat_statements可以提供所有功能，则建议这样做。默认情况下它是禁用的，因为在某些系统上计时时间很慢。</p><p> To check how fast the timers in your system are, use the   pg_test_timing utility. The overhead of collecting all this timing data is low for most hardware.</p><p> 要检查系统中的计时器有多快，请使用pg_test_timing实用程序。对于大多数硬件而言，收集所有这些时序数据的开销很低。 </p><p> I hadn&#39;t enabled track_io_timing, so we&#39;ve focused on more simple examples for now. Do keep an eye out for a future deep dive into this topic on our blog.</p><p>我尚未启用track_io_timing，所以我们现在集中在更简单的示例上。请留意我们的博客上将来深入探讨该主题。</p><p>  I describe pg_stat_statements as giving you an aggregate look at query stats. Which attributes are most important and what thresholds you want to set will probably depend on how your database is used and what your requirements are. But, once you&#39;re able to zero in on some specific queries, one of the next things you&#39;ll probably want to do is dig in individually using   EXPLAIN (ANALYZE). Then, you might go on to optimize these queries perhaps by creating new indexes. That&#39;s just one example, but I hope this helps illustrate how pg_stat_statements can be a really handy tool for improving the performance of your database.</p><p>  我将pg_stat_statements描述为使您可以总体了解查询统计信息。哪些属性最重要以及要设置的阈值可能取决于数据库的使用方式和要求。但是，一旦您能够对某些特定查询进行归零，您可能想要做的下一件事就是使用EXPLAIN（ANALYZE）分别进行挖掘。然后，您也许可以通过创建新索引来继续优化这些查询。那只是一个例子，但我希望这有助于说明pg_stat_statements如何成为提高数据库性能的便捷工具。</p><p> One thing to keep in mind is that the query texts are &#34;kept in an external disk file, and do not consume shared memory&#34; (taken from the official docs). pg_stat_statements should leave only a relatively small footprint on your system especially compared to logging  all of the things. That said, you could also make sure to set a lower threshold on  pg_stat_statements.max, or set only certain types of statements to be tracked using the  pg_stat_statements.track parameters.</p><p> 要记住的一件事是查询文本保存在外部磁盘文件中，并且不占用共享内存。 （摘自官方文档）。 pg_stat_statements应该只在您的系统上留下相对较小的占用空间，尤其是与记录所有内容相比。也就是说，您还可以确保在pg_stat_statements.max上设置一个较低的阈值，或仅使用pg_stat_statements.track参数设置要跟踪的某些类型的语句。</p><p> pg_stat_statements saves you from the effort of parsing through all your logs just to get a pulse on what&#39;s going on with your queries. For those who weren&#39;t familiar with the extension, I hope this encourages you to start digging in. And while we&#39;re here, we do have a   class on EXPLAIN (ANALYZE) in the Crunchy Learning Portal, for those of you who&#39;d also like to give that a whirl. Enjoy!</p><p> pg_stat_statements使您免于解析所有日志的工作，以使您了解查询的最新情况。对于那些不熟悉该扩展程序的人，希望这会鼓励您开始研究。在这里的同时，我们还在Crunchy Learning Portal中开设了关于EXPLAIN（ANALYZE）的课程，对于那些你们中的一个也想旋转一下。享受！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://info.crunchydata.com/blog/tentative-smarter-query-optimization-in-postgres-starts-with-pg_stat_statements">https://info.crunchydata.com/blog/tentative-smarter-query-optimization-in-postgres-starts-with-pg_stat_statements</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/查询/">#查询</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>