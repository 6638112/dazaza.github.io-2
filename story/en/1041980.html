<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>通过使用游标而不是偏移量进行API分页设计 API pagination design by using cursors instead of offsets</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">API pagination design by using cursors instead of offsets<br/>通过使用游标而不是偏移量进行API分页设计 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-27 09:27:27</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/1208df6cbb0e5e0bab9b1937052dc466.png"><img src="http://img2.diglog.com/img/2020/12/1208df6cbb0e5e0bab9b1937052dc466.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Returning all results for a given query could be a challenge for an API, especially if there are thousands of results. It puts a load on a server, on a client, on a network, and often is unnecessary. Thus people invented pagination.</p><p>返回给定查询的所有结果对于API可能是一个挑战，尤其是在有成千上万个结果的情况下。它给服务器，客户端，网络带来了负担，通常是不必要的。人们因此发明了分页。</p><p> The usual way to paginate is an offset or a page number. So you make a request like that:</p><p> 分页的常用方法是偏移量或页码。所以您发出这样的请求：</p><p>    In case of a simple offset it’ll look like  ?offset=1000 and  ?offset=1100 — it’s the same old soup, just reheated. It’ll either go straight into SQL query like  OFFSET 1000 LIMIT 100 or will be multiplied by page size (that  LIMIT value). In any case, it’s a suboptimal solution, since every database has to skip that 1000 rows. And to skip them it needs to identify them. It does not matter if it’s PostgreSQL, or ElasticSearch, or MongoDB, it’ll have to order them, count them, and throw them away.</p><p>    如果是简单的偏移量，它看起来像是？offset = 1000和？offset = 1100-是相同的旧汤，只是重新加热了。它可以直接进入SQL查询（例如OFFSET 1000 LIMIT 100），也可以乘以页面大小（即LIMIT值）。无论如何，这都是次优的解决方案，因为每个数据库都必须跳过那1000行。要跳过它们，需要识别它们。不管是PostgreSQL，ElasticSearch还是MongoDB，都必须对其进行排序，计数并丢弃。</p><p> This is a kind of work which no one needs. But it repeats over and over again since it’s  easy to implement — you directly map your API onto your query to a database.</p><p> 这是一种没人需要的工作。但是，由于易于实现，它会一遍又一遍地重复-您可以直接将API映射到查询的数据库中。</p><p> What do you do then? We could look at what databases do! They have this concept, called  cursor — it’s a pointer to a row. So you can say to a database “return me 100 rows after  that one”. And it’s much easier for a database to do since there is a good chance that you’ll identify the row by a field with an index. And suddenly you don’t need to fetch and skip those rows, you’ll go directly past them.</p><p> 那你怎么办呢？我们可以看看数据库能做什么！他们有一个称为游标的概念，它是指向行的指针。因此，您可以对数据库说“在那之后还给我100行”。数据库的操作要容易得多，因为您很有可能会通过带有索引的字段来识别行。突然之间，您不需要获取和跳过这些行，就可以直接越过它们。</p><p>   API returns an (opaque) string, which you can use then to retrieve the next page:</p><p>   API返回一个（不透明的）字符串，您可以使用它来检索下一页：</p><p>  Implementation-wise there are many options. Generally, you have some ordering criteria, for example, product id. In this case, you’ll encode your product id with some reversible algorithm (let’s say  hashids). And on receiving a request with the cursor you decode it and generate a query like  WHERE id &gt; :cursor LIMIT 100.</p><p>  在实现方面有很多选择。通常，您有一些订购条件，例如产品ID。在这种情况下，您将使用某种可逆算法（例如，哈希码）对产品ID进行编码。并在收到带有游标的请求后，将其解码并生成一个查询，例如WHERE id＆gt; ：光标限制为100。 </p><p>  =# explain analyze select id from product offset 10000 limit 100; QUERY PLAN --------------------------------------------------------------------------------------------------------------------------------- Limit (cost=1114.26..1125.40 rows=100 width=4) (actual time=39.431..39.561 rows=100 loops=1) -&gt; Seq Scan on product (cost=0.00..1274406.22 rows=11437243 width=4) (actual time=0.015..39.123 rows=10100 loops=1) Planning Time: 0.117 ms Execution Time: 39.589 ms</p><p>=＃说明分析产品偏移量10000限制100中的选择ID；查询计划------------------------------------------------ -------------------------------------------------- -------------------------------限制（费用= 1114.26..1125.40行= 100宽度= 4）（实际时间= 39.431..39.561行= 100循环= 1）->对产品进行Seq扫描（成本= 0.00..1274406.22行= 11437243宽度= 4）（实际时间= 0.015..39.123行= 10100循环= 1）计划时间：0.117毫秒执行时间：39.589毫秒</p><p>  =# explain analyze select id from product where id &gt; 10000 limit 100; QUERY PLAN ------------------------------------------------------------------------------------------------------------------------------ Limit (cost=0.00..11.40 rows=100 width=4) (actual time=0.016..0.067 rows=100 loops=1) -&gt; Seq Scan on product (cost=0.00..1302999.32 rows=11429082 width=4) (actual time=0.015..0.052 rows=100 loops=1) Filter: (id &gt; 10000) Planning Time: 0.164 ms Execution Time: 0.094 ms</p><p>  =＃解释分析ID为＆gt;的产品中的选择ID。 10000限制100;查询计划------------------------------------------------ -------------------------------------------------- ----------------------------限制（费用= 0.00..11.40行= 100宽度= 4）（实际时间= 0.016 .. 0.067行= 100循环= 1）->对产品进行序列扫描（成本= 0.00..1302999.32行= 11429082宽度= 4）（实际时间= 0.015..0.052行= 100循环= 1）过滤器：（id＆gt; 10000）计划时间：0.164 ms执行时间：0.094多发性硬化症</p><p> That is a difference of several orders of magnitude! Of course, the actual numbers depend on a size of a table, on your filters and on a store implementation. There  a great article with more technical information - there are slides embedded, see slide 42 for performance comparison.</p><p> 这相差几个数量级！当然，实际数字取决于表的大小，过滤器和商店实现。有一篇很棒的文章提供了更多的技术信息-内嵌了幻灯片，有关性能比较，请参见幻灯片42。</p><p> Of course, nobody orders products by an id — you usually order them by some relevancy (and then by id as a  tie breaker). In the real world, you’ll have to look at your data to determine what to do. Orders can be ordered by id (as it’s monotonically increasing). Wishlist items can be ordered like that as well — by wishlisting time. In our case products come from ElasticSearch, which naturally supports this cursor stuff.</p><p> 当然，没有人按ID订购产品-您通常按相关性订购产品（然后按ID作为平局决定）。在现实世界中，您必须查看数据才能确定要做什么。订单可以按ID排序（单调递增）。愿望清单项目也可以像这样订购-通过愿望清单时间。在我们的案例中，产品来自ElasticSearch，它自然支持此游标。</p><p> One deficiency you can see is that it’s impossible to generate a “previous page” link with a stateless API. So in case of a user-facing pagination, if it’s important to have prev/next and “go directly to page 10” buttons there is no way around this offset/limit stuff. But in other cases using cursor-based pagination can greatly improve performance, especially on really big tables with really deep pagination.</p><p> 您会看到一个不足之处，就是无法使用无状态API生成“上一页”链接。因此，在面向用户的分页的情况下，如果要具有上一个/下一个和“直接进入第10页”按钮很重要，则无法解决此偏移/限制问题。但是在其他情况下，使用基于游标的分页可以大大提高性能，尤其是在具有深分页的非常大的表上。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://solovyov.net/blog/2020/api-pagination-design/">https://solovyov.net/blog/2020/api-pagination-design/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/id/">#id</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>