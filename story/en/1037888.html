<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>从线圈到曲线–椭圆曲线密码学入门 From Coils to Curves – A Primer on Elliptic Curve Cryptography</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">From Coils to Curves – A Primer on Elliptic Curve Cryptography<br/>从线圈到曲线–椭圆曲线密码学入门 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-05 16:27:58</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/f3cca194bebbc4a27d77273afc53f3f9.jpeg"><img src="http://img2.diglog.com/img/2020/12/f3cca194bebbc4a27d77273afc53f3f9.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Elliptic curves are seemingly ubiquitous in modern cryptographic protocols, and may turn up again later this December. Let’s take this opportunity to gain insight on what they are and why they are used.</p><p>椭圆曲线在现代密码协议中似乎无处不在，并且可能在今年12月下旬再次出现。让我们借此机会深入了解它们是什么以及为什么使用它们。</p><p> It is well known that prime numbers are important for cryptography, although it has not always been true. The advent of primes came with several groundbreaking papers almost 50 years ago. Pioneers in introducing asymmetric cryptography, Whit Diffie, Martin Hellman, Ron Rivest, Adi Shamir and Leonard Adleman, used results from number theory to build key agreement, encryption, and signatures. Prime numbers hold a very special position in number theory, and this carried over to cryptography.</p><p> 众所周知，素数对密码学很重要，尽管并非总是如此。素数的出现伴随着将近50年前的几篇开创性论文。引入非对称密码学的先驱Whit Witt Diffie，Martin Hellman，Ron Rivest，Adi Shamir和Leonard Adleman利用数论的结果来构建密钥协议，加密和签名。质数在数论中占有非常特殊的位置，这一直延续到密码学中。</p><p>  Cryptographic protocols are typically working  modulo some prime  p. This can be likened to turning the number line into a coil, such that 0,  p, 2 p, etc. all join at the same place. From then on, whenever we add or multiply the number such that we go beyond  p, we can simply remove as many multiples of  p as necessary until we come between 0 and  p again.</p><p>  加密协议通常以某些素数p为模。这可以比喻为将数字线变成一个线圈，使得0，p，2p等都在同一位置连接。从那时起，每当我们对数字进行加法或乘积运算以使我们超过p时，我们都可以根据需要简单地删除p的倍数，直到我们再次介于0和p之间。</p><p> Now, imagine that we used a composite number instead, for example 12. Then 0 and 12 are &#34;the same&#34; in this situation, but that also means that 3 multiplied by 4 is ... 0! One of the intuitions when working with normal numbers is that if  ab = 0, then either  a or  b would have to be 0. Hence, when using composite numbers, there is simply stuff that no longer works the way we’re used to. Fortunately, this is not the case when using the primes — for instance 7 — as our so-called modulus.</p><p> 现在，假设我们改为使用一个复合数字，例如12。那么0和12是相同的。在这种情况下，但这也意味着3乘以4就是... 0！处理普通数字的一种直觉是，如果ab = 0，则a或b必须为0。因此，当使用复合数字时，有些东西将不再像以前那样工作。幸运的是，使用素数（例如7）作为我们的所谓模数时，情况并非如此。</p><p>  Let’s make a rule, and let’s call it  m. We take the coil we just made from the number line, and since we can always reduce numbers to below  p, we label our points on this circle from 0 to  p-1. Given two points  a and  b on the circle, we decided that the output of the rule  m( a,  b) should be the point which is represented by the product  ab, possibly after reducing modulo  p. It may look like a very natural rule, but it is nonetheless a rule we just agreed on. If you play around with this rule a bit, you will notice some properties:</p><p>  让我们制定一条规则，并称之为m。我们从数字线上取下刚制成的线圈，由于我们总是可以将数字减小到p以下，因此我们将该圆上的点标记为从0到p-1。给定圆上的两个点a和b，我们认为规则m（a，b）的输出应该是乘积ab表示的点，可能是在减少了模p之后。它看起来像是很自然的规则，但这仍然是我们刚刚同意的规则。如果您稍微遵循此规则，则会发现一些属性：</p><p> For any  a,  b not equal to 0,  m( a,  b) is never zero. So, if we removed 0 from the circle entirely, no harm would happen — the rule would still be well-defined.</p><p> 对于任何不等于0的a，b，m（a，b）永远不会为零。因此，如果我们从圆中完全删除0，就不会造成伤害-该规则仍然是明确定义的。</p><p> For any nonzero  a, there is always some  b such that  m( a,  b) = 1.</p><p> 对于任何非零的a，总会有一些b使得m（a，b）= 1。 </p><p> These nice properties — together with a property called associativity — are the properties we need to be able to do cryptographic computations.</p><p>这些漂亮的属性以及称为“关联性”的属性是我们进行密码计算所需的属性。</p><p> Now focus on a particular number on the circle, and let’s call it  g. If we take  m( g,  g), or — to return to the more usual notation —  g², we will reach a new point on the circle. We can continue this process and compute  g³,  g⁴, etc. At some point, we will reach 1. All the points we have visited in this process are members of the set of numbers  generated by  g, and if the number of points on the coil is a large prime, then we have a very good candidate for doing cryptography, for example Diffie-Hellman key exchange. Let  h be some number in this set generated by  g. That means that  h =  gᵉ for some exponent  e. If it is easy to find this  e from  g and  h, we would have trouble. Fortunately, it turns out that if we use  large enough primes, then this  e appears to be very difficult to find.</p><p> 现在，将重点放在圆圈上的特定数字上，我们称之为g。如果取m（g，g）或-返回更常用的表示法-g²，我们将在圆上到达新的点。我们可以继续该过程并计算g³，g⁴等。在某个点上，我们将达到1。在此过程中，我们访问的所有点都是g生成的数字集的成员，并且如果coil是一个很大的素数，那么我们有一个很好的候选人来进行加密，例如Diffie-Hellman密钥交换。令h是g生成的该集合中的某个数字。这意味着对于某些指数e，h =gᵉ。如果很容易从g和h中找到这个e，我们将遇到麻烦。幸运的是，事实证明，如果我们使用足够大的素数，那么很难找到这个e。</p><p>  Coiling up the number line is not the only way of finding suitable primitives for cryptography. Let’s make a new rule. Instead of using a circle like we did in the previous section, we consider the following equation:</p><p>  汇总数字行并不是找到适合密码学的原语的唯一方法。让我们制定一条新规则。与其使用上一节中的圆形，不如考虑以下方程式：</p><p>  If we graph this in our usual coordinate system, it may look like this curve:</p><p>  如果我们在通常的坐标系中绘制图形，则它可能看起来像这样的曲线：</p><p>  We will now make a rule on how to combine two distinct points  P and  Q on this curve. The agreed upon notation is to call this rule addition, but we will have to define what we mean by that. Programming languages often include this mental concept as operation overloading. Draw the straight line between  P and  Q. It will intersect at a third point, say,  R. This could have been a nice candidate for  P +  Q, but since we are making the rules, let’s make this a bit more interesting. Draw a vertical line through  R. It will intersect the curve on the opposite side of the  x-axis, and we define this point as  P +  Q. Just as before, this is a rule we’re deciding here and now. However, this also turns out to be a very useful rule, with the same properties as before:</p><p>  现在，我们将就如何组合此曲线上的两个不同点P和Q制定一条规则。商定的表示法是称此规则加法，但是我们必须定义我们的意思。编程语言通常将这种思想概念包括为操作重载。画出P和Q之间的直线。它将在第三点相交，例如R。这可能是P + Q的不错选择，但是由于我们正在制定规则，因此让我们变得更加有趣。在R上画一条垂直线。它将与x轴另一侧的曲线相交，我们将此点定义为P +Q。像以前一样，这是我们现在和现在要决定的规则。但是，这实际上也是一条非常有用的规则，具有与以前相同的属性：</p><p> Instead of having the point 1 on the circle, we imagine a point infinitely far up. (Remember what you see when looking at railway tracks: parallel lines actually meet beyond the horizon, at infinity.) So, now the line intersecting  R and  P +  Q is indeed also intersecting a third point: the point at infinity. This can be made precise, but requires maths from algebraic geometry, which is far beyond the scope of this blog post. This point at infinity has all the same properties as 1 had above.</p><p> 而不是将点1放在圆上，我们想象一个点无限远。 （记住在看铁轨时所看到的：平行线实际上在无限远处相交超出了地平线。）因此，现在与R和P + Q相交的线确实也与第三点相交：无限点。可以很精确地做到这一点，但是需要代数几何进行数学运算，这远远超出了本博客文章的范围。无穷大点具有与上述1相同的所有属性。</p><p> For any point  S on the curve, there is always a point  T such that we get a line intersecting  S,  T and the point at infinity. This means that for any point  S, we can find a point we can call - S.</p><p> 对于曲线上的任何点S，总会有一个点T，这样我们就得到了一条与S，T和无穷大点相交的线。这意味着对于任何点S，我们都可以找到可以称为-S的点。 </p><p>   We just assumed that  P and  Q were distinct. If  P =  Q, then we simply use the tangent to the curve at point  P instead, and proceed as before.</p><p>我们只是假设P和Q是不同的。如果P = Q，则我们仅使用点P处的曲线的切线，然后像以前一样进行。</p><p> In particular, take a point  G, and compute 2 G =  G +  G, 3 G, 4 G, etc. Eventually, we reach the point at infinity, and then back to  G. We have now spent about 1000 words of this blog post getting here, just to do the same as we did above, and what was the point? Above, we said that computing exponents are secure if the primes were large enough. It turns out that &#34;large enough&#34; is currently about 3072 bits, or a number with approximately 925 digits. That is somewhat strenuous even for a computer, but the elliptic curve version only requires us to work on numbers of size 256 bits, or 77 digits, which is far more efficient.</p><p> 特别是，取一个点G，然后计算2 G = G + G，3 G，4 G等。最终，我们到达无穷大点，然后回到G。我们现在已经花了大约1000个单词来写博客到达这里后，只是要做与我们上面相同的事情，这有什么意义？上面我们说过，如果素数足够大，计算指数是安全的。事实证明，＆＃34;足够大＆＃34;目前大约为3072位，或者是大约925位的数字。即使对于计算机来说，这也有些费劲，但是椭圆曲线版本仅要求我们处理256位或77位数字，效率更高。</p><p>  The Diffie-Hellman key-exchange protocol is widely used today, and its instantiation using elliptic curves is ranked as the best choice in modern cryptographic protocols like TLS and SSH. The protocol is fairly simple. The public information is an elliptic curve  E and a generator  G for the points on this curve. One party, Alice, samples a random integer  a and computes a point  A =  a  G. Another party, Bob, samples a random integer  b and computes  B =  b  G. Then they exchange the values  A and  B, and compute the shared key  K =  b  A =  a  B =  a  b  G. As long as both  a and  b stay secret, even when an attacker knows  G,  A and  B, then the key is secure.</p><p>  Diffie-Hellman密钥交换协议今天已被广泛使用，并且使用椭圆曲线进行实例化已被评为TLS和SSH等现代加密协议中的最佳选择。该协议非常简单。公共信息是椭圆曲线E和该曲线上各点的生成器G。一方爱丽丝（Alice）对一个随机整数a采样并计算点A = aG。另一方鲍勃（Bob）对一个随机整数b进行采样并计算B = bG。然后他们交换值A和B，并计算共享密钥。 K = b A = a B = abG。只要a和b都保持秘密，即使攻击者知道G，A和B，那么密钥也是安全的。</p><p>   To achieve long-term security, to protect previous messages in the case where someone’s secret keys are leaked after the fact, Alice and Bob can do an ephemeral key-exchange every time they communicate. If  a and  A is Alice’s long term key pair where  A is public to everyone, and similar for Bob, they can run the following protocol to agree upon a one-time session-key. Alice samples a random integer  c and computes  C =  c  G, and Bob samples a random integer  d and computes  D =  d  G. Then they exchange  C and  D, and compute the shared key as ( a  b +  c  d ) G.</p><p>   为了获得长期安全性，并在事后泄露某人的秘密密钥的情况下保护先前的消息，Alice和Bob可以在每次通信时进行临时密钥交换。如果a和A是Alice的长期密钥对，而A对所有人都是公共的，而Bob则相似，则他们可以运行以下协议来达成一次性会话密钥。爱丽丝对随机整数c进行采样并计算C = c G，鲍勃对随机整数d进行采样并计算D = dG。然后他们交换C和D，并将共享密钥计算为（a b + c d）G。</p><p> The interested reader can check out this  simple example written in Go. Are you able to extend the basic protocol to the ephemeral key-exchange on behalf of Alice and Bob?</p><p> 有兴趣的读者可以查看一下用Go编写的简单示例。您是否能够代表Alice和Bob将基本协议扩展到临时密钥交换？</p><p> We finally point out that this protocol is vulnerable to a man-in-the-middle attack, and we need to also send signatures computed on the messages to ensure that the communication is authentic. Are you able to attack the protocol as described above, when signatures are not used? If you found these problems interesting, we encourage you to check out similar challenges at  cryptohack.org.</p><p> 最后，我们指出该协议容易受到中间人攻击，并且我们还需要发送对消息计算得出的签名，以确保通信是真实的。不使用签名时，您是否能够如上所述攻击协议？如果您发现这些问题很有趣，我们建议您在cryptohack.org上检查类似的挑战。</p><p>  Not all elliptic curves are suitable for cryptography. There could also be power in choosing a curve and the distinguished base point(s). Hence, implementations tend to choose among a small number of well-known curves. The US National Institute of Standards and Technology  maintains a list of recommended curves; P-256 is perhaps the most popular among these.</p><p>  并非所有的椭圆曲线都适合加密。选择曲线和可分辨的基点也可能很有用。因此，实现倾向于在少量的众所周知的曲线中进行选择。美国国家标准技术研究院保留了推荐曲线的列表；其中P-256可能是最受欢迎的。 </p><p> Among others, there is also the  SafeCurves collection proposed by Dan Bernstein and Tanja Lange. In particular, their Curve25519 has proven to be a popular choice.</p><p>其中，还有Dan Bernstein和Tanja Lange提出的SafeCurves系列。 特别是，他们的Curve25519已被证明是受欢迎的选择。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/密码/">#密码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/曲线/">#曲线</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/curves/">#curves</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>