<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在Xbox 360（2018）中找到CPU设计错误 Finding a CPU Design Bug in the Xbox 360 (2018)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Finding a CPU Design Bug in the Xbox 360 (2018)<br/>在Xbox 360（2018）中找到CPU设计错误 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-12 10:01:45</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/6f3c3fbf3aa64cda09efd450373ae3f4.jpg"><img src="http://img2.diglog.com/img/2021/6/6f3c3fbf3aa64cda09efd450373ae3f4.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The recent reveal of  Meltdown and  Spectre reminded me of the time I found a related design bug in the Xbox 360 CPU – a newly added instruction whose mere existence was dangerous.</p><p>最近的阐述和幽灵提醒我的时间我在Xbox 360 CPU中找到了一个相关的设计错误 - 一个新添加的指令，其仅存在危险。</p><p> Back in 2005 I was the Xbox 360 CPU guy. I lived and breathed that chip. I still have a 30-cm CPU wafer on my wall, and a four-foot poster of the CPU’s layout. I spent so much time understanding how that CPU’s pipelines worked that when I was asked to investigate some impossible crashes I was able to intuit how a design bug must be their cause. But first, some background…</p><p> 回到2005年我是Xbox 360 CPU的家伙。我活着呼吸那芯片。我的墙上仍然有一个30厘米的CPU晶圆，以及CPU布局的四英尺海报。我花了很多时间了解CPU的管道如何工作，当我被要求调查一些不可能的崩溃时，我能够在设计错误的情况下如何成为他们的原因。但首先，一些背景......</p><p>  The Xbox 360 CPU is a three-core PowerPC chip made by IBM. The three cores sit in three separate quadrants with the fourth quadrant containing a 1-MB L2 cache – you can see the different components, in the picture at right and on my CPU wafer. Each core has a 32-KB instruction cache and a 32-KB data cache.</p><p>  Xbox 360 CPU是IBM制造的三核PowerPC芯片。三个核心位于三个单独的象限中，第四象限包含1-MB L2缓存 - 您可以在右侧和CPU晶圆上看到不同的组件。每个核心具有32 kB指令缓存和32 kB数据缓存。</p><p> Trivia: Core 0 was closer to the L2 cache and had measurably lower L2 latencies.</p><p> 琐事：核心0更接近L2缓存，并具有可测量的L2延迟。</p><p> The Xbox 360 CPU had high latencies for everything, with memory latencies being particularly bad. And, the 1-MB L2 cache (all that could fit) was pretty small for a three-core CPU. So, conserving space in the L2 cache in order to minimize cache misses was important.</p><p> Xbox 360 CPU的一切都具有高延迟，内存延迟特别糟糕。而且，对于三核CPU，1 MB L2缓存（所有可能适合的缓存）非常小。因此，节省L2缓存中的空间以最大限度地减少缓存未命中很重要。</p><p> CPU caches improve performance due to spatial and temporal locality. Spatial locality means that if you’ve used one byte of data then you’ll probably use other nearby bytes of data soon. Temporal locality means that if you’ve used some memory then you will probably use it again in the near future.</p><p> CPU缓存因空间和时间位置而提高性能。空间局部意味着，如果您已经使用了一个字节的数据，那么您可能很快就会使用其他附近的数据字节。时间位置意味着如果您使用了一些内存，那么您可能会在不久的将来再次使用它。</p><p> But sometimes temporal locality doesn’t actually happen. If you are processing a large array of data once-per-frame then it may be trivially provable that it will all be gone from the L2 cache by the time you need it again. You still want that data in the L1 cache so that you can benefit from spatial locality, but having it consuming valuable space in the L2 cache just means it will evict other data, perhaps slowing down the other two cores.</p><p> 但有时候暂时的地方实际上并没有发生。如果要处理大量数据，则每帧一次，那么它可能是微不足道的，即它将在您再次需要时从L2缓存中消失。您仍然希望L1缓存中的数据仍然可以从空间局部受益，但是在L2缓存中消耗有价值的空间只是意味着它会阻碍其他数据，可能会减慢其他两个核心。 </p><p> Normally this is unavoidable. The memory coherency mechanism of our PowerPC CPU  required that all data in the L1 caches also be in the L2 cache. The  MESI protocol used for memory coherency requires that when one core writes to a cache line that any other cores with a copy of the same cache line need to discard it – and the L2 cache was responsible for keeping track of which L1 caches were caching which addresses.</p><p>通常这是不可避免的。我们PowerPC CPU的内存一致性机制要求L1缓存中的所有数据也在L2缓存中。用于内存一致性的MESI协议要求当一个核心写入缓存行时，使用相同的缓存行的副本的任何其他核心需要丢弃它 - 并且L2缓存负责跟踪L1缓存的缓存地址。</p><p> But, the CPU was for a video game console and performance trumped all so a new instruction was added –   xdcbt. The normal PowerPC  dcbt instruction was a typical prefetch instruction. The   xdcbt instruction was an  extended prefetch instruction that fetched straight from memory to the L1 d-cache, skipping L2. This meant that memory coherency was no longer guaranteed, but hey, we’re video game programmers, we know what we’re doing, it will be fine.</p><p> 但是，CPU是用于视频游戏控制台，并且表现胜过所有的性能所以添加了一个新的指令 -  XDCBT。普通PowerPC DCBT指令是典型的预取指令。 XDCBT指令是一个扩展的预取指令，将从存储器直接获取到L1 D-Cache，跳过L2。这意味着内存一致性不再保证，但嘿，我们是视频游戏程序员，我们知道我们在做什么，它会很好。</p><p>  I wrote a widely-used Xbox 360 memory copy routine that optionally used  xdcbt. Prefetching the source data was crucial for performance and normally it would use  dcbt but pass in the PREFETCH_EX flag and it would prefetch with  xdcbt. This was not well-thought-out. The prefetching was basically:</p><p>  我编写了一个广泛使用的Xbox 360内存复制例程，可选择使用XDCBT。预取源数据对于性能至关重要，通常它将使用DCBT，但在预取_EX标志中通过，并且它将使用XDCBT进行预取。这不是很好的想法。预取基本上是：</p><p>  A game developer who was using this function reported weird crashes – heap corruption crashes, but the heap structures in the memory dumps looked normal. After staring at the crash dumps for awhile I realized what a mistake I had made.</p><p>  使用此函数的游戏开发人员报告奇怪的崩溃 - 堆损坏崩溃，但内存转储中的堆结构看起来正常。在盯着崩溃的垃圾箱之后，我意识到了我所犯的错误。</p><p> Memory that is prefetched with  xdcbt is toxic. If it is written by another core before being flushed from L1 then two cores have different views of memory and there is no guarantee their views will ever converge. The Xbox 360 cache lines were 128 bytes and my copy routine’s prefetching went right to the end of the source memory, meaning that  xdcbt was applied to some cache lines whose latter portions were part of adjacent data structures. Typically this was heap metadata – at least that’s where we saw the crashes. The incoherent core saw stale data (despite careful use of locks), and crashed, but the crash dump wrote out the actual contents of RAM so that we couldn’t see what happened.</p><p> 用XDCBT预取的内存有毒。如果它是由另一个核心写成的，然后从L1刷新之前，那么两个核心有不同的内存视图，并且没有保证他们的观点将收敛。 Xbox 360缓存行为128字节，我的复制例程预取右转到源存储器的末尾，这意味着XDCBT应用于后一个部分是相邻数据结构的一部分的一些高速缓存行。通常，这是堆元数据 - 至少是我们看到崩溃的地方。不连贯的核心锯陈旧数据（尽管仔细使用锁），并崩溃，但崩溃转储写出了RAM的实际内容，以便我们看不到发生的事情。</p><p> So, the only safe way to use  xdcbt was to be very careful not to prefetch even a single byte beyond the end of the buffer. I fixed my memory copy routine to avoid prefetching too far, but while waiting for the fix the game developer stopped passing the PREFETCH_EX flag and the crashes went away.</p><p> 因此，使用XDCBT的唯一安全方法是非常小心，即使在缓冲区结束之外也要预取。我修复了我的记忆复制例程，避免预取太远，但在等待修复的时候，游戏开发人员停止传递预取邮件，崩溃崩溃了。</p><p>  So far so normal, right? Cocky game developers play with fire, fly too close to the sun,  marry their mothers, and a game console almost misses Christmas.</p><p>  到目前为止如此正常，对吧？公鸡游戏开发商用火，飞到太阳太靠近阳光，嫁给他们的母亲，一场游戏机几乎错过了圣诞节。 </p><p> But, we caught it in time, we got away with it, and we were all set to ship the games and the console and go home happy.</p><p>但是，我们及时抓住了它，我们逃脱了，我们都设置了发货和控制台，回家快乐。</p><p>  The symptoms were identical. Except that the game was no longer using the  xdcbt instruction. I could step through the code and see that. We had a serious problem.</p><p>  症状相同。除了游戏不再使用XDCBT指令。我可以缩短代码并看到这一点。我们有一个严重的问题。</p><p> I used the ancient debugging technique of staring at my screen with a blank mind, let the CPU pipelines fill my subconscious, and I suddenly realized the problem. A quick email to IBM confirmed my suspicion about a subtle internal CPU detail that I had never thought about before. And it’s the same culprit behind Meltdown and Spectre.</p><p> 我用古代调试技术用空白的心灵盯着我的屏幕，让CPU管道填补我的潜意识，我突然意识到了这个问题。快速电子邮件给IBM确认我怀疑我以前从未想过的微妙内部CPU细节。它是崩溃和幽灵背后的罪魁祸首。</p><p> The Xbox 360 CPU is an in-order CPU. It’s pretty simple really, relying on its high frequency (not as high as hoped despite 10  FO4) for performance. But it does have a branch predictor – its very long pipelines make that necessary. Here’s a publicly shared CPU pipeline diagram I made (my cycle-accurate version is NDA only, but looky  here) that shows all of the pipelines:</p><p> Xbox 360 CPU是一个有序CPU。真的很简单，依靠其高频率（尽管10 o4的高度希望，尽管10 o4）进行性能。但它确实有一个分支预测因素 - 它的长管道使必要。这是一个公开共享的CPU管道图我所做的（我的循环准确版本是NDA，但在这里看起来），显示所有管道：</p><p>  You can see the branch predictor, and you can see that the pipelines are very long (wide on the diagram) – plenty long enough for mispredicted instructions to get up to speed, even with in-order processing.</p><p>  您可以看到分支预测器，并且您可以看到管道长度（图上宽） - 足够长的时间，以便在秩序处理中获得速度的错误指令。</p><p> So, the branch predictor makes a prediction and the predicted instructions are fetched, decoded, and executed – but not retired until the prediction is known to be correct. Sound familiar? The realization I had – it was new to me at the time – was what it meant to speculatively execute a prefetch. The latencies were long, so it was important to get the prefetch transaction on the bus as soon as possible, and once a prefetch had been initiated there was no way to cancel it. So a speculatively-executed  xdcbt was  identical to a real  xdcbt! (a speculatively-executed load instruction was just a prefetch, FWIW).</p><p> 因此，分支预测器使预测，预测指令被提取，解码和执行 - 但未退出，直到已知预测是正确的。听起来有点熟？我有的实现 - 当时对我来说是新的 - 它是推测性地执行预取的意义。延迟很长，因此很快就要尽快在公共汽车上获得预取交易，一旦启动预取，就无法取消它。所以授课的执行XDCBT与真正的XDCBT相同！ （推测执行的负载指令只是预取，FWIW）。</p><p> And that was the problem – the branch predictor would sometimes cause  xdcbt instructions to be speculatively executed and that was just as bad as really executing them. One of my coworkers (thanks Tracy!) suggested a clever test to verify this – replace every  xdcbt in the game with a breakpoint. This achieved two things:</p><p> 这就是问题 - 分支预测因子有时会导致XDCBT指令被推测地执行，并且与真正执行它们的情况也一样糟糕。我的一个同事（谢谢Tracy！）建议验证这个聪明的测试 - 用断点替换游戏中的每一个XDCBT。这实现了两件事： </p><p> The breakpoints were not hit, thus proving that the game was not executing  xdcbt instructions.</p><p>断点未击中，从而证明游戏未执行XDCBT指令。</p><p> I  knew that would be the result and yet it was still amazing. All these years later, and even after reading about  Meltdown, it’s still nerdy cool to see solid proof that instructions that  were not executed were causing crashes.</p><p> 我知道这将是结果，但它仍然是惊人的。这些年后，即使阅读了关于崩溃之后，它仍然是简单的酷，看看未被执行的指令造成崩溃的实心证明。</p><p> The branch predictor realization made it clear that this instruction was too dangerous to have anywhere in the code segment of any game – controlling when an instruction might be speculatively executed is too difficult. The branch predictor for indirect branches could, theoretically, predict any address, so there was no “safe place” to put an  xdcbt instruction. And, if speculatively executed it would happily do an extended prefetch of whatever memory the specified registers happened to randomly contain. It was possible to reduce the risk, but not eliminate it, and it just wasn’t worth it. While Xbox 360 architecture discussions continue to mention the instruction I doubt that any games ever shipped with it.</p><p> 分支预测器实现明确说明这条指令太危险，无法在任何游戏的代码段中的任何位置 - 控制当可能投机地执行的指令太难时。理论上，间接分支的分支预测器可以理解地预测任何地址，因此没有“安全的地方”来放置XDCBT指令。并且，如果推测性地执行，它将愉快地执行指定寄存器发生在随机包含的任何内存中的扩展预取。有可能降低风险，但不能消除它，它不值得。虽然Xbox 360架构讨论继续提及我怀疑任何游戏都会发出的指令。</p><p> I mentioned this once during a job interview – “describe the toughest bug you’ve had to investigate” – and the interviewer’s reaction was “yeah, we hit something similar on the Alpha processor”. The more things change…</p><p> 我在求职期间提到了这次曾经 - “描述了你必须调查的最艰难的虫子” - 面试官的反应是“是的，我们在阿尔法处理器上袭击了类似的东西”。改变的事情越多......</p><p>   How can a branch that is never taken be predicted to be taken? Easy. Branch predictors don’t maintain perfect history for every branch in the executable – that would be impractical. Instead simple branch predictors typically squish together a bunch of address bits, maybe some branch history bits as well, and index into an array of two-bit entries. Thus, the branch predict result is affected by other, unrelated branches, leading to sometimes spurious predictions. But it’s okay, because it’s “just a prediction” and it doesn’t need to be right.</p><p>   如何预设从未拍摄的分支？简单的。分支预测器不会为可执行文件中的每个分支保持完美的历史 - 这将是不切实际的。相反，简单的分支预测器通常会将一堆地址位挤出，也许是一些分支历史比特，并且索引到两位条目的数组中。因此，分支预测结果受其他不相关的分支的影响，导致有时是虚假的预测。但没关系，因为它是“只是一种预测”，它不需要是正确的。</p><p>    This entry was posted in  Debugging and tagged  branch predictors,  Meltdown,  PowerPC,  speculative execution,  Xbox 360. Bookmark the  permalink.</p><p>    此条目在调试和标记的分支预测器，熔点，PowerPC，推测执行，Xbox 360中发布。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://randomascii.wordpress.com/2018/01/07/finding-a-cpu-design-bug-in-the-xbox-360/">https://randomascii.wordpress.com/2018/01/07/finding-a-cpu-design-bug-in-the-xbox-360/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/cpu/">#cpu</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/预取/">#预取</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>