<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使您自己的容器兼容C ++ 20范围 Making Your Own Container Compatible with C++20 Ranges</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Making Your Own Container Compatible with C++20 Ranges<br/>使您自己的容器兼容C ++ 20范围 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-23 05:30:24</div><div class="page_narrow text-break page_content"><p>With some of my spare time lately, I’ve been enjoying learning about some of the new features inC++20.  Concepts and the closely-related  requires clauses are two greatextensions to template syntax that remove the necessity for all the SFINAE junk we used to have todo, making our code both more readable and more precise, and providing much better error messages(although MSVC has sadly been  lagging in the error messages department,at the time of this writing).</p><p>在我的一些业余时间最近，我一直在享受一些新功能Inc ++ 20的学习。概念和与密切相关的条款是模板语法的两个伟大extrisions，可以消除我们曾经拥有的所有Sfinae垃圾的必要性，使我们的代码更加可读，更精确，提供更好的错误消息（尽管MSVC已经悲伤在这个写作时，在错误消息部门一直在滞后）。</p><p> Another interesting C++20 feature is the addition of the  ranges library(also  ranges algorithms), which provides anicer, more composable abstraction for operating on containers and sequences of objects. At the mostbasic level, a range wraps an iterator begin/end pair, but there’s much more to it than that. Thisarticle isn’t going to be a tutorial on ranges, but  here’s a talkto watch if you want to see more of what it’s all about.</p><p> 另一个有趣的C ++ 20特征是添加范围库（也是范围算法），它为在对象的容器和序列上运行而提供了更合作的抽象。在大多数级别，范围内播放迭代器开始/结束对，但它比它更多。本质图并不是在范围内进行教程，但如果您想看到更多的内容，这是一个TalkTo Watch。</p><p> What I’m going to discuss today is the process of adding “ranges compatibility” to your own containerclass. Many of the C++ codebases we work in have their own set of container classes beyond the STLones, for a variety of reasons— better performance, more controlover memory layouts, more customized interfaces, and so on. With a little work, it’s possible tomake your custom containers also function as ranges and interoperate with the C++20 ranges library.Here’s how to do it.</p><p> 我今天要讨论的是将“范围兼容性”添加到您自己的ContainerClass的过程。许多C ++ Codebases我们在拥有自己的一组超出STLONES的容器类，出于各种原因 - 更好的性能，更多的Controlover存储器布局，更自定义的接口等。通过一点工作，您可以剪断您的自定义容器也用作范围，并与C ++ 20范围内互操作。该方法是怎么做的。</p><p>   At the high level, there are two basic ways that a container class can interact with ranges. First,it can be  readable as a range, meaning that we can iterate over it, pipe it into views and pass itto range algorithms, and so forth. In the parlance of the ranges library, this is known as being an input range: a range that can provide input to other things.</p><p>   在高级别，有两种基本方法可以与范围进行交互。首先，它可以作为一个范围可读，这意味着我们可以迭代它，将其引入视图并传递ITTO范围算法，等等。在范围库的概率中，这被称为输入范围：可以为其他东西提供输入的范围。</p><p> The other direction is to accept output  from ranges, storing the output into your container.We’ll do that later. To begin with, let’s see how to make your container act as an input range.</p><p> 另一个方向是接受从范围的输出，将输出存储到容器中.WE将稍后执行此操作。首先，让我们看看如何让您的容器充当输入范围。</p><p>  The first decision we have to make is what particular kind of input range we can model. The C++20STL defines a number of different  concepts for ranges,depending on the capabilities of their iterators and other things. Several of these form a hierarchyfrom more general to more specific kinds of ranges with tighter requirements. Generally speaking, it’sbest for your container to implement the most specific range concept it’s able to. This enables codethat works with ranges to make better decisions and use more optimal code paths. (We’ll see someexamples of this in a minute.)</p><p>  我们必须制作的第一个决定是我们可以模拟的特殊输入范围。 C ++ 20StL定义了许多不同的范围概念，具体取决于其迭代器和其他事物的功能。其中几种在更加细微的范围内形成了一个层次的等级，以更严格的要求。一般来说，你的容器是为了实现它能够的最具体的范围概念。这使CodeThat能够与范围一起工作以进行更好的决策和使用更优化的代码路径。 （我们会在一分钟内看到这个的Someexamples。）</p><p>  std::ranges::input_range: the most bare-bones version. It requires only that you have iterators that can retrieve the contents of the range. In particular, it  doesn’t require that the range can be iterated more than once: iterators are not required to be copyable, and  begin/ end are not required to give you the iterators more than once. This could be an appropriate concept for ranges that are actually generating their contents as the result of some algorithm that’s not easily/cheaply repeatable, or receiving data from a network connection or suchlike.</p><p>  std :: ranges :: input_range：最赤裸的版本。它只需要您具有可以检索范围内容的迭代器。特别是，它不需要该范围可以迭代多次：迭代器不需要复制，并且开始/结束不需要多次向您提供迭代器。这可能是实际生成其内容的范围的适当概念，因为某些算法不容易/不可重复地或从网络连接或类似的数据接收数据。 </p><p> std::ranges::forward_range: the range can be iterated as many times as you like, but only in the forward direction. Iterators can be copied and saved off to later resume iteration from an earlier point, for example.</p><p>std ::范围:: forward_range：范围可以像你喜欢的那样多次迭代，但只能在向前方向。例如，可以将迭代器复制并保存到以后从较早点恢复迭代。</p><p>  std::ranges::random_access_range: you can efficiently do arithmetic on iterators—you can offset them forward or backward by a given number of steps, or subtract them to find the number of steps between.</p><p>  std ::范围:: random_access_range：您可以在迭代器上有效地执行算术 - 您可以通过给定数量的步骤向前或向后抵消它们，或减去它们之间的步骤数。</p><p> std::ranges::contiguous_range: the elements are actually stored as a contiguous array in memory; the iterators are essentially fancy pointers (or literally  are just pointers).</p><p> std ::范围:: contiguous_range：该元素实际上存储为内存中的连续数组;迭代器基本上是花哨的指针（或字面上只是指针）。</p><p> In addition to this hierarchy of input range concepts, there are a couple of other standalone onesworth mentioning:</p><p> 除了输入范围概念的层次结构之外，还有几个其他独立的独立沃思：</p><p> std::ranges::sized_range: you can efficiently get the size of the range, i.e. how many elements from begin to end. Note that this is a much looser constraint than  random_access_range: the latter requires you be able to efficiently measure the distance between  any pair of iterators inside the range, while  sized_range only requires that the size of the  whole range is known.</p><p> std ::范围:: size_range：您可以有效地获得范围的大小，即，从开始结束的元素有多少。请注意，这是一个比randul_access_range更宽松的约束：后者要求您能够有效地测量范围内的任何一对迭代器之间的距离，而尺寸仅要求整个范围的大小是已知的。</p><p> std::ranges::borrowed_range: indicates that a range doesn’t own its data, i.e. it’s referencing (“borrowing”) data that lives somewhere else. This can be useful because it allows references/iterators into the data to survive beyond the lifetime of the range object itself.</p><p> std ::范围:: boRrageD_Range：表示范围不拥有其数据，即它引用（“借用”）在其他地方生活的数据。这可能是有用的，因为它允许引用/迭代器进入数据以超越范围对象本身的寿命。</p><p> The reason all these concepts are important is that if I’m writing code that operates on ranges, I might need torequire some of these concepts in order to do my work efficiently. For example, a sorting routinewould be very difficult to write for anything less than a  random_access_range (and indeed you’llsee that   std::ranges::sort requires that).In other cases, I might be able to do things more optimally when the range satisfies certainconcepts—for instance, if it’s a  sized_range, I could preallocate some storage for results,while if it’s only an  input_range and no more, then I’ll have to dynamically reallocate, as I haveno idea how many elements there are going to be.</p><p> 所有这些概念都很重要的原因是，如果我正在编写在范围内运营的代码，我可能需要torequire一些这些概念，以便有效地完成工作。例如，一个排序例程将非常难以为少于random_access_range编写的（并且确实您将STD :: Ranges :: Sort所要求的）。在其他情况下，我可能能够更好地做事范围满足定张概念 - 例如，如果它是一个尺寸的_range，我可以为结果预先采用一些存储，而如果它只是一个input_range并且不再是，那么我必须动态地重新分配，因为我没有想到有多少元素是。 </p><p> The rest of the ranges library is written in terms of these concepts (and you can write your owncode that operates generically on ranges using these concepts as well). So, once your containersatisfies the relevant concepts, it will automatically be recognized and function as a range!</p><p>根据这些概念编写了其余的范围库（并且您可以编写您的OWSCODE，这些ode在使用这些概念的范围内经常运行）。因此，一旦容器的相关概念，它将自动被识别并用作范围！</p><p> In C++20, concepts act as boolean expressions, so you can check whether your container satisfies theconcepts you expect by just writing asserts for them:</p><p> 在C ++ 20中，概念充当布尔表达式，因此您可以查看您的容器是否满足您期望的Choncepts，只需编写主题：</p><p> #include  &lt;ranges&gt;  static_assert ( std :: ranges :: forward_range &lt; MyCoolContainer &lt; int &gt;&gt; ); // int is just an arbitrarily chosen element type, since we // can&#39;t assert a concept for an uninstantiated template</p><p> #include＆lt;范围＆gt; static_assert（std ::范围:: forward_range＆lt; mycoolcontainer＆lt; int＆gt;）; // int只是一个任意选择的元素类型，因为我们//＆＃39; t＆＃39; t assert为不孤独的模板致意</p><p> Checks like this are great to add to your test suite—I’m big in favor of writing  compile-timetests for generic/metaprogramming stuff, in addition to the usual runtime tests.</p><p> 除了通常的运行时测试之外，您还可以添加到您的测试套件 - 我很大，还有很大，还有很大，有利于为通用/成分造影造成的编译时刻表。</p><p> However, when you first drop that assert into your code, it will almost certainly fail. Let’s seenow what you need to do to actually satisfy the range concepts.</p><p> 但是，当您第一次将其声明到您的代码时，它几乎肯定会失败。让我们看看你需要做些什么来实际满足范围概念。</p><p>   Have  begin and  end functions that return some iterator and sentinel types. (We’ll discuss these in a little bit.)</p><p>   开始和结束函数返回一些迭代器和Sentinel类型。 （我们将在一点点讨论这些。）</p><p> Each one of the concepts from  input_range down to  contiguous_range has a corresponding iterator concept: std::input_iterator,  std::forward_iterator, and so on. It’s these concepts that contain the realmeat of the requirements that define the different types of ranges: they list all the operationseach kind of iterator must support.</p><p> 从input_range down to contip_range的每个概念都有一个相应的迭代器概念：std ::/pinn_iterator，std :: forward_iterator等。这是这些概念，其中包含定义不同类型范围的要求的真实性：它们列出了所有操作员的迭代器必须支持。 </p><p> To begin with, there are a couple of member type aliases that any iterator class will need to define:</p><p>首先，有几个成员类型的别名别名，即任何迭代器类都需要定义：</p><p>  The second one seems pretty understandable, but I honestly have no idea why the  difference_typerequirement is here. Taking the difference between iterators doesn’t make sense until you get torandom-access iterators, which actually define that operation. As far as I can tell, the difference_type for more general iterators isn’t actually  used by anything. Nevertheless,according to the C++ standard, it has to be there. It seems that the usual idiom is to set it to std::ptrdiff_t in such cases, although it can be any signed integer type.</p><p>  第二个似乎是非常可理解的，但我真的不知道为什么差异_typerequirence是这里。在获取Torandom-Access迭代器之前，迭代器之间的差异无意义，实际上定义该操作。据我所知，更多常规迭代器的差异_TYPE实际上并不是用任何东西使用。尽管如此，根据C ++标准，必须在那里。似乎通常的成语是在这种情况下将其设置为std :: ptriff_t，但它可以是任何符号的整数类型。</p><p> (Technically you can also define these types by specializing  std::iterator_traits for your iterator,but here we’re just going to put them in the class.)</p><p> （从技术上讲，您还可以通过专门用于您的迭代器的STD :: Iterator_traits来定义这些类型，但在这里我们只是将它们放在课堂上。）</p><p>  The iterator must be default-initializable and movable. (It doesn’t have to be copyable.)</p><p>  迭代器必须是默认的初始化和可移动的。 （它不一定是可复制的。）</p><p> It must be equality-comparable with its sentinel (the value marking the end of the range). It doesn’t have to be equality-comparable with other iterators.</p><p> 它必须与其哨兵相等（标记范围结束的值）相等。它不一定与其他迭代器相等。</p><p> It must implement  operator ++, in  both preincrement and postincrement positions. However, the postincrement version does not have to return anything.</p><p> 它必须实施运算符++，在额先折叠和帖子段落位置。但是，PostIncrement版本不必返回任何内容。</p><p> It must have an  operator * that returns a reference to whatever the  value_type is.</p><p> 它必须具有运算符*，可返回value_type的任何引用。 </p><p> One point of interest here is that the default-initializable requirement means that the iterator classcan’t contain references, e.g. a reference to the container it comes from. It can store pointers,though.</p><p>这里有一个兴趣点是默认初始化的要求意味着迭代器ClassCan不包含引用，例如，它来自它来自的容器的参考。但它可以存储指针。</p><p>  template  &lt; typename  T &gt; class  Iterator { public :  using  difference_type  =  std :: ptrdiff_t ;  using  value_type  =  T ;  Iterator ();  // default-initializable  bool  operator  ==  ( const  Sentinel &amp; )  const ;  // equality with sentinel  T &amp;  operator  *  ()  const ;  // dereferenceable  Iterator &amp;  operator  ++  ()  // pre-incrementable  {  /*do stuff...*/  return  * this ;  }  void  operator  ++  ( int )  // post-incrementable  {  ++* this ;  } private :  // implementation... };</p><p>  模板＆lt; typename t＆gt; class迭代器{public：使用diversy_type = std :: ptrdiff_t;使用value_type = t;迭代器（）; //默认初始化Bool运算符==（const sentinel＆amp;）const; // Sentinel T＆amp的平等;运营商*（）const; //取消转移迭代器＆amp;运算符++（）//预递增{/ * do stuff ... * /返回*这; void运算符++（int）//后递增{++ *这;私人：//实现...};</p><p>    template  &lt; typename  T &gt; class  Iterator { public :  // ...same as the previous one, except:  bool  operator  ==  ( const  Iterator &amp; )  const ;  // equality with iterators  void  operator  ++  ( int )  // post-incrementable  {  Iterator  temp  =  * this ;  ++* this ;  return  temp ;  } };</p><p>    模板＆lt; typename t＆gt;类迭代器{public：// ...与前一个相同，除了：bool运算符==（const iterator＆amp;）const; //迭代器的平等void运算符++（int）//后递增{iterator temp = * this; ++ *这个;返回温度; }};</p><p> I’m not going to go through the rest of them in detail; you can read the details on cppreference.</p><p> 我不会详细介绍剩下的;您可以阅读CPPreference的详细信息。</p><p>  Once your container is equipped with an iterator class that satisfies the relevant concepts, you’llneed to provide  begin and  end functions to get those iterators. There are three ways to do this:they can be member functions on the container, they can be free functions that live next to thecontainer in the same namespace, or they can be  “hidden friends”;they just need to be findable by  ADL.</p><p>  一旦您的容器配备了满足相关概念的迭代器类，您将提供开始和结束功能以获取那些迭代器。有三种方法可以这样做：它们可以是容器上的成员函数，它们可以是生活在同一名称空间中的Thecontainer旁边的免费功能，或者他们可以是“隐藏的朋友”;他们只需要通过ADL找到。</p><p> The return types from  begin and  end don’t have to be the same. In some cases, it can be usefulto have  end return a different type of object, a “sentinel”, which isn’t actually an iterator; itjust needs to be equality-comparable with iterators, so you can tell when you’ve gotten to the endof the container.</p><p> 从开始和结束的返回类型不必是相同的。在某些情况下，它可以使用方法返回不同类型的对象，一个“sentinel”，这不是一个迭代器; ITJust需要与迭代器相等，因此您可以告诉您何时已将容器结束。</p><p>  One oddity worth mentioning here is that if you go the free/friend functions route, you’ll need toadd overloads for both const and non-const versions of your container:</p><p>  这里值得一提的一个奇怪的是，如果你去了免费/朋友的函数路线，你将需要容器的const和non-const版本的toadd过载： </p><p>  You might think it would be enough to provide just the const overloads, but if you do that, only theconst version of the container will be recognized as a range! The non-const overloads must bepresent as well for non-const containers to work.</p><p>您可能认为只需提供const重载就足够了，但如果您这样做，只有Contain的Contapt的TheConst版本将被识别为范围！对于非Const容器来说，非Const重载必须存在展望。</p><p> Curiously, if you provide  begin/ end as member functions instead, then this doesn’t come up:const overloads will work for both.</p><p> 奇怪的是，如果您将开始/结束作为成员函数，那么这未提出：Const重载将为两者都工作。</p><p> This behavior is surprising, and I’m not sure if it was intended. However, it’s worth noting thatiterators generally need to remember the constness of the container they came from: a constcontainer should give you a “const iterator” that doesn’t allow mutating its elements. Therefore,the const and non-const overloads of  begin/ end will generally need to return  differentiterator types, and so you’ll need to have both in any case. (The exception would be if you’rebuilding an immutable container; then it only needs a const iterator type.)</p><p> 这种行为令人惊讶，而且我不确定它是否有意。然而，值得注意的是，据说骗局通常需要记住他们来自的容器的常规：ConstContainer应该给你一个“const迭代器”，它不允许突变其元素。因此，开始/结束的const和非const重载通常需要返回不同的壁器类型，因此您需要在任何情况下都有两个。 （如果是您的构建不可变容器，则会是例外;那么它只需要Const迭代器类型。）</p><p> In addition to  begin and  end, you’ll also want to implement a  size function, if applicable.Again, this can be either a member function, a free function, or a hidden friend. Thepresence of this function satisfies  std::ranges::sized_range, which (as mentioned earlier) canenable range algorithms to operate more efficiently.</p><p> 除了开始和结束外，您还需要实现大小函数，如果适用.AGAIN，这可以是成员函数，免费功能或隐藏的朋友。此函数的主题满足STD ::范围:: size_range，该扫描范围算法（如前所述）算法更有效地运行。</p><p> So, to sum up: to allow your custom container class to be readable as a range, you’ll need to:</p><p> 所以，总结：允许您的自定义容器类作为范围可读，您需要：</p><p> Decide which range concept(s) you can model, which mainly comes down to what level of iterator capabilities you can provide;</p><p> 确定您可以模型的范围概念，这主要是您可以提供的迭代功能级别的级别;</p><p> Implement iterator classes (both const and non-const, if applicable) that fulfill all the requirements of the chosen iterator concept;</p><p> 实现迭代师类（如果适用）符合所选迭代器概念的所有要求的迭代器类（如果适用）; </p><p> Once we’ve done this, the ranges library should recognize your container as a range. It willautomatically be accepted by range algorithms, we can take views of it, we can iterate over it inrange-for loops, and so on.</p><p>完成此操作后，Ranges库应将您的容器识别为范围。它将通过范围算法接受它，我们可以拍摄它，我们可以迭代IT Itange-for Loops，等等。</p><p> As before, you can test that you’ve done everything correctly by asserting that your containersatisfies the expected range concepts. If you’re working with gcc or clang, this will even give yousome pretty reasonable error messages if you didn’t get it right! (In MSVC, for the time being, you’llhave to narrow down errors by popping open the hood and asserting each of the concept’s sub-clausesone at a time, to see which one(s) failed.)</p><p> 如前所述，您可以通过断言您的容器是预期的范围概念来测试您正确地完成了所有事情。如果您正在使用GCC或Clang，如果您没有正确效力，这甚至会给您提供相当合理的错误消息！ （在MSVC中，暂时，通过弹出敞篷并一次断言每个概念的子字核来缩小错误，以查看哪一个失败。）</p><p>  We’ve discussed how to make a custom container serve as input  to the C++20 ranges library. Now, weneed to come back to the other direction: how to let your container capture output  from theranges library.</p><p>  我们讨论了如何使自定义容器用作C ++ 20范围库的输入。现在，随后将返回另一个方向：如何让您的容器捕获从威胁库的输出。</p><p> There are a couple of different forms this can take. One way is to accept generic ranges asparameters to a constructor (or other methods, such as append or insert methods) of your containerclass. This allows, for example, easily converting other containers (that are also range-compatible)to your container. It also allows capturing the output of a ranges “pipeline” (a series of viewschained together).</p><p> 有几种不同的形式可以采取。一种方法是接受仿制函数的仿制函数（或其他方法，例如容器的其他方法，例如附加或插入方法）。例如，这允许容易地将其他容器（即也兼容的范围兼容）转换给容器。它还允许捕获范围的输出“流水线”（一系列视图将在一起）。</p><p> Another form of range output, which comes up with certain of the  range algorithms,is via  output iterators, which are iterators that allow storing or inserting values into yourcontainer.</p><p> 另一种形式的范围输出，它出现了某些范围算法，是通过输出迭代器，它是允许将值存储或插入occontainer的迭代器。</p><p>  To write a constructor (or other method) that takes a generic range parameter, we can use the samerange concepts we saw earlier. One neat new feature in C++20 is writing functions with a parametertype (or return type) constrained to match a given concept. The syntax looks like this:</p><p>  要编写拍摄泛型范围参数的构造函数（或其他方法），我们可以使用我们之前看到的SameRange概念。 C ++ 20中的一个简洁的新功能是用参数（或返回类型）的写入函数，约束以匹配给定概念。语法看起来像这样：</p><p> #include  &lt;ranges&gt;  class  MyCoolContainer { public :  explicit  MyCoolContainer ( std :: ranges :: input_range  auto &amp;&amp;  range )  {  for  ( auto &amp;&amp;  item  :  range )  {  // process the item  }  } };</p><p> #include＆lt;范围＆gt; class mycoolcontainer {public：显式mycoolcontainer（std ::范围:: input_range auto＆amp;＆amp;范围）{for（auto＆amp;＆amp;项目：范围）{//处理项目}}; </p><p> The syntax  concept-name auto for the parameter type reminds us that concepts aren’t types; thisis still, under the hood, a template function that’s performing argument type deduction (hence the auto). In other words, the above is syntactic sugar for:</p><p>参数类型的语法概念名称自动提醒我们概念不是类型; intinis仍然在引擎盖下，一个执行参数类型扣除的模板函数（因此自动）。换句话说，以上是句法糖：</p><p>    I prefer the shorthand  std::ranges::input_range auto syntax, but at the time of this writingMSVC’s support for it is still shaky (it should be fixed in 16.10, I hope). If in doubt, usethe syntax  template &lt;std::ranges::input_range R&gt;.</p><p>    我更喜欢速记std ::范围:: input_range自动语法，但在这篇写作的时间仍然是摇晃（它应该在16.10中修复）。如果有疑问，useShe语法模板＆lt; std ::范围:: input_range r>。</p><p> In any case, constraining the parameter type to satisfy  input_range allows this constructoroverload to accept anything out there that implements  begin,  end, and iterators, as we’ve seenin previous sections. You can then iterate over it generically and do whatever you want with theresults.</p><p> 在任何情况下，约束参数类型以满足input_range允许此构造overload在那里接受任何内容，它可以实现开始，结束和迭代器，正如我们在上一节中看到的那样。然后，您可以慷慨地迭代它，并与其做任何事情做任何事情。</p><p> The range parameter is declared as  auto&amp;&amp; to make it a  universal reference,meaning that it can accept either lvalues or rvalues; in particular, it can accept the result of afunction call returning a range, and it can accept the result of a pipeline:</p><p> 范围参数被声明为Auto＆amp;＆amp;使其成为一个通用的参考，这意味着它可以接受百次数或rvalues;特别是，它可以接受返回范围的上方调用的结果，它可以接受管道的结果：</p><p>  A completely generic range-accepting method like this might not be the most useful thing. If we havea container storing  int values, for example, it wouldn’t make a lot of sense for us to acceptranges of strings or other arbitrary types. We’d like to be able to put some additional constraintson the  element type of the range: perhaps we only want element types that are convertible to  int.</p><p>  完全通用的范围接受方法可能不是最有用的东西。例如，如果我们已经存储int值的容器，我们将无法对串的acceptranges或其他任意类型进行大量意义。我们希望能够将一些额外的Constraintson提供范围的元素类型：也许我们只希望将可转换为int的元素类型。</p><p> Helpfully, the ranges library provides a template   range_value_tthat retrieves the element type of a range—namely, the  value_type declared by the range’siterator. With this, we can state additional constraints like so:</p><p> 有用的，范围库提供模板Range_Value_Tthat检索范围的元素类型 - 即，范围'siterator声明的value_type。有了这个，我们可以说明额外的约束：</p><p>       You can also choose to require one of the more specialized concepts, like  forward_range or random_access_range, if you need those extra capabilities for whatever you’re doing.However, just as a container should generally implement the most  specific range concept it canprovide, a function that takes a range parameter should generally require the most  general rangeconcept it can deal with, or it will unduly restrict what kind of ranges can be passed to it.</p><p>       您还可以选择需要一个更专业化的概念，如forward_range或random_access_range，如果您需要那些您正在执行的任何额外的功能。然而，只要容器通常应该实现最具体的范围概念，它可以难以实现它这需要一个范围参数，通常需要最普遍的rangeconcept它可以处理，或者它将过度限制可以传递什么样的范围。 </p><p> That said, there might be cases where you can switch to a more efficient implementation if the rangesatisfies some extra requirements. For example, if it’s a  sized_range, then you might be able toreserve storage before inserting the elements. You can test for this inside your function body using if constexpr:</p><p>也就是说，如果距离额外的要求，您可能会在其中切换到更有效的实现。例如，如果它是一个尺寸的_range，那么您可能在插入元素之前都可以重返存储。您可以使用constexpr：</p><p> explicit  MyCoolContainer ( input_range_of &lt; int &gt;  auto &amp;&amp;  range ) {  if  constexpr  ( std :: ranges :: sized_range &lt; decltype ( range ) &gt; )  {  reserve ( std :: ranges :: size ( range ));  }  for  ( auto &amp;&amp;  item  :  range )  {  // process the item  } }</p><p> 显式MyCoolContainer（Input_Range_of＆lt; int＆gt; auto＆amp;＆amp;范围）{如果constexpr（std ::范围:: size_range＆lt; decltype（范围）＆gt;）{reaver（std ::范围:: size（范围） ; for（auto＆amp;＆amp;项目：范围）{//处理项目}}</p><p> Here,   std::ranges::size is a convenience wrapperthat knows how to call the range’s associated  size function, whether it’s implemented as a methodor a free function.</p><p> 在这里，STD ::范围::尺寸是一个便利包，Wrapperthat知道如何调用范围的关联大小函数，无论它是否都是一种自由函数。</p><p> You could also do things like: check if the range is a  contiguous_range and the item is somethingtrivially copyable, and switch to  memcpy rather than iterating over all the items.</p><p> 您也可以做的事情：检查范围是否是Contiguous_Range，并且该项目是某种目标可复制的，并且切换到Memcpy而不是迭代所有项目。</p><p>  Range views and pipelines operate on a “pull” model, where the pipeline is represented by a proxyrange object that generates its results lazily when you iterate it. Taking generic range objects asparameters to your container is an easy and useful way to consume such objects, and that probably sufficesfor most uses. However, there are a handful of bits in the ranges library that operate on a “push”model, where you call a function that wants to store values into your container via an outputiterator. This comes up with  certain ranges algorithmslike  ranges::copy,  ranges::transform, and  ranges::generate.</p><p>  范围视图和管道在“拉动”模型上运行，其中管道由Proxyrange对象表示，当您迭代它时会产生懒惰的结果。将通用范围对象响应器到您的容器中是一种容易且有用的方法来消耗此类对象，并且可能足以大多数使用。但是，范围库中存在少数位，它在“推送”模型上运行，您可以通过输出器调用想要将值存储到容器中的函数。这提出了某些范围算法范围:: copy，范围:: transform和范围:: generate。</p><p> Personally, I don’t see a hugely compelling reason to worry about these, as it’s also possible touse views to express the same operations; but for the sake of completeness, I’ll discuss thembriefly here.</p><p> 就个人而言，我看不到令人担忧的令人担忧的原因，因为它也是表达同一行动的淘汰意见;但为了完整起见，我将在这里讨论他们。</p><p> At this point, it won’t surprise you to learn that just as there were concepts for input ranges,there are also concepts  std::ranges::output_range and   std::output_iterator.In this case there’s just that one concept, not a hierarchy of refinements of them; however, if youperuse the definitions of some of the ranges algorithms, you’ll find that many of them don’t actuallyuse  output_iterator, but state slightly different, less- or more-specific requirements of theirown. (This part of the standard library feels a little less fully baked than the rest; I wouldn’t besurprised if some of this gets elaborated or polished a bit more in C++23 or later revisions.)</p><p> 在这一点上，您将不会让您感到惊讶，就像有输入范围的概念一样，也有概念std ::范围:: output_range和std :: outcum_itorirator.in在这种情况下只有那个概念，不是一个他们的改进层次;但是，如果使用某些范围算法的定义，则会发现它们中的许多不实际使用output_iterator，但状态略有不同，较少或更具体的彼此的要求。 （这部分标准图书馆感觉比其他人完全烘烤一点;如果其中一些人在C ++ 23或更高版本的修订中被详细说明或抛光了更多的话，我不会惊讶。） </p><p> The requirements for an output iterator (broadly construed) are very similar to those for an inputiterator, only adding that the value returned by dereferencing the iterator must be writable byassigning to it: you must be able to do  *iter = foo; for some appropriate type of  foo. If you’veimplemented a non-const input iterator, it probably satisfies the requirement already.</p><p>输出迭代器（广泛解释）的要求与输入终端的要求非常相似，只添加了解除解除迭代器返回的值必须可写入它：您必须能够执行* iter = foo;对于一些合适的Foo。如果youmplemented一个非const输入迭代器，它可能已经满足了这些要求。</p><p> It’s also possible to do slightly more exotic things with an output iterator, like returning a proxyobject that accepts assignment and does “something” with the value assigned. An example of this isthe STL’s   std::back_insert_iterator,which takes whatever is assigned to it and  appends to its container (as opposed to overwriting anexisting value in the container). The STL has a few more things like that, including an iteratorthat writes characters out to an  ostream.</p><p> 也可以使用输出迭代器进行稍微异乎寻常的事物，例如返回接受分配的ProxyObject，并使用分配的值进行“某些东西”。这是STL的STD :: back_insert_iterator，它需要分配给它并将其附加到其容器（而不是覆盖容器中的Anexisting值）。 STL还有一些类似的东西，包括一个iteratorthat将字符写入Ostream。</p><p> There are also some cases amongst the ranges algorithms of “input-output” iterators, such as foroperations that reorder a range in place, like sorting. These often have a bidirectional orrandom-access iterator requirement, plus needing the dereferenced types to be swappable, movable,and varying other constraints. Those details probably aren’t going to be relevant to you unlessyou’re doing something tricky, like making a container that generates elements on the fly somehow,or returns proxy objects rather than direct references to elements (like  std::vector&lt;bool&gt;).</p><p> “输入 - 输出”迭代器的范围算法中还有一些情况，例如重新开放的前进，如排序所在的范围。这些通常具有双向orrandom-access迭代器要求，加上需要取消引用的类型来交换，可移动和改变其他约束。这些细节可能不会与您有关，除非您做一些棘手的事情，如制作一个容器，就像在某种程度上发出一瞬间生成元素，或者返回代理对象而不是直接引用元素（如std :: vector＆lt; bool＆gt; bool＆gt; bool＆gt; ）。</p><p>  The C++20 ranges library provides a lot of powerful, composable tools for manipulating sequences ofobjects, and a range of specificity from the most generic and abstract container-shaped things downto the very concrete, efficient, and practical. When working with your own container types, itwould be nice to be able to take advantage of these tools.</p><p>  C ++ 20范围图书馆提供了许多强大，可商品的工具，用于操纵objects的序列，以及从最通用和抽象的容器形状的东西的一系列特异性倾向于非常具体，高效，实用。使用自己的容器类型时，它会很好能够利用这些工具。</p><p> As we’ve seen, it’s hardly an onerous task to implement ranges compatibility for your own containers.Most of the necessaries are things you were probably already </p><p> 正如我们所看到的那样，它几乎不是繁重的任务来实现您自己的容器的范围兼容性。大多数必要性是您已经已经的事情</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.reedbeta.com/blog/ranges-compatible-containers/">https://www.reedbeta.com/blog/ranges-compatible-containers/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/容器/">#容器</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/container/">#container</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/范围/">#范围</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>