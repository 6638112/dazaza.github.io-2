<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>(稍微)了解TCP(2015)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">(稍微)了解TCP(2015)</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-30 10:25:07</div><div class="page_narrow text-break page_content"><p>This isn’t about understanding  everything about TCP or reading through  TCP/IP Illustrated. It’s about how a little bit of TCP knowledge is essential. Here’s why.</p><p>这不是关于理解TCP的所有内容或阅读TCP/IP插图。它是关于一点TCP知识是如何至关重要的。原因如下。</p><p> When I was at the  Recurse Center, I wrote a TCP stack in Python ( and wrote about what happens if you write a TCP stack in Python). This was a fun learning experience, and I thought that was all.</p><p>当我在递归中心时，我用Python编写了一个TCP堆栈(还写了如果用Python编写TCP堆栈会发生什么)。这是一次有趣的学习经历，我想仅此而已。</p><p> A year later, at work, someone mentioned on Slack “hey I’m publishing messages to NSQ and it’s taking 40ms each time”. I’d already been thinking about this problem on and off for a week, and hadn’t gotten anywhere.</p><p>一年后，在工作中，有人在Slake上提到“嘿，我在向NSQ发布消息，每次需要40毫秒。”我断断续续地思考这个问题已经有一个星期了，但毫无进展。</p><p> A little background: NSQ is a queue that you send to messages to. The way you publish a message is to make an HTTP request on localhost. It really should not take  40 milliseconds to send a HTTP request to localhost. Something was terribly wrong. The NSQ daemon wasn’t under high CPU load, it wasn’t using a lot of memory, it didn’t seem to be a garbage collection pause. Help.</p><p>稍微介绍一下背景知识：NSQ是一个队列，您可以将消息发送到该队列。发布消息的方式是在localhost上发出HTTP请求。向localhost发送HTTP请求确实不应该花费40毫秒。有些事出了很大的问题。NSQ守护进程没有处于高CPU负载下，它没有使用大量内存，这似乎不是垃圾收集暂停。帮助。</p><p> Then I remembered an article I’d read a week before called  In search of performance - how we shaved 200ms off every POST request. In that article, they talk about why every one of their POST requests were taking 200 extra milliseconds. That’s.. weird. Here’s the key paragraph from the post</p><p>然后，我想起了一周前我读到的一篇文章--我们如何将每个帖子请求减少了200毫秒。在那篇文章中，他们谈到了为什么他们的每个POST请求都多花了200毫秒。那是..。怪怪的。以下是帖子中的关键段落。</p><p>  Ruby’s Net::HTTP splits POST requests across two TCP packets - one for theheaders, and another for the body. curl, by contrast, combines the two ifthey’ll fit in a single packet. To make things worse, Net::HTTP doesn’t setTCP_NODELAY on the TCP socket it opens, so it waits for acknowledgement of thefirst packet before sending the second. This behaviour is a consequence ofNagle’s algorithm.</p><p>Ruby的net：：HTTP将POST请求分成两个TCP包-一个用于头，另一个用于正文。相比之下，Curl将两者结合在一起，如果它们可以放在一个包中的话。更糟糕的是，Net：：HTTP没有在它打开的TCP套接字上设置TCP_NODELAY，因此它在发送第二个数据包之前等待对第一个数据包的确认。这种行为是纳格尔算法的结果。</p><p> Moving to the other end of the connection, HAProxy has to choose how toacknowledge those two packets. In version 1.4.18 (the one we were using), itopted to use TCP delayed acknowledgement. Delayed acknowledgement interactsbadly with Nagle’s algorithm, and causes the request to pause until the serverreaches its delayed acknowledgement timeout..</p><p>移动到连接的另一端，HAProxy必须选择如何确认这两个数据包。在版本1.4.18(我们使用的版本)中，它选择使用TCP延迟确认。延迟确认与Nagle的算法相互作用严重，并导致请求暂停，直到服务器达到延迟确认超时。</p><p>    application: hi! Here’s packet 1.  HAProxy: &lt;silence, waiting for the second packet&gt; HAProxy: &lt;well I’ll ack eventually but nbd&gt; application: &lt;silence&gt; application: &lt;well I’m waiting for an ACK maybe there’s network congestion&gt; HAProxy: ok i’m bored. here’s an ack application: great here’s the second packet!!!! HAProxy: sweet. we’re done here</p><p>申请：嗨！这是数据包1.HAProxy：&lt；静默，等待第二个数据包&gt；HAProxy：&lt；嗯，我最终还是会确认的，但是NBD&gt；应用程序：&lt；静默&gt；应用程序：&lt；嗯，我在等待ACK，可能是网络拥塞。&lt；HAProxy：好的，我很无聊。这是一个ACK应用程序：太棒了，这是第二个数据包！HAProxy：太好了。我们这里说完了</p><p> That period where the application and HAProxy are both passive-aggressivelywaiting for the other to send information? That’s the extra 200ms. The application is doing it because of Nagle’s algorithm, and HAProxy because of delayed ACKs.</p><p>应用程序和HAProxy都处于被动-主动等待对方发送信息的阶段？这是额外的200ms。应用程序之所以这么做是因为Nagle的算法，而HAProxy是因为延迟的ACK。</p><p> Delayed ACKs happen, as far as I understand, by default on  every Linux system.So this isn’t an edge case or an anomaly – if you send your data in more than 1TCP packet, it can happen to you.</p><p>据我所知，每个Linux系统默认都会发生延迟的ACK，所以这不是边缘情况，也不是异常情况--如果您以超过1个TCP数据包的形式发送数据，那么这种情况可能会发生在您身上。</p><p>  So I read this article, and forgot about it. But I was stewing about my extra 40ms, and then I remembered.</p><p>所以我读了这篇文章，然后就忘了。但是我还在为我额外的40毫秒发愁，然后我就想起来了。</p><p> And I thought – that can’t be my problem, can it? can it??? And I sent an email to my team saying “I think I might be crazy but this might be a TCP problem”.</p><p>我想-那不会是我的问题，对吧？可以吗？我给我的团队发了一封电子邮件，说“我想我可能疯了，但这可能是TCP的问题”。</p><p>    A quick sidebar – I just read  this comment on Hacker News from John Nagle (of Nagle’s algorithm) via  this awesome tweet by @alicemazzy.</p><p>快速侧栏-我刚刚通过@alicemazzy的这条很棒的tweet读到了John Nagle(Nagle的算法)对Hacker News的这条评论。</p><p> The real problem is ACK delays. The 200ms “ACK delay” timer is a bad idea thatsomeone at Berkeley stuck into BSD around 1985 because they didn’t reallyunderstand the problem. A delayed ACK is a bet that there will be a reply fromthe application level within 200ms. TCP continues to use delayed ACKs even ifit’s losing that bet every time.</p><p>真正的问题是ACK延迟。200ms的“ACK Delay”计时器是一个糟糕的主意，伯克利的一些人在1985年左右陷入了BSD，因为他们没有真正理解这个问题。延迟的ACK打赌在200ms内会有来自应用程序级别的回复。TCP继续使用延迟的ACK，即使它每次都会输掉这个赌注。</p><p> He goes on to comment that ACKs are small and inexpensive, and that the problemscaused in practice by delayed ACKs are probably much worse than the problemsthey solve.</p><p>他接着评论说，ACK很小而且便宜，而且延迟ACK在实践中引起的问题可能比它们解决的问题严重得多。</p><p>  I used to think that TCP was really low-level and that I did not need to understand it. Which is mostly true! But sometimes in real life you have a bug and that bug is because of something in the TCP algorithm. So it turns out that understanding TCP is important. (as we frequently discuss on this blog, this turns out to be true for a lot of things, like, system calls &amp; operating systems :) :))</p><p>我过去常常认为TCP是非常低级的，我不需要理解它。这几乎是真的！但在现实生活中，有时您会有一个bug，而这个bug是由于TCP算法中的某些东西造成的。因此，了解TCP是很重要的。(正如我们经常在本博客上讨论的那样，事实证明，这在很多事情上都是正确的，比如系统调用和操作系统：)：)</p><p> This delayed ACKs / TCP_NODELAY interaction is particularly bad – it could affect anyone writing code that makes HTTP requests, in any programming language. You don’t have to be a systems programming wizard to run into this. Understanding a tiny bit about how TCP worked really helped me work through this and recognize that that thing the blog post was describing also might be my problem. I also used strace, though. strace forever.</p><p>这种延迟的ACKS/TCP_NODELAY交互特别糟糕-它可能会影响任何使用任何编程语言编写发出HTTP请求的代码的人。您不必是系统编程向导就能遇到这种情况。稍微了解一下TCP是如何工作的确实帮助我解决了这个问题，并认识到博客文章描述的东西也可能是我的问题。不过，我也用了strace。永不停歇。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://jvns.ca/blog/2015/11/21/why-you-should-understand-a-little-about-tcp/">https://jvns.ca/blog/2015/11/21/why-you-should-understand-a-little-about-tcp/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/了解/">#了解</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tcp/">#tcp</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>