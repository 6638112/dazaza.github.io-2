<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>设计一个更好的strcpy Designing a Better Strcpy</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Designing a Better Strcpy<br/>设计一个更好的strcpy </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-20 02:47:15</div><div class="page_narrow text-break page_content"><p>Like them or not,  null-terminated strings are essential to C, and working with them is necessary in all but the most trivial programs. While C-style strings are a fundamental part of using the language, manipulating them is a common source of security bugs and lost performance. One of the most common operations is copying a string from one buffer to another, and there are a variety of string functions that claim to do this in C. Anecdotally, however, there is much confusion about what they actually do, and many people desire a string copying function with the following properties:</p><p>与它们一样，终止终止字符串对于C至关重要，并且在所有琐碎的程序中都必须与它们一起工作。虽然C型字符串是使用语言的基本部分，但操作它们是安全错误和性能丢失的共同来源。其中一个最常见的操作是将字符串从一个缓冲区复制到另一个，并且有各种字符串函数声称在C.轶事中执行此操作，但是，对他们实际做的事情有很大的困惑，而且许多人渴望具有以下属性的字符串复制功能：</p><p> The function should accept a null-terminated source string, a destination buffer, and an integer representing the size of the destination buffer.</p><p> 该函数应接受一个返回的源字符串，目标缓冲区和表示目标缓冲区大小的整数。</p><p>  Upon return the function should ensure that the destination buffer points to a null-terminated string containing a prefix of the source string when possible (specifically, when the destination buffer has a non-zero size) to avoid issues in the future with unterminated strings. (While string truncation has its own issues, it is often a fairly reasonable fallback.)</p><p>  返回后，函数应确保目的地缓冲区在可能时（具体地，当目的地缓冲器具有非零大小时）以避免未经未勿绒的字符串的问题，以确保目标缓冲区指向包含源极字符串的前缀。 （虽然字符串截断有自己的问题，但通常是一个相当合理的回力。）</p><p>  The function should indicate how many characters it copied from the source, as well as indicate if an overflow occurred. (This allows for dealing with the overflow, if desired.)</p><p>  该函数应指示它从源复制的字符数量，以及指示是否发生了溢出。 （如果需要，这允许处理溢出。）</p><p>  The function should be efficient, and it should not read or write memory that it does not have to. These go partially hand-in-hand: the function should run in a single pass, not write to the destination buffer past the NUL byte it places, or read characters from the source string once it’s determined that it has filled the destination buffer. Ideally, the implementation would be vectorizable (relaxing some of the previous constraints slightly to within platform alignment guarantees).</p><p>  该函数应该是有效的，它不应该读取或写入它不必的内存。这些部分携手合作：函数应该在单个通行证中运行，而不是将目标缓冲区写入NUL字节IT位置，或者从源字符串中读取字符，一旦确定它已填充目标缓冲区。理想情况下，实现将是矢量图（放宽一些先前的约束，以便在平台对齐保证中）。</p><p>  The function should be standardized, so that it may be used portably across systems. Conformance to  ISO C or  POSIX.1 are generally the most desirable.</p><p>  该功能应该是标准化的，因此可以跨系统使用它。符合ISO C或POSIX.1通常是最理想的。</p><p> That is, what is often necessary is the function below, which we’ll call  strxcpy:</p><p> 也就是说，通常需要的是下面的功能，我们将调用strxcpy： </p><p> char  * strxcpy ( char  * restrict  dst ,  const  char  * restrict  src ,  size_t  len )  {	 if  ( ! len )  {		 return  NULL ;	 }	 while  ( -- len  &amp;&amp;  ( * dst ++  =  * src ++ ))		 ;	 if  ( ! len )  {		 * dst ++  =  &#39;\0&#39; ;		 return  * src  ?  NULL  :  dst ;	 }  else  {		 return  dst ;	 } }</p><p>char * strxcpy（char *限制dst，const char *限制src，size_t len）{if（！len）{return null; } whiled（ -  len＆amp;＆amp;（* dst ++ = * src ++））;如果（！len）{* dst ++ =＆＃39; \ 0＆＃39; ;返回* src？ null：dst; }否则{返回dst; }}</p><p> Other than standardization, this function will copy the smaller of  strlen(src) or  len - 1 bytes from  src to  dst and cap the copy with a NUL character. In the case where  src fits in  dst, it will return a pointer past the NUL byte it placed; otherwise it returns  NULL to indicate a truncation. While  current  compilers seem to have trouble with its control flow, it should also be fairly straightforwards to vectorize, as the core loop is somewhat similar to a combination of  strncpy and  strlen.</p><p> 除了标准化之外，此函数将从SRC到DST和CUP副本复制STRLEN（SRC）或LEN  -  1字节的较小函数。在SRC在DST中配合的情况下，它将返回一个指针，它放置了NUL字节;否则，它返回null以指示截断。虽然目前的编译器似乎在其控制流程时遇到困难，但它也应该相当直接向矢量化，因为核心环路有点类似于Strncpy和Strlen的组合。</p><p> With guidance to look back to, let’s take a look at a variety of copying routines and see if they can help us.</p><p> 通过指导回顾，让我们来看看各种复制例程，看看它们是否可以帮助我们。</p><p> To head off the usual concerns, we’ll assume that we must use C, and that we will be eschewing the various length-prefixed or aggregate string constructions available as third-party libraries. While using a different language can solve many of the issues in C besides the one mentioned here; it’s not always desirable or even possible to utilize them. In addition to the usual drawbacks to using third-party libraries, replacing null-terminated strings often causes added syntactical overhead and incompatibilities with other code that has been designed to work with them.</p><p> 要远离通常的问题，我们将假设我们必须使用C，并且我们将避免使用作为第三方库可用的各种长度前缀或聚合字符串结构。除了使用不同的语言时可以解决此处提到的语言中的许多问题;它并不总是可取的甚至可能利用它们。除了使用第三方库的通常缺点外，替换空终止字符串通常会导致添加句法开销和不兼容性，这些代码旨在与它们一起使用。</p><p>   The standard  strcpy function, which copies characters from  src to  dst, up to and including the first NUL byte encountered. If  dst is smaller than or aliases  src, then the behavior of the program is undefined.  dst is returned.</p><p>   标准strcpy函数，将字符从src副本复制到dst，最多，包括第一个NUL字节。如果DST小于或别名SRC，则程序的行为是未定义的。 DST被归还。</p><p> strcpy certainly fulfills requirement 2 and parts of 4: it will always write out a null-terminated string and it’ll do so quickly. However, it cannot perform bounds checks at all, so we can only use it if we know our destination buffer is smaller than our source buffer–it fails requirement 1. Plus it doesn’t tell us how many characters it wrote, either–that’s requirement 3. It’s been part of C forever, so it does meet requirement 5.</p><p> Strcpy肯定会满足要求2和4的部分：它将始终写出空终止的字符串，它会很快。但是，它根本无法执行界限，所以我们只能使用它，如果我们知道我们的目标缓冲区小于我们的源缓冲区 - 它失败要求1.此外，它并不告诉我们它写了多少个字符，即它要求3.这是C的一部分，所以它确实满足要求5。</p><p>  strncpy copies up to  len characters from  src to  dst. If  src is shorter than  len, then  dst is NUL-padded to  len characters.  dst is returned.</p><p>  STRNCPY将从SRC到DST的LEN字符复制到LEN字符。如果SRC短于LEN，则DST为NUL-PADDED到LEN字符。 DST被归还。 </p><p> strncpy takes the parameters we want, so it satisfies requirement 1; even in the face of an arbitrary source string it won’t exhibit undefined behavior, provided that we supply it with the correct destination buffer length. However, if the source is longer that the destination, the buffer will not be null-terminated, and if it is shorter  strncpy will continue writing NUL bytes to the destination up to its size. In addition, it doesn’t indicate how many characters from the source were written, though it is possible to detect overflow by writing a NUL byte to the last character of the destination buffer and checking it after the call. That means it fails requirements 2, 3, and 4, but as it’s been around in C for as long as  strcpy it does meet requirement 5.</p><p>Strncpy采用我们想要的参数，所以它满足要求1;即使在一个任意源字符串的面上，它也不会表现出未定义的行为，只要我们将其提供正确的目的地缓冲区长度。但是，如果源更长的是目标，则缓冲区不会终止，如果它缩短strncpy将继续将NUL字节写入目的地。此外，它并不指示写入源中的许多字符，但是可以通过将NUL字节写入目标缓冲区的最后一个字符并在呼叫后检查来检测溢出。这意味着它失败了2,3和4的要求，但由于它已经存在，只要它确实满足要求5。</p><p>   memcpy doesn’t care about NUL characters at all; it doesn’t even require the source to be a null-terminated string. It fails the first three requirements right off the bat, but it’s part of C and it sure is fast so it meets requirements 4 and 5.</p><p>   Memcpy根本不关心NUL角色;它甚至不需要源是空终止的字符串。它失败了蝙蝠的前三个要求，但它是C的一部分，它肯定会达到要求4和5。</p><p>  strcpy_s conforms to  ISO C11, and is available if  __STDC_WANT_LIB_EXT1__ is defined prior to including string.h and  __STDC_LIB_EXT1__ is defined.</p><p>  strcpy_s符合ISO C11，如果在包括字符串之前定义__stdc_want_lib_ext1__并且定义__stdc_lib_ext1__，则可用。</p><p>    A bounds-checked version of  strcpy that performs the same operation and returns zero except it can write unspecified values to the remainder of  dst, and if  src == NULL,  dst == NULL, if truncation would occur,  len is zero or greater than  RSIZE_MAX, or  src and  dst overlap, it will write a NUL byte to  *dst if possible, return a nonzero value, and call a constraint handler function.</p><p>    执行相同操作的strcpy的界限版本，除了它可以将未指定的值写入DST的剩余部分，如果src == null，dst == null，如果发生截断，则Len为零或大于RSIZE_MAX或SRC和DST重叠，如果可能，它将将NUL字节写入* DST，返回非零值，并调用约束处理程序函数。</p><p> On the surface, this function  seems useful–but a closer look shows that it has a number of unfortunate issues. The largest is that any truncation will call a constraint handler function which can do many things,  like abort the program. In addition, it doesn’t tell us how much it wrote, can scribble over the destination, and is standardized but only available as an optional extension to C11. Overall, it only satisfies requirement 1.</p><p> 在表面上，这种功能似乎有用 - 但仔细观察显示它有许多不幸的问题。最大的是，任何截断都会调用约束处理程序功能，该函数可以执行许多事情，例如中止程序。此外，它并没有告诉我们它写了多少，可以涂鸦目的地，并且是标准化的，但仅作为C11的可选扩展名。总的来说，它只满足要求1。</p><p>  strncpy_s conforms to  ISO C11, and is available if  __STDC_WANT_LIB_EXT1__ is defined prior to including string.h and  __STDC_LIB_EXT1__ is defined.</p><p>  strncpy_s符合ISO C11，如果在包括字符串之前定义__stdc_want_lib_ext1__和定义__stdc_lib_ext1__，则可用。</p><p>    A bounds-checked version of  strncpy, that returns a non-zero value if  src == NULL,  dst == NULL, if truncation would occur,  len is zero or greater than  RSIZE_MAX, or  src and  dst overlap, in which case it will write the NUL byte to  *dst if possible, unspecified values to the remainder of  dst, return a nonzero value, and call a constraint handler function. Otherwise is will copy  len bytes from  src to  dst and then add a NUL terminating byte at  dst[len - 1], returning zero.</p><p>    strncpy的界限版本，如果src == null，dst == null，则返回非零值，如果发生截断，则Len为零或大于RSize_max，或SRC和DST重叠，在这种情况下将NUL字节写入* DST，如果可能，未指定的值为DST的剩余部分，返回非零值，并调用约束处理程序函数。否则，将从SRC复制LEN字节从SRC到DST，然后在DST [LEN-1]中添加NUL终端字节，返回零。 </p><p> This function has the same constraint handler issue as  strcpy_s, and is also standardized but often not available. While it will null-terminate when the string fits and only clobber the destination on an error, it still only satisfies the first requirement.</p><p>此函数具有与strcpy_s相同的约束处理程序问题，也是标准化但通常不可用。虽然当字符串适合并仅在错误时删除目的地时，它将终止，但它仍然只满足第一个要求。</p><p>  Identical to  strncpy, except that a pointer to the written NUL byte is returned, if any; otherwise  dst + len is returned.</p><p>  与strncpy相同，除了返回指向写入NUL字节的指针，如果有的话;否则返回DST + LEN。</p><p> stpncpy is an improvement on  strncpy, but it only fixes the issue of detecting termination or overflow, which is requirement 3. It still fails requirement 2 because it doesn’t necessarily null-terminate and it fails requirement 4 because it writes NULs to the end of the destination buffer. Unlike  strncpy it’s part of POSIX, but it still meets requirement 5 in addition to requirement 1.</p><p> stpncpy是对strncpy的改进，但它只修复了检测终止或溢出的问题，这是要求3.它仍然失败的要求2，因为它不一定是空终止，它失败要求4因为它将nuls写入结束目的地缓冲区。与它是POSIX的一部分，但除了要求1之外，它仍然符合要求5。</p><p>  When used with  %s as  fmt, copies the first variadic parameter (a string) to  dst, or the first  len - 1 bytes followed by the NUL byte. Returns the length of the first variadic parameter.</p><p>  当与％s一起使用时，将第一个Variadic参数（一个字符串）复制到DST，或者第一LEN  -  1字节后跟NUL字节。返回第一个Variadic参数的长度。</p><p> snprintf is a somewhat strange inclusion, but it’s a standard function that can help us if we use “%s” as the format string, taking a size and null-terminating its destination. It fulfills requirements 1, 2, and 5, but falls short on 3 and 4: its return value is essentially “what  sprintf would have returned”, which means it must perform an equivalent of a  strlen at the very least. This is slow, not what we want, and an  int (not a  size_t).</p><p> SnPrintf是一种奇怪的包含，但它是一个标准函数，可以帮助我们，如果我们使用“％s”作为格式字符串，则占据尺寸和终止其目的地。它符合要求1,2和5，但在3和4下降：其返回值基本上是“Sprintf将返回的是什么”，这意味着它必须至少执行相同的Strlen。这很慢，而不是我们想要的，以及一个int（不是size_t）。</p><p>  Semantically equivalent to  sprintf(dst, len, &#34;%s&#34;, src) save for the return value, which is a  size_t.</p><p>  语义上等同于Sprintf（DST，Len，＆＃34;％s＆＃34; src）保存返回值，这是一个size_t。</p><p> strlcpy is identical to the  sprintf invocation from before, except it uses the correct  size_t return type. This still means it fails to satisfy the performance requirements of 3 and 4, and it’s not standard so it doesn’t satisfy 5 either. Since it does the copy and leaves you with a null-terminated string it fills the first two requirements.</p><p> strlcpy与之前的Sprintf调用相同，除了它使用正确的size_t return类型。这仍然意味着它无法满足3和4的性能要求，而不是标准，因此它不满足5。由于它执行副本并将您带有零终止的字符串，它填充了前两个要求。 </p><p>  strscpy copies  src to  dst if it fits in the buffer and return the number of characters copied excluding the trailing NUL byte; otherwise it will copy the first  len - 1 characters and set  dst[len - 1] to a NUL byte, returning  -E2BIG.</p><p>strscpy复制src到dst如果它适合缓冲区并返回复制的字符数，则不包括尾随NUL字节;否则它将复制第一个LEN  -  1个字符并将DST [LEN-1]设置为NUL字节，返回-e2big。</p><p> strscpy is the first function we’ve seen that satisfies the four functional requirements: it copies the as much of the source string as possible, null terminates the destination buffer, returns the number of characters copied, and does not perform excessive reads or writes. In fact, we can implement our  strxcpy function using it:</p><p> strscpy是我们看到的第一个功能，它满足了四个功能要求：它可以追溯到尽可能大的源字符串，null终止目标缓冲区，返回复制的字符数，并且不执行过多的读取或写入。实际上，我们可以使用它来实现我们的strxcpy函数：</p><p> char  * strxcpy ( char  * restrict  dst ,  const  char  * restrict  src ,  size_t  len )  {	 ssize_t  copied  =  strscpy ( dst ,  src ,  len );	 return  copied  !=  - E2BIG  :  src  +  copied  +  1  :  NULL ; }</p><p> char * strxcpy（char *限制dst，const char *限制src，size_t len）{ssize_t复制= strscpy（dst，src，len）;复制返回！=  -  e2big：src +复制+ 1：null; }</p><p> It has two issues: the first, is that it returns an  ssize_t rather than a  size_t, but in practice this isn’t really a problem. The second is that it’s unfortunately non-standard–it’s something the Linux kernel wrote for itself–which means it violates requirement 5.</p><p> 它有两个问题：第一个问题，它是它返回一个ssize_t而不是size_t，但实际上这不是一个问题。第二个是，不幸的是非标准 - 这是Linux内核为自己写的东西 - 这意味着它违反了要求5。</p><p>  memccpy is identical to  memcpy, but may stop prematurely if  src contains  chr, copying  chr and returning pointer after its location in  dst. If  len characters are copied without encountering  chr, then  NULL is returned.</p><p>  Memccpy与Memcpy相同，但如果SRC在DST中的位置后，SRC包含CHR，复制CHR和返回指针，则可能会过早停止。如果在不遇到CHR的情况下复制LEN字符，则返回NULL。</p><p> memccpy, when used with the NUL character, satisfies all the requirements except for the second one, but this is trivial to fix:</p><p> Memccpy，当与NUL字符一起使用时，满足除了第二个之外的所有要求，但这是微不足道的修复：</p><p> char  * strxcpy ( char  * restrict  dst ,  const  char  * restrict  src ,  size_t  len )  {	 char  * end  =  memccpy ( dst ,  src ,  &#39;\0&#39; ,  len );	 if  ( ! end )  {		 dst [ len  -  1 ]  =  &#39;\0&#39; ;	 }	 return  end ; }</p><p> char * strxcpy（char *限制dst，const char *限制src，size_t len）{char * end = memccpy（dst，src，＆＃39; \ 0＆＃39;，len）;如果（！结束）{dst [len-1] =＆＃39; \ 0＆＃39; ;返回结束; } </p><p> While it’ll ship in an upcoming C standard, it’s already widely available as a popular, optional POSIX extension.</p><p>虽然它将在即将推出的C标准中发货，但它已经广泛使用作为流行的可选POSIX扩展。</p><p>  There’s a couple of other functions– stpcpy,  mempcpy,  sprintf,  sprintf_s, and  snprintf_s–that have been omitted for brevity, as their behavior (and issues) are fairly self-explanatory based on the other functions. ( mempcpy is a GNU extension.)</p><p>  对于简洁起见，存在一些其他功能 -  Stpcpy，Mempcpy，Sprintf，Sprintf_s和SnPrintf_s  - 因为它们的行为（和问题）是基于其他功能的相当自我解释。 （Mempcpy是一个GNU扩展。）</p><p>  Copying strings in C is an extremely common operation, but doing so safely and efficiently is non-trivial. Almost all currently available string routines, standardized or not, have subtle quirks that often prevent them from matching the expectations of the programmer who reaches for them. This issue is compounded by the fact that many style guides or linters will recommend the use of one (or sometimes more than one!) of these functions to replace  strcpy without discussing their limitations. Finally, as we saw above the functions compose quite poorly: our  strxcpy, an academic but not improbable scenario, could not use any of them in its implementation; one can only imagine that those writing an ad-hoc replacement for it may make both errors in doing so.</p><p>  复制C字符串在C中是一个极其常见的操作，但是如此安全有效地进行了非琐碎。几乎所有目前可用的字符串例程，标准化与否，具有微妙的怪癖，通常阻止它们匹配达到它们的程序员的期望。这个问题是通过许多样式指南或林特将建议使用其中一个（或有时超过一个！）这些函数来替换Strcpy而不讨论其限制。最后，正如我们在上面所看到的那样，职能相当差：我们的StrxCPY，学术而不是不可能的场景，无法在其实施中使用任何一个;人们只能想象那些为其编写ad-hoc的人来说，这两个错误都可能产生错误。</p><p> In contrast, the standardization of  memccpy is a very welcome improvement, as it facilitates the construction of safer and more efficient string algorithms–in addition to  strxcpy, a number of the functions discussed are  also easy to construct with it. As it becomes more widespread, most code that relies on some of the semantics of  strxcpy but uses one of the other functions to achieve it should probably migrate to  memccpy, and ideally the push to phase out the use of them will drive the standardization and adoption of many more widely applicable string functions.</p><p> 相比之下，Memccpy的标准化是一个非常欢迎的改进，因为它促进了更安全和更高效的字符串算法的构建 - 除了Strxcpy之外，讨论的许多功能也很容易构建它。由于它变得更广泛，大多数依赖于StrxCPY的一些语义的代码，但使用其他功能的代码应该迁移到Memccpy，理想情况下，推动逐步淘汰它们将推动标准化和采用。许多广泛适用的字符串函数。</p><p> Questions? Comments? Corrections? Feel free to reach out to me at  saagar@saagarjha.com; I&#39;d love to hear your thoughts!</p><p> 问题？注释？更正？随意在saagar@saagarjha.com与我联系;我喜欢听到你的想法！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://saagarjha.com/blog/2020/04/12/designing-a-better-strcpy/">https://saagarjha.com/blog/2020/04/12/designing-a-better-strcpy/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/designing/">#designing</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/字符串/">#字符串</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>