<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>应对基本和偶然的复杂性 Against Essential and Accidental Complexity</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Against Essential and Accidental Complexity<br/>应对基本和偶然的复杂性 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-29 20:53:30</div><div class="page_narrow text-break page_content"><p>The essence of a software entity is a construct of interlocking concepts: data sets, relationships among data items, algorithms, and invocations of functions. This essence is abstract, in that the conceptual construct is the same under many different representations. It is nonetheless highly precise and richly detailed.</p><p>软件实体的本质是互锁概念的构建：数据集，数据项之间的关系，算法和功能调用。这个本质是抽象的，因为在许多不同的表示形式下，概念构造都是相同的。尽管如此，它还是非常精确和详尽的。</p><p>  I believe the hard part of building software to be the specification, design, and testing of this conceptual construct, not the labor of representing it and testing the fidelity of the representation. We still make syntax errors, to be sure; but they are fuzz compared to the conceptual errors in most systems.</p><p>  我认为构建软件的难点在于对​​该概念结构的规范，设计和测试，而不是对其进行表示和测试表示形式的真实性的劳动。当然，我们仍然会犯语法错误。但是与大多数系统中的概念错误相比，它们是模糊的。</p><p>   [return]</p><p>   [返回]</p><p>  curiously, he also claims, in the same essay, that no individual improvement can yield a 10x improvement within one decade. While this technically doesn&#39;t contradict his Ahmdal&#39;s law argument plus the claim that &#34;most&#34; (i.e., at least half) of complexity is essential/conceptual, it&#39;s unclear why he would include this claim as well.</p><p>  奇怪的是，他在同一篇文章中还声称，没有任何个人进步可以在十年内产生10倍的增长。尽管从技术上讲这并不与他的艾哈迈德（Ahmdal）法则论证相抵触，但也有与“大多数”相抵触的说法。 （即至少一半）的复杂性是必不可少的/概念性的，目前尚不清楚为什么他也将这一要求也包括在内。</p><p>  When Brooks revisited his essay in 1995 in No Silver Bullet Refired, he claimed that he was correct by using the weakest form of the three claims he made in 1986, that within one decade, no single improvement would result in an order of magnitude improvement. However, he did then re-state the strongest form of the claim he made in 1986 and made it again in 1995, saying that this time, no set of technological improvements could improve productivity more than 2x, for real:</p><p>  当布鲁克斯于1995年在《无银子弹再燃》（No Silver Bullet Refireed）上重新审视自己的论文时，他声称自己是正确的，使用了他在1986年提出的三项主张中的最弱形式，即十年之内，没有任何一项改进会导致数量级的改进。但是，他确实重申了他在1986年提出的最强主张的形式，并在1995年再次提出了这一观点，他说这一次，没有任何一项技术改进可以使生产率实际提高2倍以上：</p><p>  It is my opinion, and that is all, that the accidental or representational part of the work is now down to about half or less of the total. Since this fraction is a question of fact, its value could in principle be settled by measurement. Failing that, my estimate of it can be corrected by better informed and more current estimates. Significantly, no one who has written publicly or privately has asserted that the accidental part is as large as 9/10.</p><p>  我的观点是，仅此而已，工作的偶然性或代表性部分现在减少到总数的一半或更少。由于该分数是一个事实问题，因此其值原则上可以通过度量确定。未能做到这一点，我的估计值可以通过了解更多和最新的估计值加以纠正。值得注意的是，没有任何人公开或私下写过断言意外部分高达9/10。</p><p>  By the way, I find it interesting that he says that no one disputed this 9/10ths figure. Per the body of this post, I would put it at far above 9/10th for my day-to-day work and, if I were to try to solve the same problems in 1986, the fraction would have been so high that people wouldn&#39;t have even conceived of the problem. As a side effect of having worked in hardware for a decade, I&#39;ve also done work that&#39;s not too different from what some people faced in 1986 (microcode, assembly &amp; C written for DOS) and I would put that work as easily above 9/10th as well.</p><p>  顺便说一句，我感到有趣的是，他说没有人对此9/10的数字提出异议。根据这篇文章的内容，我的日常工作会远远超过9/10。如果我想在1986年解决相同的问题，那么这个比例会很高，以至于人们不会＃39;甚至还没有想到过这个问题。作为在硬件上工作了十年的副作用，我所做的工作与某些人在1986年所面对的工作（微代码，为DOS编写的汇编和C语言）相差无几。将该工作也轻松置于9/10以上。 </p><p>  Another part of his follow-up that I find interesting is that he quotes Harel&#39;s &#34;Biting the Silver Bullet&#34; from 1992, which, among other things, argues that that decade deadline for an order of magnitude improvement is arbitrary. Brooks&#39; response to this is</p><p>我觉得有趣的是，他引用了哈雷尔（Harel）的《咬银子弹》（Biting the Silver Bullet）的另一部分内容。从1992年开始，其中除其他事项外，认为数量级改进的十年期限是任意的。布鲁克斯对此的回应是</p><p>  There are other reasons for the decade limit: the claims made for candidate bullets all have had a certain immediacy about them . . . We will surely make substantial progress over the next 40 years; an order of magnitude over 40 years is hardly magical.</p><p>  十年限制还有其他原因：对候选子弹的要求都具有一定的即时性。 。 。我们肯定会在未来40年中取得重大进展；在40年内增加一个数量级几乎不是神奇的。</p><p>  But by Brooks&#39; own words when he revisits the argument in 1995, if 9/10th of complexity is essential, it would be impossible to get more than an order of magnitude improvement from reducing it, with no caveat on the timespan:</p><p>  但是布鲁克斯他在1995年重新讨论该论点时说了自己的话，如果9/10的复杂度是必不可少的，那么减少它就不可能获得超过一个数量级的改进，而且不会引起时间上的警告：</p><p>  &#34;NSB&#34; argues, indisputably, that if the accidental part of the work is less than 9/10 of the total, shrinking it to zero (which would take magic) will not give an order of magnitude productivity improvement.</p><p>  ＆＃34; NSB＆＃34;无可争辩地认为，如果工作的偶然部分少于总数的9/10，将其缩小到零（这很神奇）将不会给生产力带来一个数量级的提高。</p><p>  Both his original essay and the 1995 follow-up are charismatically written and contain a sort of local logic, where each piece of the essay sounds somewhat reasonable if you don&#39;t think about it too hard and you forget everything else the essay says. As with the original, a pedant could argue that this is technically not incoherent — after all, Brooks could be saying:</p><p>  他的第一篇论文和1995年的后续论文都是有魅力的，并包含一种局部逻辑，如果您不认真考虑而忘记了该论文所说的其他内容，则每篇论文听起来都比较合理。 。就像原始人一样，一个学徒可能会争辩说这在技术上并不是不连贯的-毕竟布鲁克斯会说：</p><p>  at most 9/10th of complexity is accidental (if we ignore the later 1/2 claim, which is the kind of suspension of memory/disbelief one must do to read the essay)</p><p>  最多不超过9/10的复杂度是偶然的（如果我们忽略后来的1/2主张，这是阅读本文必须做的那种记忆/怀疑的暂停）</p><p>  it would not be surprising for us to eliminate 100% of accidental complexity after 40 years</p><p>  对于我们来说，在40年后消除100％的意外复杂性就不足为奇了 </p><p>  While this is technically consistent (again, if we ignore the part that&#39;s inconsistent) and is a set of claims one could make, this would imply that 40 years from 1986, i.e., in 2026, it wouldn&#39;t be implausible for there to be literally zero room for any sort of productivity improvement from tooling, languages, or any other potential source of improvement. But this is absurd. If we look at other sections of Brooks&#39; essay and combine their reasoning, we see other inconsistencies and absurdities.</p><p>尽管从技术上讲这是一致的（再次，如果我们忽略不一致的部分），并且是可以提出的一组主张，但这意味着从1986年开始即40年（即2026年），从工具，语言或任何其他潜在的改进源来的任何形式的生产率提高几乎没有零空间是令人难以置信的。但这是荒谬的。如果我们看一下布鲁克斯的其他部分，散文并结合他们的推理，我们会发现其他不一致和荒谬之处。</p><p>   [return]</p><p>   [返回]</p><p>  another issue that we see here is Brooks&#39; insurance on bright-line distinctions between categories. Essential vs. accidental complexity. &#34;Types&#34; of solutions, such as languages vs. &#34;build vs. buy&#34;, etc.</p><p>  我们在这里看到的另一个问题是Brooks＆＃39;保险之间明确区分类别。基本与意外的复杂性。 ＆＃34;类型＆＃34;解决方案，例如语言vs.＆＃34;构建vs.购买＆＃34;等。</p><p>  Brooks admits that &#34;build vs. buy&#34; is one avenue of attack on essential complexity. Perhaps he would agree that buying a regexp package would reduce the essential complexity since that would allow me to avoid keeping all of the concepts associated with writing a parser in my head for simple tasks. But what if, instead of buying regexes, I used a language where they&#39;re bundled into the standard library or is otherwise distributed with the language? Or what if, instead of having to write my own concurrency primitives, those are bundled into the language? Or for that matter, what about  an entire HTTP server? There is no bright-line distinction between what&#39;s in a library one can &#34;buy&#34; (for free in many cases nowadays) and one that&#39;s bundled into the language, so there cannot be a bright-line distinction between what gains a language provides and what gains can be &#34;bought&#34;. But if there&#39;s no bright-line distinction here, then it&#39;s not possible to say that one of these can reduce essential complexity and the other can&#39;t and maintain a bright-line distinction between essential and accidental complexity (in a response to Brooks, Harel argued against there being a clear distinction in a response, and Brooks&#39; response was to say that there there is, in fact, a bright-line distinction, although he provided no new argument).</p><p>  布鲁克斯（Brooks）承认“建造与购买”是攻击本质复杂性的一种途径。也许他会同意购买regexp软件包会降低基本的复杂性，因为这将使我避免将与编写解析器相关的所有概念放在脑海中以完成简单的任务。但是，如果我不是购买正则表达式，而是使用将它们捆绑到标准库中或以其他方式随该语言一起分发的语言，该怎么办？或者，如果不必将自己的并发原语捆绑到语言中，该怎么办？或者说，整个HTTP服务器呢？在图书馆可以购买的东西之间没有明显的区别。 （如今在许多情况下都是免费的）和捆绑到该语言中的语言，因此，在一种语言所提供的收益与可以买到的收益之间不能有明确的区分。但是，如果这里没有明线区别，那么就不可能说其中一个可以降低本质复杂性，而另一个则不能并保持本质区别和基本区别。意外的复杂性（在对Brooks的回应中，Harel反对在回应中存在明显的区别，而Brooks的回应是在事实上存在明确的区别，尽管他没有提供新的论点。 ）。</p><p>  Brooks&#39; repeated insistence on these false distinctions means that the reasoning in the essay isn&#39;t composable. As we&#39;ve already seen in another footnote, if you take reasoning from one part of the essay and apply it alongside reasoning from another part of the essay, it&#39;s easy to create absurd outcomes and sometimes outright contradictions.</p><p>  布鲁克斯反复坚持这些错误的区分意味着论文中的推理是不可组合的。正如我们在另一个脚注中已经看到的那样，如果您从文章的一部分进行推理，然后将其与文章的另一部分进行推理相结合，则很容易产生荒谬的结果，有时甚至产生矛盾。</p><p>  I suspect this is one reason discussions about essential vs. accidental complexity are so muddled. It&#39;s not just that  Brooks is being vague and handwave-y, he&#39;s actually not self-consistent, so there isn&#39;t and cannot be a coherent takeaway. Michael Feathers has noted  that people are generally not able to correct identify essential complexity; as he says,  One person’s essential complexity is another person’s accidental complexity.. This is exactly what we should expect from the essay, since people who have different parts of it in mind will end up with incompatible views.</p><p>  我怀疑这是关于本质与偶然复杂性的讨论如此混乱的原因之一。布鲁克斯不仅含糊其词，而且实际上是自相矛盾的，因此没有而且不可能是一个连贯的外卖。迈克尔·费瑟斯（Michael Feathers）指出，人们通常无法正确识别本质的复杂性。就像他说的那样，一个人的本质复杂性是另一个人的偶然复杂性。这正是我们从这篇论文中所期望的，因为头脑中具有不同部分的人最终将获得不相容的观点。</p><p>   [return]</p><p>   [返回] </p><p>  Let&#39;s arbitrarily use a Motorola 68k processor with an FP co-processor that could do 200 kFLOPS as a reference for how much power we might have in a consumer CPU (FLOPS is a bad metric for multiple reasons, but this is just to get an idea of what it would take to get 1 CPU-year of computational resources, and Brooks himself uses MIPS as a term as if it&#39;s meaningful). By comparison, the Cray-2 could achieve 1.9 GFLOPS, or roughly 10000x the performance (I think actually less if we were to do a comparable comparison instead of using non-comparable GFLOPS numbers, but let&#39;s be generous here). There are 525600 / 5 = 105120 five minute periods in a year, so to get 1 CPU year&#39;s worth of computation in five minutes we&#39;d need 105120 / 10000 = 10 Cray-2s per query, not including the overhead of aggregating results across Cray-2s.</p><p>让我们任意使用Motorola 68k处理器和FP协处理器，该协处理器可以做200 kFLOPS作为参考，说明我们在消费类CPU中可能有多少电量（FLOPS是一个不好的指标，原因有很多，但这仅仅是来了解获得1个CPU年的计算资源将需要什么，布鲁克斯本人使用MIPS作为术语，就好像它有意义。相比之下，Cray-2可以达到1.9 GFLOPS，或者大约是10000倍的性能（我想如果做一个可比较的比较而不是使用不可比拟的GFLOPS数值，实际上要少一些，但在这里要宽泛一些）。一年中有5分钟的时间为525600/5 = 105120，因此要在5分钟内获得1 CPU年的计算价值，我们每个查询需要105120/10000 = 10 Cray-2，不包括跨Cray-2汇总结果的开销。</p><p>  It&#39;s unreasonable to think that a consumer software company in 1986 would have enough Cray-2s lying around to allow for any random programmer to quickly run CPU years worth of queries whenever they wanted to do some data analysis. One sources claims that 27 Cray-2s were ever made over the production lifetime of the machine (1985 to 1990). Even if my employer owned all of them and they were all created by 1986, that still wouldn&#39;t be sufficient to allow the kind of ad hoc querying capacity that I have access to in 2020.</p><p>  认为一家消费类软件公司在1986年将拥有足够多的Cray-2来允许任何随机程序员在需要进行数据分析时快速运行CPU年价值的查询是不合理的。一位消息人士称，在该机器的整个使用寿命（1985年至1990年）中，共生产了27架Cray-2。即使我的老板所有这些都是在1986年创建的，但这仍然不足以允许我在2020年使用这种临时查询功能。</p><p>   [return]</p><p>   [返回]</p><p>  in this specific case, I&#39;m sure somebody will argue that Visual Studio was quite nice in 2000 and ran on much slower computers (and the debugger was arguably better than it is in the current version). But there was no comparable tool on Linux, nor was there anything comparable to today&#39;s options in the VSCode-like space of easy-to-learn programming editor that provides programming-specific facilities (as opposed to being a souped up version of notepad) without being a full-fledged IDE.   [return]</p><p>  在这种特定情况下，我敢肯定有人会说Visual Studio在2000年相当不错，并且在速度较慢的计算机上运行（可以说调试器比当前版本要好）。但是在Linux上没有可比的工具，在类似于VSCode的易于学习的编程编辑器空间中，也没有任何可与今天的选项相提并论的东西，它提供特定于编程的功能（而不是强大的版本）而不是成熟的IDE。 [返回]</p><p>  And by the way, this didn&#39;t only happen in 1955. I&#39;ve worked with people who, this century, told me that assembly is basically as productive as any high level language. This probably sounds ridiculous to almost every reader of this blog, but if you talk to people who spend all day writing microcode or assembly, you&#39;ll occasionally meet somebody who believes this.</p><p>  顺便说一句，这并不是在1955年才发生的。我与本世纪告诉我汇编语言与任何高级语言一样高效的人们一起工作。这对于几乎每个博客读者来说都是荒谬的，但是如果您与花一整天编写微代码或汇编代码的人交谈，您有时会遇到一个相信这一点的人。</p><p>  Thinking that the tools you personally use are as good as it gets is an easy trap to fall into.</p><p>  认为您个人使用的工具好用就容易陷入陷阱。</p><p>   [return]</p><p>   [返回] </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://danluu.com/essential-complexity/">https://danluu.com/essential-complexity/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/应对/">#应对</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>