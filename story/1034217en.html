<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Scala 3进行显式项推理</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">使用Scala 3进行显式项推理</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-10 15:24:45</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/84e9ef6db136f3fbdf494272e186a3fb.png"><img src="http://img2.diglog.com/img/2020/11/84e9ef6db136f3fbdf494272e186a3fb.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>One of the most striking changes for developers adopting Scala 3 is the introductionof a new syntax to replace the implicit mechanism used in previous Scala versions.</p><p>对于采用Scala3的开发人员来说，最显著的变化之一是引入了新的语法来取代以前Scala版本中使用的隐式机制。</p><p> The motivation behind the new syntax is that the same  implicit keyword wasused for different purposes and patterns and thus it became a way to express  how to implementpatterns. This means that when encountering this ambiguous incantation, users need to decipher whatthe intent of the developer was: is this a conversion? Does this avoid parameter repetition?Is this an extension of a type? Is this a typeclass? How do I import this?</p><p>新语法背后的动机是，相同的隐式关键字用于不同的目的和模式，因此它成为表达如何实现模式的一种方式。这意味着，当用户遇到这个模棱两可的咒语时，需要破译开发者的意图：这是一种转换吗？这是否避免了参数重复？这是类型的扩展吗？这是打字机吗？我怎么导入这个？</p><p> Seeing how pervasive implicits became in libraries and projects, Scala 3 aims at reducing confusion and cognitive load by using new keywords that convey the intent of the developer.</p><p>看到隐含含义在库和项目中变得如此普遍，Scala3的目标是通过使用传达开发人员意图的新关键字来减少困惑和认知负担。</p><p> This post briefly introduces the new syntax and semantics available to Scala 3 programmers by analysing themost common use cases and patterns: extension methods, implicit parameters, implicit conversions and typeclasses.</p><p>本文通过分析最常见的用例和模式：扩展方法、隐式参数、隐式转换和类型类，简要介绍了Scala3程序员可以使用的新语法和语义。</p><p>  While we believe that the new syntax represents an improvement, it is very important to highlightthat older code using  implicit is still perfectly valid for the Scala 3.0 compiler, even if it will be deprecated in future releases.You do not need to port your codebase right away, it can be an incremental and gradual process.</p><p>虽然我们认为新的语法代表了一种改进，但需要强调的是，使用隐式的旧代码在Scala 3.0编译器中仍然完全有效，即使它将在未来的版本中被弃用。您不需要立即移植代码库，这可能是一个渐进的过程。</p><p>  When you do not have control over a type but you need to extend its capabilities with a new method,Scala 3 allows you to define an  extension method.</p><p>当您无法控制某个类型，但需要使用新方法扩展其功能时，Scala3允许您定义扩展方法。</p><p> Assume that you are working with  List[Try[String]] and that you often need to retrievethe elements for which the computation succeeded.</p><p>假设您正在使用List[try[String]]，并且经常需要检索计算成功的元素。</p><p>  // ListTryOps.scala import  scala.util. { Try ,  Success } extension  ( ls :  List [ Try [ String ]])  def  collectSucceeded :  List [ String ]  =  ls . collect  {  case  Success ( x )  =&gt;  x  }</p><p>//ListTryOps.scala导入scala.util。{try，uccess}扩展名(ls：list[try[string]])def Collect成功：list[string]=ls。收集{案例成功(X)=&gt；x}</p><p> To remember the syntax, notice how  collectSucceeded follows the object on which it will be available:  ls.collectSucceeded.Extension methods can have type parameters as well:</p><p>要记住语法，请注意集合成功是如何跟在它将在其上可用的对象之后的：ls.Collection tSucceede.Extension方法也可以有类型参数：</p><p>   extension [ A ]  ( ls :  List [ Try [ A ]]) :  def  collectSucceeded:  List [ A ]  =  ls . collect  {  case  Success ( x )  =&gt;  x  }  def  getIndexOfFirstFailure :  Option [ Int ]  =  ls . zipWithIndex . find (( t ,  _ )  =&gt;  t . isFailure )  . map ( _ . _2 )</p><p>扩展名[A](ls：List[Try[A]])：def集合成功：List[A]=ls。收集{Case Success(X)=&gt；x}def getIndexOfFirstFailure：Option[Int]=ls。ZipWithIndex。找到((t，_)=&gt；t.。IsFailure)。地图(_.。(2)。</p><p>  // Main.scala import  scala.util.Try // import ListTryOps._ // Using wildcard import  ListTryOps.collectSucceeded def  getLastTweet ( username :  String ) :  Try [ String ]  =  ??? @main  def  main  =  val  niceTweets  =  List ( getLastTweet ( &#34;scala_lang&#34; ),  getLastTweet ( &#34;odersky&#34; )). collectSucceeded  println ( niceTweets )</p><p>//Main.scala导入scala.util.Try//导入ListTryOps。_//使用通配符导入ListTryOps.ColltSucccessdef getLastTweet(用户名：字符串)：try[String]=？@main def main=val niceTwets=list(getLastTweet(&#34；Scala_lang&34；)，getLastTweet(&#34；odersky。集合成功打印(NiceTwets)。</p><p>  This pattern was particularly cumbersome to implement prior to Scala 3.A typical approach would be the following:</p><p>在Scala3之前，这个模式的实现特别麻烦。典型的方法如下：</p><p> implicit  class  ListTryExtension [ A ]( private  val  in :  List [ Try [ A ]])  extends  AnyVal  {  def  collectSucceeded :  List [ A ]  =  ls . collect  {  case  Success ( a )  =&gt;  a  }  def  getIndexOfFirstFailure :  Option [ Int ]  =  in . zipWithIndex . find  {  case  ( t ,  _ )  =&gt;  t . isFailure  }  . map  {  case  ( _ ,  index )  =&gt;  index  } }</p><p>隐式类ListTryExtension[A](私有Val in：List[Try[A]])扩展AnyVal{def Collect Succcessed：List[A]=ls。收集{案例成功(A)=&gt；a}定义getIndexOfFirstFailure：OPTION[Int]=in。ZipWithIndex。查找{case(t，_)=&gt；t.。IsFailure}。MAP{case(_，index)=&gt；index}}。</p><p> Note that you need to define a name for the class, even if this is probably never going to be used besides the import statement.You also need to understand what  AnyVal is, why it is good practice to extend it andwhat its limitations are.</p><p>请注意，您需要为类定义一个名称，即使除了IMPORT语句之外可能永远不会使用这个名称。您还需要了解AnyVal是什么，为什么扩展它是一种好的做法，以及它的限制是什么。</p><p> Some experience is required when reading this code to understand that its only goal is toadd a couple of methods to  List[Try[A]].</p><p>阅读这段代码时需要一些经验，才能理解它的唯一目标是添加几个方法来列出[try[A]]。</p><p>  You can find more information about extension methods on  the dedicated documentation page.We also suggest that you read how they complement another new Scala 3 feature:  opaque types.Later in this post we will see how they simplify a very common pattern: typeclasses.</p><p>您可以在专门的文档页面上找到更多关于扩展方法的信息。我们还建议您阅读它们如何补充Scala 3的另一个新特性：不透明类型。在本文的后面，我们将看到它们如何简化一个非常常见的模式：类型类。</p><p>  Similarly to other programming languages, Scala allows you to omit the type of a variable as thecompiler can perform  type inference. For example we can write</p><p>与其他编程语言类似，Scala允许您省略变量的类型，因为编译器可以执行类型推断。例如，我们可以写。</p><p>    In this case we declared the value and the compiler inferred the corresponding type.One of the distinctive features of Scala is being able to infer values when the type is specified.</p><p>在本例中，我们声明了值，然后编译器推断出相应的类型。Scala的一个独特特性是，当指定类型时能够推断出值。</p><p> Consider the  Future abstraction in the standard library. Each time you create a  Future byproviding a computation, you need to specify on which  ExecutionContext the computation willbe evaluated:</p><p>考虑一下标准库中的未来抽象。每次通过提供计算来创建Future时，都需要指定计算将在哪个ExecutionContext上求值：</p><p> import  scala.concurrent._ def  factorial ( n :  Int ) :  Int  =  ??? def  fibonacci ( n :  Int ) :  Int  =  ??? @main  def  main  =  val  executor :  ExecutionContext  =  ExecutionContext . global  val  fact100  =  Future ( factorial ( 100 ))( executor )  val  fibo100  =  Future ( fibonacci ( 100 ))( executor )  // ...</p><p>导入scala.conflic._def阶乘(n：int)：int=？Def Fibonacci(n：int)：int=？@main def main=val Executor：ExecutionContext=ExecutionContext。全局Val fact100=Future(阶乘(100))(执行者)Val fibo100=Future(斐波纳奇(100))(执行者)//...。</p><p> As you can see, the repetition of  executor quickly becomes a tedious task.We can declare that this parameter is common to the current context and avoid its repetition:</p><p>如您所见，Executor的重复很快就变成了一项乏味的任务。我们可以声明此参数是当前上下文通用的，并避免其重复：</p><p> @main  def  main  =  given  executor  as  ExecutionContext  =  ExecutionContext . global  val  fact100  =  Future ( factorial ( 100 ))  val  fibo100  =  Future ( fibonacci ( 100 ))</p><p>@main def main=给定的执行程序为ExecutionContext=ExecutionContext。全局Val fact100=未来(阶乘(100))Val fibo100=未来(Fibonacci(100))。</p><p>  // scala.concurrent.Future.scala object  Future  {  // ..  def  apply [ T ]( body :  =&gt;  T )( using  executor :  ExecutionContext ) :  Future [ T ]  =  // ... }</p><p>//scala.concurrent.Future.scala对象未来{//.。Def Apply[T](Body：=&gt；T)(使用Executor：ExecutionContext)：Future[T]=//...}。</p><p> We see here the other half of the syntax: if we declare a parameter as  using, the compilerwill search the current scope at call sites for  given values with a compatible type.</p><p>我们在这里看到了语法的另一半：如果我们将一个参数声明为USING，那么编译器将在调用点的当前作用域中搜索具有兼容类型的给定值。</p><p>      Another important aspect is how we import these values. For example, if you had amore involved definition for the  ExecutionContext that is used in multiplefiles, you could refactor it into a different file:</p><p>另一个重要的方面是我们如何导入这些值。例如，如果您有多个文件中使用的ExecutionContext的更多相关定义，则可以将其重构为不同的文件：</p><p>        You can learn more about  using /  given and about the rules of resolution in the documentation.</p><p>您可以在文档中了解有关使用/给定以及解析规则的更多信息。</p><p>  In Scala 2 this pattern was achieved by marking both the value and the parameter with the implicit keyword. The previous example would look like this:</p><p>在Scala2中，这种模式是通过用IMPLICIT关键字标记值和参数来实现的。上一个示例如下所示：</p><p> // Main.scala import  scala.concurrent._ object  Main  extends  App  implicit  val  ec :  ExecutionContext  =  ExecutionContext . global  Future ( println ( &#34;Hello World&#34; )) } // scala.concurrent.Future.scala object  Future  {  // ..  def  apply [ T ]( body :  =&gt;  T )( implicit  executor :  ExecutionContext ) :  Future [ T ]  =  // ... }</p><p>//Main.scala导入scala.consist._Object Main扩展App隐式Val EC：ExecutionContext=ExecutionContext。Global Future(println(&#34；Hello World&34；))}//scala.concurrent.Future.scala对象未来{//.。Def Apply[T](Body：=&gt；T)(隐式Executor：ExecutionContext)：Future[T]=//...}。</p><p> We note again that we had to provide a name which might not be used for the variable. The  implicitly function from Scala 2 is renamed to  summon in Scala 3.</p><p>我们再次注意到，我们必须提供一个可能不会用于变量的名称。Scala 2中的隐式函数在Scala 3中被重命名为call。</p><p> Finally the special import syntax allows users to explicitly import  given instances by type rather than by name. This makes more sense since we usually refer to them by type as well.</p><p>最后，特殊的导入语法允许用户按类型而不是按名称显式导入给定的实例。这更有意义，因为我们通常也用类型来指代它们。</p><p>   The implicit conversion feature is dangerous. For this reason, in Scala 3, the compilerwill warn you every time it is used. You can disable the warning at your own risk byexplicitly importing the feature into the current scope.</p><p>隐式转换功能很危险。出于这个原因，在Scala3中，每次使用编译器时都会发出警告。您可以通过将功能显式导入当前范围来禁用警告，风险自负。</p><p> The Java standard library provides an  Optional type which is very similar to  Option.If you are working with a Java library which produces a lot of objects with this type,but you also have many  Options around, you might want to define an automatic conversion.</p><p>Java标准库提供了一个与Options非常相似的可选类型。如果您正在使用的Java库生成了大量具有此类型的对象，但您也有很多选项，那么您可能希望定义一个自动转换。</p><p>    // OptionalConversion.scala import  java.util.Optional object  OptionalConversion :  given  [ A ]  as  Conversion [ Optional [ A ],  Option [ A ]] :  def  apply ( in:  Optional [ A ]) :  Option [ A ]  =  if  in . isPresent  then  Some ( in . get ())  else  None</p><p>//OptionalConversion.scala导入java.util.OptionalConversion：给定[A]作为转换[Optional[A]，Option[A]]：def Apply(in：Optional[A])：Option[A]=if in。如果有的话，就会有一些(在……中)。Get())否则无。</p><p>    Use of implicit conversion class given_Conversion_Optional_Option in object OptionalConversion should be enabledby adding the import clause &#39;import scala.language.implicitConversions&#39;or by setting the compiler option -language:implicitConversions.See the Scala docs for value scala.language.implicitConversions for a discussionwhy the feature should be explicitly enabled.</p><p>应通过添加IMPORT子句或通过设置编译器选项-LANGUAGE：IMPLICTICT CONVERSIONS来启用对象OptionalConversion中给定的_CONVERSION_OPTIONAL_OPTION隐式转换类。有关为何应显式启用该功能的讨论，请参阅Scala文档中的值scala.language.implitConversions。</p><p>      import  java.util.Optional object  OptionalConversion  {  implicit  def  optionalToOption [ A ]( in :  Optional [ A ]) :  Option [ A ]  =  if  ( in . isPresent )  Some ( in . get ())  else  None }</p><p>IMPORT java.util.Optional Object OptionalConversion{IMPLICIT def optionalToOption[A](in：可选[A])：Option[A]=if(in.。存在的)一些(在.)。Get())否则无}。</p><p>   Note that at a glance, it is not clear that the definition is intended as an automatic conversion to an expected type:</p><p>请注意，乍一看，并不清楚该定义是否旨在自动转换为预期类型：</p><p> the name of the method can be a hint, but this is merely a convention thatother developers might not share</p><p>该方法的名称可能是一个提示，但这只是其他开发人员可能不同意的约定。</p><p>  the implicit def may be intended give you extension methods on its parameter type, depending on its result</p><p>隐式def可能意在为您提供其参数类型的扩展方法，具体取决于其结果。</p><p>  there is not straightforward way to verify that this function will not be used as implicitargument for a function with an implicit parameter list</p><p>没有直接的方法来验证此函数是否不会用作具有隐式参数列表的函数的隐含参数。</p><p>   This pattern is fundamental to Scala functional programming libraries such as  Cats. In Scala 2 we used to heavily rely on  implicit conversions to add methodsand on  implicit parameters to propagate instances, which was a bit cryptic to beginners who were maybe already struggling with new concepts in functional programming.</p><p>该模式是Cats等Scala函数式编程库的基础。在Scala2中，我们过去严重依赖隐式转换来添加方法，依赖隐式参数来传播实例，这对于可能已经在函数编程中纠结于新概念的初学者来说有点神秘。</p><p> In Scala 3, this pattern becomes simpler thanks to the new syntax.Let’s consider a simple typeclass such as  Show which describes the capability of types to have a  String representation.</p><p>在Scala3中，由于有了新的语法，这个模式变得更加简单。让我们考虑一个简单的类型类，比如Show，它描述了类型具有字符串表示的能力。</p><p>   We can then add a companion object to provide a couple of auxiliary methods and instancesthat make instance creation less tedious:</p><p>然后，我们可以添加一个配套对象来提供两个辅助方法和实例，以减少创建实例的繁琐：</p><p> // Show.scala object  Show :  def  from [ A ]( f :  A  =&gt;  String ) :  Show [ A ]  =  new  Show [ A ] :  extension  ( a:  A )  def  show:  String  =  f ( a )  given [ A:  Show ]  as  Show [ List [ A ]] :  extension  ( ls:  List [ A ])  def  show :  String  =  ls . map ( _ . show ). mkString ( &#34;,&#34; )</p><p>//Show.scala对象Show：def from[A](f：A=&gt；string)：show[A]=new Show[A]：Extension(a：A)def show：String=f(A)给定[A：Show]as Show[List[A]]：Extension(ls：List[A])def show：String=ls。地图(_.。显示)。MkString(&#34；，&#34；)。</p><p>  // Main.scala import  Show. { _ ,  given } case  class  Mountain ( name :  String ,  height :  Int ) given  Show [ Mountain ]  =  Show . from (( m :  Mountain )  =&gt;  s &#34;${m.name} is ${m.height} meters high&#34; ) @main  def  main  =  val  mountains  =  List ( Mountain ( &#34;Mont Blanc&#34; ,  4808 ),  Mountain ( &#34;Matterhorn&#34; ,  4478 ))  println ( mountains . show )</p><p>//Main.scala导入显示。{_，给定}案例类Mountain(名称：字符串，高度：int)给定Show[Mountain]=Show。从((m：Mountain)=&gt；s&34；${m.name}为${m.Height}米高&34；)@main def main=Val Mountain=list(Mountain(&#34；Mont Blanc&#34；，4808)，Mountain(&#34；Matterhorn&#34；，4478))println(Mountain。(秀场)。</p><p> As the extension method is defined inside the trait, there is no additional import statement required contrarily to what used to happen in Scala 2, as you will see in the following section.</p><p>因为扩展方法是在特征中定义的，所以不需要额外的导入语句，这与Scala 2中过去发生的情况相反，您将在下面的小节中看到这一点。</p><p>  In Scala 2 there was more boilerplate code involved. It all starts with defining the interface:</p><p>在Scala2中，涉及到更多的样板代码。这一切都要从定义接口开始：</p><p>   // ShowOps.scala object  ShowOps  {  implicit  class  showOps [ A ]( in :  A )  extends  AnyVal  {  def  show ( implicit  instance :  Show [ A ]) :  String  =  instance . show ( in )  } }</p><p>//ShowOps.scala对象ShowOps{IMPLICIT类showOps[A](in：A)扩展AnyVal{def show(IMPLICIT INSTANCE：SHOW[A])：String=Instance。显示(输入)}}。</p><p>  // Show.scala object  Show  {  def  from [ A ]( f :  A  =&gt;  String ) :  Show [ A ]  =  new  Show [ A ]  {  def  show ( a :  A ) :  String  =  f ( a )  }  // Either this or import ShowOps and use context bound  implicit  def  showList [ A ]( ls :  List [ A ])( implicit  instance :  Show [ A ])  =  ls . map ( instance . show ). mkList ( &#34;,&#34; ) }</p><p>//Show.scala Object Show{def from[A](f：A=&gt；string)：show[A]=new Show[A]{def show(a：a)：string=f(A)}//此选项或导入ShowOps并使用上下文绑定的隐式def showList[A](ls：list[A])(隐式实例：show[A])=ls。贴图(实例。显示)。MkList(&#34；，&#34；)}</p><p>  // Main.scala import  Show._ import  ShowOps._ case  class  Mountain ( name :  String ,  height :  Int ) object  Main  extends  App  {  implicit  val  mountainShow :  Show [ Mountain ]  =  Show . fromFunction (( m :  Mountain )  =&gt;  s &#34;The ${m.name} is ${m.height} meters high&#34; )  val  mountains  =  List ( Mountain ( &#34;Mont Blanc&#34; ,  4808 ),  Mountain ( &#34;Matterhon&#34; ,  4478 ))  println ( mountains . show ) }</p><p>//Main.scala导入Show._import ShowOps._Case类Mountain(Name：String，Height：int)Object Main扩展App{隐式Val Mountain Show：Show[Mountain]=Show。FromFunction((m：Mountain)=&gt；s&#34；${m.name}是${m.Height}米高&34；)Val Mountain=list(Mountain(&#34；Mont Blanc&#34；，4808)，Mountain(&#34；Matterhon&#34；，4478))println(Mountain。显示)}。</p><p> We believe that this example shows how  implicit was used to achieve different goalsand, in doing so, used to be more confusing:</p><p>我们认为，这个例子展示了隐含如何被用来实现不同的目标，而在这样做的过程中，往往更令人困惑：</p><p> If you are providing an implicit instance, use  given to declare that the value is now available</p><p>如果要提供隐式实例，请使用GISTEN声明该值现在可用。</p><p>    If you are never going to refer to a value by its name, do not provide one</p><p>如果您永远不会按名称指定值，请不要提供该值。</p><p>   Another extremely interesting, yet more advanced, feature in Scala 3 related to contextual abstractions are  Context Functions.</p><p>Scala3中与上下文抽象相关的另一个非常有趣但更高级的特性是上下文函数。</p><p>  We went over the main use cases of  implicit in Scala 2 and offered a quick glance of whatthey would look like in Scala 3. While the final result is almost the same, code is moreexplicit and readable so that you can focus on solving your business problems rather than onsyntax.</p><p>我们回顾了Scala 2中隐式的主要用例，并提供了它们在Scala 3中的外观。虽然最终结果几乎相同，但代码更加明确和可读性更好，这样您就可以专注于解决业务问题，而不是语法。</p><p> This is part of a larger set of usability and ergonomy improvements for Scala 3 that we believewill make the language easier and more fun to use and we are very excited to see what thecommunity will create with them.</p><p>这是Scala 3的一系列更大的可用性和人体工程学改进的一部分，我们相信这些改进将使Scala 3使用起来更容易、更有趣，我们非常兴奋地看到社区将用它们创造什么。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.scala-lang.org/2020/11/06/explicit-term-inference-in-scala-3.html">https://www.scala-lang.org/2020/11/06/explicit-term-inference-in-scala-3.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/scala/">#scala</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/term/">#term</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>