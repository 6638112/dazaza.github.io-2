<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Linus Torvalds对链表的良好品味论点解释 Linus Torvalds' good taste argument for linked lists, explained</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Linus Torvalds' good taste argument for linked lists, explained<br/>Linus Torvalds对链表的良好品味论点解释 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-07 05:42:53</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/04d64f8959c524ed27bf583c949df3be.jpeg"><img src="http://img2.diglog.com/img/2020/12/04d64f8959c524ed27bf583c949df3be.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In a 2016  TED interview (14:10) Linus Torvalds speaks about what heconsiders  good taste in coding. As an example, he presents twoimplementations of item removal in singly linked lists (reproduced below). Inorder to remove the first item from a list, one of the implementations requiresa special case, the other one does not. Linus, obviously, prefers the latter.</p><p>在2016年TED的一次采访中（14:10），Linus Torvalds谈到了他认为编码方面的良好品味。作为一个示例，他提出了单链接列表中项目删除的两种实现方式（如下所示）。为了从列表中删除第一项，其中一种实现需要特殊情况，而另一种则不需要。显然，Linus更喜欢后者。</p><p>  [...] I don&#39;t want you to understand why it doesn&#39;t have the if statement.But I want you to understand that sometimes you can see a problem in adifferent way and rewrite it so that a special case goes away and becomes thenormal case, and that&#39;s  good code. [...] -- L. Torvalds</p><p>  [...]我不想让您理解为什么它没有if语句。但是我想让您理解有时您会以不同的方式看到问题并重写它，因此情况消失了，变成了正常情况，这就是很好的代码。 [...]-L. Torvalds</p><p> The code snippets he presents are C-style pseudocode and are simple enough tofollow. However, as Linus mentions in the comment, the snippets lack aconceptual explanation and it is not immediately evident how the more elegantsolution actually works.</p><p> 他呈现的代码段是C样式的伪代码，并且足够简单以至于可以遵循。但是，正如Linus在评论中提到的那样，这些代码片段缺乏概念上的解释，而且尚无法立即证明更优雅的解决方案实际上是如何工作的。</p><p> The next two sections look at the technical approach in detail and demonstratehow and why the indirect addressing approach is so neat. The last sectionextends the solution from item deletion to insertion.</p><p> 接下来的两节将详细介绍技术方法，并说明间接寻址方法如此整洁的方式以及原因。最后一部分将解决方案从项目删除扩展到插入。</p><p>  The basic data structure for a singly linked list of integers is shown inFigure 1.</p><p>  整数单链表的基本数据结构如图1所示。</p><p>  Numbers are arbitrarily chosen integer values and arrows indicate pointers. head is a pointer of type  IntListItem* and each of the boxesis an instance of an  IntListItem struct, each with a member variable (called next in the code) of type  IntListItem* that points to the next item.</p><p>  数字是任意选择的整数值，箭头表示指针。 head是IntListItem *类型的指针，每个框都是IntListItem结构的实例，每个都有一个IntListItem *类型的成员变量（在代码中称为next），该成员变量指向下一个项目。</p><p>  struct IntListItem {  int value;  struct IntListItem* next;}; typedef  struct IntListItem IntListItem; struct IntList { IntListItem* head;}; typedef  struct IntList IntList;</p><p>  struct IntListItem {int value; struct IntListItem * next;}; typedef struct IntListItem IntListItem; struct IntList {IntListItem * head;}​​; typedef struct IntList IntList; </p><p>  /* The textbook version  */ void  remove_cs101(IntList* l, IntListItem* target);  /* A more elegant solution  */ void  remove_elegant(IntList* l, IntListItem* target);</p><p>/ *教科书版本* / void remove_cs101（IntList * l，IntListItem * target）; / *一个更优雅的解决方案* / void remove_elegant（IntList * l，IntListItem * target）;</p><p> With that in place, let&#39;s have a look at the implementations of remove_cs101() and  remove_elegant(). The code of these examples is trueto the pseudocode from Linus&#39; example and also compiles and runs.</p><p> 有了这个，让我们看一下remove_cs101（）和remove_elegant（）的实现。这些示例的代码与Linus的伪代码相同。示例，并进行编译和运行。</p><p>   void  remove_cs101(IntList *l, IntListItem *target){ IntListItem *cur = l-&gt; head, *prev =  NULL;  while (cur != target) { prev = cur; cur = cur-&gt; next; }  if (prev) { prev-&gt; next = cur-&gt; next; }  else { l-&gt; head = cur-&gt; next; }}</p><p>   void remove_cs101（IntList * l，IntListItem * target）{IntListItem * cur = l->头* prev = NULL; while（cur！= target）{prev = cur; cur = cur-＆gt;下一个; } if（prev）{prev-＆gt;下一个= cur-＆gt;下一个; }其他{l-＆gt;头=当前->下一个; }}</p><p> The standard CS101 approach makes use of two traversal pointers  cur and prev, marking the current and previous traversal position in the list,respectively.  cur starts at the list head  head, and advances until thetarget is found.  prev starts at  NULL and is subsequently updated with theprevious value of  cur every time  cur advances. After the target is found,the algorithm tests if  prev is non- NULL. If yes, the item is not at thebeginning of the list and the removal consists of re-routing the linked listaround  cur. If  prev is  NULL,  cur is pointing to the first element inthe list, in which case, removal means moving the list head forward.</p><p> 标准的CS101方法使用两个遍历指针cur和prev，分别在列表中标记当前和先前的遍历位置。 cur从列表的开头开始，一直前进到找到目标为止。 prev从NULL开始，并在每次cur前进时使用cur的先前值进行更新。找到目标后，算法将测试prev是否为非NULL。如果是，则该项目不在列表的开头，并且删除操作包括在cur周围重新路由链接的列表。如果prev为NULL，则cur指向列表中的第一个元素，在这种情况下，删除意味着将列表头向前移动。</p><p>  The more elegant version has less code and does not require a separate branchto deal with deletion of the first element in a list.</p><p>  更优雅的版本具有更少的代码，并且不需要单独的分支来处理列表中第一个元素的删除。</p><p> void  remove_elegant(IntList *l, IntListItem *target){ IntListItem **p = &amp;l-&gt; head;  while ((*p) != target) { p = &amp;(*p)-&gt; next; } *p = target-&gt; next;}</p><p> void remove_elegant（IntList * l，IntListItem * target）{IntListItem ** p =＆l-＆gt;头;而（（* p）！=目标）{p =＆amp;（* p）-＆gt;下一个; } * p = target-＆gt;下一个;}</p><p> The code uses an indirect pointer  p that holds the address of a pointer to alist item, starting with the address of  head. In every iteration, thatpointer is advanced to hold the address of the pointer to the next list item,i.e. the address of the  next element in the current  IntListItem.When the pointer to the list item  (*p) equals  target, we exit the searchloop and remove the item from the list.</p><p> 该代码使用一个间接指针p，该指针从头的地址开始保存指向列表项的指针的地址。在每次迭代中，该指针都会前进以保存指向下一个列表项的指针的地址，即当前IntListItem中下一个元素的地址。当指向列表项（* p）的指针等于target时，我们退出searchloop并将其从列表中删除。 </p><p>   It allows us to interpret the linked list in a way that makes the  headpointer an integral part the data structure. This eliminates the needfor a special case to remove the first item.</p><p>它使我们能够以使指针成为数据结构不可或缺的一部分的方式来解释链表。这样就无需特殊情况下即可删除第一个项目。</p><p> It also allows us to evaluate the condition of the  while loop withouthaving to let go of the pointer that points to  target. This allows us tomodify the pointer that points to  target and to get away with a singleiterator as opposed to  prev and  cur.</p><p> 它还允许我们评估while循环的条件，而不必放开指向目标的指针。这使我们可以修改指向目标的指针，并使用单迭代器来代替prev和cur。</p><p>   The standard model interprets the linked list as a sequence of  IntListIteminstances. The beginning of the sequence can be accessed through a  headpointer.</p><p>   标准模型将链接列表解释为IntListIteminstances的序列。序列的开头可以通过头指针访问。</p><p> This leads to the chunking illustrated in Figure 2. The  head pointer ismerely considered as a handle to access the start of the list.  prev and  curare pointers of type  IntListItem* and always point to an item or  NULL.</p><p> 这导致图2中所示的分块。头指针仅被视为访问列表开头的句柄。类型IntListItem *的prev和curare指针，始终指向一个项目或NULL。</p><p> The elegant implementation uses indirect addressing scheme that yields a differentview on the data structure:</p><p> 优雅的实现使用间接寻址方案，该方案对数据结构产生了不同的看法：</p><p>  Here,  p is of type  IntListItem** and holds the address of the pointer tothe current list item. When we advance the pointer, we forward to the addressof the pointer to the next list item.</p><p>  在这里，p的类型为IntListItem **，并保存指向当前列表项的指针的地址。当我们前进指针时，我们将前进到下一个列表项的指针的地址。</p><p>  -&gt;next: dereference that pointer again and select the field that holdsthe address of the next list item</p><p>  ->下一个：再次取消引用该指针，然后选择保存下一个列表项地址的字段 </p><p> This corresponds to an interpretation of the data structure where the list is aa sequence of pointers to  IntListItems (cf. Figure 3).</p><p>这对应于对数据结构的解释，其中列表是一个指向IntListItems的指针序列（请参见图3）。</p><p>  An additional benefit of that particular interpretation is that it supportsediting the  next pointer of the predecessor of the current item throughout theentire traversal.</p><p>  该特定解释的另一个好处是，它在整个遍历过程中都支持编辑当前项目的前任的下一个指针。</p><p> With  p holding the address of a pointer to a list item, the comparison in thesearch loop becomes</p><p> 通过p持有指向列表项的指针的地址，搜索循环中的比较变为</p><p>  The search loop will exit if  (*p) equals  target, and once it does, we arestill able to modify  (*p) since we hold its address  p. Thus, despiteiterating the loop until we hit  target, we still maintain a handle (theaddress of the  next field or the  head pointer) that can be used to directlymodify the pointer that points  to the item.</p><p>  如果（* p）等于目标，则搜索循环将退出，并且一旦完成，由于我们保留了它的地址p，我们仍然可以修改（* p）。因此，尽管重复循环直到我们达到目标，我们仍然维护一个句柄（下一个字段的地址或头指针），该句柄可用于直接修改指向该项目的指针。</p><p> This is the reason why we can modify the incoming pointer to an item to pointto a different location using  *p = target-&gt;next and why we do not need  prevand  cur pointers to traverse the list for item removal.</p><p> 这就是为什么我们可以使用* p = target-> next修改指向项目的传入指针以指向其他位置的原因，以及为什么我们不需要prevand cur指针来遍历列表以删除项目的原因。</p><p>  It turns out that the idea behind  remove_elegant() can be applied to yield aparticularly concise implementation of another function in the list API: insert_before(), i.e. inserting a given item before another one.</p><p>  事实证明，remove_elegant（）背后的思想可以应用于在列表API中生成另一个函数的特别简洁的实现：insert_before（），即在给定项之前插入另一个。</p><p>    The function will take a pointer to a list  l, a pointer  before to anitem in that list and a pointer to a new list item  item that the functionwill insert before  before.</p><p>    该函数将使用指向列表l的指针，指向该列表中anitem的指针以及指向该函数将在其之前插入的新列表项的指针。 </p><p>   static  inline IntListItem ** find_indirect(IntList *l, IntListItem *target){ IntListItem **p = &amp;l-&gt; head;  while ((*p) &amp;&amp; (*p) != target) { p = &amp;(*p)-&gt; next; }  return p;}</p><p>静态内联IntListItem ** find_indirect（IntList * l，IntListItem * target）{IntListItem ** p =＆amp; l-＆gt;头; while（（（* p）＆amp;＆amp;（* p）！= target）{p =＆amp;（* p）-＆gt;下一个; } return p;}</p><p>     void  insert_before(IntList *l, IntListItem *before, IntListItem *item){ IntListItem **p =  find_indirect(l, before); *p = item; item-&gt; next = before;}</p><p>     void insert_before（IntList * l，IntListItem *之前，IntListItem * item）{IntListItem ** p = find_indirect（l，before）; * p =项目；项目-＆gt;下一个=之前；}</p><p> A particularly beautiful outcome is that the implementation has consistentsemantics for the edge cases: if  before points to the list head, the new itemwill be inserted at the beginning of the list, if  before is  NULL or invalid(i.e. the item does not exist in  l), the new item will be appended at theend.</p><p> 一个特别美丽的结果是，实现在边缘情况下具有一致的语义：如果before指向列表头，则新项目将插入到列表的开头，如果before为NULL或无效（即该项目在l中不存在） ），新项目将在末尾附加。</p><p>  The premise of the more elegant solution for item deletion is a single, simplechange: using an indirect  IntListItem** pointer to iterate over the pointersto the list items. Everything else flows from there: there is no need for aspecial case or branching and a single iterator is sufficient to find andremove the target item.It also turns out that the same approach provides an elegant solution for iteminsertion in general and for insertion  before an existing item in particular.</p><p>  删除项目的更优雅解决方案的前提是一个简单的更改：使用间接IntListItem **指针迭代指针到列表项。所有其他一切都从那里流动：不需要特殊的情况或分支，并且仅需要一个迭代器就可以找到和删除目标项目。同样，该方法还为一般的项目插入和在现有项目之前插入提供了优雅的解决方案特别是项目。</p><p> So, going back to Linus&#39; initial comment: is it good taste? Hard to say, butit&#39;s certainly a different, creative and very elegant solution to a well-knownCS task.</p><p> 因此，回到Linus＆＃39;初步点评：味道好吗？很难说，但是对于著名的CS任务，它无疑是一种不同的，创造性的且非常优雅的解决方案。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/torvalds/">#torvalds</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指针/">#指针</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>