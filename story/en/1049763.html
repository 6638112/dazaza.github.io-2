<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Bupstash垃圾收集器 The Bupstash Garbage Collector</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Bupstash Garbage Collector<br/>Bupstash垃圾收集器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-27 13:29:45</div><div class="page_narrow text-break page_content"><p>My backup tool  bupstash stores backups in a repository as an evergrowing set ofencrypted data trees which use content addressing and structural sharingto deduplicate data. In order to delete unused backups we need to do something very similar to howmany programming languages free unreferenced memory - garbage collection. This post willexplain the evolution and implementation of the garbage collector in bupstash for the curious.</p><p>我的备份工具bupstash将备份作为一组不断增长的加密数据树存储在存储库中，这些数据树使用内容寻址和结构共享来消除重复数据。为了删除未使用的备份，我们需要执行与多种编程语言非常相似的操作，以释放未引用的内存-垃圾回收。出于好奇，本文将解释bupstash中垃圾收集器的演变和实现。</p><p>  The initial version of the bupstash garbage collector was a naive stop-the-worldgarbage collector. It walks all backup data trees creating a set of reachable data chunksby address and then deletes unreachable data.</p><p>  bupstash垃圾收集器的最初版本是一个幼稚的世界垃圾收集器。它遍历所有备份数据树，以创建一组可访问的数据块（按地址），然后删除不可达的数据。</p><p>    lock_repository()reachable_addresses = empty_set()for data_tree in all_backups(): work_list = new_work_list_from_backup(data_tree.root_address) until work_list.is_empty(): node_height, node_address = work_list.pop() reachable_addresses.add(node_address) if node_height != 0: add_child_nodes_to_worklist(work_list, node_address)for chunk_address in repository: if not reachable_addresses.has(chunk_address): delete_chunk(chunk_address)unlock_repository()</p><p>    在all_backups（）中用于data_tree的lock_repository（）reachable_addresses = empty_set（）：work_list = new_work_list_from_backup（data_tree.root_address）直到work_list.is_empty（）：node_height，node_address = work_list.pop（）reachable_addresses.add（nodeeightaddress！） ：存储库中的块地址的add_child_nodes_to_worklist（work_list，node_address）：如果没有可达地址.has（chunk_address）：delete_chunk（chunk_address）unlock_repository（）</p><p> This algorithm is short and sweet, but if the repository is very large our repository becomes unavailablefor a potentially long time. The next version shortens the downtime of the repository significantly.</p><p> 该算法简短有效，但是如果存储库很大，则可能很长一段时间我们的存储库都不可用。下一版本大大缩短了存储库的停机时间。</p><p>   Because many backups share data with each other, we can memoize the walk phase to skip work.</p><p>   由于许多备份彼此共享数据，因此我们可以记住步行阶段以跳过工作。</p><p> Because backups are immutable while the repository is unlocked, we can walk most of them withoutstopping the world.</p><p> 因为在存储库未锁定时备份是不可变的，所以我们可以在不停步的情况下完成大部分备份。</p><p> This time we walk the repository without the repository locked, then lock it and walkthe repository again using our memoization to quickly complete the job. If any new backupsappeared during our first walk, we are guaranteed to mark them now that the repository lock is held. Doing the majority of the slow mark phase without locking the repository greatly increasesthe repository availability for other operations.</p><p> 这次，我们在没有锁定存储库的情况下遍历存储库，然后将其锁定并使用我们的备忘录再次遍历存储库以快速完成作业。如果在我们的第一个步骤中出现了任何新的备份，则保证已保存存储库锁定，因此我们将对其进行标记。在不锁定存储库的情况下执行大部分慢标记阶段将大大提高存储库可用于其他操作的可用性。 </p><p>    walked_trees = empty_set()reachable_addresses = empty_set()func walk_repository(): for data_tree in all_backups(): if walked_trees.has(data_tree): continue walked_trees.add(data_tree) work_list = new_work_list_from_backup(data_tree.root_address) until work_list.is_empty(): node_height, node_address = work_list.pop() already_walked = reachable_addresses.has(node_address) reachable_addresses.add(node_address) if node_height != 0 and not already_walked: add_child_nodes_to_worklist(work_list, node_address)walk_repository()lock_repository()walk_repository()for chunk_address in repository: if not reachable_addresses.has(chunk_address): delete_chunk(chunk_address)unlock_repository()</p><p>walked_trees = empty_set（）reachable_addresses = empty_set（）func walk_repository（）：用于all_backups（）中的data_tree：如果walked_trees.has（data_tree）：继续walked_trees.add（data_tree）work_list = new_work_list_from_backup（data_tree.is ）：node_height，node_address = work_list.pop（）has_walked = reachable_addresses.has（node_address）reachable_addresses.add（node_address）如果node_height！= 0且尚未被walked：add_child_nodes_to_worklist（work_list，node_address）walk_repository（）lock_repository（）存储库中的chunk_address：如果不可达，则为has（chunk_address）：delete_chunk（chunk_address）unlock_repository（）</p><p>   In bupstash each data chunk address is 32 bytes, which means we need at least 32 bytes of RAM per chunk in the repository to successfully perform a garbage collection. For a repository containing a 100 million chunks ormore this could easily exhaust memory on a busy or small system.</p><p>   在bupstash中，每个数据块地址为32个字节，这意味着我们必须在存储库中每个块至少有32个字节的RAM才能成功执行垃圾回收。对于包含1亿块或更多块的存储库，这很容易耗尽繁忙或小型系统上的内存。</p><p> If we are willing to accept a very low probability of retaining some extra data, we can reduce this downto a few  bits per chunk reducing memory usage by 64x or more.To do this we use a probabilistic data structure called a  bloom filter to track reachable addresses.</p><p> 如果我们愿意接受保留一些额外数据的可能性非常低，则可以将其减少到每块几位，从而将内存使用量减少64倍或更多，为此，我们使用一种称为Bloom Bloom的概率数据结构来跟踪可访问数据地址。</p><p>  They can have false positives. For us this means we might keep a data chunk by accident we could have actually freed.</p><p>  他们可能有误报。对我们来说，这意味着我们可能会意外释放实际上可以释放的数据块。</p><p>  Because memory use is so low per address, we can generously size our bloom filter reducing false positives to less than one percent, even for large repositories.</p><p>  由于每个地址的内存使用量非常低，因此即使对于大型存储库，我们也可以慷慨地设置Bloom过滤器的大小，从而将误报率降低到小于百分之一。</p><p> We can easily detect when a bloom filter gets overly full and produces many false positives, and thus adjust it’s size for future garbage collections.</p><p> 我们可以很容易地检测出Bloom过滤器何时变得过满并产生许多误报，从而为将来的垃圾收集调整其大小。</p><p> As a bonus, the bupstash implementation of a bloom filter is actually simpler than a hash table, with the implemenationweighing in at around 30 lines of code plus tests and helpers.</p><p> 另外，bloom过滤器的bupstash实现实际上比哈希表更简单，实现的权重约为30行代码以及测试和帮助程序。 </p><p>    walked_trees = empty_set()walked_addresses = empty_cache()reachable_addresses = empty_bloom_filter(repository_bloom_size())func walk_repository(): for data_tree in all_backups(): if walked_trees.has(data_tree): continue walked_trees.add(data_tree) work_list = new_work_list_from_backup(data_tree.root_address) until work_list.is_empty(): node_height, node_address = work_list.pop() already_walked = walked_addresses.has(node_address) reachable_addresses.add(node_address) walked_addresses.add(node_address) if node_height != 0 and not already_walked: add_child_nodes_to_worklist(work_list, node_address)walk_repository()lock_repository()walk_repository()if bloom_filter_overutilized(reachable_addresses): increase_bloom_filter_size_for_next_gc()else if bloom_filter_underutilized(reachable_addresses): decrease_bloom_filter_size_for_next_gc()for chunk_address in repository: if not reachable_addresses.has(chunk_address): delete_chunk(chunk_address)unlock_repository()</p><p>walked_trees = empty_set（）walked_addresses = empty_cache（）reachable_addresses = empty_bloom_filter（repository_bloom_size（））func walk_repository（）：用于all_backups（）中的data_tree：如果walked_trees.has（data_tree）：继续walked_trees.back（list_upload_list_ups） .root_address）直到work_list.is_empty（）：node_height，node_address = work_list.pop（）has_walked = walked_addresses.has（node_address）reachable_addresses.add（node_address）walked_addresses.add（node_address）如果node_height！= 0而不是not_walked：add_child_node_to work_list，node_address）walk_repository（）lock_repository（）walk_repository（）如果​​bloom_filter_overutilized（reachable_addresses）：则增加bloom_filter_size_for_next_gc（）否则如果bloom_filter_underutilized（reachable_addresses），则减少_bloom_filter_size_for_next_g unlock_repository（）</p><p> One thing to note about this implementation is that because the bloom filter has false positives we can not use it to skip processing addresses, insteadwe must introduce a new cache for this purpose. A cache also lets us put a fixed upper bound on memory usage for large repositories.</p><p> 关于此实现的注意事项是，由于Bloom筛选器具有误报，因此我们不能使用它来跳过处理地址，相反，我们必须为此目的引入一个新的缓存。高速缓存还使我们可以为大型存储库设置固定的内存使用上限。</p><p> Overall for large repositories, the addition of a bloom filter reduces ram requirements from the gigabyte range down to tens of megabytes while increasing the repository size by only a fraction of a percent.</p><p> 总体而言，对于大型存储库，添加Bloom Bloom过滤器可将内存需求从千兆字节的范围降低到数十兆字节，同时将存储库的大小仅增加百分之一。</p><p>  The bupstash garbage collector tries hard to keep the repository avaliable as longas possible while also providing excellent performance with a small memory profile. If you are implementinga content addressed storage system, this post will hopefully provide you with some new ideas.</p><p>  bupstash垃圾收集器尽力使存储库尽可能长时间可用，同时还以较小的内存配置文件提供出色的性能。如果您正在实施内容寻址的存储系统，则希望该博文为您提供一些新的想法。</p><p> In the future bupstash could follow the same path as programming language garbage collectors to find more improvements:</p><p> 将来，bupstash可能会遵循与编程语言垃圾收集器相同的路径，以寻求更多改进： </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://acha.ninja/blog/the_bupstash_garbage_collector/">https://acha.ninja/blog/the_bupstash_garbage_collector/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/垃圾/">#垃圾</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/garbage/">#garbage</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/存储/">#存储</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>