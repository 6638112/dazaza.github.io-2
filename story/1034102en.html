<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在Unikernel上使用“Virtio-Fs”</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">在Unikernel上使用“Virtio-Fs”</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-10 02:32:25</div><div class="page_narrow text-break page_content"><p>This article provides an overview of  virtio-fs,a novel way for sharing the host file system with guests and OSv, a specialized, lightweightoperating system (unikernel) for the cloud, as well as how these two fittogether.</p><p>本文概述了virtio-fs，这是一种与来宾和OSV共享主机文件系统的新方法，OSV是一种专门的、轻量级的云操作系统(Unikernel)，本文将介绍这两种文件系统是如何结合在一起的。</p><p>  Virtio-fs is a new host-guest shared filesystem, purpose-built for local filesystem semantics and performance. To that end, it takes full advantage of thehost’s and the guest’s colocation on the same physical machine, unlikenetwork-based efforts, like virtio-9p.</p><p>Virtio-fs是一种新的主机-来宾共享文件系统，专门为本地文件系统语义和性能而构建。为此，它充分利用了主机和来宾主机在同一台物理机上的位置，这与基于网络的工作不同，比如virtio-9p。</p><p> As the name suggests, virtio-fs builds on virtio for providing an efficienttransport: it is included in the (currently draft, to become v1.2) virtio specification as a new device. Theprotocol used by the device is a slightly extended version of FUSE, providing a solid foundation forall file system operations native on Linux. Implementation-wise, on the QEMUside, it takes the approach of splitting between the guest interface (handledby QEMU) and the host file system interface (the device “backend”). The latteris handled by virtiofsd (“virtio-fs daemon”), running as a separate process,utilizing the vhost-user protocolto communicate with QEMU.</p><p>顾名思义，virtio-fs构建在virtio之上以提供高效的传输：它作为一种新设备包含在virtio规范(目前的草案将成为v1.2)中。该设备使用的协议是FUSE的略微扩展版本，为Linux上原生的所有文件系统操作提供了坚实的基础。在实现方面，在QEMU端，它采取在客户接口(由QEMU处理)和主机文件系统接口(设备“后端”)之间拆分的方法。后者由virtiofsd(“virtio-fs daemon”)处理，作为单独的进程运行，利用vhost-user协议与qemu通信。</p><p> One prominent performance feature of virtio-fs is the DAX (Direct Access)window. It’s a shared memory window between the host and the guest, exposed asdevice memory (a PCI BAR) to the second. Upon request, the host (QEMU) maps file contents to the window for the guest to access directly. This bears performancegains due to taking VMEXITs out of the read/write data path and bypassing theguest page cache on Linux, while not counting against the VM’s memory (sinceit’s just device memory, managed on the host).</p><p>Virtio-fs的一个突出性能特征是DAX(直接访问)窗口。它是主机和来宾之间的一个共享内存窗口，作为设备内存(一个PCI条)暴露给第二个来宾。根据请求，主机(QEMU)将文件内容映射到来宾可以直接访问的窗口。这是由于将VMEXIT移出读/写数据路径并绕过Linux上的来宾页面缓存，而不计入VM内存(因为它只是主机上管理的设备内存)，所以具有很高的性能。</p><p>  Virtio-fs is under active development, with its community focussing on a pair ofdevice implementation in QEMU and device driver in Linux. Both components arealready available upstream in their initial iterations, while upstreamingcontinues further e.g. with DAX window support.</p><p>Virtio-fs正在积极开发中，其社区专注于QEMU中的两个设备实现和Linux中的设备驱动程序。这两个组件在最初的迭代中都已经在上游可用，而上游还在继续，例如通过DAX窗口支持。</p><p>   Application-specialized: a unikernel is an executable machine image,consisting of an application and supporting code (drivers, memory management,runtime etc.) linked together, running in a single address space (typicallyin guest “kernel mode”).</p><p>应用程序专门化：单核是一个可执行的机器镜像，由应用程序和支持代码(驱动程序、内存管理、运行时等)组成。链接在一起，在单个地址空间中运行(通常在来宾“内核模式”下)。</p><p>  Library OS: each unikernel only contains the functionality mandated by itsapplication in terms of non-application code, i.e. no unused drivers, or evenwhole subsystems (e.g. networking, if the application doesn’t use thenetwork).</p><p>库操作系统：每个单内核只包含其应用程序在非应用程序代码方面要求的功能，即不包含未使用的驱动程序，甚至不包含整个子系统(例如，如果应用程序不使用网络，则为网络)。</p><p> OSv in particular strives for binary compatibility with Linux, using a  dynamiclinker. This meansthat applications built for Linux should run as OSv unikernels without requiringmodifications or even rebuilding, at least most of the time. Of course, not thewhole Linux ABI is supported, with system calls like  fork() and relativesmissing by design in all unikernels, which lack the notion of a process. Despitethis limitation, OSv is quite full featured, with full SMP support, virtualmemory, a virtual file system (and many filesystem implementations, includingZFS) as well as a mature networking stack, based on the FreeBSD sources.</p><p>OSV尤其使用动态链接器努力实现与Linux的二进制兼容性。这意味着为Linux构建的应用程序应该作为OSV单核运行，而不需要修改甚至重建，至少在大多数情况下是这样。当然，并不是整个Linux ABI都被支持，在所有缺乏进程概念的单核中，像fork()和relatis这样的系统调用在设计上都是缺失的。尽管有这个限制，但OSV功能相当齐全，完全支持SMP、虚拟内存、虚拟文件系统(以及许多文件系统实现，包括ZFS)以及基于FreeBSD源代码的成熟网络堆栈。</p><p> At this point, one is sure to wonder “Why bother with unikernels?”. The problemthey were originally introduced to solve is thebloated software stack in modern cloud computing. Running general-purposeoperating systems as guests, typically for a single application/service, on topof a hypervisor which already takes care of isolation and provides a standarddevice model means duplication, as well as loss of efficiency. This is wereunikernels come in, trying to be just enough to support a single applicationand as light-weight as possible, based on the assumption that they are executinginside a VM. Below is an illustration of the comparison betweengeneral-purpose OS, unikernels and containers (as another approach to the sameproblem, for completeness).</p><p>在这一点上，人们肯定会问：“为什么要为单一内核操心呢？”引入它们最初要解决的问题是现代云计算中臃肿的软件堆栈。在已经负责隔离并提供标准设备模型的管理程序之上，将通用操作系统作为来宾运行，通常用于单个应用程序/服务，这意味着重复，以及效率损失。这就是我们引入的统一内核，基于它们在一个虚拟机内执行的假设，试图只支持单个应用程序，并且尽可能轻量级。下面是通用操作系统、单内核和容器之间的比较(作为解决相同问题的另一种方法，为了完整性)。</p><p>   As is apparent e.g. from the container world, it is very common for applicationsrunning in isolated environments (such as containers, or unikernels even moreso) to require host file system access. Whereas containers sharing the hostkernel thus have an obvious, controlled path to the host file system, withunikernels this has been more complex: all solutions were somewhat heavyweight,requiring a network link or indirection through network protocols. Virtio-fsthen provided a significantly more attractive route: straight-forward mapping offs operations (via FUSE), reusing the existing virtio transport and decentperformance without high memory overhead.</p><p>例如，从容器世界中可以明显看出，在隔离环境(例如容器或单内核，甚至更多)中运行的应用程序需要主机文件系统访问是非常常见的。因此，共享主机内核的容器具有通向主机文件系统的明显的、可控的路径，而对于单内核，情况则更为复杂：所有解决方案都有些重量级，需要网络链接或通过网络协议间接连接。然后，Virtio-fs提供了一条更有吸引力的路线：直接映射关闭操作(通过FUSE)，重用现有的virtio传输并降低性能，而不需要很高的内存开销。</p><p> The OSv community quickly identified the opportunity and came up with aread-only implementation on its side, when executing under QEMU. This emphasizedbeing lightweight complexity-wise, while catering to many of its applications’requirements (they are stateless, think e.g. serverless). Notably, it includessupport for the DAX window (even before that’s merged in upstream QEMU),providing  excellent performance, directlyrivalling that of its local (non-shared) counterparts such as ZFS and ROFS (anOSv-specific read-only file system).</p><p>当在QEMU下执行时，OSV社区很快发现了机会，并提出了仅限区域的实现。这强调了在复杂性方面是轻量级的，同时满足了许多应用程序的需求(它们是无状态的，可以认为是无服务器的)。值得注意的是，它包括对DAX窗口的支持(甚至在它被合并到上游QEMU之前)，提供了卓越的性能，可以直接与本地(非共享)的同类产品相媲美，比如ZFS和ROFS(一种特定于OSv的只读文件系统)。</p><p> One central point is OSv’s support for booting from virtio-fs: this enablesdeploying a modified version or a whole new application  without rebuildingthe image, just by adjusting its root file system contents on the host. Last,owing to the DAX window practically providing low-overhead access to the host’spage cache, scalability is also expected to excel, with it being a commonconcern due to the potentially high density of unikernels per host.</p><p>一个中心点是OSV支持从virtio-fs引导：这使得无需重新构建镜像即可部署修改后的版本或整个新的应用程序，只需在主机上调整其根文件系统内容即可。最后，由于DAX窗口实际上提供了对主机页面缓存的低开销访问，因此可扩展性也有望出类拔萃，这是一个普遍关注的问题，因为每个主机的单内核密度可能很高。</p><p> For example, to build the  cli OSv image, bootable from virtio-fs, using thecore OSv  buildsystem:</p><p>例如，要使用核心OSV构建系统构建可从virtio-fs引导的cli OSV镜像：</p><p>  This results in a minimal image (just the initramfs), while the root fs contentsare placed in a directory on the host ( build/export here, by default).</p><p>这会产生一个最小的图像(只有initramfs)，而根文件系统的内容则放在主机上的一个目录中(默认情况下，这里是构建/导出)。</p><p> Running the above imageis just a step away (may want to use the virtio-fs development version of QEMU, e.g. for DAXwindow support):</p><p>运行上面的镜像只有一步之遥(可能需要使用QEMU的virtio-fs开发版本，例如用于DAXWindow支持)：</p><p>  This orchestrates running both virtiofsd and QEMU, using the contents of build/export as the root file system. Any changes to this directory, directlyfrom the host will be visible in the guest without re-running the previous buildstep.</p><p>这将使用build/export的内容作为根文件系统来协调virtiofsd和qemu的运行。直接从主机对此目录所做的任何更改都将在来宾系统中可见，而无需重新运行前面的构建步骤。</p><p>  OSv has gained a prominent new feature, powered by virtio-fs and its QEMUimplementation. This allows efficient, lightweight and performant access to thehost’s file system, thanks to the native virtio transport, usage of the FUSEprotocol and the DAX window architecture. In turn, it enables use cases likerapid unikernel reconfiguration.</p><p>OSV获得了一个突出的新特性，由virtio-fs及其QEMU实现提供支持。得益于本地Virtio传输、FUSE协议和DAX窗口架构的使用，这允许高效、轻量级和高性能地访问主机的文件系统。反过来，它支持像erapid单内核重新配置这样的用例。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.qemu.org/2020/11/03/osv-virtio-fs/">https://www.qemu.org/2020/11/03/osv-virtio-fs/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/virtio/">#virtio</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/fs/">#fs</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/osv/">#osv</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>