<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>看看iOS 14中的iMessage A Look at iMessage in iOS 14</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A Look at iMessage in iOS 14<br/>看看iOS 14中的iMessage </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-29 08:42:58</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/64e84300118c0f6091562cfc5d5e2f97.png"><img src="http://img2.diglog.com/img/2021/1/64e84300118c0f6091562cfc5d5e2f97.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>On December 20, Citizenlab published “  The Great iPwn ”, detailing how  “Journalists [were] Hacked with Suspected NSO Group iMessage ‘Zero-Click’ Exploit” . Of particular interest is the following note: “We do not believe that [the exploit] works against iOS 14 and above, which includes new security protections&#39;&#39;. Given that it is also now almost exactly one year ago since we published the   Remote iPhone Exploitation  blog post series , in which we described how an iMessage 0-click exploit can work in practice and gave a number of suggestions on how similar attacks could be prevented in the future, now seemed like a great time to dig into the security improvements in iOS 14 in more detail and explore how Apple has hardened their platform against 0-click attacks.</p><p>12月20日，Citizenlab发布了“ The Great iPwn”，详细介绍了“新闻记者如何被NSO怀疑的iMessage组“零点击”利用所黑客入侵。需要特别注意的是以下注意事项：“我们认为[漏洞利用]不适用于iOS 14及更高版本，其中包括新的安全保护。鉴于距我们发布远程iPhone漏洞博客博客系列已经差不多一年了，在该系列文章中，我们描述了iMessage 0-click漏洞如何在实践中发挥作用，并就如何防止类似攻击提供了一些建议在将来，现在似乎是个绝佳时机，更详细地研究iOS 14中的安全性改进，并探索Apple如何针对0次点击攻击强化其平台。</p><p>  The content of this blog post is the result of a roughly one-week reverse engineering project, mostly performed on a M1 Mac Mini running macOS 11.1, with the results, where possible, verified to also apply to iOS 14.3, running on an iPhone XS. Due to the nature of this project and the limited timeframe, it is possible that I have missed some relevant changes or made mistakes interpreting some results. Where possible, I’ve tried to describe the steps necessary to verify the presented results, and would appreciate any corrections or additions.</p><p>  该博客文章的内容是大约一个星期的反向工程项目的结果，该项目主要在运行macOS 11.1的M1 Mac Mini上执行，其结果在可能的情况下也经过验证，也适用于在iPhone XS上运行的iOS 14.3。 。由于该项目的性质和时间限制，我可能错过了一些相关更改或在解释某些结果时犯了错误。在可能的情况下，我尝试描述了验证所显示结果所必需的步骤，并希望您进行任何更正或补充。</p><p>  The blog post will start with an overview of the major changes Apple implemented in iOS 14 which affect the security of iMessage. Afterwards, and mostly for the readers interested in the technical details, each of the major improvements is described in more detail while also providing a walkthrough of how it was reverse engineered. At least for the technical details, it is recommended to briefly review the blog post series from last year for a basic introduction to iMessage and the exploitation techniques used to attack it.</p><p>  博客文章将首先概述Apple在iOS 14中实施的，影响iMessage安全性的重大变化。之后，对于大多数对技术细节感兴趣的读者，将详细介绍每项主要改进，同时还提供了反向工程的演练。至少就技术细节而言，建议简要回顾一下去年的博客文章系列，以基本了解iMessage及其用于攻击它的开发技术。</p><p>   A memory corruption vulnerability, reachable without user interaction and ideally without triggering any user notifications</p><p>   内存损坏漏洞，无需用户交互即可到达，理想情况下无需触发任何用户通知即可到达</p><p>   ( Likely ) A way to break out of any sandbox, typically by exploiting a separate vulnerability in another operating system component (e.g. a userspace service or the kernel)</p><p>   （可能）一种突破任何沙箱的方法，通常是利用另一个操作系统组件（例如，用户空间服务或内核）中的单独漏洞</p><p>  With iOS 14, Apple shipped a significant refactoring of iMessage processing, and made all four parts of the attack harder. This is mainly due to three central changes:</p><p>  在iOS 14上，Apple进行了iMessage处理的重大重构，并使攻击的所有四个部分都更加困难。这主要是由于三个主要变化：</p><p>  One of the major changes in iOS 14 is the introduction of a new, tightly sandboxed “BlastDoor” service which is now responsible for almost all parsing of untrusted data in iMessages (for example,   NSKeyedArchiver payloads ). Furthermore, this service is written in   Swift ,  a (mostly) memory safe language which makes it significantly harder to introduce classic memory corruption vulnerabilities into the code base.</p><p>  iOS 14的主要变化之一是引入了一个新的，紧密沙盒化的“ BlastDoor”服务，该服务现在负责iMessages中几乎所有的不可信数据解析（例如NSKeyedArchiver负载）。此外，此服务使用Swift（一种（主要）内存安全的语言）编写，这使得将经典内存损坏漏洞引入代码库的难度大大提高。 </p><p>  The following diagram shows the rough new iMessage processing pipeline, with the name of the respective service process shown at the top of each box.</p><p>下图显示了粗略的新iMessage处理管道，各个服务进程的名称显示在每个框的顶部。</p><p>     As can be seen, the majority of the processing of complex, untrusted data has been moved into the new BlastDoor service. Furthermore, this design with its 7+ involved services allows fine-grained sandboxing rules to be applied, for example, only the  IMTransferAgent  and  apsd  processes are required to perform network operations. As such, all services in this pipeline are now properly sandboxed (with the BlastDoor service arguably being sandboxed the strongest).</p><p>     可以看出，大多数复杂，不受信任的数据处理已移至新的BlastDoor服务中。此外，此设计及其7种以上涉及的服务允许应用细粒度的沙盒规则，例如，仅需IMTransferAgent和apsd进程即可执行网络操作。因此，该管道中的所有服务现在都已正确地沙盒化（可以说BlastDoor服务被最强大的沙盒化）。</p><p>  Historically, ASLR on Apple’s platforms had one architectural weakness: the   shared cache region , containing most of the system libraries in a single prelinked blob, was only randomized per boot, and so would stay at the same address across all processes. This turned out to be especially critical in the context of 0-click attacks, as   it allowed an attacker, able to remotely observe process crashes (e.g. through timing of automatic delivery receipts), to infer the base address of the shared cache  and as such break ASLR, a prerequisite for subsequent exploitation steps.</p><p>  从历史上看，Apple平台上的ASLR具有一个体系结构上的弱点：共享缓存区域（在一个预链接的blob中包含大多数系统库）仅在每次引导时被随机分配，因此在所有进程中都将保持相同的地址。事实证明，这在0单击攻击的情况下尤为重要，因为它允许攻击者能够远程观察进程崩溃（例如，通过自动发送收据的时间），推断共享缓存的基址等。打破ASLR，这是后续利用步骤的先决条件。</p><p>  However, with iOS 14, Apple has added logic to  specifically  detect this kind of attack, in which case the shared cache is re-randomized for the targeted service the next time it is started, thus rendering this technique useless. This should make bypassing ASLR in a 0-click attack context significantly harder or even impossible (apart from brute force) depending on the concrete vulnerability.</p><p>  但是，在iOS 14上，苹果添加了专门用于检测这种攻击的逻辑，在这种情况下，下次启动时针对目标服务将共享缓存重新随机化，从而使该技术无用。根据具体的漏洞，这将使在0单击攻击上下文中绕过ASLR变得更加困难甚至不可能（除了蛮力外）。</p><p>  To limit an attacker’s ability to retry exploits or brute force ASLR, the BlastDoor and imagent services are now subject to a newly introduced  exponential throttling mechanism enforced by  launchd , causing the interval between restarts after a crash to double with every subsequent crash (up to an apparent maximum of 20 minutes). With this change, an exploit that relied on repeatedly crashing the attacked service would now likely require in the order of multiple hours to roughly half a day to complete instead of a few minutes.</p><p>  为了限制攻击者重试漏洞利用或蛮力ASLR的能力，BlastDoor和Imagent服务现在受新引入的指数限制机制的约束，该机制由launchd强制执行，从而导致崩溃后重新启动之间的间隔加倍，每次后续崩溃均会增加一倍。最多20分钟）。通过此更改，依赖于反复崩溃被攻击服务的漏洞利用现在可能需要几个小时到大约半天才能完成，而不是几分钟。</p><p>  The remainder of this blog post will now look at each of these three changes in greater depths.</p><p>  现在，本博客文章的其余部分将更深入地探讨这三个更改。</p><p>   The new BlastDoor service and its role in the processing of iMessages can be studied by following the flow of an incoming iMessage. On the wire, a simple text iMessage would look something like this, encoded as binary   plist :</p><p>   可以通过跟踪传入的iMessage的流程来研究新的BlastDoor服务及其在iMessage的处理中的作用。在线上，一个简单的文本iMessage看起来像这样，编码为二进制plist： </p><p>                            Previously, all of this work happened in imagent. With iOS 14, however, it all moved into the new BlastDoor service. While the main processing flow still starts in  imagent , which receives the raw but unencrypted payload bytes from  identityservicesd  (part of the IDS framework) in  -[IMDiMessageIDSDelegate service:account:incomingTopLevelMessage:fromID:messageContext:] , messages  are then more or less immediately forwarded to the BlastDoor service through  +[IMBlastdoor sendDictionary:withCompletionBlock:]   which creates the reply handler block and then calls  -[IMMessagesBlastDoorInterface diffuseTopLevelDictionary:resultHandler:] . At that point processing ends up in Swift code that deserializes the binary payload and sends it to the BlastDoor service over XPC.</p><p>以前，所有这些工作都是在imagent中发生的。但是，在iOS 14中，所有功能都转移到了新的BlastDoor服务中。尽管主要处理流程仍从imagent开始，但imagent从-[IMDiMessageIDSDelegate service：account：incomingTopLevelMessage：fromID：messageContext：]中的identityservicesd（IDS框架的一部分）接收原始但未加密的有效载荷字节，然后立即或多或少立即发送消息通过+ [IMBlastdoor sendDictionary：withCompletionBlock：]转发到BlastDoor服务，该服务创建了回复处理程序块，然后调用-[IMMessagesBlastDoorInterfacediffuseTopLevelDictionary：resultHandler：]。那时，处理过程以Swift代码结束，该代码反序列化二进制有效负载，然后通过XPC将其发送到BlastDoor服务。</p><p>  Inside BlastDoor, the work mostly happens in BlastDoor.framework and MessagesBlastDoorService. As most of it is written in Swift, it is fairly unpleasant to statically reverse engineer it (no symbols, many virtual calls, swift runtime code sprinkled all over the place), but fortunately, that is also not really necessary for the purpose of this blog post. However, it is worth noting that while the high level control flow logic is written in Swift, some of the parsing steps still involve the existing ObjectiveC or C implementations. For example, XML is being parsed by libxml, and the NSKeyedArchiver payloads by the ObjectiveC implementation of NSKeyedUnarchiver.</p><p>  在BlastDoor内部，工作大部分发生在BlastDoor.framework和MessagesBlastDoorService中。由于大多数代码都是用Swift编写的，因此对它进行静态反向工程是相当不愉快的（没有符号，许多虚拟调用，遍布各处的swift运行时代码），但是幸运的是，这实际上并不是必需的博客文章。但是，值得注意的是，尽管高级控制流逻辑是用Swift编写的，但某些解析步骤仍涉及现有的ObjectiveC或C实现。例如，XML由libxml解析，而NSKeyedArchiver有效负载由NSKeyedUnarchiver的ObjectiveC实现解析。</p><p>  The responses from BlastDoor can be seen by breaking on the reply handler function in imagent (the function can be found in  +[IMBlastdoor sendDictionary:withCompletionBlock:]  or  by searching for XREFs to the string “ Blastdoor response %p received (command: %hhu, guid: %@) ” in IMDaemonCore.framework). A typical BlastDoor response for a simple text message is shown below:</p><p>  可以通过中断imagent中的回复处理程序函数来查看BlastDoor的响应（该函数可以在+ [IMBlastdoor sendDictionary：withCompletionBlock：]中找到，或者通过搜索字符串“ Blastdoor响应％p收到XREFs（命令：％hhu ，guid：％@）”）。下面显示了一个简单文本消息的典型BlastDoor响应：</p><p>                                               One can roughly associate every field in this data structure with parts of the on-wire iMessage format. For example, the  plainTextBody  field contains the content of the `t` field, while the  content  field corresponds to the content of the `x` field.</p><p>                                               可以将这种数据结构中的每个字段大致与在线iMessage格式的一部分相关联。例如，plainTextBody字段包含t字段的内容，而content字段对应于x字段的内容。</p><p>  Besides simple text messages, iMessages can additionally contain attachments (essentially arbitrary files which are encrypted and temporarily uploaded to iCloud) as well as rather complex serialized   NSKeyedArchiver  archives, which   have been the source of bugs in the past .</p><p>  除了简单的文本消息外，iMessages还可以包含附件（基本上是任意文件，这些文件已加密并临时上传到iCloud）以及相当复杂的序列化NSKeyedArchiver归档文件，这些文件过去是bug的来源。</p><p>     As an example, consider what happens when a user sends a link to a website over iMessage. In that case, the sending device will first render a preview of the webpage and collect some metadata about it (such as the title and page description), then pack those fields into an NSKeyedArchiver archive. This archive is then encrypted with a temporary key and uploaded to the iCloud servers. Finally, the link as well as the decryption key are sent to the receiver as part of the iMessage. In order to create a useful user notification about the incoming iMessage, this data has to be processed by the receiver on a 0-click code path. As that again involves a fair amount of complexity, it is also done inside BlastDoor: after receiving the BlastDoor reply from above and realizing that the message contains an attachment,  imagent  first instructs  IMTransferAgent  to download and decrypt the iCloud attachment. Afterwards, it will call into  -[IMTranscodeController decodeiMessageAppPayload:bundleID:completionBlock:blockUntilReply:]  w hich forwards the relevant data to the  IMTranscoderAgent, which then proceeds into  +[IMAttachmentBlastdoor sendBalloonPluginPayloadData:withBundleIdentifier:completionBlock:]   a nd finally calls  -[IMMessagesBlastDoorInterface defuseBalloonPluginPayload:withIdentifier:resultHandler:] .</p><p>     例如，请考虑当用户通过iMe​​ssage将链接发送到网站时会发生什么。在这种情况下，发送设备将首先呈现网页的预览并收集有关该网页的一些元数据（例如标题和页面说明），然后将这些字段打包到NSKeyedArchiver档案中。然后，此存档使用临时密钥加密，并上​​传到iCloud服务器。最后，链接和解密密钥作为iMessage的一部分发送到接收器。为了创建有关传入iMessage的有用的用户通知，接收者必须在0单击代码路径上处理此数据。由于这又涉及相当多的复杂性，因此也需要在BlastDoor内部完成：从上方收到BlastDoor答复并意识到消息包含附件后，imagent首先指示IMTransferAgent下载和解密iCloud附件。之后，它将调用-[IMTranscodeController解码器iMessageAppPayload：bundleID：completionBlock：blockUntilReply：]，然后将相关数据转发到IMTranscoderAgent，然后该代理进入+ [IMAttachmentBlastdoor sendBalloonPluginPayloadData：withBundleIndifier：lastpleallDollingDolledDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollingDollantDoll ：withIdentifier：resultHandler：]。</p><p>  In the  BlastDoor service, the plugin data decoding is then again performed in Swift, and dispatched to the corresponding plugin type, as determined by the plugin id. For RichLinks (plugin id com.apple.messages.URLBalloonProvider), processing ends up in  LinkPresentation.MessagesPayload.init(dataRepresentation:) , which deserializes the NSKeyedArchiver payload and to extract the preview image and URL metadata from it in order to generate a preview message.</p><p>  在BlastDoor服务中，然后再次在Swift中执行插件数据解码，并分配给相应的插件类型，具体取决于插件ID。对于RichLinks（插件ID com.apple.messages.URLBalloonProvider），处理结束于LinkPresentation.MessagesPayload.init（dataRepresentation :)，该过程反序列化NSKeyedArchiver有效负载并从中提取预览图像和URL元数据以生成预览。信息。 </p><p>  The sandbox profile can be found in  System/Library/Sandbox/Profiles/blastdoor.sb  and appears to be identical on iOS and macOS. It can be studied statically, and for that purpose can be found   here , or dynamically, for example by using the  sandbox-exec  tool:</p><p>沙箱配置文件可以在System / Library / Sandbox / Profiles / blastdoor.sb中找到，并且在iOS和macOS上看起来是相同的。可以进行静态研究，为此可以在此处找到它，也可以动态地进行研究，例如使用sandbox-exec工具：</p><p>            only a handful of local IPC services, namely  diagnosticd ,  logd ,  opendirectoryd ,  syslogd , and  notifyd , can be reached</p><p>            只能访问少数本地IPC服务，即Diagnosticd，logd，opendirectoryd，syslogd和notifyd。</p><p>  Furthermore, the profile makes use of syscall filtering to restrict the interactions with the core kernel. However, as of now the syscall filter seems to be in “permissive” mode:</p><p>  此外，该配置文件利用系统调用过滤来限制与核心内核的交互。但是，到目前为止，系统调用筛选器似乎处于“允许”模式：</p><p>     As such, the BlastDoor service is still allowed to perform any syscall, but it is to be expected that the syscall filtering will soon be put into “enforcement mode”, which would further boost its effectiveness.</p><p>     这样，仍然允许BlastDoor服务执行任何系统调用，但是可以预期，系统调用筛选将很快进入“强制模式”，这将进一步提高其有效性。</p><p>   An interesting side effect of the new processing pipeline is that  imagent  is now able to detect when an incoming message caused a crash in BlastDoor (it will receive an XPC error). Even more interesting is the fact that  imagent  appears to be informing Apple’s servers about such events, as can be seen by setting a breakpoint on  -[APSConnectionServer handleSendOutgoingMessage:]  in  apsd , the daemon responsible for implementing Apple’s push services (on top of which iMessage is built). Displaying the outgoing message will show the following:</p><p>   新处理管道的一个有趣的副作用是imagent现在可以检测传入消息何时导致BlastDoor崩溃（它将收到XPC错误）。更有趣的是，imagent似乎正在向Apple服务器通知此类事件，这可以通过在apsd中的-[APSConnectionServer handleSendOutgoingMessage：]上设置一个断点来看出，该守护程序负责实现Apple的push服务（在其上是iMessage建成）。显示外发消息将显示以下内容：</p><p>                         As can be seen,  imagent  is apparently informing the iMessage servers that the message with the UUID 0x3a4912626c9645f98cb26c7c2d439520 ( fU  key) has caused a crash in BlastDoor.</p><p>                         可以看出，imagent显然在通知iMessage服务器，其UUID为0x3a4912626c9645f98cb26c7c2d439520（fU键）的消息已导致BlastDoor崩溃。</p><p> It is unclear what the purpose of this is without access to the server’s code. While these notifications may simply be used for statistical purposes, they would also give Apple a fairly clear signal about attacks against iMessage involving brute-force and a somewhat weaker signal about any failed exploits against the BlastDoor service.</p><p> 尚不清楚访问服务器代码的目的是什么。尽管这些通知仅可用于统计目的，但它们也将为苹果提供有关iMessage涉及蛮力攻击的明确信号，而对于任何针对BlastDoor服务的漏洞利用失败的信号则较弱。 </p><p>  In my experiments, after observing one of these crash notifications, the server would start directly sending delivery receipts to the sender for messages that hadn&#39;t actually been processed by the receiver yet. Possibly this is another, independent effort to break the crash oracle technique by confusing the sender, but that is hard to verify without access to the code running on the server. In any case, it is worth noting that this “spoofing” of delivery receipts by the server is generally possible as the message UUID, which is more or less the only content of a delivery receipt, is part of the non-end2end encrypted payload and is thus known to the server (break on  -[APSConnectionServer handleSendOutgoingMessage:]  and inspect outgoing iMessages to verify this, the UUID will be in the  U  key, while the e2e-encrypted data will be in the  P  key) . This is most likely necessary so the server can track which messages have already been delivered and which ones it still needs to keep around for delivery in the future.</p><p>在我的实验中，观察到这些崩溃通知之一后，服务器将开始直接将发送收据发送给发送方，以接收尚未由接收方实际处理过的消息。可能这是另一种独立的工作，通过混淆发送方来打破崩溃Oracle技术，但是如果不访问服务器上运行的代码，很难验证这一点。在任何情况下，值得注意的是，服务器对交付收据进行“欺骗”通常是可能的，因为消息UUID（或多或少是交付收据的唯一内容）是非end2end加密有效负载的一部分，并且因此对服务器是已知的（断开-[APSConnectionServer handleSendOutgoingMessage：]并检查传出的iMessage以验证这一点，UUID将在U密钥中，而e2e加密的数据将在P密钥中）。这很可能是必需的，因此服务器可以跟踪哪些消息已经被传递，以及将来仍需要保留哪些消息。</p><p>   Previously, when exploiting an iMessage memory corruption bug, a “crash oracle” could be used to reveal the location of the shared cache region in memory: the attacker would trigger the memory corruption bug in a way that would cause an access to a memory location somewhere in the region 0x180000000 - 0x280000000 (where the shared cache can be mapped). If the memory was valid, no crash would occur and  imagent  would then send a delivery receipt to the attacker. However, If a crash occurred, no such receipt would be delivered, informing the attacker that the address was unmapped. Through clever selection of the queried addresses, the location of the shared cache could be revealed in logarithmic time, with only about 20 messages.</p><p>   以前，在利用iMessage内存损坏错误时，可以使用“崩溃预言”来显示共享缓存区域在内存中的位置：攻击者将以导致访问内存位置的方式触发内存损坏错误。区域0x180000000-0x280000000（可以映射共享缓存）中的某个位置。如果内存有效，则不会发生崩溃，然后将通过成像将发送收据发送给攻击者。但是，如果发生崩溃，则不会发送此类收据，通知攻击者该地址未映射。通过巧妙地选择查询的地址，共享缓存的位置可以以对数时间显示，只有大约20条消息。</p><p>  However, with iOS 14 Apple has added a mechanism to re-randomize the location of the shared cache region for an “attacked” process, thus breaking a fundamental assumption of this technique and rendering it ineffective. This is significant as the crash oracle technique was likely one of very few, if not the only, fairly generic ASLR bypass techniques usable in 0-click iMessage attacks.</p><p>  但是，在iOS 14上，Apple添加了一种机制，可以对“攻击”过程重新分配共享缓存区域的位置，从而打破了对该技术的基本假设，并使其无效。这非常重要，因为崩溃oracle技术可能是可用于0单击iMessage攻击的极少数（即使不是唯一的）相当通用的ASLR旁路技术之一。</p><p>  To understand how the shared cache resliding works, one can start by looking at the kernel. In iOS 14, the kernel can now have  two  active shared cache regions: the “regular” region and   a “reslided” region . During an attack, the following then happens:</p><p>  要了解共享缓存重新滑动的工作方式，可以先查看内核。在iOS 14中，内核现在可以具有两个活动的共享缓存区域：``常规''区域和``隐藏''区域。在攻击过程中，将发生以下情况：</p><p>  When an attacker attempts to use a crash-oracle-based technique, the attacked process would quickly end up accessing unmapped memory in the range 0x180000000 - 0x280000000 (where the shared cache is mapped) and crashes</p><p>  当攻击者尝试使用基于崩溃的Oracle的技术时，被攻击的进程将很快最终访问范围为0x180000000-0x280000000（映射共享缓存）的未映射内存，并崩溃</p><p> The kernel handles the segmentation fault generated by the CPU, and   sets a specific flag in the crash info  that signals that the crash happened inside the shared cache region</p><p> 内核处理由CPU产生的分段错误，并在崩溃信息中设置一个特定的标志，以表明崩溃发生在共享缓存区域内</p><p> At the same time, the kernel will   mark the currently active reslided shared cache region (if one exists) as stale , causing it to be recreated and thus re-randomized the next time it is used</p><p> 同时，内核会将当前活动的重新滑动的共享缓存区域（如果存在）标记为陈旧，从而导致重新创建它，并在下次使用它时对其进行随机化。 </p><p> launchd  (as the parent process of the crashed service) receives the crash info, notices the  OS_REASON_FLAG_SHAREDREGION_FAULT  flag, and sets the  ReslideSharedCache  property on the service associated with the crashed process (see ` launchctl procinfo $pid ` and search for ` reslide shared cache = 1 `)</p><p>启动（作为崩溃服务的父进程）接收崩溃信息，注意到OS_REASON_FLAG_SHAREDREGION_FAULT标志，并设置与崩溃进程相关的服务的ReslideSharedCache属性（参见`launchctl procinfo $ pid`并搜索`reslide shared cache = 1`）</p><p> The next time the service is restarted,  launchd  then adds the   POSIX_SPAWN_RESLIDE  attribute for   posix_spawn  due to the  ReslideSharedCache  property</p><p> 下次重新启动服务时，启动该服务，然后由于ReslideSharedCache属性而添加posix_spawn的POSIX_SPAWN_RESLIDE属性</p><p> In the kernel, this flag now causes the newly created process to be given the   reslided shared cache image . However, as no active reslided region currently exists (the previous one was marked as stale in step 3.), a new one is created at a newly randomized address.</p><p> 在内核中，此标志现在使新创建的进程获得重新滑动的共享缓存映像。但是，由于当前不存在活动的隐藏区域（在步骤3中将前一个区域标记为陈旧），因此将在新的随机地址处创建一个新区域。</p><p>  The result of this is that whenever an attacker attempts to use a crash-oracle to break ASLR, the attacked service would receive a different shared cache region every time it is launched, thus preventing the attack from succeeding. For the time being, this feature appears to   only be active on iOS  though , but it would be expected to come to macOS as well.</p><p>  其结果是，每当攻击者尝试使用崩溃Oracle破坏ASLR时，被攻击的服务每次启动时都会收到不同的共享缓存区域，从而阻止了攻击的成功。目前，尽管该功能似乎仅在iOS上有效，但也有望在macOS上使用。</p><p>  While this mechanism would in principle also protect 3rd party apps from similar attacks, protection for those is currently somewhat weaker, likely in order to first evaluate the real-world performance impact of this change (the shared cache is a significant performance optimization of the OS). In particular, step 3 is currently only performed if the crashing process is a   platform binary  (essentially binaries that ship with the OS and are directly signed by Apple) such as the services handling iMessages. However, for 3rd party processes, it would only happen if the global   vm_shared_region_reslide_restrict  is set to zero:</p><p>  虽然此机制原则上也可以保护第三方应用程序免受类似攻击，但目前对这些应用程序的保护程度较弱，这可能是为了首先评估此更改对现实世界的性能影响（共享缓存是操作系统的重要性能优化） ）。特别是，当前的第3步仅在崩溃过程是平台二进制文件（基本上是操作系统附带的二进制文件并由Apple直接签名）（例如处理iMessages的服务）时执行。但是，对于第三方进程，只有在全局vm_shared_region_reslide_restrict设置为零的情况下才会发生：</p><p>          Which is   controlled by the   vm_shared_region_reslide_restrict   bootarg . This currently seems to be set to one. In essence, for 3rd party apps this means:</p><p>          由vm_shared_region_reslide_restrict bootarg控制。当前似乎设置为1。本质上，对于第三方应用程序，这意味着：</p><p>  When the attacked process first crashes, the kernel will still set the  OS_REASON_FLAG_SHAREDREGION_FAULT  flag, and  launchd  will add the  ReslideSharedCache  property, but the current reslided region won’t be invalidated</p><p>  当被攻击的进程首次崩溃时，内核仍将设置OS_REASON_FLAG_SHAREDREGION_FAULT标志，并且启动后将添加ReslideSharedCache属性，但当前的滑动区域不会无效 </p><p> The restarted service is then restarted and now uses the “reslided” shared cache region</p><p>重新启动的服务然后重新启动，现在使用“隐藏”的共享缓存区域</p><p> When the service crashes the next time, and if that service is the only one currently using the reslided shared cache region (which should usually be the case, but could possibly be influenced by the attacker), the region’s refcount drops to zero, and the shared cache region is marked for removal.</p><p> 当服务下次崩溃时，并且如果该服务是当前唯一使用重新组合的共享缓存区域的服务（通常应该是这种情况，但是可能受到攻击者的影响），则该区域的refcount会降为零，并且共享缓存区域标记为要删除。</p><p> However, removal will only actually happen   after two minutes . As such, if the service is restarted within two minutes, it will receive the same shared cache region at the same location in memory.</p><p> 但是，删除实际上只会在两分钟后发生。这样，如果服务在两分钟内重新启动，它将在内存中的相同位置接收相同的共享缓存区域。</p><p>  As a result, a third-party app could still be attacked through a crash-oracle technique if it automatically sends some form of delivery receipt to the sender and restarts quickly enough after a crash. This could, however, be prevented for example by enabling  ExponentialThrottling  for these services. Ideally, and assuming that the performance penalty is reasonable, Apple would enable re-randomization for all apps in the future.</p><p>  结果，如果第三方应用程序自动将某种形式的交付收据发送给发件人并在崩溃后足够快地重新启动，则它仍可能通过崩溃预兆技术受到攻击。但是，例如可以通过为这些服务启用ExponentialThrottling来防止这种情况。理想情况下，假设性能损失合理，Apple将在将来为所有应用程序重新随机化。</p><p>  Another thing we suggested back in 2019 was to limit the number of attempts an attacker gets when attempting to exploit a vulnerability. This was mostly important to defend against the crash-oracle technique, but would also help to prevent brute force attacks (e.g., given enough attempts, one could simply brute force the location of the shared cache region).  The new ExponentialThrottling feature in  launchd  seems to achieve just that.</p><p>  我们在2019年建议的另一件事是限制攻击者尝试利用漏洞的尝试次数。这对于抵御崩溃预言技术最为重要，但也有助于防止暴力攻击（例如，如果进行了足够的尝试，则可以简单地将共享缓存区域的位置暴力破解）。推出的新ExponentialThrottling功能似乎可以实现这一目标。</p><p>  To use it, a system daemon or agent has to opt-in by setting  &#34;_ExponentialThrottling = 1” in its Info.plist (essentially the service metadata), as can be seen below for the BlastDoor service:</p><p>  要使用它，系统守护程序或代理必须通过在其Info.plist（主要是服务元数据）中设置``＆＃34; _ExponentialThrottling = 1”来选择加入，如下面的BlastDoor服务所示：</p><p>                    but doesn’t appear to be used for any other service, as can, for example, be seen by looking at the output of the  launchctl dumpstate  command, which will only show “ exponential throttling = 1”  for  com.apple.imagent  and  com.apple.MessagesBlastDoorService.</p><p>                    但似乎没有用于其他任何服务，例如可以通过查看launchctl dumpstate命令的输出来看到，该命令对于com.apple.imagent和com仅显示“ exponential throttling = 1”。 .apple.MessagesBlastDoorService。 </p><p>  Presumably, the  _ExponentialThrottling  property instructs launchd (the macOS and iOS init process), to delay subsequent restarts of a crashing service. While it is somewhat challenging to statically reverse engineer launchd due to the lack of source code or binary symbols, it is fortunately fairly easy to experimentally determine the impact of the  _ExponentialThrottling  property, for example by installing a custom daemon that writes the current timestamp to a file before crashing. By default, so  without  ExponentialThrottling, one would see the following:</p><p>据推测，_ExponentialThrottling属性指令已启动（macOS和iOS初始化过程），以延迟崩溃服务的后续重启。虽然由于缺少源代码或二进制符号而使静态逆向工程启动具有一定的挑战性，但幸运的是，通过实验确定_ExponentialThrottling属性的影响相当容易，例如通过安装将当前时间戳记写为文件崩溃。默认情况下，因此如果没有ExponentialThrottling，则会看到以下内容：</p><p>       As can be seen, by default, a service is, at the earliest, restarted ten seconds after it was previously started. However, using the following service plist which enables ExponentialThrottling:</p><p>       可以看出，默认情况下，服务最早是在先前启动后十秒重新启动的。但是，使用以下服务plist启用ExponentialThrottling：</p><p>                             Here, the exponential increase in the time between subsequent restarts is clearly visible, and goes up to an apparent maximum of 20 minutes. And indeed,  launchd  does contain the following bit of code in a function presumably responsible for computing the next restart delay (search for XREFs to the string &#34;%s: service throttled by %llu seconds&#34;):</p><p>                             在此，可以清楚地看到后续重新启动之间的时间呈指数增长，并且上升到最多20分钟。实际上，启动的函数中可能包含以下代码，该函数可能负责计算下一个重启延迟（搜索字符串＆＃34;％s：服务受％llu seconds＆＃34;限制的XREF）：</p><p>       With this change, an exploit that relied on brute force would now only get one attempt every 20 minutes instead of every 10 seconds.</p><p>       进行此更改后，依靠暴力破解的漏洞现在每20分钟就会尝试一次，而不是每10秒一次。</p><p>  The PoC exploit against iMessage on iOS 12.4 relied heavily on faking ObjectiveC objects to gain a form of arbitrary code execution despite the presence of   pointer authentication (PAC) . This was mainly possible because the ISA field,</p><p>  尽管存在指针身份验证（PAC），但在iOS 12.4上针对iMessage的PoC攻击在很大程度上依赖于伪造ObjectiveC对象来获得某种形式的任意代码执行。这主要是因为ISA字段，</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://googleprojectzero.blogspot.com/2021/01/a-look-at-imessage-in-ios-14.html">https://googleprojectzero.blogspot.com/2021/01/a-look-at-imessage-in-ios-14.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/ios/">#ios</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/看看/">#看看</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/imessage/">#imessage</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/服务/">#服务</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>