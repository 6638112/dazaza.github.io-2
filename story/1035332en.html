<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>让你的后端层越薄越好</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">让你的后端层越薄越好</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-16 05:20:03</div><div class="page_narrow text-break page_content"><p>You need to come up with an API between your backend (running in the cloud) and your frontend (running on users’ devices, whether in the form of a mobile or a web app).</p><p>你需要在你的后台(在云中运行)和你的前端(在用户的设备上运行，无论是以移动应用还是web应用的形式)之间提供一个API。</p><p> We try to define such an API by identifying the domain objects in our system and the operations that will be performed on them, have the backend and frontend team agree on these nouns and verbs, have the backend team implement the API, and the frontend team consume them.</p><p>我们尝试通过识别系统中的域对象以及将对其执行的操作来定义这样的API，让后端和前端团队就这些名词和动词达成一致，让后端团队实现API，并由前端团队使用它们。</p><p>  In the three-tier frontend-backend-database architecture, try to have as thin a middle layer as possible. Or even eliminate the backend layer altogether by directly exposing the database to the frontend.</p><p>在三层前端-后端-数据库体系结构中，尝试使用尽可能薄的中间层。或者甚至通过直接将数据库暴露给前端来完全消除后端层。</p><p> For example, if your API returns a Person object, just return the fields of the underlying table 1:1. Do a SELECT *, iterate over all the columns, and copy them to the JSON that will be sent back to the frontend. Such a backend layer won’t need changing when you add columns to your database. As opposed SELECT’ing only certain columns in your SQL query. Or copying only certain columns from the SQL response to the JSON like:</p><p>例如，如果API返回Person对象，只需返回底层表1：1的字段。执行SELECT*，迭代所有列，并将它们复制到将发送回前端的JSON。向数据库添加列时，这样的后端层不需要更改。相反，只选择SQL查询中的某些列。或者只将SQL响应中的某些列复制到JSON中，如下所示：</p><p>  This code will require changing whenever you add a new database column. And when — not if — you forget, it result in needless confusion and debugging:</p><p>无论何时添加新的数据库列，都需要更改此代码。当--而不是如果--你忘记了，它会导致不必要的混淆和调试：</p><p> Frontend engineer: Why am I not getting the phone number field on the frontend? Did you not add the column to the database? Backend engineer: Yes, I did. Frontend engineer: Did you not populate it? Backend engineer: Yes I did. Frontend engineer: Then what’s going wrong? Backend engineer: Are you making the right request? Frontend engineer: Yes, look at this code… Backend engineer: That looks correct, but maybe the parameters are wrong at runtime. Why don’t you show me the actual request that’s sent? Frontend engineer: Here it is. Backend engineer: Hmm… the request is correct. How can we be sure that the backend isn’t returning the phone number. Maybe it is, and it’s getting missed at some layer of the frontend code… Frontend engineer: I don’t think so, because… Backend engineer: Better test it using Postman, to be sure. Frontend engineer: *goes off and tests* See, here’s the API request and response. Backend engineer: Hmm, let me look at it, maybe in a few days, I’m busy with something else now. (After two days) Oh, the backend API implementation needs to be updated to add the new field.</p><p>前台工程师：为什么我没有看到前台的电话号码栏？您没有将该列添加到数据库中吗？后台工程师：是的，我是这么做的。前台工程师：你没填上吗？后台工程师：是的，我是这么做的。前台工程师：那是怎么回事？后端工程师：您提出的请求是正确的吗？前台工程师：是的，看看这段代码…。后台工程师：看起来是正确的，但可能在运行时参数有误。你为什么不给我看看真正发出的请求呢？前台工程师：在这里。后台工程师：嗯，…。这个请求是正确的。我们如何确定后端不会返回电话号码。也许是这样的，但是在前端代码…的某一层中，它被遗漏了。前台工程师：我不这么认为，因为…。后端工程师：可以肯定的是，最好使用Postman进行测试。前台工程师：*去测试*看，这是API请求和响应。后台工程师：嗯，让我看看，也许几天后，我现在正忙着做别的事情。(两天后)哦，后端API实现需要更新才能添加新的字段。</p><p> You can bypass this whole inefficiency by making the backend a pass-through. That gives you one fewer thing to worry about, which any engineer will welcome.</p><p>通过使后端成为直通通道，您可以绕过整个效率低下的问题。这让你少了一件担心的事情，这是任何工程师都会欢迎的。</p><p> In your API documentation, don’t list out fields that will be returned, and their types, one by one. Instead say “Returns the same fields as the database.” Again, for the same reason: It can — no,  will — get out of date, and misleading documentation has a negative value to your company. Instead, ask the frontend engineers to directly refer to the database schema, which can’t get out of date, because it is the source of truth.</p><p>在API文档中，不要逐个列出要返回的字段及其类型。取而代之的是“返回与数据库相同的字段”。同样，出于同样的原因：它可能--不，将--过时，并且误导性的文档对您的公司有负面价值。相反，让前端工程师直接参考数据库模式，它不会过时，因为它是真相的来源。</p><p>   That’s a layer of translation that doesn’t add value. And makes it harder for engineers to get an end to end view of the system, say if they’re curious whether names are represented as separated given and family name fields or as a single full name field. Not only that, but such translation layers will have bugs that need fixing.</p><p>这是一层不会增加价值的翻译。这使得工程师更难获得系统的端到端视图，比如他们是否好奇姓名是以独立的名字和姓氏字段表示，还是以单个全名字段表示。不仅如此，这样的翻译层还会有需要修复的错误。</p><p> You can take this one step further by directly exposing the database to the client app, such as by having the client app just send SQL queries to the server to execute. If you go this far, you wouldn’t even have a backend layer — instead of a three-tier frontend-backend-database architecture, you’d have a two-tier frontend-database architecture.</p><p>您可以更进一步，直接将数据库公开给客户端应用程序，例如让客户端应用程序只将SQL查询发送到服务器执行。如果走到这一步，您甚至不会拥有后端层--而不是三层前端后端数据库体系结构，而是两层前端数据库体系结构。</p><p> Now, that may not always be possible. Say for security — you don’t want a compromised client getting access to other clients’ data, or for a client to mark itself as being on the premium plan despite not paying. Or maybe some code requires access to resources not available on the client. Or is too demanding to run on the client. Or needs to be run at a certain time irrespective of whether the client device is online at that time.</p><p>现在，这可能并不总是可能的。比如说安全性--你不想让一个受到威胁的客户获得其他客户数据的访问权，或者让一个客户在没有付费的情况下将自己标记为高级计划中的一员。或者，可能某些代码需要访问客户端上不可用的资源。或者要求太高而不能在客户机上运行。或者需要在特定时间运行，而不管客户端设备当时是否在线。</p><p> So, intead of no backend, a thin backend may be the right choice for you. Maybe you can give clients read-only access to the database, but not write. Or maybe you can give clients read-write access to only their data. Ask yourself how you can be lazy, pushing as much work as possible down to the database. Modern backend frameworks use maybe 5% of the power of databases. This is unfortunate.</p><p>所以，在没有后端的情况下，一个瘦的后端可能是你的正确选择。也许您可以授予客户端对数据库的只读访问权限，但不能授予其写入权限。或者，您可以只授予客户端对其数据的读写访问权限。问问你自己，你怎么会懒惰，把尽可能多的工作推给数据库。现代后端框架使用的数据库能力可能只有5%。这是不幸的。</p><p> As an example of directly exposing only some data from the database, imagine you’re building a social network, where friend information is public. Say you model this as a friends table consisting of two columns for the user IDs of the two people who are friends. Now, the conventional approach would have you define a backend API for the frontend to get friends. Instead, you can define an API that takes an SQL query from the client, runs it, and returns the results. This query can be run under a database user account that has only read access, that too only to the friends table. This can accommodate unforeseen uses, like getting the number of friends rather than the actual list. Or if there’s a search box where the user can filter his friends, you can do a LIKE query. Or you can limit the number of friends returned to how many will be displayed in the UI. Or return only some fields, the ones you’ll use in your frontend. Or filter only friends who have a phone number, say if you’re building some kind of dialer UI. All this flexibility is now available without you having to foresee it, plan for it, and build it. Don’t make the backend layer a straitjacket between the database and the frontend, any more than you’d force participants in a meeting to communicate via morse code.</p><p>作为仅直接公开数据库中部分数据的示例，假设您正在构建一个社交网络，其中的朋友信息是公开的。假设您将其建模为一个Friends表，该表由两列组成，其中包含两个好友的用户ID。现在，传统的方法是让你为前台定义一个后端API来交朋友。相反，您可以定义一个API，该API从客户端获取SQL查询，运行它，然后返回结果。此查询可以在仅具有读取访问权限的数据库用户帐户下运行，该数据库用户帐户也仅具有对FRIENDS表的访问权限。这可以适应不可预见的用途，比如获取好友数量，而不是实际的列表。或者，如果有一个搜索框，用户可以在其中过滤他的朋友，你可以进行Like查询。或者，您可以将返回的好友数量限制为在用户界面中显示的数量。或者只返回一些字段，即您将在前端使用的字段。或者只过滤有电话号码的朋友，比如你是否正在构建某种拨号器用户界面。所有这些灵活性现在都是可用的，而您不必预见、规划和构建它。不要让后端层成为数据库和前端之间的紧身衣，就像你不会强迫与会者通过摩尔斯电码进行交流一样。</p><p> SQL is powerful, simple, declarative and most engineers know it — there’s nothing else with all these benefits. Certainly not your custom API. Greenspun’s tenth rule of programming says that any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp. Similarly, your custom API contains an ad-hoc, informally-specified, bug-ridden, slow implementation of half of SQL. At most half. Don’t define such an anaemic API.</p><p>SQL强大、简单、声明性强，大多数工程师都知道这一点--没有其他任何东西能带来这些好处。当然不是您的定制API。Greenspun的第十条编程规则说，任何足够复杂的C或Fortran程序都包含一个临时的、非正式指定的、充满错误的、缓慢实现的Common Lisp的一半。类似地，您的自定义API包含半个SQL的临时的、非正式指定的、充满错误的、缓慢的实现。至多一半。不要定义如此贫乏的API。</p><p> This is a new way of thinking: build a backend API when it has something to do, not as a pass through to your database. This is the same reason you wouldn’t define an object that wraps another object and forwards all method calls to it, and the return values back, without doing anything else.</p><p>这是一种新的思维方式：在有事情要做的时候构建一个后端API，而不是作为对数据库的传递。这与您不会定义一个对象来包装另一个对象并转发对该对象的所有方法调用和返回值，而不做任何其他操作的原因是相同的。</p><p> You’re anyway going to put in a lot of thought into designing your database schema. And if you’re not, you should, since that’s harder to change than either backend or frontend code. But once you do that, why design another schema, which is the responses returned by your backend?</p><p>无论如何，您都会在设计数据库模式时投入大量心思。如果不是，就应该这么做，因为这比后端或前端代码更难更改。但是，一旦这样做了，为什么还要设计另一个模式，即后端返回的响应呢？</p><p> Now, you may disagree with the above advice, by objecting that an ideal API should not change if the backend database changes. An ideal API should be a layer of abstraction. But you don’t need every possible layer of abstraction on day 1. Layers of abstraction take time to design and implement, and make it hard to refactor functionality and move it to another layer.</p><p>现在，您可能不同意上面的建议，因为您反对理想的API不应该在后端数据库更改的情况下更改。理想的API应该是抽象层。但是，您不需要在第一天就进行所有可能的抽象层。抽象层的设计和实现需要时间，而且很难重构功能并将其转移到另一个层。</p><p> A layer of abstraction may even require hiring a separate backend team, which in turn imposes a coordination cost between the teams, which will never go away. Getting each additional person onboarded and fully productive takes a  year. Having teams write a spec to agree on the interface between them, implement this spec, deal with bugs caused by the backend not implementing the spec or the frontend assuming things that the spec doesn’t guarantee, updating this layer when needs change, and so on, is more overhead.</p><p>抽象层甚至可能需要雇佣一个单独的后端团队，这反过来又会增加团队之间的协调成本，这种成本永远不会消失。让每个额外的人都加入进来并充分发挥效率需要一年的时间。让团队编写一个规范来就它们之间的接口达成一致，实现这个规范，处理由于后端没有实现规范或前端假定规范不能保证的东西而导致的错误，在需要更改时更新这一层等等，这些都是更大的开销。</p><p> Instead, put your frontend (which includes mobile) engineers in charge of the API. The backend engineers should be there to advise, assist, implement and point out things the frontend engineers overlooked, not to define the API. Instead of an equal partnership between the frontend and the backend teams, put the frontend team in charge of the API.</p><p>取而代之的是，让你的前端(包括移动)工程师负责API。后端工程师应该在那里提供建议、协助、实现和指出前端工程师忽略的事情，而不是定义API。让前端团队负责API，而不是让前端团队和后端团队建立平等的合作伙伴关系。</p><p> For example, suppose your frontend engineers propose that instead of having an API to get people, and a second API to get orders, and a third API to get something else, they’ll have an API to get all the data needed to render the home page in one go. Let them have their way. This, in fact, saves frontend engineers from having to make multiple calls to get the data they want to render the page and knit it together. Which in turn causes more complexity like how to handle partial failures, where one call succeeds and another fails. Also, if the calls be made one after another, as a naive implementation would, it increases latency. It’s better to make them in parallel. Unless the second API depends on the first. All this complexity goes away when you define APIs that do what you immediately need, like  get data for home page. If you want a car, you don’t want to buy an engine, a steering wheel, brakes and other components and assemble them into a car yourself.</p><p>例如，假设您的前端工程师提议，不是先用API来吸引人，再用第二个API来获得订单，再用第三个API来获得其他东西，他们将用一个API来一次性获得渲染主页所需的所有数据。让他们为所欲为吧。事实上，这使前端工程师不必进行多次调用来获取他们想要呈现页面并将其组合在一起的数据。这进而导致了更复杂的问题，比如如何处理部分失败，其中一个调用成功，另一个调用失败。此外，如果像幼稚的实现那样一个接一个地进行调用，则会增加延迟。最好是把它们放在一起。除非第二个API依赖于第一个API。当您定义能够满足您的即时需求的API(如获取主页数据)时，所有这些复杂性就不复存在了。如果你想要一辆车，你不会想买一个发动机、方向盘、刹车和其他部件，然后自己把它们组装成一辆车。</p><p> Whenever the home page UX changes, and different information is needed, let the API change. Good APIs aren’t supposed to change, but that doesn’t matter when you control both sides of the API [1]. An internal API should not be held to the same standard as a public API. If you try to, you’ve over-engineering it. Take shortcuts. You’re designing in a context, not in a vacuum, so it’s foolish not to take advantage of that context.</p><p>每当主页UX发生更改，并且需要不同的信息时，让API更改。好的API不应该改变，但当您控制API的两端时，这并不重要[1]。内部API不应与公共API遵循相同的标准。如果你试图这样做，你就过度设计了它。走捷径。你是在一个背景下进行设计，而不是在真空中，所以不利用那个背景是愚蠢的。</p><p> In fact, even using the same term  API to refer to two completely different things — internal and public APIs — is questionable, because connotations from one don’t apply to the other. It’s like using the term  vehicle to refer to both a bicycle and a nuclear submarine, and trying to apply some principles from designing the sub to the cycle.</p><p>事实上，即使使用同一术语API来指代两个完全不同的事物-内部API和公共API-也是有问题的，因为其中一个的含义并不适用于另一个。这就像用车辆这个词来指代自行车和核潜艇，并试图将潜艇设计中的一些原则应用到自行车上。</p><p> If you take this idea of having as small a backend as possible to its logical conclusion, you’ll end up with a BaaS, like Firebase. There’s a lot of wisdom behind that architecture. If I were starting a new product, BaaS would be my first choice. I’d use others only if I’m sure BaaS wouldn’t work for me.</p><p>如果你把拥有一个尽可能小的后端的想法推向它的逻辑结论，你最终会得到一个Baas，就像Firebase一样。这个架构背后蕴含着很多智慧。如果我要开始一种新产品，Baas会是我的第一选择。只有在我确定巴斯不会为我工作的情况下，我才会使用其他人。</p><p> If BaaS doesn’t work for you, explore things like  PostGraphile or  Hasura that take in a database and autogenerate an API server, exposing the database contents via GraphQL. Or  PostgREST, which is similar but autogenerates a REST server, if GraphQL is unnecessary for you.</p><p>如果Baas对您不起作用，可以尝试PostGraphile或Hasura等接受数据库并自动生成API服务器的工具，通过GraphQL公开数据库内容。或者PostgREST，它类似，但是会自动生成一个REST服务器，如果您不需要GraphQL的话。</p><p> Eventually you may find that you’ve outgrown this architecture, and need a heavier backend. That’s the time to build one, not before. That goes for a lot of things — you don’t need to have automated tests as a general practice. Or  microservices. Or formalised HR policies. Or a lot of things. Don’t ape Google or Amazon. Do what’s right for you, given where you are.</p><p>最终，您可能会发现这种架构已经无法满足您的需求，需要一个更重的后端。现在是建造一个的时候，而不是在此之前。这适用于很多事情--通常情况下，您不需要进行自动化测试。或微服务。或者正式的人力资源政策。或者很多事情。不要效仿谷歌或亚马逊。考虑到你所处的位置，做对你合适的事。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://kartick.substack.com/p/make-your-backend-layer-as-thin-as">https://kartick.substack.com/p/make-your-backend-layer-as-thin-as</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/后端/">#后端</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/layer/">#layer</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/api/">#api</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>