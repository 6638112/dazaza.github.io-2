<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Linux可执行文件中有什么？</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Linux可执行文件中有什么？</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-29 12:05:16</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/99194f67e5542018f2c1c325832cade0.png"><img src="http://img2.diglog.com/img/2020/10/99194f67e5542018f2c1c325832cade0.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Executables have been fascinating to me ever since I discovered, as a kid,that they were just files. If you renamed a  .exe to something else, youcould open it in notepad! And if you renamed something else to a  .exe,you&#39;d get a neat error dialog.</p><p>自从我还是个孩子的时候就发现可执行文件只是文件之后，我就一直对它们着迷。如果您将.exe重命名为其他名称，您可以在记事本中打开它！如果您将其他文件重命名为.exe，您会看到一个整齐的错误对话框。</p><p> Clearly, something was different about these files. Seen from notepad, theywere mostly gibberish, but there  had to be order in that chaos. 12-year-oldme knew that, although he didn&#39;t quite know how or where to dig to make senseof it all.</p><p>显然，这些文件有些不同。从记事本上看，他们大多是胡言乱语，但在混乱中必须有秩序。12岁的我知道这一点，尽管他不太知道如何或在哪里挖掘才能让这一切变得有意义。</p><p> So, this series is dedicated to my past self. In it we&#39;ll attempt tounderstand how Linux executables are organized, how they are executed, andhow to make a program that takes an executable fresh off the linker andcompresses it - just because we can.</p><p>所以，这个系列是献给我过去的自己。在这本书中，我们将试图理解Linux可执行文件是如何组织的，它们是如何执行的，以及如何编写一个程序，将可执行文件从链接器上取下并压缩--这仅仅是因为我们可以做到这一点。</p><p> Since the last big series,  Making our own ping,was all about Windows, this one will be focused on 64-bit Linux.</p><p>由于上一个大型系列(自己制作ping)都是关于Windows的，所以这一个系列将重点关注64位Linux。</p><p>  Throughout the course of this series, we&#39;re definitely going to want to emitour own ELF files, but - just like we did when tackling Ethernet, IPv4 andICMP, we&#39;re first going to get our hands on a well-formed, fully-working Linuxexecutable, and then poke it with various sticks.</p><p>在本系列的整个过程中，我们肯定会想要发出我们自己的ELF文件，但是-就像我们在处理以太网、IPv4和ICMP时所做的那样，我们首先要拿到一个格式良好、工作正常的Linux可执行文件，然后用各种棍子戳它。</p><p> ELF stands for  Executable and Linkable Format. It was first publishedin 1983, as part of  SysV 4,and it&#39;s still in use on Linux today, although new sections have been added.</p><p>ELF代表可执行和可链接格式。它第一次发布是在1983年，作为SysV4的一部分，今天它仍然在Linux上使用，尽管增加了新的部分。</p><p> I had to go back to  Reading files the hard way - Part2 to get a quick refresher onnasm - the Netwide Assembler - so I wouldn&#39;t blame you if you had to, too.</p><p>我不得不回到阅读文件的艰难道路上来--第2部分是为了快速复习一下--Netwide汇编程序--所以如果你不得不这么做，我也不会责怪你。</p><p> In any case, here&#39;s the short version: here&#39;s some code to print &#34;hi there&#34;to the standard output, followed by a newline:</p><p>无论如何，这里是简短的版本：这里是一些要打印到标准输出的代码。你好，后面跟一个换行符：</p><p> ; in `hello.asm` global _start section .text_start: mov rdi, 1 ; stdout fd mov rsi, msg mov rdx, 9 ; 8 chars + newline mov rax, 1 ; write syscall syscall xor rdi, rdi ; return code 0 mov rax, 60 ; exit syscall syscall section .datamsg: db &#34;hi there&#34;, 10</p><p>；在`hello.asm`global_start节.text_start：mov rdi，1；stdout FD mov rsi，msg mov rdx，9；8个字符+换行符mov rax，1；写入syscall syscall xor rdi，rdi；返回代码0 mov rax，60；退出syscall syscall节.datamsg：db&#34；hi&#34；，10。</p><p>   $ nasm -f elf64 hello.asm$ ld hello.o -o hello$ file hellohello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped$ ./hellohi there</p><p>$NASM-f elf64 hello.asm$ld hello.o-o hello$file hellohello：ELF 64位LSB可执行文件，x86-64，版本1(SYSV)，静态链接，而不是剥离$。/hellohi在那里。</p><p>  Now, our executable is about 8.68 KiB as-is. If we use  gzip -9 on it, wecan easily get that down to 372 B, so I&#39;m kinda curious to see what&#39;s inthere, to be quite honest.</p><p>现在，我们的可执行文件按原样大约是8.68 KiB。如果我们在它上面使用gzip-9，我们可以很容易地把它降到372B，所以我有点好奇，老实说，我想看看里面有什么。</p><p> This series is  not about lamenting the good old days when everything usedto fit on a floppy. It&#39;s not about how modern software is bloated and slow.It&#39;s not about to go into a tangent about developers being &#34;lazy&#34; and it&#34;not being that hard if only someone tried&#34;.</p><p>这个系列不是关于哀叹过去的美好时光，那时所有的东西都可以放在软盘上。这不是关于现代软件是如何臃肿和缓慢的，也不是要谈到开发人员是多么懒惰，只要有人尝试一下，事情就不会那么难了。</p><p> We are not developing something  practical here, we are picking a challengepurely for the sake of learning stuff.</p><p>我们在这里不是在开发一些实用的东西，我们纯粹是为了学习东西而选择一个挑战。</p><p> If you need a chunky dose of nostalgia instead, feel free to check out  gesturesvaguely at almost all of the internet.</p><p>如果你需要一大片怀旧之情，那么你可以在几乎所有的互联网上模糊地查看一下。</p><p> If we look at an hex dump of  hello, we see the  ELF string early on, followedby a bunch of binary data:</p><p>如果我们查看hello的十六进制转储，我们会看到早期的ELF字符串，后面跟着一组二进制数据：</p><p> $ xxd &lt; hello | head00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000 .ELF............00000010: 0200 3e00 0100 0000 0010 4000 0000 0000 ..&gt;.......@.....00000020: 4000 0000 0000 0000 3821 0000 0000 0000 @.......8!......00000030: 0000 0000 4000 3800 0300 4000 0600 0500 ....@.8...@.....00000040: 0100 0000 0400 0000 0000 0000 0000 0000 ................00000050: 0000 4000 0000 0000 0000 4000 0000 0000 ..@.......@.....00000060: e800 0000 0000 0000 e800 0000 0000 0000 ................00000070: 0010 0000 0000 0000 0100 0000 0500 0000 ................00000080: 0010 0000 0000 0000 0010 4000 0000 0000 ..........@.....00000090: 0010 4000 0000 0000 2500 0000 0000 0000 ..@.....%.......</p><p>$xxd&lt；hello|head00000000：7f45 4c46 0201 0100 0000 0000 0000.ELF.00000010：0200 3e00 0100 0000 0010 4000 0000 0000 0000.&gt；00000020：4000 0000 0000 0000 3821 0000 0000@.8.00000030：0000 0000 4000 3800 0300 4000 0600 0500...@.8.00000040：0100 0000 0400 0000 0000 0000.00000050：0000 4000 0000 0000 0000 4000 0000 0000 0000...@...00000060：e800。00000070：00100 0000 0000 0000 0100 0000 0500 0000...00000080：0010 0000 0000 0000 0010 4000 0000 0000.00000090：0010 4000 0000 0000 2500 0000 0000 0000</p><p> But we can pretty easily see that most of the file is made out ofnull (zero) bytes:</p><p>但是我们可以非常容易地看到，文件的大部分由空(零)字节组成：</p><p> $ xxd &lt; hello | tail -60 | head00001f00: 0000 0000 0000 0000 0000 0000 0000 0000 ................00001f10: 0000 0000 0000 0000 0000 0000 0000 0000 ................00001f20: 0000 0000 0000 0000 0000 0000 0000 0000 ................00001f30: 0000 0000 0000 0000 0000 0000 0000 0000 ................00001f40: 0000 0000 0000 0000 0000 0000 0000 0000 ................00001f50: 0000 0000 0000 0000 0000 0000 0000 0000 ................00001f60: 0000 0000 0000 0000 0000 0000 0000 0000 ................00001f70: 0000 0000 0000 0000 0000 0000 0000 0000 ................00001f80: 0000 0000 0000 0000 0000 0000 0000 0000 ................00001f90: 0000 0000 0000 0000 0000 0000 0000 0000 ................</p><p>$xxd&lt；HELLO|Tail-60|head00001f00：0000 0000 0000.00001f10：0000 0000 0000.00001f20：0000 0000 0000.00001f30：0000 0000 0000.00001f40：0000 0000 0000。00001f50：0000 0000 0000.00001f60：0000 0000 0000.00001f70：0000 0000 0000.00001f70：0000 0000 0000.00001f50：0000 0000 0000.00001f70：0000 0000 0000。00001f90：0000 0000 0000.。</p><p> We can also find a section that contains a bunch of names, maybe theyhave some sort of meaning?</p><p>我们还可以找到一个包含一堆名字的部分，也许它们有某种意义？</p><p> $ xxd &lt; hello | tail -32 | head000020c0: 0920 4000 0000 0000 0000 0000 0000 0000 . @.............000020d0: 2b00 0000 1000 0200 1020 4000 0000 0000 +........ @.....000020e0: 0000 0000 0000 0000 0068 656c 6c6f 2d6f .........hello-o000020f0: 7269 6769 6e61 6c2e 6173 6d00 6d73 6700 riginal.asm.msg.00002100: 5f5f 6273 735f 7374 6172 7400 5f65 6461 __bss_start._eda00002110: 7461 005f 656e 6400 002e 7379 6d74 6162 ta._end...symtab00002120: 002e 7374 7274 6162 002e 7368 7374 7274 ..strtab..shstrt00002130: 6162 002e 7465 7874 002e 6461 7461 0000 ab..text..data..00002140: 0000 0000 0000 0000 0000 0000 0000 0000 ................00002150: 0000 0000 0000 0000 0000 0000 0000 0000 ................</p><p>$xxd&lt；hello|ail-32|head000020c0：0920 4000 0000 0000 0000。@.000020d0：2b00 0000 1000 0200 1020 4000 0000 0000+.。@...000020e0：0000 0000 0000 0068 656c 6c6f 2d6f.hello-o000020f0：7269 6769 6e61 6c2e 6173 6d00 6d73 6700 riginal.asm.msg.00002100：5f5f 6273 735f 7374 6172 7400 5f65 6461__bss_start._eda00002110：7461 005f 656e 6400 002e 7379 6d74 6162._end...symtab00002120：002e 73274 6162 2e 73274str..sht00002130：600162 e 7465 780074 2e 64761.。00002150：0000 0000 0000。</p><p> Now, there&#39;s a whole  host of tools that would let us poke this ELF file fromthe comfort of a terminal. Ohh yes. A slew of them. Tools and tools as far asthe eye can see. But we shan&#39;t be using them today. Not today, matey.</p><p>现在，有一整套工具可以让我们在舒适的终端上戳到这个ELF文件。哦，是的。他们中的许多人。一目了然的工具和工具。但我们今天不会使用它们。今天不行，伙计。</p><p> Today, we parse things ourselves. Using the  nom crate, which we used in the Making our own ping series, and armed withwhich I would be willing to parse darn near anything -  even PSD.</p><p>今天，我们自己解析事物。使用的是我们在“制造我们自己的ping”系列中使用的Nom板条箱，并配备了它，我愿意分析几乎任何东西-即使是PSD。</p><p> For that, though, we&#39;ll need a few pointers. The  Wikipedia page forELF is not halfbad, but it&#39;s not the greatest overview - in part because it bothers itselfwith 32-bit ELF, which we will, for the entire length of this series,conveniently forget.</p><p>不过，要做到这一点，我们需要一些指导。ELF的维基百科页面还算不错，但它也不是最好的概述--部分原因是它为32位ELF而烦恼，我们在本系列的整个篇幅中都会很方便地忘记这一点。</p><p>    I realize that&#39;s a lot to take in - a lot of this doesn&#39;t make sense yet!</p><p>我意识到要接受的东西太多了--很多东西现在还说不通呢！。</p><p> Before we start writing any code, let&#39;s do some basic exploration by hand. Accordingto that diagram, at offset  62 in the file, there&#39;s an &#34;index of entry with section names&#34;.For our  hello executable, that&#39;s...</p><p>在我们开始编写任何代码之前，让我们手工做一些基本的探索。根据该图，在文件中的偏移量62处，有一个带有节名称的条目索引。对于我们的hello可执行文件，这是...。</p><p> $ # -s = seek, -l = length$ xxd -s 62 -l 2 ./hello0000003e: 0500 ..</p><p>$#-s=查找，-l=长度$xxd-s 62-l 2。/hello0000003e：0500.。</p><p> The bytes  05 and  00 - now, we&#39;re dealing with a little-endian file, so that means  0x0005,which is just  5. So the  fifth section header in the table contains section names.</p><p>字节05和00-现在，我们正在处理一个小端文件，这意味着0x0005，也就是5。因此，表中的第五节标题包含节名称。</p><p> At this point we have no idea what sections are, but I think it&#39;s safe to saythat the file is divided into them and that their beginning and size is storedin those section headers.</p><p>在这一点上，我们不知道段是什么，但我认为可以安全地说，文件被分成几个段，并且它们的开始和大小存储在这些段标题中。</p><p>  $ # -g = group size, -e = little-endian$ xxd -s 40 -l 8 -g 8 -e ./hello00000028: 0000000000002140</p><p>$#-g=组大小，-e=小端$xxd-s 40-l 8-g 8-e./hello00000028：0000000000002140。</p><p>   Even though  xxd itself doesn&#39;t support hexadecimal notation, we can perform  shell arithmetic with  $((expr))!</p><p>即使xxd本身不支持十六进制记数法，我们也可以用$((Expr))！</p><p> According to the  Wikipedia page on ELF,every section header contains the offset in the file where the section data is stored... at offset 0x18!</p><p>根据ELF上的Wikipedia页面，每个区段标题都包含存储区段数据的文件中的偏移量……。偏移量为0x18！</p><p>  $ xxd -s $((0x2140 + 0x40 * 5 + 0x18)) -l 8 -g 8 -e ./hello00002298: 0000000000002118 .!......</p><p>$xxd-s$((0x2140+0x40*5+0x18))-l 8-g 8-e./hello00002298：0000000000002118。！.</p><p> That means that the data of the section that contains section names should be at  0x2118. Let&#39;s check it out:</p><p>这意味着包含节名称的节的数据应该是0x2118。让我们来看看吧：</p><p> $ xxd -s $((0x2118)) ./hello | head -400002118: 002e 7379 6d74 6162 002e 7374 7274 6162 ..symtab..strtab00002128: 002e 7368 7374 7274 6162 002e 7465 7874 ..shstrtab..text00002138: 002e 6461 7461 0000 0000 0000 0000 0000 ..data..........00002148: 0000 0000 0000 0000 0000 0000 0000 0000 ................</p><p>$xxd-s$((0x2118))./hello|head-400002118：002e 7379 6d74 6162 002e 7374 7274 6162.symtab..strtab00002128：002e 7368 7374 7274 6162 002e 7465 7874.shstrtab..text00002138：002e 6461 7461 0000 0000 0000数据.00002148：0000 0000 0000.。</p><p>   It was fun looking through the file by hand, and we learned to use  xxd todo exactly that (which might definitely come in handy in the nuclear winterif a graphical hex viewer/editor isn&#39;t available), but we probably wantto start writing an actual parser now.</p><p>手工浏览文件很有趣，我们学会了使用xxd来做这件事(如果没有图形十六进制查看器/编辑器，这在核冬天肯定会派上用场)，但是我们现在可能想要开始编写一个真正的解析器了。</p><p>  $ cargo new --lib delf$ cd delf$ cargo add nom Adding nom v5.1.2 to dependencies</p><p>$Cargo new--lib Delf$cd Delf$Cargo将NOM添加到依赖项中添加NOM v5.1.2。</p><p>   // in `delf/src/parse.rs` pub  type  Input &lt; &#39; a &gt; =  &amp; &#39; a  [ u8 ] ; pub  type  Result &lt; &#39; a,  O &gt; = nom :: IResult &lt; Input &lt; &#39; a &gt;,  O, nom ::error :: VerboseError &lt; Input &lt; &#39; a &gt; &gt; &gt; ;</p><p>//在`delf/src/parse.rs`pub type input&lt；&#39；a&&gt;；=&amp；&39；a[U8]；；pub type result&lt；a，O&gt；=nom：：IResult&lt；input&lt；，O，nom：：error：：VerboseError&lt；input&lt；&#39；a&gt；&gt；；</p><p>   Like I said earlier, we&#39;re not going to bother with big-endian ELFs, or 32-bit ELFs, so wecan hardcode a few values. Let&#39;s get started!</p><p>就像我前面说的，我们不会费心使用大端ELF或32位ELF，所以我们可以硬编码一些值。让我们开始吧！</p><p> // in `delf/src/lib.rs` # [derive (Debug ) ] pub  struct  File {  // we&#39;ll add fields as we go} impl  File {  const MAGIC:  &amp; &#39; static  [ u8 ] =  &amp; [ 0x7f,  0x45,  0x4c,  0x46 ] ;  pub  fn  parse ( i: parse :: Input ) -&gt; parse :: Result &lt; Self &gt; {  use nom ::{ bytes ::complete ::{tag, take}, error ::context, sequence ::tuple, } ;  let  (i, _ ) =  tuple ( (  // -------  context ( &#34;Magic&#34;,  tag ( Self ::MAGIC ) ),  context ( &#34;Class&#34;,  tag ( &amp; [ 0x2 ] ) ),  context ( &#34;Endianness&#34;,  tag ( &amp; [ 0x1 ] ) ),  context ( &#34;Version&#34;,  tag ( &amp; [ 0x1 ] ) ),  context ( &#34;OS ABI&#34;,  tag ( &amp; [ 0x0 ] ) ),  // -------  context ( &#34;Padding&#34;,  take ( 8_usize ) ),  ) ) (i )? ; Ok ( (i,  Self {} ) ) }}</p><p>//在`delf/src/lib.rs`#[Derive(Debug)]pub struct File{//we&#39；ll add field as we go}Impl File{const Magic：&amp；&39；static[U8]=&amp；[0x7f，0x45，0x4c，0x46]；pub FN parse(i：parse：：input)-&gt；parse：：result&lt；self&gt；{Use Nom：：{Bytes：：Complete：：{Tag，Take}，Error：：Context，Sequence：：tuple，}；let(i，_)=tuple((//-Context((//-Context(&#34；Magic&#34；，Tag(&#34；Class&#34；，Tag(&amp；[0x2])，Context(&#34；Endianness&#34；，标记(&amp；[0x1])，上下文(&#34；版本&#34；，标记(&amp；[0x1]))，上下文(&#34；操作系统ABI&34；，标记(&amp；[0x0]))，//-上下文(&#34；填充&#34；，Take(8_Usize))，))(I)？；好的((我，自己{}))}}。</p><p> That looks reasonable. Let&#39;s make another crate to test the  delf crate.We&#39;ll name it &#34;elk&#34;, for &#34;Executable &amp; Linker Kit&#34;</p><p>这看起来很合理。让我们再做一个板条箱来测试Delf的板条箱。我们将把它命名为Elk&34；，用于Executable&amp；Linker Kit&#34；</p><p>  // in `src/elk/main.rs` use std ::{env, error ::Error, fs} ; fn  main ( ) -&gt;  Result &lt; ( ),  Box &lt; dyn  Error &gt; &gt; {  let input_path = env :: args ( ) . nth ( 1 ) . expect ( &#34;usage: elk FILE&#34; ) ;  let input = fs :: read ( &amp;input_path )? ; delf :: File :: parse ( &amp;input [.. ] ) . map_err (|e|  format ! ( &#34;{:?}&#34;, e ) )? ;  println ! ( &#34;input is a supported ELF file!&#34; ) ; Ok ( ( ) )}</p><p>//在`src/elk/main.rs`中使用std：：{env，error：：error，fs}；fn main()-&gt；result&lt；()，Box&lt；dyn error&gt；&gt；{let input_path=env：：args()。第n(1)。预期(&#34；用法：ELK文件&#34；)；让INPUT=fs：：Read(&amp；INPUT_PATH)？；Delf：：File：：Parse(&amp；INPUT[.。]))。Map_err(|e|format！(&#34；{：？}&#34；，e))？；println！(&#34；输入为支持的ELF文件！&#34；)；确定(())}。</p><p>      Let&#39;s start with the type - declaring an enum in Rust is simple enough.We&#39;ll want to derive some useful traits -  Debug for printing,  Clone and Copy so it has copy semantics (instead of transmitting ownership), PartialEq and  Eq to compare  Type values for equality.</p><p>让我们从类型开始-在Rust中声明一个枚举就足够简单了。我们会想要派生一些有用的特性-Debug for Print，Clone and Copy，这样它就有了Copy语义(而不是传递所有权)，PartialEq和Eq来比较Type值是否相等。</p><p> // in `delf/src/lib.rs` # [derive (Debug, Clone, Copy, PartialEq, Eq ) ] pub  enum  Type { None, Rel, Exec, Dyn, Core,}</p><p>//在`delf/src/lib.rs`#[Derate(Debug，Clone，Copy，PartialEq，Eq)]pub枚举类型{None，Rel，Exec，Dyn，Core，}中。</p><p> When reading our ELF file though, we won&#39;t get a  Type - we&#39;ll get a  u16.And similarly, when we write out an ELF file, we&#39;ll also need a  u16.</p><p>但是，当读取ELF文件时，我们不会得到Type-我们会得到u16。同样，当我们写出ELF文件时，我们也需要u16。</p><p>  // in `delf/src/lib.rs` impl  Type { to_u16 ( &amp; self ) -&gt; u16 { match  self {  Self ::None =&gt;  0,  Self ::Rel =&gt;  1,  Self ::Exec =&gt;  2,  Self ::Dyn =&gt;  3,  // etc. } }}</p><p>//在`delf/src/lib.rs`实施类型{to_u16(&amp；self)-&gt；u16{Match Self{Self：：None=&gt；0，Self：：Rel=&gt；1，Self：：Exec=&gt；2，Self：：Dyn=&gt；3，//etc}}。</p><p> Or we could just set the  representation of the  Type enum to  u16 - andthen we&#39;d get that for free:</p><p>或者，我们可以将类型枚举的表示形式设置为u16-然后我们将免费获得：</p><p> // in `delf/src/lib.rs` # [derive (Debug, Clone, Copy, PartialEq, Eq ) ] # [repr (u16 ) ] pub  enum  Type { None =  0x0, Rel =  0x1, Exec =  0x2, Dyn =  0x3, Core =  0x4,}</p><p>//在`delf/src/lib.rs`中#[Derate(Debug，Clone，Copy，PartialEq，Eq)]#[repr(U16)]pub枚举类型{None=0x0，rel=0x1，Exec=0x2，dyn=0x3，Core=0x4，}。</p><p> Now, we can use the  as operator to cast our  Type to  u16 - let&#39;swrite a quick test to validate our assumptions:</p><p>现在，我们可以使用as运算符将Type强制转换为u16-let swrite快速测试来验证我们的假设：</p><p>   $ # t == test, --lib == only library unit tests (not doc tests)$ cargo t --lib Finished test [unoptimized + debuginfo] target(s) in 0.02s Running target/debug/deps/delf-d6fdd5529c793a0brunning 1 testtest tests::type_to_u16 ... oktest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</p><p>$#t==测试，--lib==仅库单元测试(不是文档测试)$Cargo t--库已完成测试[未优化+调试信息]运行target/debug/deps/delf-d6fdd5529c793a0brunning 1测试测试的0.02s目标：：TYPE_TO_u16...。OK测试结果：OK。1通过；0失败；0忽略；0测量；0过滤掉。</p><p> Splendid! Now there&#39;s the small matter of going the  other way - convertingan  u16 to a  Type. The problem here, of course, is that not all  u16 valuesare valid  Type values.</p><p>好极了！现在有了另一种方式的小问题-将u16转换为Type。当然，这里的问题是并不是所有的u16值都是有效的Type值。</p><p> In fact, had we written  from_u16 ourselves, we would have had to dealwith this problem head-on:</p><p>事实上，如果我们自己从_u16开始写，我们将不得不正面处理这个问题：</p><p> // in `delf/src/lib.rs` impl  Type {  pub  fn  from_u16 ( x:  u16 ) -&gt;  Self {  match x {  0 =&gt;  Self ::None,  1 =&gt;  Self ::Rel,  2 =&gt;  Self ::Exec,  3 =&gt;  Self ::Dyn,  4 =&gt;  Self ::Core, } }}</p><p>//在`delf/src/lib.rs`实施类型{pub fn from_u16(x：u16)-&gt；self{Match x{0=&gt；self：：None，1=&gt；self：：rel，2=&gt；self：：exec，3=&gt；self：：dyn，4=&gt；self：：core，}。</p><p>  # b = build, -q = quiet$ cargo b -qerror[E0004]: non-exhaustive patterns: `5u16..=std::u16::MAX` not covered --&gt; src/lib.rs:17:15 |17 | match x { | ^ pattern `5u16..=std::u16::MAX` not covered | = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms</p><p>#b=构建，-q=安静$CAROR b-qerror[E0004]：非穷举模式：`5u16..=std：：u16：：max`未覆盖--&gt；src/lib.rs：17：15|17|match x{|^pattern`5u16..=std：：u16：：max`未覆盖|=help：确保正在处理所有可能的情况，可能是通过添加通配符或更多匹配臂。</p><p>  // in `delf/src/lib.rs` impl  Type {  pub  fn  from_u16 ( x:  u16 ) -&gt;  Option &lt; Self &gt; {  match x {  0 =&gt; Some ( Self ::None ),  1 =&gt; Some ( Self ::Rel ),  2 =&gt; Some ( Self ::Exec ),  3 =&gt; Some ( Self ::Dyn ),  4 =&gt; Some ( Self ::Core ), _ =&gt; None, } }} # [cfg (test ) ] mod tests {  // omitted: previous tests  # [test ]  fn  type_from_u16 ( ) {  assert_eq ! ( super::Type::from_u16 ( 0x3 ), Some ( super::Type::Dyn ) ) ;  assert_eq ! ( super::Type::from_u16 ( 0xf00d ), None ) ; }}</p><p>//在`delf/src/lib.rs`impl Type{pub fn from_u16(x：u16)-&gt；option&lt；self&gt；{Match x{0=&gt；Some(Self：：None)，1=&gt；Some(Self：：Rel)，2=&gt；Some(Self：：Exec)，3=&gt；Some(Self：：Dyn)，4=&gt；Some(Self：：Core)，_=&gt；Some(Self：：Core)，_=&gt；无，}#[cfg(Test)]mod test{//省略：以前的测试#[test]fn type_from_u16(){assert_eq！(Super：：type：：from_u16(0x3)，ome(Super：：type：：dyn))；assert_eq！(Super：：type：：from_u16(0xf00d)，None)；}}。</p><p>  $ cargo t --lib Finished test [unoptimized + debuginfo] target(s) in 0.02s Running target/debug/deps/delf-d6fdd5529c793a0brunning 2 teststest tests::type_to_u16 ... oktest tests::type_from_u16 ... oktest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</p><p>$Cargo t--lib已在0.02s内完成测试[未优化+调试信息]目标，运行类型2测试测试：：target/debug/deps/delf-d6fdd5529c793a0brunning_to_u16...。正常测试测试：：type_from_u16...。OK测试结果：OK。2通过；0失败；0忽略；0测量；0过滤掉。</p><p> ...but it&#39;s kinda tedious. We already specify a  Type &lt;-&gt; u16 mapping, when wefirst define the enum. Why should we  repeat ourselves?</p><p>...但是这有点单调乏味。当我们第一次定义枚举时，我们已经指定了Type&lt；-&gt；u16映射。我们为什么要重复我们自己呢？</p><p> As it turns out..  eyes light up in wonder there is a crate for that!</p><p>事实证明..。眼睛会惊奇地亮起来，有一个板条箱可以放这个！</p><p>   // in `delf/src/lib.rs` use derive_try_from_primitive ::TryFromPrimitive ; # [derive (Debug, Clone, Copy, PartialEq, Eq, TryFromPrimitive ) ] # [repr (u16 ) ] pub  enum  Type { None =  0x0, Rel =  0x1, Exec =  0x2, Dyn =  0x3, Core =  0x4,} # [derive (Debug, Clone, Copy, PartialEq, Eq, TryFromPrimitive ) ] # [repr (u16 ) ] pub  enum  Machine { X86 =  0x03, X86_64 =  0x3e,} # [cfg (test ) ] mod tests {  use  super ::Machine ;  use std ::convert ::TryFrom ;  # [test ]  fn  try_enums ( ) {  assert_eq ! (Machine::X86_64  as  u16,  0x3E ) ;  assert_eq ! (Machine::try_from ( 0x3E ), Ok (Machine::X86_64 ) ) ;  assert_eq ! (Machine::try_from ( 0xFA ), Err ( 0xFA ) ) ; }}</p><p>//在`delf/src/lib.rs`中使用Deriate_try_from_primitive：：TryFromPrimitive；#[Deriate(Debug，Clone，Copy，PartialEq，Eq，TryFromPrimitive)]#[repr(U16)]pub枚举类型{None=0x0，rel=0x1，Exec=0x2，dyn=0x3，Core=0x4，}#[Deriate(Debug，Clone，Copy，PartialEq，Eq，TryFromPrimitive)]#[repr(U16)]pub enum Machine{X86=0x03，X86_64=0x3e，}#[CFG(Test)]mod test{Use Super：：Machine；Use STD：：Convert：：TryFromPrimitive)]#[repr(U16)]pub enum Machine{X86=0x03，X86_64=0x3e，}#[CFG(Test)]mod test{USE SUPER：：MACHINE；USE STD：：CONVERT：：TryFromPrimitive。#[test]fn try_enum(){assert_eq！(MACHINE：：x86_64 as u16，0x3E)；assert_eq！(MACHINE：：TRY_FROM(0x3E)，OK(MACHINE：：x86_64))；ASSERT_eq！(MACHINE：：TRY_FROM(0xFA)，Err(0xFA))；}}。</p><p> In a previous version of this article, we used  derive-try-from-primitive v0.1.0,which returned an  Option&lt;T&gt;. But, since then,  derive-try-from-primitive v1.0.0was released, which returns a  Result&lt;T, E&gt; since it implements the standard  TryFrom interface.</p><p>在本文的前一个版本中，我们使用了Derate-try-from-primitive v0.1.0，它返回一个选项&lt；T&gt；。但是，从那时起，发布了从原语派生-尝试-版本1.0.0，它返回一个结果&lt；T，E&gt；，因为它实现了标准的TryFrom接口。</p><p>  $ cargo t Finished test [unoptimized + debuginfo] target(s) in 0.01s Running /home/amos/ftl/elf-series/target/debug/deps/delf-2d44b198a598eda8running 1 testtest tests::try_enums ... oktest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out Doc-tests delfrunning 0 teststest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</p><p>$Cargo t已在0.01s内完成测试[未优化+调试信息]目标，运行/home/amos/ftl/elf-series/target/debug/deps/delf-2d44b198a598eda8running 1测试测试：：Try_enums...。OK测试结果：OK。1通过；0失败；0忽略；0测量；0过滤出单据-测试脱机测试0测试结果：OK。0通过；0失败；0被忽略；0被测量；0被过滤掉。</p><p> Now, we can finally parse both the type and the machine. First let&#39;s addthem to the  File struct:</p><p>现在，我们终于可以解析类型和机器了。首先让我们将它们添加到文件结构中：</p><p>   $ cargo b -qerror: expected identifier, found keyword `type` --&gt; src/lib.rs:24:5 |24 | type: Type, | ^^^^ expected identifier, found keyword |help: you can escape reserved keywords to use them as identifiers |24 | r#type: Type, | ^^^^^^</p><p>$Cargo b-qerror：预期标识符，找到关键字`type`--&gt；src/lib.rs：24：5|24|type：type，|^预期标识符，找到关键字|help：您可以转义保留关键字以将其用作标识符|24|r#type：type，|^。</p><p> It is! We could use  typ instead - but just this once, let&#39;s use theescaped form instead, like the compiler suggests.</p><p>它是!。我们可以改用类型--但就这一次，让我们按照编译器的建议，改用转义形式。</p><p>    // in `delf/src/lib.rs` // new! use std ::convert ::TryFrom ; impl  File {  // omitted: magic constant  pub  fn  parse ( i: parse :: Input ) -&gt; parse :: Result &lt; Self &gt; {  use nom ::{ bytes ::complete ::{tag, take}, error ::context, sequence ::tuple, combinator ::map, number ::complete ::le_u16, } ;  // omitted: parse magic, etc.  let  (i,  (r#type, machine ) ) =  tuple ( (  context ( &#34;Type&#34;,  map (le_u16, |x|  Type :: try_from (x ) . unwrap ( ) ) ),  context ( &#34;Machine&#34;,  map (le_u16, |x|  Machine :: try_from (x ) . unwrap ( ) ) ),  ) ) (i )? ;  let res =  Self { machine, r#type } ; Ok ( (i, res ) ) }}</p><p>//在`delf/src/lib.rs`中//new！Use std：：Convert：：TryFrom；Iml File{//省略：魔术常数pub FN parse(i：parse：：input)-&gt；parse：：result&lt；self&gt；{use nom：：{bytes：：Complete：：{Tag，Take}，Error：：Context，Sequence：：Tuple，Combinator：：Map，Number：：Complete：：LE_u16，}；//省略：解析魔术等let(i，(r#type，machine))=tuple((context(&#34；Type&#34；，map(le_u16，|x|Type：：try_from(X)。展开())，上下文(&#34；Machine&#34；，map(le_u16，|x|Machine：：try_from(X)。Unwork()，)(I)？；设res=self{机器，r#type}；OK((i，res))}}</p><p> To try that, we&#39;ll switch back to our binary crate,  elk, for a second,and print the  File struct, now that it has fields!</p><p>为了尝试这一点，我们将切换回我们的二进制机箱elk一秒钟，并打印File结构，现在它有了字段！</p><p> // in `elk/src/main.rs` fn  main ( ) -&gt;  Result &lt; ( ),  Box &lt; dyn  Error &gt; &gt; {  let input_path = env :: args ( ) . nth ( 1 ) . expect ( &#34;usage: elk FILE&#34; ) ;  let input = fs :: read ( &amp;input_path )? ;  let  (_, file ) = delf :: File :: parse ( &amp;input [.. ] ) . map_err (|e|  format ! ( &#34;{:?}&#34;, e ) )? ;  // new!  println ! ( &#34;{:#?}&#34;, file ) ; Ok ( ( ) )}</p><p>//在`elk/src/main.rs`fn main()-&gt；result&lt；()中，Box&lt；dyn error&gt；&gt；{let input_path=env：：args()。第n(1)。预期(&#34；用法：ELK文件&#34；)；let input=fs：：read(&amp；input_path)？；let(_，file)=Delf：：file：：parse(&amp；input[.。]))。Map_err(|e|format！(&#34；{：？}&#34；，e))？；//new！Println！(&#34；{：#？}&#34；，file)；确定(())}。</p><p>   $ ./target/debug/elk /usr/lib32/libc.soError: &#34;Error(VerboseError { errors: [([47, 42, 32, 71, 78, 85, 32, 108, 100, 32, 115, 99, 114, 105, 112, 116, 10, 32, 32, 32, 85, 115, 101, 32, 116, 104, 101, 32, 115, 104, 97, 114, 101, 100, 32, 108, 105, 98, 114, 97, 114, 121, 44, 32, 98, 117, 116, 32, 115, 111, 109, 101, 32, 102, 117, 110, 99, 116, 105, 111, 110, 115, 32, 97, 114, 101, 32, 111, 110, 108, 121, 32, 105, 110, 10, 32, 32, 32, 116, 104, 101, 32, 115, 116, 97, 116, 105, 99, 32, 108, 105, 98, 114, 97, 114, 121, 44, 32, 115, 111, 32, 116, 114, 121, 32, 116, 104, 97, 116, 32, 115, 101, 99, 111, 110, 100, 97, 114, 105, 108, 121, 46, 32, 32, 42, 47, 10, 79, 85, 84, 80, 85, 84, 95, 70, 79, 82, 77, 65, 84, 40, 101, 108, 102, 51, 50, 45, 105, 51, 56, 54, 41, 10, 71, 82, 79, 85, 80, 32, 40, 32, 47, 117, 115, 114, 47, 108, 105, 98, 51, 50, 47, 108, 105, 98, 99, 46, 115, 111, 46, 54, 32, 47, 117, 115, 114, 47, 108, 105, 98, 51, 50, 47, 108, 105, 98, 99, 95, 110, 111, 110, 115, 104, 97, 114, 101, 100, 46, 97, 32, 32, 65, 83, 95, 78, 69, 69, 68, 69, 68, 32, 40, 32, 47, 117, 115, 114, 47, 108, 105, 98, 51, 50, 47, 108, 100, 45, 108, 105, 110, 117, 120, 46, 115, 111, 46, 50, 32, 41, 32, 41, 10], Nom(Tag)), ([47, 42, 32, 71, 78, 85, 32, 108, 100, 32, 115, 99, 114, 105, 112, 116, 10, 32, 32, 32, 85, 115, 101, 32, 116, 104, 101, 32, 115, 104, 97, 114, 101, 100, 32, 108, 105, 98, 114, 97, 114, 121, 44, 32, 98, 117, 116, 32, 115, 111, 109, 101, 32, 102, 117, 110, 99, 116, 105, 111, 110, 115, 32, 97, 114, 101, 32, 111, 110, 108, 121, 32, 105, 110, 10, 32, 32, 32, 116, 104, 101, 32, 115, 116, 97, 116, 105, 99, 32, 108, 105, 98, 114, 97, 114, 121, 44, 32, 115, 111, 32, 116, 114, 121, 32, 116, 104, 97, 116, 32, 115, 101, 99, 111, 110, 100, 97, 114, 105, 108, 121, 46, 32, 32, 42, 47, 10, 79, 85, 84, 80, 85, 84, 95, 70, 79, 82, 77, 65, 84, 40, 101, 108, 102, 51, 50, 45, 105, 51, 56, 54, 41, 10, 71, 82, 79, 85, 80, 32, 40, 32, 47, 117, 115, 114, 47, 108, 105, 98, 51, 50, 47, 108, 105, 98, 99, 46, 115, 111, 46, 54, 32, 47, 117, 115, 114, 47, 108, 105, 98, 51, 50, 47, 108, 105, 98, 99, 95, 110, 111, 110, 115, 104, 97, 114, 101, 100, 46, 97, 32, 32, 65, 83, 95, 78, 69, 69, 68, 69, 68, 32, 40, 32, 47, 117, 115, 114, 47, 108, 105, 98, 51, 50, 47, 108, 100, 45, 108, 105, 110, 117, 120, 46, 115, 111, 46, 50, 32, 41, 32, 41, 10], Context(\&#34;Magic\&#34;))] })&#34;</p><p>$./target/debug/elk/usr/lib32/libc.soError：&#34；错误(VerboseError{错误：[47，42，32，71，78，85，32,108,100，32,115，99,114,105,112,116，10，32，32，32，85,115,101，32,116,104,101，32,115,104，97,114,101,100，32,108,105，98,114，97,114,121，44，32，98,117,116，32,115,111,109,101，32,102,117,110，99,116,105,111,110，115、32、97、114、101、32、111、110、108、121、32、105、110、10、32、32、116、104、101、32、115、116、97、116、105、99、32、108、105、98、114、97、114、121、44、32、115、111、32、116、114、121、32、116、104、97、116、32、115、101、99、111、110、100、97、97、114、105、108、121、46、32、32、42、47、10。79，85，84，80，85，84，95，70，79，82，77，65，84，40,101,108,102，51，50，45,105，51，56，54，41，10，71，82，79，85，80，32，40，32，47,117,115,114，47,108,105，98，51，50，47,108,105，98，99，46,115,111，46，54，32，47,117,115,114，47,108,105，98，50,108,105，98，99，46,115,111，46，54，32，47,117,115,114，47,108,105，98，51，50，47，47。108、105、98、99、95、110、111、110、115、104、97、114、101、100、46、97、32、32、65、83、95、78、69、69、68、32、40、32、47、117、115、114、47、108、105、98、51、50、47、108、100、45、108、105、110、117、120、46、115、111、46、50、32、41、32、41、10]、nom(标签)，([47，42，32、71、78、85、32、108、100、32、115、99、114、105、112、116、10、32、32、32、85、115、101、32、116、104、101、32、32、115、104、97、114、101、100、32、108、105、98、114、97、114、121、44、32、98、117、116、32、115、111、109、101、32、102、117、110、99、116、105、111、110、115、32、97、114、101、32、111、115、32、97、114、101、32、111、115、32、97、114、101、32、111、110、99、116、105、111、110、115、32、97、114、101、32、111。110、108、121、32、105、110、10、32、32、32、116、104、101、32、115、116、97、116、105、99、32、108、105、98、114、97、114、121、44、32、115、111、32、116、114、121、32、116、104、97、116、32、115、101、99、111、110、100、97、114、105、108、121、46、32、32、42、47、10、79、85、84、80、85、95。70，79，82，77，65，84，40,101,108,102，51，50，45,105，51，56，54，41，10，71，82，79，85，80，32，40，32，47,117,115,114，47,108,105，98，51，50，47,108,105，98，51，50，47,108,105，98，99，46,115,111，46，54，32，47,117,115,114，47,108,105，98，51，50，47,108,105，98，99，95,110,111，110、115、104、97、114、101、100、46、97、32、32、65、83、95、78、69、69、68、69、68、32、40、32、47、117、115、114、47、108、105、98、51、50、47、108、100、45、108、105、110、117、120、46、115、111、46、50、32、41、32、41、41、41、10]、上下文(\&#34；魔术\&#34；))]})&#34；</p><p>    // in `delf/src/lib.rs` pub  struct  HexDump &lt; &#39; a &gt; ( &amp; &#39; a  [ u8 ] ) ; use std ::fmt ; impl &lt; &#39; a &gt; fmt :: Debug  for  HexDump &lt; &#39; a &gt; {  fn  fmt ( &amp; self,  f:  &amp; mut fmt :: Formatter ) -&gt; fmt :: Result {  for  &amp;x  in  self . 0 . iter ( ) . take ( 20 ) {  write ! (f,  &#34;{:02x} &#34;, x )? ; } Ok ( ( ) ) }}</p><p>//在`delf/src/lib.rs`pub struct HexDump&lt；&#39；a&gt；(&amp；#39；a[U8])；使用std：：fmt；Iml&lt；&#39；a&gt；fmt：：debug for HexDump&lt；&#39；a&gt；{fn fmt(&amp；self，f：&amp；mut fmt：：Formatter)-&gt；fmt：：result{for&amp；x in self。0。ITER()。拿(20){写！(F，&#34；{：02x}&#34；，x)？；}OK(())}}。</p><p>  nom::Err::Error is recoverable. Maybe another branch will work(if we&#39;re trying several parsers in a row), or maybe we justneed to get more input.</p><p>NOM：：ERR：：错误是可以恢复的。也许另一个分支可以工作(如果我们连续尝试几个解析器)，或者我们只需要获得更多的输入。</p><p> nom::Err::Failure is unrecoverable - we&#39;ve tried all the parsers,more input won&#39;t help, something is just plain wrong.</p><p>Nom：：Err：：失败是无法恢复的-我们已经尝试了所有的解析器，更多的输入是没有帮助的，只是有些地方是完全错误的。</p><p> In either case, they just wrap a  nom::error::VerboseError, which itselfcan contain multiple  nom::error::ErrorKind, along with the relevant input slice.</p><p>在任何一种情况下，它们只包装一个NOM：：Error：：VerboseError，它本身可以包含多个Nom：：Error：：ErrorKind，以及相关的输入片。</p><p> I know, I know - that&#39;s a lot! But thanks to  pattern matching, it&#39;s not so bad.</p><p>我知道，我知道--那太多了！但多亏了模式匹配，它并不是那么糟糕。</p><p> We can make a much better error printer in just a few lines. We&#39;ll add itdirectly in  delf, so that we don&#39;t have use  nom types in  elk:</p><p>我们可以在短短几行内制作出更好的错误打印机。我们将直接在Delf中添加它，这样我们就不会在ELK中使用NOM类型：</p><p> // in `delf/src/lib.rs` impl  File {  pub  fn  parse ( i: parse :: Input ) -&gt; parse :: Result &lt; Self &gt; {  let original_i = i ;  use nom ::{ error ::{ErrorKind, ParseError, VerboseError}, number ::complete ::le_u16, Err, } ;  let  (i, x ) =  le_u16 (i )? ;  match  Self :: try_from (x ) { Ok (res ) =&gt; Ok ( (i, res ) ), Err (_ ) =&gt; Err ( Err ::Failure ( VerboseError :: from_error_kind ( original_i,  ErrorKind ::Alt,  ) ) ), } }}</p><p>//在`delf/src/lib.rs`impl File{pub FN parse(i：parse：：input)-&gt；parse：：result&lt；self&gt；{let Original_i=i；use nom：：{error：：{ErrorKind，ParseError，VerboseError}，number：：Complete：：le_u16，err，}；let(i，x)=le_u16(I)？；匹配self：：try_from(X){OK(Res)=&gt；OK((i，res))，Err(_)=&gt；Err(Err：：Failure(VerboseError：：FROM_ERROR_KIND(Original_I，ErrorKind：：alt，)，}。</p><p>  // in `elk/src/main.rs` fn  main ( ) -&gt;  Result &lt; ( ),  Box &lt; dyn  Error &gt; &gt; {  // omitted: grabbing first argument  let file =  match delf :: File :: parse_or_print_error ( &amp;input [.. ] ) { Some (f ) =&gt; f, None =&gt; std ::process :: exit ( 1 ), } ;  println ! ( &#34;{:#?}&#34;, file ) ;}</p><p>//在`elk/src/main.rs`fn main()-&gt；result&lt；()中，Box&lt；dyn error&gt；&gt；{//省略：抓取第一个参数let file=Match Delf：：File：：parse_or_print_error(&amp；input[.。])){Some(F)=&gt；f，None=&gt；std：：process：：exit(1)，}；println！(&#34；{：#？}&#34；，file)；}。</p><p> $ cargo b -q$ ./target/debug/elk /usr/lib</p><p>$Cargo b-q$./target/debug/elk/usr/lib。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://fasterthanli.me/series/making-our-own-executable-packer/part-1">https://fasterthanli.me/series/making-our-own-executable-packer/part-1</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/u16/">#u16</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1031876.html"><img src="http://img2.diglog.com/img/2020/10/thumb_6b6739de6498c22a43a4a89275ba0e7b.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031876.html">Dn2l-Dos Navigator开源项目的Linux移植</a></div><span class="my_story_list_date">2020-10-29 10:29</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031674.html"><img src="http://img2.diglog.com/img/2020/10/thumb_aa894409fa807c74d89e9d9ad6dea94c.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031674.html">将MacOS作为虚拟化操作系统运行的Linux PC比hackinstosh更快</a></div><span class="my_story_list_date">2020-10-28 9:30</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031631.html"><img src="http://img2.diglog.com/img/2020/10/thumb_444d759ef07609563082147df13a7e22.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031631.html">Linus Torvalds欢呼“历史性的”Linux5.10抛弃了废弃的地址artef</a></div><span class="my_story_list_date">2020-10-28 6:6</span></div><div class="col-sm"><div><a target="_blank" href="/story/1031114.html"><img src="http://img2.diglog.com/img/2020/10/thumb_aaa5aab1b67a713eb47b833c758a0da1.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1031114.html">那么，Edge在Linux上有多好呢？</a></div><span class="my_story_list_date">2020-10-25 23:13</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>