<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>当我想到编程时我是怎么想的How I think when I think about programming</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How I think when I think about programming<br/>当我想到编程时我是怎么想的</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-21 09:08:12</div><div class="page_narrow text-break page_content"><p>this is a post I&#39;ve wanted to write for some time.in it, I attempt to explain, on a very basic level, how I think about programming.my hope is to give newer programmers some background knowledge and bigger-picture context.to help give form and structure to what is often presented as just a bunch of shit to remember</p><p>这是一篇我&#39；我想写一段时间了。在这篇文章中，我试图在一个非常基本的层面上解释我是如何看待编程的。我希望给新的程序员一些背景知识和更大的背景知识。帮助给那些经常被呈现为一堆要记住的狗屎赋予形式和结构</p><p> I don&#39;t attempt to teach programming per se.I don&#39;t cover all the details needed to write a program that compiles and runs.there are very many guides for that.I don&#39;t discuss computer science, nor do I get into type theory, though both of these topics can serve as a highly eluciditory basis for understanding programming.I talk about &#34;fundamentals&#34; a lot, but my fundamentals aren&#39;t a set of overarching theories.just a bag of tools</p><p>我不&#39；不要试图教授编程本身。我不&#39；t涵盖编写编译和运行程序所需的所有细节。这方面有很多指南。我不&#39；我不会讨论计算机科学，也不会进入类型理论，尽管这两个主题都可以作为理解编程的非常难以捉摸的基础。我说的是&#34；基础知识&#34；很多，但我的基础不是&#39；这不是一套总的理论。只是一袋工具</p><p> my goal is to impart some general heuristics about how to think about programming for the subset of people who happen to think like me</p><p>我的目标是传授一些关于如何为碰巧像我这样思考的人思考编程的一般启发</p><p> I got started programming by just messing around.making tiny modifications to existing javascript twitter bots to fashion my own, with a &#34;fuck it, whatever works&#34; kind of attitude.gradually my modifications got more ambitious, and after a couple months I could write the programs myself.a couple months after that, I found someone doing freelance webdev willing to take me on as a junior partner.and then from there I just kinda learned on the job</p><p>我开始编程的时候只是胡闹。对现有的javascript推特机器人进行微小的修改，打造我自己的，带有&#34；去他妈的，随便什么都行&#34；一种态度。渐渐地，我的修改变得更加雄心勃勃，几个月后，我可以自己编写程序了。几个月后，我发现有人做自由职业者webdev，愿意让我做初级合伙人。从那以后，我在工作中学到了一些东西</p><p> I generally consider theory to be useful background knowledge but fastidious study a poor substitute for firsthand experience.I &#34;learn with my hands,&#34; is the way I&#39;ve always put it.it has its upsides and downsides</p><p>我通常认为理论是有用的背景知识，但挑剔的学习是第一手经验的一个很差的替代品。我&#34；用我的双手学习，&#34；就是我&#39；我总是这么说。它有它的优点和缺点</p><p> getting up to &#34;working knowledge&#34; on something is usually trivial for me.I can speedrun in weeks what might take others months, or months what could take them years.I just bang my head on the problem until it (the problem, ideally) breaks</p><p>34岁；工作知识&#34；有些事情对我来说通常是微不足道的。我可以在几周内快速奔跑，这可能需要其他人几个月的时间，或者几个月的时间，这可能需要他们几年的时间。我只是猛击这个问题，直到它（理想情况下，这个问题）破裂</p><p> on the other hand, it means that I usually power through things in manic bursts.I easily get bored once progress becomes more incremental, when patience and diligence pay higher dividends than brashness and force.I go back and forth on whether I can and should train myself to be more disciplined, or if I am just a natural crosspollinator-type human and should just embrace it</p><p>另一方面，这意味着我通常会在狂躁的爆发中获得力量。一旦进步变得越来越大，耐心和勤奋比鲁莽和暴力带来的回报更高，我很容易感到厌倦。我反反复复地思考我是否能够也应该训练自己变得更有纪律，或者我是否只是一个天生的异花授粉者类型的人，应该接受它</p><p> anyway, if this description of how I learn feels familiar to you, it is likely that the way I think about this stuff will be useful.if you learn better in a formal classroom setting, or with guided mentorship, or through diligent study, or by leaning on carefully composed theoretical foundations, then it&#39;s possible the only value this post can provide is a voyeur&#39;s glimpse into how the fauves live</p><p>不管怎样，如果你对我的学习方式很熟悉，那么我对这些东西的思考方式可能会很有用。如果你在正式的课堂环境中，或在指导下，或通过勤奋学习，或通过学习精心编写的理论基础，学习得更好，那么它&#39；这篇文章可能提供的唯一价值就是偷窥者&#39；让我们来看看野兽的生活方式</p><p> I&#39;ve given bits and pieces of these lectures to at least a dozen people who&#39;ve come to me at various times for advice about how to get started with programming.I deliver a rundown of the fundamental abstractions used in imperative programming.then I give a glimpse above, at abstractions that can be constructed out of them, and a peek below, at what they themselves abstract over</p><p>我&#39；我给至少十几个人做了这些讲座的零碎部分，他们&#39；I’我经常来找我，征求关于如何开始编程的建议。我简要介绍了命令式编程中使用的基本抽象。然后我在上面瞥了一眼，可以从他们身上构造出抽象，在下面瞥了一眼，他们自己抽象出了什么</p><p> &#34;abstraction&#34; in mathematics means to use a higher-level concept that carries fewer assumptions but covers a broader superset of cases.complexity is removed for the sake of generalizability.&#34;abstraction&#34; in programming means to paper over the underlying workings of a system with shorthands or conveniences.complexity is added so you can pretend it isn&#39;t there.no matter how you dress it up, when you&#39;re using a computer, you are always somewhere in the jenga pagoda</p><p>&#34;抽象&#34；在数学中，这意味着使用一个更高层次的概念，它承载的假设更少，但涵盖的案例范围更广。为了通用性，复杂性被去除了&#34;抽象&#34；在编程中，指用简写或方便的方式记录系统的基本工作原理。增加了复杂性，所以你可以假装它不是&#39；不在那里。无论你如何打扮，当你&#39；当你使用电脑时，你总是在延加宝塔的某个地方</p><p>master the fundamentals, understand how they&#39;re composed into abstractions, and you can pick almost anything up as you go.I&#39;ve gotten hired for jobs where I didn&#39;t know the language I&#39;d be writing, expecting to learn it on their dime in the first couple days.it&#39;s easy once you stop seeing syntax and features like &#34;so what does this thing do...&#34; and start seeing &#34;ah, this is what they call that.&#34;not a ubiquitous skill in software, but not an uncommon one the volume of software in existence is massive.hundreds of ecosystems, thousands of tools, millions of libraries.if you tried to learn them all as individual things, it would be impossible.but they&#39;re all built out of the same basic parts</p><p>掌握基本原理，了解它们的原理&#39；重新组合成抽象概念，你可以边走边挑选几乎任何东西。我&#39；我得到了一份我没有得到的工作&#39；我不懂语言&#39；I’我在写，希望在头几天里用一分钱就能学会。它&#39；一旦你不再看到&#34；那么这东西做什么&#34; 然后开始看&#34；啊，这就是他们所说的&#34;这不是一种普遍存在的软件技能，但也不是一种罕见的技能现有的软件数量巨大。数百个生态系统，数千种工具，数百万个图书馆。如果你试着把它们都当作单独的东西来学习，那是不可能的。但是他们&#39；我们都是用相同的基本部件制造的</p><p> I remember when I first started programming, looking at job postings and seeing dozens of languages, tools, acronyms, jargon rattled off as necessary requirements.java c# php perl js ajax ruby go mysql postgres angular react agile scrum aws azure.it was daunting!I barely knew one thing, how was I going to learn 10 or 15, just to get started working?</p><p>我记得当我第一次开始编程的时候，看着招聘启事，看到几十种语言、工具、首字母缩略词、行话在必要时喋喋不休。java c#php perl js ajax ruby go mysql postgres敏捷scrum aws azure。真让人望而生畏！我几乎不知道一件事，我要如何学习10或15，只是为了开始工作？</p><p> now I roll my eyes at these lists.I know what they all are, I&#39;ve dabbled in many, I can easily learn any of them to professional proficiency.a lot of them are particular cases of general things, a lot of them are different words for the same thing, a lot of them are just bullshit.but all of them can be comprehended at a glance and learned by doing</p><p>现在我看着这些清单翻白眼。我知道他们都是什么，我&#39；我已经涉猎了很多领域，我可以很容易地将其中任何一个学习到专业水平。很多都是一般事物的特例，很多都是同一事物的不同词汇，很多都是胡说八道。但所有这些都可以一目了然，通过实践学习</p><p> learning a new technology, for an experienced programmer, usually doesn&#39;t look like concerted study, thwarted attempts, struggle and triumph.it looks like reading a three-paragraph summary of it, coding in or against it based on vibes, checking documentation for syntax, and bitching about how dumb the guy who designed it must have been</p><p>对于一个经验丰富的程序员来说，学习一项新技术通常不会有什么好处；看起来不像是协同学习、挫败尝试、奋斗和胜利。它看起来像是在阅读一个三段式的摘要，基于vibes对其进行编码，检查文档中的语法，并抱怨设计它的人一定是多么愚蠢</p><p> the title of the post is &#34;how I think about programming,&#34; not &#34;how you should think about programming.&#34;therefore I will brook no criticism.I&#39;m a strong believer in learning styles, and I think people should naturally adopt what is most comfortable.if everything that follows rings false, we probably just have different perspectives</p><p>这篇文章的标题是&#34；我是如何看待编程的&#34；不是&#34；你应该如何思考编程&#34;因此，我不会容忍任何批评。我&#39；我非常相信学习方式，我认为人们应该自然而然地采用最舒适的方式。如果接下来的一切听起来都是假的，我们可能只是有不同的观点</p><p> the material should be reasonably accessible to anyone who possesses general familiarity with a curlybrackets language.I admit sometimes I may move too fast, and other times I may get bogged down in detail.I do my best to explicitly introduce technical terminology before making it load-bearing.but pedagogy is hard, and unless you&#39;re constantly working with new learners, it&#39;s very difficult to keep in mind all the little quirks and customs that you&#39;ve come to take for granted</p><p>任何对curlybrackets语言有普遍了解的人都应该能够合理地获取这些材料。我承认有时我可能行动太快，有时我可能会陷入细节。在使其承载之前，我尽最大努力明确介绍技术术语。但是教育学很难，除非你&#39；我们不断与新学员合作，it&#39；It’很难记住你&#39；我已经习以为常了</p><p> if this post feels valuable, but parts are inaccessible, it may be worth revisiting as you gain more experience.I&#39;m trying to bridge gaps between concepts, more than I am trying to actually teach the concepts themselves.form, rather than content</p><p>如果你觉得这篇文章很有价值，但部分内容是无法访问的，那么当你获得更多经验时，也许值得重温。我&#39；我试图弥合概念之间的鸿沟，而不是试图教授概念本身。形式，而不是内容</p><p> I&#39;ve been programming for about six years now.before that, I cooked pancakes for a living.don&#39;t believe anyone who says you need a fancy degree, specialized training, or exposure since childhood to code.you can pick up programming just by being clever and stubborn</p><p>我&#39；我已经编程六年了。在那之前，我以做煎饼为生。唐&#39；I don’我不相信有人说你需要一个高级学位、专业培训，或者从小就接触代码。你可以通过聪明和固执来学习编程</p><p>    the first set of basics are assignment, flow control, and scope.all examples are in c unless otherwise stated.don&#39;t be scared if you&#39;re used to python or js.c is very easy to write.it&#39;s only hard to write correctly</p><p>第一组基础是分配、流控制和范围。除非另有说明，所有示例均为c。唐&#39；如果你&#39；我们习惯于python或js。c很容易写。它&#39；It’只是很难写正确</p><p> assignment is conceptually very simple.you are storing a value in some named piece of storage:</p><p>作业在概念上非常简单。您正在某个命名的存储器中存储一个值：</p><p>  here, the value 2 is being stored in  a, an integer variable.you can access the value via the name you&#39;ve given your storage:</p><p>这里，值2存储在一个整型变量中。您可以通过名称&#39；我给了你的存储空间：</p><p>    the algebraically confusing second line is not an equation.the value of  a, then 2, is loaded out of its storage space, and added to the value of  b.the sum is stored back in the space  b, replacing the 3 that used to be there</p><p>代数上令人困惑的第二条线不是一个方程式。a的值，然后是2，从其存储空间中加载，并添加到b的值中。总和存储回空间b中，取代原来的3</p><p> the thing to remember is that  a and  b are not objects.they are names of boxes in which we deposit objects</p><p>要记住的是a和b不是对象。它们是我们存放物品的盒子的名称</p><p> normally a program proceeds top to bottom, line by line, executing each statement and moving on to the next.it does this forever, until it encounters a statement that tells it to stop, or a kind of error that forces it to stop.but a program that can only proceed or halt cannot do much that is really interesting</p><p>通常情况下，一个程序从上到下逐行执行每一条语句，然后继续执行下一条语句。它会一直这样做，直到它遇到一个命令它停止的语句，或者一种迫使它停止的错误。但是一个只能继续或停止的程序不能做很多真正有趣的事情</p><p> programs become truly expressive once you have a way to change the future order of execution based on some present state.mechanisms that do this are called control-flow constructs, and the two most common are branches and loops</p><p>一旦你有了一种基于当前状态改变未来执行顺序的方法，程序就会变得真正有表现力。实现这一点的机制称为控制流构造，最常见的两种是分支和循环</p><p>   the condition is checked, and based on the result, one of two different blocks will be executed.the code in the blocks can be arbitrarily complex.you can have several conditions checked in sequence, or more complicated constructs with fallthrough rules, but they are computationally equivalent</p><p>检查条件，并根据结果执行两个不同块中的一个。块中的代码可以是任意复杂的。可以按顺序检查多个条件，或者使用故障排除规则检查更复杂的构造，但它们在计算上是等效的</p><p>   the block is executed once unconditionally, then the condition is checked, and based on the result, the block will either be run again, or flow will proceed past the loop to continue as normal.depending on what condition you set, the loop can execute arbitrarily many times, possibly indefinitely.there are other loop forms that check the condition at the top, or lack a condition and force you to explicitly abort inside a nested branch, but they are computationally equivalent</p><p>块无条件执行一次，然后检查条件，并基于结果，块将再次运行，或者流将继续通过循环正常运行。根据设置的条件，循环可以任意执行多次，可能是无限期的。还有其他一些循环形式检查顶部的条件，或者缺少条件，并强制您在嵌套分支中显式中止，但它们在计算上是等效的</p><p> in c, coherent units of execution are grouped together in blocks.blocks are self-contained, enclosed in curlybrackets, and can have their own isolated storage space.when the end of a block is reached, program flow continues in the context it was contained in.in this way, blocks are nested inside each other, ultimately all nested in the  main function.a block can access storage areas from its outer containers, but once execution moves outside of a block, all of that block&#39;s storage is lost, though changes it made to outside storage is kept</p><p>在c语言中，连贯的执行单元被分组在块中。区块是独立的，封闭在卷曲支架中，可以有自己的独立存储空间。当到达一个块的末尾时，程序流在它所包含的上下文中继续。通过这种方式，块彼此嵌套，最终全部嵌套在主函数中。一个块可以从其外部容器访问存储区域，但一旦执行移动到块外部，所有的块&#39；s存储丢失，但对外部存储所做的更改保留</p><p> the area of influence a block has, including storage it owns and storage it can access, is called its scope.a block that has a name and can be invoked from somewhere else and passed information is called a function</p><p>区块的影响范围，包括其拥有的存储和可访问的存储，称为其范围。一个块有一个名称，可以从其他地方调用并传递信息，称为函数</p><p> int timestwo(int n) { int x = n * 2; return x;}for(int i = 0; i &lt; 10; i++) { int x = timestwo(i); printf(&#34;%d\n&#34;, x);}</p><p>int times2（int n）{int x=n*2；返回x；}对于（int i=0；i&lt；10；i++）{int x=times2（i）；printf（&#34；%d\n&#34；，x）；}</p><p> here, the increasing values of  i generated by the  for loop are passed in as an argument to the function  int timestwo(int).an  x is calculated inside the scope of the function and returned to its caller.it then is assigned to  x outside, a completely different storage location which just happens to share a name.the storage that was internal to  int timestwo(int) is now gone</p><p>这里，for循环生成的i的递增值作为参数传递给函数int times2（int）。x在函数的作用域内计算并返回给其调用者。然后它被分配到x outside，一个完全不同的存储位置，恰好共享一个名称。int times2（int）内部的存储现在不存在了</p><p> it&#39;s worth noting that other languages, notably javascript, have a somewhat different notion of scope than c.the point I would make is that scope, like many things in programming, is a convention, not a fact of reality.most of the rules don&#39;t really &#34;mean&#34; anything on a deep level.they don&#39;t transcend the contexts in which they were implemented</p><p>它&#39；值得注意的是，其他语言，尤其是javascript，对作用域的概念与c有所不同。我想指出的是，与编程中的许多事情一样，作用域是一种约定，而不是事实。大多数规则没有&#39；真的&#34；平均值&#34；任何深层次的东西。他们没有&#39；我们不能超越实施它们的环境</p><p> type theorists, computer scientists, and category theorists would have a very different view on such an assertion.but that isn&#39;t relevant to us right now.we fuck around and find out</p><p>类型理论家、计算机科学家和范畴理论家对这样的断言会有截然不同的看法。但这并不是&#39；目前与我们无关。我们到处搞清楚</p><p> learn the rules, how to play within their bounds, and how any when to break them.existentially meaningless but internally consistent is the way to approach.if you obsess over what everything &#34;really means,&#34; you will get lost.this is useful for navigating many systems designed by humans besides programming languages</p><p>学习规则，如何在他们的范围内比赛，以及何时打破规则。这是一种无意义但内在一致的方法。如果你沉迷于一切&#34；真正的意思是&#34；你会迷路的。除了编程语言，这对于导航许多由人类设计的系统非常有用</p><p>    I like to think of basic programming concepts as akin to martial arts kata.those of us who tried karate as kids probably remember going in expecting to be doing flips and flying kicks from day one.we were instead instructed to perform the same punch, over and over, without variation.this is kata: the most elementary building block of technique</p><p>我喜欢把基本的编程概念想象成类似于武术武士。我们这些小时候尝试过空手道的人可能记得，从第一天开始，他们就期待着做翻转和飞踢。相反，我们被告知要一次又一次地进行同样的打击，没有任何变化。这就是kata：最基本的技术构件</p><p> kata is, I think, the secret to how you actually get good at programming.learning the big fancy stuff—baroque libraries, sprawling plugin ecosystems, towering frameworks—to a very deep level is the province of domain specialists.I respect what they do when they&#39;re good at it, but it is not how I work</p><p>我认为，kata是你真正擅长编程的秘诀。学习巴洛克风格的图书馆、庞大的插件生态系统、高耸的框架，到一个非常深的层次，是领域专家的职责。我尊重他们在&#39；我们很擅长，但这不是我的工作方式</p><p> the way I see it, to be really good, you don&#39;t need to study any particular big thing.you need to practice and understand the small things, over and over, until they&#39;re second nature.a 100ms lag time on an interface is the limit below which response will feel instantaneous.you want to be able to work that fast with the absolute basics.fast enough that you don&#39;t have to think about them at all</p><p>在我看来，要做到真正的好，你不&#39；我不需要研究任何特别的大事。你需要反复练习和理解小事情，直到它们&#39；你是第二天性。接口上的100毫秒延迟时间是响应瞬间的极限。你希望能够快速掌握基本知识。足够快以至于你不&#39；I don’我根本不必去想它们</p><p> there is a wonderful quote by bruce lee that I love to deploy whenever appropriate:</p><p>李小龙有一句精彩的话，我喜欢在适当的时候引用：</p><p> Before I learned the art, a punch was just a punch, and a kick, just a kick. After I learned the art, a punch was no longer a punch, a kick, no longer a kick. Now that I understand the art, a punch is just a punch and a kick is just a kick.</p><p>在我学会这门艺术之前，一拳只是一拳，一踢，只是一踢。在我学会这门艺术之后，一拳不再是一拳，一踢，不再是一踢。现在我了解了这门艺术，一拳就是一拳，一脚就是一脚。</p><p> before you understand a field, you are mired in sameness.everything is opaque and undifferentiated.as you learn more, you begin to distinguish elements, group them into classes, construct a taxonomy.when you really, deeply understand something, it gets harder to hold to such strict distinctions, but easier to feel.you can discuss and build models, but you hold those models as contingent and insufficient</p><p>在你了解一个领域之前，你就陷入了相同的困境。一切都是不透明的，没有区别的。随着学习的深入，您开始区分元素，将它们分组到类中，构建分类法。当你真正地、深刻地理解某件事时，很难坚持这样严格的区分，但更容易感受到。你可以讨论和构建模型，但你认为这些模型是偶然的，不充分的</p><p> there is something deep in the tension between analysis and synthesis that goes way beyond this topic.I feel like that tension is one of the really important ideas about thought, people, cultures, the world.I can&#39;t really articulate the weight of it properly.it&#39;s just a feeling</p><p>在分析和综合之间的紧张关系中，有一些东西远远超出了这个主题。我觉得这种紧张感是关于思想、人、文化和世界的一个非常重要的想法。我能&#39；I don’我不能准确地表达它的重量。它&#39；这只是一种感觉</p><p> having only holism, you are a rube, a sitting duck.you know not.armed with reason, the ability to categorize, to distinguish and dissect, you are dangerous, a weapon.you think you know, but you still don&#39;t.it is essential to relearn holism with a grounding in reason to be able to move past this, to feel the world without turning what you touch into ash</p><p>只有整体主义，你是一个笨蛋，一只坐着的鸭子。你不知道。有了理性，有了分类、辨别和剖析的能力，你就是危险的武器。你以为你知道，但你还是不知道&#39；t、 有了理性的根基，重新学习整体主义是非常必要的，这样才能超越它，感受这个世界，而不会把你接触到的东西变成灰烬</p><p> there&#39;s a stereotype that a scholar-bureaucrat adheres to confucian doctrine in his working years, then indulges in daoism upon retiring.it is probably true that pushing past petty analysis makes it harder to tolerate bullshit, to be a cog in an ugly system, to accept duty and sacrifice.but it also makes you frighteningly effective at work, for those things you do deem valuable enough to work on</p><p>那里&#39；这是一种刻板印象，一个士大夫在工作期间坚持儒家学说，退休后沉迷于道教。也许是真的，推动过去琐碎的分析会让人更难容忍胡说八道，更难成为丑陋系统中的一个齿轮，更难接受责任和牺牲。但它也会让你在工作中表现出惊人的效率，因为那些你认为有足够价值去做的事情</p><p> that is the higher goal I&#39;m setting here, for this one little field, that itself has remarkably little to say about life.don&#39;t get stuck in the models.see past them.and then you can see, a kick is just a kick</p><p>这是我更高的目标&#39；我把这里设定为一个小小的领域，它本身对生命几乎没有什么可说的。唐&#39；不要被困在模型里。看过去。然后你可以看到，踢就是踢</p><p>    we&#39;ve been talking about variables in terms of placing values into boxes that we access with convenient names.the place where all those boxes reside is called memory</p><p>我们&#39；我一直在谈论变量，把值放入我们用方便的名称访问的框中。所有这些盒子所在的地方叫做内存</p><p> memory has no inherent structure or meaning to it.it is a very long series of one-byte (eight binary bits, max value 255) boxes, numbered starting from 0, all the way up into the billions.all meaning that the sequences of bytes in memory contain is imposed by the programmer, and thus the programs they write and run on top of</p><p>记忆没有固有的结构或意义。它是一个非常长的一个字节（八个二进制位，最大值255）框序列，从0开始编号，一直到数十亿。所有这一切都意味着，内存中包含的字节序列是由程序员强加的，因此，他们编写和运行的程序也是由程序员强加的</p><p> when a program is started, the operating system provides it with the illusion that it is the only program on the machine.its address space starts from the special 0 address—unwritable and used as a standard null value—and nothing else tramples upon its preserve</p><p>当一个程序启动时，操作系统会给它一种错觉，以为它是机器上唯一的程序。它的地址空间从特殊的0地址unwritable开始，用作标准的空值，其他任何东西都不会破坏它的保留</p><p> it needn&#39;t be this way: msdos famously passed full control of all memory to any program, meaning everything ran as root and multitasking didn&#39;t exist.but unix-style virtual memory allows each program to arrange its own memory however it sees fit while protecting other programs and the os from misbehavior.by convention, usually memory has a handful of read-only sections, plus two major writable sections, called stack and heap</p><p>它不需要&#39；不要这样：众所周知，msdos将所有内存的完全控制权传递给任何程序，这意味着所有程序都以root运行，而多任务处理没有&#39；不存在。但是unix风格的虚拟内存允许每个程序按照自己认为合适的方式安排自己的内存，同时保护其他程序和操作系统免受错误行为的影响。按照惯例，内存通常有几个只读部分，外加两个主要的可写部分，称为堆栈和堆</p><p> the stack is a last-in, first-out queue that starts at the last address in memory, and grows downward, toward the lower addresses.every time you call a function, one stack frame is added on top of the stack.a stack frame is a chunk of space where one function&#39;s arguments and internal storage live.when a function returns, its stack frame is disregarded, and the new top of the stack is once again the function that originally called it</p><p>堆栈是一个后进先出队列，从内存中的最后一个地址开始，向下扩展，指向较低的地址。每次调用函数时，都会在堆栈顶部添加一个堆栈帧。堆栈框架是一块空间，其中一个函数&#39；s参数和内部存储都是实时的。当一个函数返回时，它的堆栈帧被忽略，新的堆栈顶部再次是最初调用它的函数</p><p> the heap starts from somewhere after the 0 address and grows up toward higher addresses.it is persistent storage, controlled by the programmer directly, and unrelated to where in the function stack you are.you directly ask the operating system for a chunk of memory of a specific size via the function  malloc:</p><p>堆从0地址之后的某个地方开始，向更高的地址增长。它是持久存储，由程序员直接控制，与函数堆栈中的位置无关。您可以通过函数malloc直接向操作系统请求特定大小的内存块：</p><p>  here, enough space for 16 integers is allocated.each integer is multiple bytes, needed to store numbers larger than 255.our chunk of memory is called a &#34;buffer,&#34; and malloc returns a pointer to its first byte</p><p>在这里，为16个整数分配了足够的空间。每个整数是多个字节，需要存储大于255的数字。我们的记忆块被称为a&#34；缓冲区和#34；malloc返回指向其第一个字节的指针</p><p> unless released, our buffer will persist for the entire life of the program.when we&#39;re done with it, we tell the operating system, so it can recycle the space back into the pool it allocates memory from:</p><p>除非被释放，我们的缓冲区将在程序的整个生命周期中持续存在。当我们&#39；我们告诉操作系统，这样它就可以将空间回收到分配内存的池中：</p><p>  the reason why stack and heap grow in opposite directions (towards each other) is so programs have use of all memory available to them if they need to allocate much more on one than the other</p><p>堆栈和堆以相反的方向（相互）增长的原因是，如果程序需要在其中一个上分配比另一个多得多的内存，那么它们就可以使用所有可用的内存</p><p>    as we&#39;ve seen, every location in memory has an address, and the named boxes we&#39;ve been storing data in are really just pieces of memory.we can take any of our boxes and get the address its storage starts at as a value we can then store somewhere else:</p><p>正如我们&#39；我们已经看到，内存中的每个位置都有一个地址，我们命名的框&#39；我一直在把数据存储在内存中。我们可以取下任何一个盒子，将其存储起始地址作为一个值，然后存储到其他地方：</p><p>  the asterisk in the type of  p indicates that this variable stores a pointer, ie a memory address.the ampersand is the address-of operator, returning the address of the storage used by a variable</p><p>p类型中的星号表示该变量存储指针，即内存地址。符号AND是运算符的地址，返回变量使用的存储器的地址</p><p> the address can then be dereferenced, ie the pointer can be followed and the value at the address it points to retrieved:</p><p>然后可以取消对地址的引用，即可以跟随指针，并检索其指向的地址处的值：</p><p>  the function  malloc returns the type  void *, that is, a pointer that could point to anything.traversing pointers to use or manipulate values stored at their address is often called &#34;indirection&#34; because it is an indirect mechanism of data access</p><p>函数malloc返回void*类型，即可以指向任何对象的指针。遍历指针以使用或操作存储在其地址的值通常称为&#34；间接&#34；因为这是一种间接的数据访问机制</p><p> pointers can nest arbitrarily deep.you can have pointers to pointers, and so on, forming large, abstract graphs.the don&#39;t truly &#34;nest.&#34;fundamentally pointers are just numbers, stored in memory, like large integers.it&#39;s only because they&#39;re interpreted as memory addresses that they have any meaning</p><p>指针可以嵌套任意深度。可以有指向指针的指针，等等，形成大型抽象图形。唐&#39；t真的&#34；巢穴&#34;从根本上说，指针只是存储在内存中的数字，就像大整数一样。它&#39；这只是因为他们&#39；重新解释为具有任何意义的内存地址</p><p> because strings in c are just continuous series of characters, a collection of strings may be represented by the double pointer  char **.it&#39;s useful to use double pointers to resizable containers so functions can reallocate storage implicitly when needed without breaking references.complex objects are typically represented by structures that point to structures which themselves point to structures.and so on</p><p>因为c中的字符串只是连续的字符序列，所以字符串集合可以用双指针字符**表示。它&#39；使用双指针来调整容器大小很有用，这样函数就可以在需要时隐式地重新分配存储，而不会中断引用。复杂对象通常由指向结构的结构表示，而结构本身指向结构。等等</p><p> recursion is the idea of a function calling itself, effecting sequential repeated execution in a manner not unlike a loop.the classic examples of this are the factorial and fibonacci functions, where any result depends on all previous results of the same calculation.this allows them to be expressed succinctly and naturally (albeit often horrifically inefficiently) via recursion:</p><p>与顺序执行不同的是，循环本身并不是以递归的方式实现的。这方面的经典例子是阶乘和斐波那契函数，其中任何结果都取决于相同计算的所有先前结果。这使得它们可以通过递归简洁自然地表达（尽管通常效率很低）：</p><p> int factorial(int n) { if(n == 0) { return 1; } else { return n * factorial(n - 1); }}</p><p>因式阶乘（因式n）{if（n==0）{return 1；}else{return n*阶乘（n-1）；}</p><p> here, if you were to call  factorial(5), the function would fall into the  else branch, and attempt to calculate  5 * factorial(4).this would necessitate another call into the function, and another, until hitting the &#34;base case&#34; of  n == 0.then a series of returns effectively unwind all the function calls made thus far, producing the result 120</p><p>在这里，如果调用factorial（5），函数将落入else分支，并尝试计算5*factorial（4）。这需要对函数进行另一次调用，再调用一次，直到达到&#34；基本情况&#34；n=0。然后，一系列的返回有效地解除了迄今为止所进行的所有函数调用，从而产生结果120</p><p> clever use of recursion allows you to iterate in much more complex ways than a simple loop.it is much easier, for instance, to continuously subdivide a group to perform some task on the subsets with recursion than with looping.various means of sorting collections, or searching for items in complicated nested hierarchies, are naturally suited to being subdivided or accumulated in this manner</p><p>巧妙地使用递归可以让你以比简单循环更复杂的方式进行迭代。例如，使用递归比使用循环更容易连续地细分一个组以在子集上执行某些任务。对集合进行排序或在复杂的嵌套层次结构中搜索项的各种方法自然适合以这种方式进行细分或累积</p><p> things get even more interesting in a language with first-class functions.that is, functions that can be assigned to variables, passed as values, and constructed at runtime (crucially, capturing the environments in which they are constructed).c has the first two properties but not the third.moreover, its syntax for function pointers is notoriously cumbersome, and the language is just not suited for this kind of programming.javascript, being at its core the worst dialect of scheme, has all the necessary features</p><p>在一种具有一流函数的语言中，事情变得更加有趣。也就是说，可以分配给变量、作为值传递并在运行时构造的函数（关键是，捕获构造它们的环境）。c有前两个属性，但没有第三个。此外，它的函数指针语法是出了名的麻烦，而且这种语言不适合这种编程。javascript的核心是最糟糕的scheme方言，它具有所有必要的特性</p><p> in a language with first-class functions, you can easily construct functi</p><p>在一种具有一流函数的语言中，您可以轻松地构造functi</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/想到/">#想到</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/存储/">#存储</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>