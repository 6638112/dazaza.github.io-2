<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Windows Linux子系统：失去的潜力Windows Subsystem for Linux: The lost potential</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Windows Subsystem for Linux: The lost potential<br/>Windows Linux子系统：失去的潜力</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-21 12:06:41</div><div class="page_narrow text-break page_content"><p>If you have followed Windows 10 at all during the last few years, you know that the  Windows Subsystem for Linux, or  WSL for short, is  the hot topic among developers. You can finally run your Linux tooling on Windows as a first class citizen, which means you no longer have to learn PowerShell or, god forbid, suffer through the ancient  CMD.EXE console.</p><p>如果您在过去几年中完全遵循Windows 10，您就会知道Linux的Windows子系统（简称WSL）是开发人员中的热门话题。您最终可以在Windows上以一流的公民身份运行Linux工具，这意味着您不再需要学习PowerShell或天生就不能通过古老的CMD.EXE控制台受苦。</p><p> Unfortunately, not everything is as rosy as it sounds. I now have to do development  on Windows  for Windows as part of my new role within Azure… and the fact that WSL continues to be separate from the native Windows environment shows. Even though I was quite hopeful, I cannot use WSL as my daily driver because I need to interact with “native” Windows tooling.</p><p>不幸的是，并非所有事情都像听起来那样乐观。我现在必须在Windows for Windows上进行开发，这是我在Azure中担任新角色的一部分……而WSL仍与本机Windows环境继续保持独立这一事实表明。即使我满怀希望，我也不能将WSL用作日常驱动程序，因为我需要与“本地” Windows工具进行交互。</p><p> I believe things needn’t be this way, but with the recent push for WSL 2, I think that the potential of an alternate world is now gone. But what do I mean with this? For that, we must first understand the differences between WSL 1 and WSL 2 and how the push for WSL 2 may shut some interesting paths.</p><p>我相信事情并不一定要这样，但是随着最近对WSL 2的推动，我认为替代世界的潜力已经消失了。但是，这是什么意思呢？为此，我们必须首先了解WSL 1和WSL 2之间的区别以及对WSL 2的推动如何关闭一些有趣的路径。</p><p> DISCLAIMER: I have zero insight on what’s going on within the WSL team or what their future plans are. This is purely my personal opinion based on what I have experienced as a user.</p><p>免责声明：我对WSL团队内部的情况或他们的未来计划没有任何见解。这纯粹是基于我作为用户所经历的个人观点。</p><p>  Let’s first take a look at WSL 1, and for that, we must look at what’s in the awkward name. Why was this feature named Windows subsystem…  for Linux? Isn’t that backwards? This is not a subsystem in Linux to do anything Windows-related; it’s the other way around!</p><p>首先让我们看一下WSL 1，为此，我们必须看一下尴尬名称中的含义。为什么将此功能命名为Windows子系统…for Linux？那不是倒退吗？这不是Linux中的子系统，它不能执行与Windows相关的任何事情；反过来！</p><p> Well… you see, the name is technically correct when considering the design of the Windows NT kernel. From the  Architecture of Windows NT page in the Wikipedia, we find (emphasis mine):</p><p>好吧……您会发现，在考虑Windows NT内核的设计时，该名称在技术上是正确的。从Wikipedia的Windows NT体系结构页面中，我们发现（重点是我）：</p><p> User mode in Windows NT is made of subsystems capable of passing I/O requests to the appropriate kernel mode device drivers by using the I/O manager.  The user mode layer of Windows NT is made up of the “Environment subsystems”, which run applications written for many different types of operating systems, and the “Integral subsystem”, which operates system-specific functions on behalf of environment subsystems. The kernel mode stops user mode services and applications from accessing critical areas of the operating system that they should not have access to.</p><p>Windows NT中的用户模式由子系统组成，这些子系统能够使用I / O管理器将I / O请求传递到适当的内核模式设备驱动程序。 Windows NT的用户模式层由运行用于许多不同类型操作系统的应用程序的“环境子系统”和代表环境子系统运行系统特定功能的“集成子系统”组成。内核模式使用户模式服务和应用程序无法访问它们不应访问的操作系统的关键区域。</p><p> Windows NT was designed from the ground up to support running processes from a multitude of operating systems, and Win32 was “just” one of those environment subsystems. With these solid foundations, WSL 1 supplies a new environment subsystem, the Linux subsystem, to run Linux binaries atop the Windows NT kernel. Both the Win32 and Linux environment subsystems share the common integral subsystem.</p><p>Windows NT是从头设计的，旨在支持多种操作系统中正在运行的进程，而Win32“只是”这些环境子系统之一。在这些坚实的基础上，WSL 1提供了一个新的环境子系统Linux子系统，以在Windows NT内核之上运行Linux二进制文件。 Win32和Linux环境子系统都共享公共的集成子系统。</p><p>  Different system call “front-ends”—that’s what it means. A user-space process is a collection of binary instructions that the processor executes uninterruptedly (leaving interrupts aside). The operating system’s kernel is unaware of what the process is doing until the process issues a system call: at that point, the kernel regains control to perform an operation on behalf of the user, which can be something like reading a file or pausing for a few seconds.</p><p>这就是不同的系统调用“前端”。用户空间进程是处理器不间断执行（保留中断的地方）的二进制指令的集合。直到进程发出系统调用之前，操作系统的内核才知道进程在做什么：此时，内核重新获得控制权以代表用户执行操作，这可能类似于读取文件或暂停操作。几秒钟。</p><p> The way a process issues system calls, and the semantics of those system calls, are specific to the operating system. For example, on old x86: opening a file on Win32 is system call number  17h invoked via  INT 2Eh whereas opening a file on Linux is system call number  5h invoked via  INT 80h.</p><p>进程发出系统调用的方式以及这些系统调用的语义特定于操作系统。例如，在旧的x86上：在Win32上打开文件是通过INT 2Eh调用的系统调用号17h，而在Linux上打开文件是通过INT 80h调用的系统调用号5h。</p><p> But… conceptually, opening a file is opening a file, right? The fact that the system call numbers or the software interrupt numbers are different among them is not particularly interesting. And hereby lies the key design aspect of WSL 1: the Linux subsystem in the NT kernel is, simply put, an implementation of Linux’s system call layer in front of the NT kernel. These system calls later delegate to NT primitives,  not Win32 calls. Which is important to repeat: there is no translation from Linux to Win32 system calls.</p><p>但是...从概念上讲，打开文件就是打开文件，对吗？它们之间系统调用号或软件中断号不同的事实并不是特别有趣。这就是WSL 1的关键设计方面：简单地说，NT内核中的Linux子系统是在NT内核前面的Linux系统调用层的实现。这些系统调用以后将委托给NT原语，而不是Win32调用。重复这一点很重要：没有从Linux到Win32系统调用的转换。</p><p> This is a feat of engineering considering how generally good support for Linux apps got to be under WSL 1 and the many ways in which NT internally differs from Unix,  fork+exec being the eternal archenemy.</p><p>考虑到在WSL 1下一般如何对Linux应用程序提供良好的支持以及NT在内部与Unix之间有很多不同，在很多方面，这是一项工程技术壮举，其中fork + exec是永恒的敌人。</p><p> The true beauty of this design is that there is a single kernel running on the machine, and this kernel has a holistic view of all the processes beneath it. The kernel knows everything about the Win32  and Linux processes. And these processes all interact with unified resources, such a single networking stack, a single memory manager, and a single process scheduler.</p><p>该设计的真正优点在于，机器上运行的是单个内核，并且该内核具有其下所有进程的整体视图。内核了解有关Win32和Linux进程的所有信息。这些进程都与统一资源进行交互，例如单个网络堆栈，单个内存管理器和单个进程调度程序。</p><p>   WSL 1 has to, essentially, implement all of Linux’s kernel ABI, “bit by bit”. If there is a bug in that interface, the WSL 1 has to replicate it. And if there is a feature that is difficult to represent within the NT kernel, either the feature cannot be implemented or it needs extra kernel logic (and thus becomes slower).</p><p>本质上，WSL 1必须“逐位”实现Linux的所有内核ABI。如果该接口中存在错误，则WSL 1必须对其进行复制。而且，如果某个功能很难在NT内核中表示，则该功能将无法实现，或者需要额外的内核逻辑（因此会变慢）。</p><p> Linux subsystem in WSL 1 has to abide by any “limitations” and inherent differences that exist between the NT kernel and the traditional Unix design. The most obvious one is the NTFS file system and its semantics, and how these differences harm performance of Linux binaries. Poor file system performance seems to be a common complaint in WSL 1.</p><p>WSL 1中的Linux子系统必须遵守NT内核与传统Unix设计之间存在的任何“限制”和固有差异。最明显的一个是NTFS文件系统及其语义，以及这些差异如何损害Linux二进制文件的性能。文件系统性能差似乎是WSL 1中的常见抱怨。</p><p> WSL 2 “throws away” all of the Linux subsystem parts of the name and replaces everything with a full-blown (but very well-hidden and fast) virtual machine. The virtual machine then runs a proper Linux kernel, a proper Linux file system, and a proper Linux networking stack within it.</p><p>WSL 2“丢弃”了该名称的所有Linux子系统部分，并用功能完善（但功能齐全且快速运行）的虚拟机替换了所有内容。然后，虚拟机将在其中运行适当的Linux内核，适当的Linux文件系统和适当的Linux网络堆栈。</p><p> What this means is that the beauty of the WSL 1 design is gone: the Windows NT kernel doesn’t get to see anything that happens within the Linux world any more. All it knows is that there is a big black box that does “stuff” inside, and all it gets to see are the  VMENTER and  VMEXIT hook points for virtual machines and block-level read/write requests on a virtual disk. The NT kernel is now unaware of Linux processes and file accesses. Similarly, the Linux kernel is unaware of anything in NT land.</p><p>这意味着WSL 1设计的美已消失：Windows NT内核不再能看到Linux世界中发生的任何事情。它所知道的是，内部有一个大的黑匣子在其中进行“填充”，并且看到的只是虚拟机的VMENTER和VMEXIT挂钩点以及虚拟磁盘上的块级读/写请求。 NT内核现在不知道Linux进程和文件访问。同样，Linux内核不了解NT领域中的任何内容。</p><p>   From the user’s point of view, WSL 2 feels strictly better: Linux apps now run much, much faster because they are not subject to awkward Linux system call “emulation” within the NT kernel. If using NTFS with Linux semantics is difficult, that’s no problem because the Linux environment now uses ext4 on a virtual disk. And support for Linux apps can be much more complete, because, well, WSL 2  is Linux: if you want FUSE, to name something, you got it.</p><p>从用户的角度来看，WSL 2感觉更好：Linux应用程序现在运行得快得多，因为它们不受NT内核中笨拙的Linux系统调用的“模拟”。如果很难将NTFS与Linux语义结合使用，那没有问题，因为Linux环境现在在虚拟磁盘上使用ext4。而且对Linux应用程序的支持可以更加完善，因为WSL 2是Linux：如果您想用FUSE命名，就可以了。</p><p>  Can you imagine how cool it would be if you could type  ps or  top within a WSL session and see Linux  and Windows processes side-by-side, able to mutate their state with  kill?</p><p>您能想象如果您可以在WSL会话中键入ps或top并看到Linux和Windows进程并排运行，并能够通过kill改变它们的状态时，会有多酷？</p><p> Can you imagine how cool it would be to manipulate Windows services from the WSL session?</p><p>您能想象从WSL会话操纵Windows服务会有多酷吗？</p><p> Can you imagine how cool it would be if you could use  ifconfig (wait, is that  ip? 🙄) within a WSL session to inspect and modify the machine’s network interfaces?</p><p>您能想象如果您可以在WSL会话中使用ifconfig（等待，是ip吗？）来检查和修改计算机的网络接口，会有多酷？</p><p> Essentially, can you imagine doing all of your Windows system administration tasks from within WSL?</p><p>本质上，您是否可以想象在WSL中执行所有Windows系统管理任务？</p><p> Although this never existed, I can well imagine such a world… and it’s one that  only the WSL 1 design can provide. And the reason I can imagine this is because macOS gives you this model (albeit cheating because macOS is essentially Unix).</p><p>尽管这从未存在过，但我可以想象得到这样一个世界……而这是只有WSL 1设计才能提供的世界。我可以想象的原因是macOS提供了这种模型（尽管作弊是因为macOS本质上是Unix）。</p><p> Which is what brings me to my frustration: even though I could install WSL on my development machine for Azure, there is nothing I can use it for. I still have to interact with the system via  CMD.EXE because I have to deal with Windows-native processes and resources, and because the tooling I have to deal with is Windows-only.</p><p>这就是让我感到沮丧的原因：即使我可以在用于Azure的开发计算机上安装WSL，也无法使用它。我仍然必须通过CMD.EXE与系统进行交互，因为我必须处理Windows本地进程和资源，并且因为我必须处理的工具仅适用于Windows。</p><p> The FAQ for WSL 2 claims that  WSL 1 will not be abandoned, and if we abide by Microsoft’s backwards-compatibility guarantee, that may be true. But keeping WSL 1 running is a monumental effort due to the need to keep up with Linux changes. Regardless, I hope that this is the case and that WSL 1 continues to exist. Who knows, maybe the reason WSL 1 stays behind is to pursue this magical world I’m describing? 🤔</p><p>WSL 2的FAQ声称不会放弃WSL 1，如果我们遵守Microsoft的向后兼容性保证，那可能是正确的。但是由于需要跟上Linux的变化，保持WSL 1的运行是一项艰巨的工作。无论如何，我希望情况确实如此，WSL 1继续存在。谁知道，也许WSL 1落后的原因是追求我所描述的这个神奇的世界？ 🤔</p><p>  I can’t finish this post without talking about the various BSDs. The BSDs, always trailing behind Linux and other commercial operating systems, have had binary-level compatibility for ages. The earliest I can find is Linux compatibility in the NetBSD kernel back in 1995. That’s 25 years ago, and 21 before WSL 1’s first debut.</p><p>我不能不谈各种BSD而结束这篇文章。一直落后于Linux和其他商业操作系统的BSD已有二进制级别的兼容性。我最早能找到的是1995年NetBSD内核中的Linux兼容性。那是25年前，而WSL 1首次亮相之前有21年。</p><p> And, heck, this isn’t limited to Linux. NetBSD has had support to emulate  various different operating systems throughout the years. SVR4 support appeared in 1994 and, for a brief stint,  NetBSD even had support for… 🥁… PE/COFF binaries—that’s right, Win32 binaries. So, in a way, NetBSD implemented the WSL 1 model in reverse: it let you run Win32 binaries atop the NetBSD kernel back in 2002.</p><p>而且，这不仅限于Linux。多年来，NetBSD一直支持模拟各种不同的操作系统。对SVR4的支持始于1994年，并且暂时来说，NetBSD甚至还支持……PE / COFF二进制文件—正确的是Win32二进制文件。因此，在某种程度上，NetBSD反向实现了WSL 1模型：它使您可以在2002年在NetBSD内核之上运行Win32二进制文件。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://jmmv.dev/2020/11/wsl-lost-potential.html">https://jmmv.dev/2020/11/wsl-lost-potential.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/subsystem/">#subsystem</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/wsl/">#wsl</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>