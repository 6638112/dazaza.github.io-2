<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>通过多线程优化Lambda成本 Optimizing Lambda Cost with Multi-Threading</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Optimizing Lambda Cost with Multi-Threading<br/>通过多线程优化Lambda成本 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-14 22:26:58</div><div class="page_narrow text-break page_content"><p>Amazon has released support for up to 10 GB memory and 6 vCPUs for your Lambda functions. In this article we will explore how these new memory configuration options can drive down costs and execution times for compatible workloads.</p><p>亚马逊已经为您的Lambda功能发布了对10 GB内存和6个vCPU的支持。在本文中，我们将探讨这些新的内存配置选项如何降低兼容工作负载的成本和执行时间。</p><p> Let’s quickly review the Lambda pricing scheme. We’ll ignore the free tier. Lambda is billed at $0.0000166667 for every GB-second. A GB-second is the unit of measurement for 1 GB of memory running for 1 second. Lambdas are often very short lived, so let’s say a particular function has an average execution time of 100ms, and is executed 100 times every minute. That’s 10 seconds of execution time per minute, 14.400 seconds per day, and 432.000 seconds per 30 days. This function is configured to use 128 MB or RAM (1/8th of a GB), so you’re billed for 432.000 / 8 = 54.000 GB-seconds per month. At $0.0000166667 per GB-second, this function will cost a whopping $0.90 per month.</p><p> 让我们快速回顾一下Lambda定价方案。我们将忽略免费套餐。 Lambda的每GB每秒收费0.0000166667美元。 GB秒是1 GB内存运行1秒的度量单位。 Lambda通常寿命很短，因此可以说某个特定函数的平均执行时间为100毫秒，每分钟执行100次。这是每分钟10秒的执行时间，每天14.400秒，每30天432.000秒。此功能配置为使用128 MB或RAM（GB的1/8），因此每月需要为432.000 / 8 = 54.000 GB-秒付费。每GB每秒$ 0.0000166667，此功能每月将花费$ 0.90。</p><p> The only tunable performance configuration for Lambda is the amount of memory available to the function. The CPU performance scales with the memory configuration. Lambda functions used to always have 2 vCPU cores, regardless of memory. These cores would be throttled at certain memory configurations. The  documentation states that at 1,769 MB, a function has the equivalent of one vCPU.</p><p> Lambda唯一可调整的性能配置是该功能可用的内存量。 CPU性能随内存配置而扩展。过去，Lambda函数始终具有2个vCPU内核，而与内存无关。这些内核将在某些内存配置下受到限制。该文档指出，一个函数具有1,769 MB的空间，相当于一个vCPU。</p><p> With the increased maximum memory of 10GB, up from 3008 MB ( AWS News -  AWS Blog), the number of CPUs has become more flexible. We ran some tests and found out that Lambda now has the following CPU tiers:</p><p> 随着最大内存从3008 MB增加到10GB（AWS新闻-AWS Blog），CPU的数量变得更加灵活。我们进行了一些测试，发现Lambda现在具有以下CPU层：</p><p>  This opens up a number of new price tuning options. If a workload supports multi-threading, for example, we can try to optimize the number of vCPUs to reduce execution time. A multi-threading function configured at 3009 MB might execute 1.5x as fast as a 3008 MB function, a 33.3% cost reduction! Let’s see if we can produce these results in real life benchmarks.</p><p>  这打开了许多新的价格调整选项。例如，如果工作负载支持多线程，我们可以尝试优化vCPU的数量以减少执行时间。配置为3009 MB的多线程功能执行速度可能是3008 MB功能的1.5倍，成本降低了33.3％！让我们看看是否可以在现实生活的基准测试中得出这些结果。</p><p>  To test Lambda’s performance we compiled  ffmpeg from source and packaged it together with a 100 MB sample video and a simple Python app. Because this package exceeds the maximum size for Lambda deployment packages, we used the new Lambda Container Image Support ( AWS News -  AWS Blog) to put  ffmpeg and the video together in a container and create a Lambda function from that container. Our performance benchmark will consist of 100 iterations of a video format conversion. The exact command for our initial run of benchmarks is  ffmpeg -i source.mkv -c:v libx264 -b:a 128k -threads 1 -y /tmp/target.mp4</p><p>  为了测试Lambda的性能，我们从源代码中编译了ffmpeg并将其与100 MB示例视频和一个简单的Python应用程序打包在一起。由于此软件包超出了Lambda部署软件包的最大大小，因此我们使用了新的Lambda容器映像支持（AWS News-AWS Blog）将ffmpeg和视频放到一个容器中，并从该容器创建Lambda函数。我们的性能基准将包括视频格式转换的100次迭代。最初运行基准测试的确切命令是ffmpeg -i source.mkv -c：v libx264 -b：a 128k -threads 1 -y /tmp/target.mp4</p><p> As you can see, this command is hardcoded to use only one thread. This allows us to set a single-threaded baseline on various memory configurations. We ran 100 iterations on the key memory sizes in the table below. The values chosen are the top and bottom values for every CPU tier. 832 MB was the minimum required to successfully convert the video within 15 minutes.</p><p> 如您所见，此命令被硬编码为仅使用一个线程。这使我们可以在各种内存配置上设置单线程基准。下表对关键内存大小进行了100次迭代。选择的值是每个CPU层的最高和最低值。要在15分钟内成功转换视频，最少需要832 MB。 </p><p>    This data clearly shows that any memory configuration above 3008 MB does not improve single thread performance. Memory configurations up to 1769 MB are throttled, from 1769 MB to 3008 MB there are some minor performance increases, and from 3008 MB and up you’re using the full capacity of a single core, which means the average execution time plateaus. At the same time the costs for higher memory configurations are skyrocketing. Clearly, if you’re running single-threaded processes in Lambda you would do well to fit your Lambda’s memory closely to your function’s actual requirements.</p><p>此数据清楚地表明，任何高于3008 MB的内存配置都不会提高单线程性能。内存配置最多可节流1769 MB，从1769 MB增加到3008 MB，性能会有一些小幅提高，从3008 MB起，您将使用单个内核的全部容量，这意味着平均执行时间稳定。同时，更高内存配置的成本飞涨。显然，如果您在Lambda中运行单线程进程，则最好使Lambda的内存紧靠函数的实际需求。</p><p>  For our multi-threaded tests, we obtain the number of CPUs from  /proc/cpuinfo and configure  ffmpeg to use as many threads as there are cores. Let’s take a look at the results.</p><p>  对于我们的多线程测试，我们从/ proc / cpuinfo获取CPU数量，并将ffmpeg配置为使用与内核一样多的线程。让我们看一下结果。</p><p>   What jumps out immediately is that at 832 MB using two threads is actually slower than the single-threaded benchmark. This likely relates to the CPU throttling applied to Lambda functions below 1769 MB: two threads competing for the same limited resources are slower than a single thread having those resources to itself.</p><p>   立即跳出来的是，使用两个线程的832 MB内存实际上比单线程基准测试慢。这可能与应用于1769 MB以下的Lambda函数的CPU节流有关：争夺相同有限资源的两个线程比拥有这些资源本身的单个线程慢。</p><p> At 1769 MB the multi-threaded measurement is almost exactly equal to the single-threaded result. This makes sense, since the documentation states that at 1769 MB, a function has the equivalent of one vCPU. At this level contestation is apparently no longer an issue.</p><p> 在1769 MB时，多线程测量几乎完全等于单线程结果。这是有道理的，因为文档指出该功能为1769 MB，相当于一个vCPU。在这个级别上，竞争显然不再是问题。</p><p> At 3008 MB, the old maximum memory configuration, we start to benefit from using multiple cores. But it starts to get interesting at exactly 1 MB higher, at 3009 MB. This is the first time we get to use more than two cores, and we would expect an immediate performance bump. However, the results at three cores and 3009 MB are only 1.73% better than at two cores and 3008 MB. Apparently, the three cores at 3009 MB do not offer 1.5x the performance of the two cores at 3008 MB, and some throttling is taking place. This is corroborated by the benchmark at 5307 MB: even though this configuration has the same amount of cores, its performance is 28.96% higher than at 3009 MB. This means that AWS is dynamically limiting the amount of processing power available to the function, based on its memory configuration.</p><p> 在3008 MB（旧的最大内存配置）下，我们开始受益于使用多核。但恰好高出1 MB，即3009 MB，它开始变得很有趣。这是我们第一次使用两个以上的内核，并且我们期望性能会立即提高。但是，在三个内核和3009 MB的结果仅比在两个内核和3008 MB的结果好1.73％。显然，3009 MB的三个内核无法提供3008 MB的两个内核的1.5倍性能，并且正在出现一些节流。基准5307 MB证实了这一点：即使此配置具有相同数量的内核，其性能也比3009 MB时高28.96％。这意味着AWS正在根据其内存配置动态限制该功能可用的处理能力。</p><p> Next, at 5308 MB, we have our first four-core benchmark. Here we see that the fourth core adds a significant improvement. Although we added only 0.0188% of memory, performance jumped by 10.65%. The other four-core measurement at 7076 MB yields further improvements, but not enough to offset the additional cost.</p><p> 接下来，以5308 MB的带宽，我们有了第一个四核基准测试。在这里，我们看到第四个核心增加了重大改进。尽管我们仅添加了0.0188％的内存，但性能却提高了10.65％。其他的四核测量为7076 MB，可以带来进一步的改进，但不足以抵消额外的成本。</p><p> Then at 7077 MB, the first five-core benchmark, we see another BIG jump. Again, we only added a single MB of memory, but the fifth core increased performance by an incredible 26.56%. Increasing memory to 8845 MB adds another improvement of 8.64%, but like in the four-core block, this doesn’t offset the additional cost.</p><p> 然后，在第一个五核基准测试7077 MB处，我们看到了另一个大跃进。同样，我们只添加了一个MB的内存，但是第五个核心将性能提高了令人难以置信的26.56％。将内存增加到8845 MB可以再提高8.64％，但是就像在四核模块中一样，这不能抵消额外的费用。 </p><p> At 8846 MB the additional MB and 6th core yields a 5.52% performance boost, and the maximum configuration of 10240 MB is 2.87% faster than the 8846 MB setting.</p><p>在8846 MB处，额外的MB和第6个内核可提高5.52％的性能，而10240 MB的最大配置比8846 MB设置快2.87％。</p><p>  The single-threaded benchmarks showed that a single core maxes out at relatively low memory configurations. The same logic doesn’t apply to multi-threaded solutions: every tier increased multi-threaded performance. Adding an additional core sometimes adds a big performance gain, and sometimes it hardly adds value.</p><p>  单线程基准测试表明，单个内核在相对较低的内存配置下会达到最大值。相同的逻辑不适用于多线程解决方案：每一层都提高了多线程性能。添加额外的内核有时可以大大提高性能，有时很难增加价值。</p><p> This leads me to conclude that AWS applies a sort of dynamic capacity ceiling to Lambda functions. For example, this ceiling might be set at 0.5 at 832 MB, which means you can at max use half a core. It’s set to 1.0 at 1769 MB, which means we can use one full core. At 3008 it seems to be set to 1.6667. A full list of ceiling values can be found in the table below:</p><p> 这使我得出结论，AWS对Lambda函数应用了一种动态容量上限。例如，此上限可能设置为832 MB处的0.5，这意味着您最多可以使用半个核心。设置为1.0时为1769 MB，这意味着我们可以使用一个完整的内核。在3008，它似乎设置为1.6667。最大值的完整列表可以在下表中找到：</p><p>  This explains how single-threaded functions can completely utilize a single core, but multi-threaded applications can’t do the same on multiple cores.</p><p>  这说明了单线程函数如何完全利用单个内核，但是多线程应用程序不能在多个内核上执行相同的操作。</p><p> Please note that these values are for my specific video conversion benchmark. This benchmark might not be able to max out all the cores available to it. Other benchmarks might be able to use multiple cores more efficiently and produce different results.</p><p> 请注意，这些值适用于我的特定视频转换基准。该基准可能无法使所有可用内核最大化。其他基准可能能够更有效地使用多个内核并产生不同的结果。</p><p> The core take-away is that this benchmark has run exactly the same process under different memory configurations, and consistently produces better results for higher memory configurations in the same CPU tier.</p><p> 核心要点是，该基准测试在不同的内存配置下运行完全相同的过程，并且对于同一CPU层中的更高内存配置始终如一地产生更好的结果。</p><p> The second finding is that adding an additional core always yields a performance benefit for multi-threaded processes. Some cores (the third and sixth) provide smaller benefits than others (the fourth and fifth). If your function is configured just below one of these thresholds, slightly increasing the value might result in big gains.</p><p> 第二个发现是，添加额外的内核始终会为多线程进程带来性能优势。一些核心（第三个和第六个）提供的收益要小于其他一些核心（第四个和第五个）。如果将功能配置为低于这些阈值之一，则稍微增加该值可能会带来很大收益。 </p><p>  Multi-threaded Lambda functions complete faster at higher memory settings, leading to lower costs. In general, the lower execution time offsets a big chunk of the higher memory costs. This is especially visible at 1769, 3009 and 7077 MB: the first configuration costs $1.1602 for 100 executions. The second configuration completes its operation 41.05% faster, at a 0.28% price increase ($1.1635). The 7077 MB setting completes 74.11% faster than the 1769 MB variant, at a 3.57% price increase ($1.2016).</p><p>在更高的内存设置下，多线程Lambda函数可以更快地完成，从而降低了成本。通常，较低的执行时间可以抵消较高的内存成本中的很大一部分。这在1769、3009和7077 MB上尤其明显：第一个配置的100次执行费用为$ 1.1602。第二种配置的运行速度提高了41.05％，价格上涨了0.28％（1.1635美元）。 7077 MB设置比1769 MB变体完成74.11％的速度，价格增加3.57％（$ 1.2016）。</p><p> Deciding which price point is best for your workload depends on your requirements: if it’s purely cost-driven, 1769 MB or 3009 MB might be a good starting point. If it’s performance driven, do run some tests at 5308, 7077 and 8846 MB. These memory configurations might perform significantly better at a marginally higher cost.</p><p> 确定哪个价格点最适合您的工作负载取决于您的要求：如果纯粹出于成本考虑，则最好使用1769 MB或3009 MB。如果是性能驱动的，请以5308、7077和8846 MB运行一些测试。这些内存配置可能会以稍高的成本获得更好的性能。</p><p>  You might have hoped that the new high-memory Lambda functions would also improve single-threaded performance, but alas - the functions seem to run on exactly the same hardware as their lowly 3008 MB siblings. However, the higher Lambda tiers do include three, four, five and six CPU cores. In multi-threaded processes, a single MB difference in your memory configuration might have a big impact on your function’s execution time. This complicates finding the ideal price point - it’s no longer simply a case of matching the memory configuration to your function’s memory needs. However, investing some time in trying out different values might lead to big savings.</p><p>  您可能希望新的高内存Lambda函数也可以提高单线程性能，但是可惜-这些函数似乎在与其最低的3008 MB兄弟姐妹相同的硬件上运行。但是，较高的Lambda层确实包含三个，四个，五个和六个CPU内核。在多线程进程中，内存配置的单个MB差异可能会对函数的执行时间产生重大影响。这使找到理想的价格变得复杂，而不仅仅是将内存配置与您的功能的内存需求相匹配的情况。但是，花一些时间尝试不同的价值可能会节省大量资金。</p><p> Additionally you might be able to achieve big gains in performance and cost if you’re able to rewrite your single-threaded Lambdas to use multiple threads.</p><p> 此外，如果您能够重写单线程Lambda以使用多个线程，则可能会在性能和成本上取得重大收益。</p><p> This article is part of a series published around re:Invent 2020. If you would like to read more about re:Invent 2020, check out my other posts:</p><p> 本文是围绕re：Invent 2020发布的系列文章的一部分。如果您想了解有关re：Invent 2020的更多信息，请查看我的其他文章：</p><p>  I share posts like these and smaller news articles on  Twitter, follow me there for regular updates! If you have questions or remarks, or would just like to get in touch, you can also find me on  LinkedIn.</p><p>  我在Twitter上分享此类帖子和较小的新闻文章，请在此处关注我进行定期更新！如果您有任何疑问或评论，或者想与您取得联系，也可以在LinkedIn上找到我。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.sentiatechblog.com/aws-re-invent-2020-day-3-optimizing-lambda-cost-with-multi-threading">https://www.sentiatechblog.com/aws-re-invent-2020-day-3-optimizing-lambda-cost-with-multi-threading</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/线程/">#线程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/lambda/">#lambda</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/mb/">#mb</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>