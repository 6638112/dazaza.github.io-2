<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>API版本控制没有“正确的方式” API Versioning Has No “Right Way”</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">API Versioning Has No “Right Way”<br/>API版本控制没有“正确的方式” </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-24 09:02:10</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/9423ad6b0711fb3b134e582f7590f7b8.png"><img src="http://img2.diglog.com/img/2021/4/9423ad6b0711fb3b134e582f7590f7b8.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>API versioning is a really difficult topic, and sometimes seen as a merelyreligious debate. It’s done differently at different companies, and differentteams within different companies often vary.</p><p>API版本控制是一个非常困难的主题，有时被视为一个卑微的辩论。它在不同的公司中的不同方式，不同公司内的不同偏见通常会有所不同。</p><p> Some folks move from approach A to approach B, and when approach B solves theirspecific issues they act like approach B is &#34;best&#34; and nobody should ever useapproach A. That’s all well and good until they realize approach C might be agood idea.</p><p> 有些人从方法A移动到接近B，当方法B解决他们的特殊问题时，他们表现得像是喜欢B是＆＃34;最好的＆＃34;没有人应该是USEAPPROAP A.这一切都很好，直到他们实现方法C可能是Agood的想法。</p><p> There are so many approaches to versioning that it can be hard to talkabout — let alone understand — them all, but I’m going to attempt to create adefinitive guide.</p><p> 版本传感器有很多方法，它可能很难进行Talkabout  - 更不用说理解 - 他们所有人，但我将尝试创建一个adefinigitive指南。</p><p> At work I am tasked with recommending one approach to API versioning, becauseright now we have a mixture of approaches, and we’re using a few subtle variantsof the worst possible approach. My recommendations and research are beingconverted to a guide for all of y’all.</p><p> 在工作中，我是任务的推荐一个方法到API版本控制，因为现在我们有一个方法的混合方法，我们正在使用最糟糕的可能方法的一些微妙级别。我的建议和研究是对所有你所有人的指南。</p><p>   Usually in the path (e.g.,  /api/v1/companies), this could be a subdomain(e.g.,  api-v2.foo.com/companies). If functionality was required that forcedthe API to change the representation of companies drastically, a new version ofthe entire API would be created, even if users did not change at all.</p><p>   通常在路径中（例如，/ api / v1 / companies），这可能是子域（例如，API-v2.foo.com/companies）。如果要求迫使API更改公司的代表性的功能，即使用户根本没有改变，也会创建一个新版本的整个API。</p><p> Usually these are planned timed releases, where — for example — a v2 of the iOSapp and v2 of the API were timed deployments, and v1 probably has a sunset date.</p><p> 通常这些是计划定时版本，其中 - 例如 -  API的IOSApp和V2的V2是定时部署，V1可能有日落日期。</p><p> The downside here is that rarely are changes communicated clearly. In ourexample, when the users had not changed, client developers have a rough timeconfirming that. Also, it’s very common for smaller breaking changes to sneakin, because &#34;It’s a major release, that’s time to change stuff&#34;. With thatmindset, it’s very easy for API developers to shove in breaking changes that maynot be communicated or documented particularly well.</p><p> 这里的缺点是很少发生变化清晰。在我们的示例中，当用户没有改变时，客户端开发人员有一个粗略的时间记住。此外，对于偷偷摸的更改，因为＆＃34;这是一个重大释放，这是改变东西的时候，这是非常常见的。通过该命令集，API开发人员非常容易推出梅图所得沟通或记录的更改。 </p><p> Some companies avoid this by being honest about the situation, and just makeentirely new API applications, on new servers, with new domains. They build http://new-api.example.com, or use codenames,then ditch the old. Eventually they’ll blackhole the old DNS once the oldversion has hit acceptable low or zero usage.</p><p>有些公司通过诚实的情况来避免这种情况，并且在新服务器上的新型API应用程序，新域名具有新的API应用程序。他们构建http://new-api.example.com，或者使用代号名，然后抛弃旧。最终，一旦旧货机达到了可接受的低或零用法，他们就会将旧DNS黑洞。</p><p> This has the benefit of eradicating legacy as you go, but regardless of usingnames, version numbers, or anything else, building out multiple APIs and forcingthe clients to consistently develop against new version after new version is the most time consuming approach to versioning, for not just the APIdevelopers but the client developers too. Everyone has to test  everything oneach new upgrade, and this all takes forever.</p><p> 这有利于您离开时遗弃的遗产，但无论使用什么名称，版本号，还是其他任何东西，构建多个API并强迫客户端在新版本之后持续开发新版本，这不是版本控制的最耗时的方法，而不是只是apidevelopers，但客户开发人员也是如此。每个人都必须测试Oneach新升级的一切，这一切都是永远的。</p><p>   In the same example of  /api/v1/companies and  /api/v1/users, if companieschanged substantially then maybe a  /api/v2/companies is created, but /api/v1/users remains untouched. This makes upgrades easier for clients asthey know where to focus their attention. If there is no v2 for users, they justkeep on using the v1.</p><p>   在/ API / V1 /公司和/ API / V1 / USER的相同示例中，如果Company offeruld，那么可能会创建A / API / V2 /公司，但是/ API / V1 / USER仍未受到影响。这使客户更容易升级Asthey知道在哪里关注他们的注意力。如果用户没有v2，则他们刚刚使用V1。</p><p> One problem with this approach is it looks nearly identical to global versioningon the outside, and isn’t.</p><p> 这种方法的一个问题看起来几乎与外部的全局版本平均相同，而不是。</p><p> I’ve seen apps built with  API::V1::BaseController,  API::V2::BaseController,and  API::V3::BaseController, each of which have their own error format. Thatwould be entirely fine in global versioning, as the assumption is a client willuse all of v1, all of v2, or all of v3. In resource versioning a client mighthit a selection of v1, v2 and v3 endpoints at any time, and that means they needto support  three different error formats.</p><p> 我看到使用API​​ :: V1 :: BaseController，API :: V2 :: BaseController和AP​​I :: V3 :: BaseController构建的应用程序，每个都有自己的错误格式。在全球版本中完全完全罚款，因为假设是客户威尔斯的所有V1，所有V2或所有V3。在资源版本中，客户端在任何时间都可以选择V1，V2和V3端点，这意味着它们需要支持三种不同的错误格式。</p><p> One end-user application was producing errors like  Error: [object Object] toactual end users, because the JavaScript code was expecting the v2 format  {&#34;error&#34; : &#34;some message&#34; }, but a v3 error of  { &#34;error&#34; : {&#34;message&#34; :&#34;something&#34;, &#34;code&#34; :&#34;err-123&#34; } } has come back.</p><p> 一个最终用户应用程序产生错误的错误，如错误：[对象对象]交换最终用户，因为JavaScript代码预计V2格式{＆＃34;错误＆＃34; ：＆＃34;一些消息＆＃34; }，但{＆＃34;错误＆＃34的v3错误; ：{＆＃34;消息＆＃34; ：＆＃34;某事＆＃34;，＆＃34;代码＆＃34; ：＆＃34; er-123＆＃34; }}已经回来了。</p><p> We could counter this specific issue with the use of a standard error responseacross all systems (shout-out to   RFC 7807 Problem Details for HTTPAPIs ), but that is just fixing onesymptom of a larger problem.</p><p> 我们可以根据使用标准错误响应响应所有系统（向RFC 7807对HTTPAPI的问题详细信息喊叫），但这只是修复了更大问题的onesyMptom。 </p><p>  This approach is very similar, but instead of versioning in the URL, versions goin the  Accept and  Content-Type headers.</p><p>这种方法非常相似，但不是在URL中的版本控制，版本GoIn接受和内容类型标题。</p><p>  The keeps the URL issue out of the way, and avoids API developers mistakenlysharing conventions in version specific base controllers. This is what manyconsidered for a long time to be the height of API versioning (myself included),and was the approach used by GitHub for a long time.</p><p>  将URL问题脱颖而出，避免了API开发人员错误地分析了Version特定基础控制器的惯例。这是一个很长一段时间的多当版本控制（我所包括的身高），并且是Github很长一段时间的方法。</p><p> It keeps the same endpoint working for a long time, but if the header isoptional it can cause confusion. If clients don’t request a specific version,should they get the earliest supported version, or the latest?</p><p> 它保持相同的端点工作了很长时间，但如果标题isoptionalions会导致混淆。如果客户端不请求特定版本，如果他们得到最早支持的版本，还是最新的？</p><p> If v3 is added and v2 is eventually deprecated, clients would rather suddenlystart getting a whole new version which might break their apps.</p><p> 如果添加了V3并且v2最终被弃用，则客户端宁愿突出启动一个可能破坏其应用程序的全新版本。</p><p>    I have only ever seen this one approach used at WeWork, but I’m sure it’s beendone elsewhere. It’s a variant of &#34;Resource Versioning (URI-based)&#34;, whichbasically does not version an entire resource, only the method for thatresource.</p><p>    我曾经看到过这种在Wework的这种方法，但我相信它是诸如其他地方的浓度。这是＆＃34的变体;资源版本控制（基于URI）＆＃34;，在没有版本的整个资源中，只有该方法的方法。</p><p> That’s hard to wrap your head around for a good reason. Let’s see how it mightwork:</p><p> 这很难出于充分的理由包围你的头。让我们看看它如何令人作呕：</p><p> The latest &#34;fetch all&#34; for companies might be GET /api/v2/companies, but tocreate a company you might  POST /api/v3/companies, even though  GET/api/v3/companies does not exist. The resource is not even guaranteed to matchon the same method, as method + URI is what makes it unique, so  GET/api/v1/companies/{id} might be the best way to grab a single resource, and who knows if those serializers are the same.</p><p> 最新＆＃34;取代所有＆＃34;对于公司可能是GET / API / V2 /公司，但为您可能发布/ API / V3 /公司的公司，即使GET / API / V3 /公司不存在。资源甚至没有保证匹配相同的方法，因为方法+ URI是什么使其成为唯一的是，所以get / api / v1 / companies / {id}可能是抓取单个资源的最佳方式，谁知道那些资源Serializers是一样的。 </p><p> This has all of the cons of the previously mentioned solutions, with a few morethrown in.</p><p>这拥有前面提到的解决方案的所有缺点，近几个云端。</p><p> Primarily, that API developers get used to disposable endpoints. Every timeClient B needs to update a resource, they create their own new method, ignorethe existing one, and this is tolerated as normal due to a lack of APIversioning strategy.</p><p> 主要是，API开发人员习惯了一次性端点。每个时期B需要更新资源，他们创建自己的新方法，Ignorethe现有方法，这是由于缺乏实现方面的策略，这是正常的。</p><p> Disposable endpoint thinking has lead to situations where new update methodshave been created that only contain subset of earlier update methodfunctionality. The API developer adding functionality was unaware of thefunctionality in previous versions, and didn’t worry about lookingbecause &#34;nobody ever upgrades anyway.&#34;</p><p> 一次性端点思维导致了创建新更新MethodShave的情况，其中仅包含早期更新方法功能的子集。 API开发人员添加功能是不知道以前版本中的功能，并且没有担心看起来＆＃34;无论如何都没有升级。＆＃34;</p><p> Due to this divergence,  even if a client wanted to upgrade, they could not!They are trapped on older versions, which then have to be supported forever, forfear of breaking the clients using the newer endpoint.</p><p> 由于这种分歧，即使客户端想要升级，他们也无法捕获它们，它们被困在旧版本上，然后必须永远支持，旧版本必须使用较新的端点来打破客户端。</p><p> This increased functionality is essentially asking all API teams to support morefunctionality than they should, and that is time and money that could be spenton more useful things.</p><p> 这种增加的功能基本上询问所有API团队支持比他们应该的功能更加功能，而那就是斯普定的时间和金钱。</p><p>  API Evolution is the concept of never breaking your contracts until youabsolutely absolutely have to, then when you do you manage that change withsensible warnings to clients. It is  not about making arbitrary changes andbreaking stuff.</p><p>  API Evolution是从不违反您的合同的概念，直到youbolsolutelly必须，然后您可以管理对客户的致密警告更改。它不是关于制作任意变化和破坏的东西。</p><p> Generally you add new fields, or add a new resource, and if you absolutely mustyou can deprecate and eventually remove the old bits when it’s no longer beingused.</p><p> 一般来说，您添加新字段，或添加新资源，如果您绝对不能弃用，并且当它不再使用时，最终可以撤消旧位。 </p><p> This is an approach currently being popularized by GraphQL, but one that RESTadvocates have been talking about for decades. A great writeup on  HTTPEvolution was doneback in 2012, and more recently an excellent post on  API ChangeManagement.</p><p>这是目前被GraphQL推广的方法，而是重建于几十年来谈论的方法。在HttpEvolution上进行了一系列伟大的写作，于2012年在2012年进行，最近在API长长的MageMagement上的优秀帖子。</p><p> Evolution is not a GraphQL feature, but a concept that works rather well in most types of API.</p><p> Evolution不是GraphQL功能，而是一个在大多数类型的API中工作的概念。</p><p> At a  previous company offering crowdsourcedcarpooling,we only added fields, never removed them. This was fine for the majority ofchanges, but when backwards compatible issues absolutely could not at all beavoided, we took advantage of the fact that a business name for a concept hadchanged, and took the chance to make our API match the business name.</p><p> 在以前的公司提供众包，我们只添加了字段，切勿删除它们。这对大多数宽度来说很好，但是当向后兼容问题绝对不能被标记时，我们利用了一个概念的商业名称，并抓住了我们的API与商业名称相匹配。</p><p> Matches were a relationship between a driver and a passenger, and multiplematches would make up the carpool. The BC change was to add multiple drivers,which completely screwed the concept of matches. When we switched from /matches to  /riders, we changed the JSON representation entirely, butinternally those two representations shared the same code.</p><p> 匹配是驾驶员和乘客之间的关系，并且多重算法将构成拼车。 BC的变化是添加多个驱动程序，它完全拧紧匹配的概念。当我们从/乘客切换到/ riveers时，我们完全更改了JSON表示，这两个表示共享相同的代码。</p><p> After a few months, the matches concept was deprecated, and clients startedusing the new riders concept. The internals changed multiple times as we workedon recoding towards the new goal, and we converted matches to riders, theneventually matches was just a different serializer sat on top of riders. Duringthis process  the contract never changed.</p><p> 几个月后，贬值的概念被贬值了，客户始终开始新的骑手的概念。内部的改变了多次，因为我们对新目标进行了重新编码，我们将与骑手转换为骑手，那么文本匹配只是一个不同的串行器坐在骑手顶部。在此过程中，合同从未改变过。</p><p> We went through a few backflips to make that happen, but our clients didn’t needto do a thing, other than switch to &#34;riders&#34; in their own time. Android and iOSapps launched independently, and that didn’t matter for us at all.</p><p> 我们经历了几个背面来实现这一点，但我们的客户不需要做一件事，除了切换到＆＃34;骑手＆＃34;在自己的时间。 Android和iOSApps独立推出，这根本没什么重要的。</p><p> The approach of evolution pushes some extra work onto the API development team,but avoids a similar amount of work being pushed onto the client teams. If oneAPI has 5 clients, then we’re saving 5x the development, testing, etc.</p><p> 进化方法将一些额外的工作推向API开发团队，但避免了将类似的工作量推向客户团队。如果Oneapi有5个客户端，那么我们正在节省5倍的开发，测试等。 </p><p>  Whether you use Global URI Versioning, or want to use Evolution, you are goingto need to consider how you handle deprecations.</p><p>无论您是使用全局URI版本控制，还是想要使用Evolution，您都需要考虑如何处理弃用。</p><p> If your team is small enough, you can just email the iOS developer and suggestthey use the newer endpoint, or the newer whole damn API, but if you work at acompany with  hundreds of developers (and 30+ services!) this might not be asuccessful approach.</p><p> 如果您的团队足够小，您只需通过电子邮件发送IOS开发人员，并建议使用较新的端点，或者更新的整个Damn API，但如果您使用数百名开发人员（和30多个服务！）在Acompany工作，这可能不会效力方法。</p><p>   At WeWork we built a Faraday wrapper (popular Ruby HTTP client) called we-callthat forces some good conventions onto client and server alike, using the powerof middleware.</p><p>   在Wework中，我们构建了一个名为We-Callthat的法拉第包装器（流行的Ruby HTTP客户端），迫使使用中间件的PowerOf上的客户端和服务器的一些良好约定。</p><p> One of those conventions is syntactic sugar around using the still-in-draft Sunset header, usingannotations to make it super easy. You don’t need to use the whole we-call gem,you can just use faraday-sunset, or if you’reusing PHP you can use guzzle-sunset.</p><p> 其中一个公约是在使用静止草案日落标题的句法糖，使用了annotations，使其超级简单。您无需使用整个We-Call Gem，您只能使用Faraday-Sunset，或者如果您可以使用Guze-Sunset。</p><p>  You can advertise to humans that fields are going away with OpenAPI and it’s &#34;deprecated&#34; keyword,added in v3.0. This is far from perfect as there is not really a computery wayto detect these deprecations without shoving a link to your OpenAPI schemas intothe JSON response.</p><p>  您可以向人类宣传田地正在与Openapi和它的＆＃34;弃用＆＃34;关键字，在v3.0中添加。这远非完美，因为没有计算机检测这些折旧，而无需向OpenAPI模式Intoshe JSON响应即可迁移链接。</p><p> JSON Schema is working on addingthis, and it’sfar more common for JSON Schema links to be placed into the JSON response. Fornow, don’t remove any fields, just add new fields, and use a new representationif you really just cannot handle the old contract.</p><p> JSON Schema正在处理添加本，并且对于将JSON模式链接放入JSON响应，它更常见。 fornow，不要删除任何字段，只需添加新字段，并使用您真正无法处理旧合同的新代表。</p><p>  PayPal dothisfor their APIs, but they’re using vendor extensions that pre-date OpenAPI’sdeprecated functionality.</p><p>  PayPal Dothisfors他们的API，但他们正在使用预先约会的供应商扩展名为OpenApi'Depecated功能。 </p><p>  Stripe have outlined an approach to  making their public APIevolvable, which is way above andbeyond. Instead of using HTTP / in-band metadata to advertise the fact that it’sgoing away, they build out migrations which translate older requests into newerones internally.</p><p>条纹已经概述了一种让他们的公众可爱的方法，这是高于聪明的方式。它们而不是使用HTTP / In-Band Metadata宣传它的事实，而是构建迁移迁移，将旧请求转换为新闻界内部。</p><p> They keep things backwards compatible for a certain amount of time beforedestroying the migration, emailing the client developers a whole bunch about thechange before that point.</p><p> 它们以一定时间兼容迁移，将其保留向后兼容，通过电子邮件向客户端发送电子邮件，在此之前，将客户开发人员提供一整群。</p><p> This was done by Facebook for years, before they threw everything in and wentwith global versioning in the path…</p><p> 这是由Facebook完成的几年，然后在他们在路径中扔进了全球版本的全部和培训的所有内容......</p><p>  Most URI-based versioning is thinly veiled RPC, that just  look a bit RESTish.If companies doing URI-based versioning using RPC naming conventions, the APIswould look a bit more like this:</p><p>  基于URI的大多数版本控制是薄薄的RPC，只需看起来有点恢复。如果使用RPC命名约定的公司正在进行基于URI的版本控制，那么API将更像这样：</p><p>  If people are going to design their APIs as RPC with a RESTish facade, theyshould just commit to being an RPC API and build endpoint for specific clientslike they’re literally already doing.</p><p>  如果人们将其API设计为RPC，并且只需承诺成为RPC API并为特定客户提供的终端，他们已经在实际上已经做了。</p><p> Just be honest about it. Hide the false intention, RPC the lot, document assuch, and maybe just use  gRPC.</p><p> 诚实地对此。隐藏虚假意图，RPC，文档ASSUCH，也许只是使用GRPC。</p><p>  API Evolution is incredibly powerful if you put in the work to make it possible.A  commitment tocontractswill make things easier, especially with JSON Schema bringing deprecated in thefuture.</p><p>  API Evolution是令人难以置信的功能，如果您投入工作以使其成为可能。致力于努力，更容易让事情变得更加容易，特别是JSON Schema带来了在Future中弃用。 </p><p> Global URI Versioning is the least awful alternative. I would only recommendthis to teams who cannot commit to contracts, and build incredibly differentAPIs to match incredibly different iterations of applications (e.g., v1, v2, v3of a mobile app). Maybe just use codenames for each version and delete the oldAPIs, instead of trying to jam it all into one codebase and potentially taintone version with changes to some shared code in another version.</p><p>全球URI版本控制是最不可思议的替代方案。我只推出无法承诺合同的团队，并建立令人难以置信的差异，以匹配令人难以置信的应用程序的迭代（例如，V1，V2，移动应用程序）。也许只需使用每个版本的代码符并删除Oldapis，而不是尝试将其全部堵塞到一个代码库中，并在另一个版本中更改了某些共享代码的潜在棕色版本。</p><p> Either way, global versioning is literally not at all RESTful, and hints towardsRPC, and that’s coming straight from Roy.</p><p> 无论哪种方式，全球版本都没有完全依赖，并提示散步，这是从罗伊直接来的。</p><p> Resource-based content-negotiation is ok if you’ve got some very HTTP-savvyclients and document your intentions incredibly well, but it’s essentially ashortcut to kinda evolution, which doesn’t really add any benefit.</p><p> 基于资源的内容协商如果您有一些非常http-sevvyclieser并令人难以置信地记录您的意图，但它基本上是ashortcut，有点演变，这并没有真正添加任何好处。</p><p> And for the love of The Flying Spaghetti Monster, please don’t ever do any formof method-based versioning. It never makes any sense. You’re making thingsterrible for everyone, splitting expectations, creating overhead, and focusingon short-term gains and long-term confusion.</p><p> 为爱的意大利面条怪物的爱，请不要做任何基于方法的版本控制。它永远不会有任何意义。您正在为每个人制作意义，分裂期望，创造开销和聚焦短期收益和长期混乱。</p><p> However you decide to version, so long as you’re using one of the few moresensible approaches, remember that it’s not about deciding which is &#34;best&#34;. It’sabout sharing and understanding the pros and cons of various approaches, and thepriority is educated decisions based on that information.</p><p> 然而，您决定版本，只要您使用少数几个莫比语方法之一，请记住它不是决定哪个是＆＃34;最好的＆＃34;它的分享和理解各种方法的优缺点和缺点，以及基于该信息的教育决策。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://apisyouwonthate.com/blog/api-versioning-has-no-right-way">https://apisyouwonthate.com/blog/api-versioning-has-no-right-way</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/版本控制/">#版本控制</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/api/">#api</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>