<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>加密备份枪战 Encrypted Backup Shootout</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Encrypted Backup Shootout<br/>加密备份枪战 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-03 11:13:39</div><div class="page_narrow text-break page_content"><p>Recently I have been spending time on improving the performance of  bupstash (my encrypted backup tool), and wanted to compare it to some existing tools to try and find its relative performance in the backup tool landscape.</p><p>最近，我一直在花时间来提高bupstash（我的加密备份工具）的性能，并想将其与一些现有工具进行比较，以尝试在备份工具领域中找到其相对性能。</p><p> This post compares  bupstash,  restic,  borg backup and plain old tar + gzip + GPG across a series of simple benchmarks.</p><p> 这篇文章比较了一系列简单的基准测试中的bupstash，restic，borg备份和普通的tar + gzip + GPG。</p><p>   Feel free to checkout the project websites to learn more, let’s get to the benchmarks.</p><p>   随时查看项目网站以了解更多信息，让我们进入基准测试。</p><p>    The test machine has an AMD Ryzen Threadripper 1950X 16-Core Processor with 16 GB of ram, and an NVMe SSD hard drive. It is probably best to simply compare results relatively, as reproducing my test environment exactly would be difficult.</p><p>    该测试计算机具有AMD Ryzen Threadripper 1950X 16核处理器，16 GB内存和NVMe SSD硬盘驱动器。最好只是相对地比较结果，因为要完全复制我的测试环境将很困难。</p><p> The scripts I used for my benchmarking can be found  here, though they will definitely need tweaking for your environment.</p><p> 我用于基准测试的脚本可以在这里找到，尽管它们确实需要针对您的环境进行调整。</p><p>  For this benchmark we take 20 different consecutive versions of the linux kernel source code and add them all to the same directory, we then create a snapshot and measure the size of the resulting tarball/repository.</p><p>  对于此基准测试，我们采用20个连续的Linux内核源代码版本，并将它们全部添加到同一目录中，然后创建快照并测量生成的tarball /存储库的大小。</p><p> The linux kernel versions chosen for this test are all the consecutive git commits preceeding version 5.9, with the resulting directory containing 21 GB of uncompressed files.</p><p> 为此测试选择的linux内核版本是5.9版之前的所有连续git commit，其结果目录包含21 GB的未压缩文件。 </p><p>   This benchmark shows the advantage the more sophisticated tools have over plain tarballs, they all have extremely good compression ratios when similar data is added multiple times toa backup repository.</p><p>该基准测试表明，与普通的tarball相比，更先进的工具具有优势，当将相似的数据多次添加到备份存储库中时，它们都具有极好的压缩率。</p><p>    The snapshots are all made to tmpfs so hopefully does not measure delays introduced by the network or disk activity.</p><p>    快照都是针对tmpfs创建的，因此希望不会测量网络或磁盘活动引起的延迟。</p><p>       This benchmark is the same as the fresh local snapshot benchmark except the files are sent to a remote server hosted on google cloud via ssh. This benchmark should only be considered an approximation of the effect latency has on the tool performance as it is so dependent on network speeds.</p><p>       该基准与新鲜的本地快照基准相同，只不过这些文件是通过ssh发送到托管在Google云上的远程服务器的。该基准仅应视为延迟对工具性能的影响的近似值，因为它取决于网络速度。</p><p> At the time of benchmarking my connection to the remote server can be summarized as follows:</p><p> 在进行基准测试时，与远程服务器的连接可以总结如下：</p><p>      Plain tar takes the win, Restic performs poorly here, it has a far more latency-sensitive upload protocol.</p><p>      普通的tar赢得了胜利，Restic在这里表现不佳，它具有对时延敏感的上传协议。</p><p>  This benchmark is the same as the fresh local snapshot benchmark, except now we measure the time for an incremental snapshot using the builtin caching mechanism of the tools. What this means is each tool keeps a record of what files it has already sent, and is able toskip doing that work again.</p><p>  该基准与新的本地快照基准相同，除了现在我们使用工具的内置缓存机制来测量增量快照的时间。这意味着每个工具都会记录其已发送的文件，并且能够跳过此工作。</p><p>     Incremental tar is the clear winner here, but why are the other tools slower? I think this is mainly because the other tools present each snapshot to the user as a full backup and thus do extra work to spare the end user from managing incremental backups manually.</p><p>     增量tar是这里的明显赢家，但是为什么其他工具速度较慢？我认为这主要是因为其他工具将每个快照作为完整备份呈现给用户，因此进行了额外的工作以使最终用户免于手动管理增量备份。 </p><p> It is also interesting to me that  bupstash put is an order of magnitude faster than the other similar tools, though I currently can not explain clearly why that may be the case.</p><p>我也很有趣，bupstash put比其他类似工具快一个数量级，尽管我目前无法清楚地解释为什么可能是这种情况。</p><p>  This benchmark is the same as the incremental local snapshot benchmark except the files are sent to a remote server hosted on google cloud via ssh.</p><p>  该基准与增量本地快照基准相同，只不过这些文件是通过ssh发送到托管在Google云上的远程服务器的。</p><p>        In this benchmark we will restore the snapshot made in the fresh local snapshot benchmark to tmpfs. This is what measuring what happens when you need to do a bulk disaster recovery from your backup repository.</p><p>        在此基准测试中，我们会将在新的本地快照基准测试中创建的快照还原到tmpfs。这是衡量需要从备份存储库进行批量灾难恢复时发生的情况的信息。</p><p>       In this benchmark we will restore the snapshot made in the fresh remote snapshot benchmark to tmpfs. The main difference from the previous benchmark is the introduction ofan internet connection between the backup repository and restore point.</p><p>       在此基准测试中，我们会将在新的远程快照基准测试中创建的快照还原到tmpfs。与以前的基准测试的主要区别是在备份存储库和还原点之间引入了Internet连接。</p><p>      Interestingly, the introduction of the network pushed tar ahead of bupstash for backup restoration - this is something I am very interested in investigating further.</p><p>      有趣的是，网络的引入使tar领先于bupstash进行备份还原-这是我非常有兴趣进一步研究的事情。</p><p>  In this benchmark we will be removing an old snapshot from the backup repository on the same computer. For this test we generate a backup repository with 50 different snapshots of different versions of the linux kernel source code and then time how long it takes to remove one of the snapshots. This benchmark simulatescycling old backups out of your backup repository when you no longer need them.</p><p>  在此基准测试中，我们将从同一台计算机上的备份存储库中删除旧快照。对于此测试，我们生成一个备份存储库，其中包含不同版本的Linux内核源代码的50个不同的快照，然后确定删除其中一个快照所花的时间。当不再需要旧基准备份时，此基准可以模拟将旧备份从备份存储库中循环出来。</p><p> Tar with incremental backups does not easily support pruning of old backups, so does not participate in this benchmark.</p><p> 具有增量备份的Tar无法轻易支持对旧备份的修剪，因此不参与此基准测试。 </p><p>     The bupstash garbage collector is an order of magnitue faster than both restic and borg at pruning the backup repository.</p><p>在修剪备份存储库时，bupstash垃圾收集器的速度比restic和borg快了一个数量级。</p><p>  In this benchmark we will be removing an old snapshot from the backup repository stored on a remote server. The remote server is the same as the one used in fresh remote snapshot benchmark, and the test data is the same as the local prune bench mark.</p><p>  在此基准测试中，我们将从存储在远程服务器上的备份存储库中删除旧快照。远程服务器与新鲜远程快照基准测试中使用的服务器相同，测试数据与本地修剪基准标记相同。</p><p>       For this benchmark we repeat the fresh snapshot benchmark, but measure the peak client ram usage (RSS) as reported by the ‘time’ command. For tar we approximate this by summing the peak memory usage across tar, gpg and gzip.</p><p>       对于此基准，我们重复新的快照基准，但是要测量“ time”命令报告的客户端ram峰值使用量（RSS）。对于tar，我们通过将tar，gpg和gzip的峰值内存使用量相加来近似得出。</p><p>     Bupstash is very memory-efficient compared to restic and borg, but ultimately loses out to the simplicity of tar + gzip + GPG.</p><p>     与restic和borg相比，Bupstash的存储效率非常高，但最终却失去了tar + gzip + GPG的简单性。</p><p>  GNU Tar + gzip + gpg is an excellent encrypted backup option and performed better than I expected. I think tar and gpg is still a great choice for users who prefer to DIY their own backup scripts. With this in mind, we must ask what are the problems with tar that the other tools address? My opinion is that managingincremental backups, deduplication, pruning, and searching backups are far more difficult when using incremental tar compared to borg/restic/bupstash. With incremental tar, it quickly becomes quite hard to track which incrementaltarballs depend on eachother and you often need to periodically do full snapshots - losing most of the speed benefits.</p><p>  GNU Tar + gzip + gpg是一个出色的加密备份选项，性能比我预期的要好。我认为tar和gpg对于喜欢自己备份自己的备份脚本的用户来说仍然是一个不错的选择。考虑到这一点，我们必须问其他工具解决的tar问题是什么？我的观点是，与使用borg / restic / bupstash相比，使用增量tar时管理增量备份，重复数据删除，修剪和搜索备份要困难得多。使用增量tar，很快很难跟踪哪些增量tarball相互依赖，并且您通常需要定期进行完整快照-失去了大部分速度优势。</p><p> As the biased author of bupstash, I am also pleased with how it has performed and hope I can push it further in the future. Restic, while fast at local operation, seems to trail the other tools when network latency is thrown into the mix. Borg is an all-around great tool and performed very well.</p><p> 作为bupstash有偏见的作者，我也对bupstash的表现感到满意，并希望我将来能将其进一步推广。 Restic，尽管在本地操作上速度很快，但是当网络延迟变得混乱时，似乎落后于其他工具。 Borg是一个全方位的出色工具，并且表现出色。</p><p> I can see both strengths and room for improvement in each of the tools tested, and encourage everyone to give them a try for yourself if you haven’t already.</p><p> 我可以看到每种测试工具的优点和改进的余地，并鼓励大家尝试一下，如果您还没有尝试过的话。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://acha.ninja/blog/encrypted_backup_shootout/">https://acha.ninja/blog/encrypted_backup_shootout/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/备份/">#备份</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/backup/">#backup</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>