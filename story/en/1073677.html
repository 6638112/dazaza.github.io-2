<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>C++中的函数处理程序库A library for effect handlers in C++</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">A library for effect handlers in C++<br/>C++中的函数处理程序库</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-17 03:08:53</div><div class="page_narrow text-break page_content"><p>Effect handlers allow for programming with user-defined computational effects, with applications including custom lightweight concurrency (threads, async-await, actors, generators), error handling, dependency injection, etc. Effect handlers originate from the realm of functional programming, and the main goal of this  highly experimental library is to explore how they fit in the more object-oriented setting of C++.</p><p>效果处理程序允许使用用户定义的计算效果进行编程，应用程序包括自定义轻量级并发（线程、异步等待、参与者、生成器）、错误处理、依赖项注入等。效果处理程序起源于函数式编程领域，这个高度实验性的库的主要目标是探索它们如何适合于面向对象的C++设置。</p><p> The library relies on modern C++ features (move semantics, variadic templates, compile-time evaluation) to achieve elegant programmer-level interface, memory management of handlers, and relative type-safety. Internally, it uses the  boost::context library for call-stack manipulation, and so it implements one-shot handlers only.</p><p>该库依赖于现代C++特性（移动语义、可变模板、编译时评估），以实现优雅的程序员级接口、处理程序的内存管理和相对类型安全性。在内部，它使用boost:：context库进行调用堆栈操作，因此它只实现了一次性处理程序。</p><p>  Reference - A detailed explanation of the library&#39;s API and a short discussion about the overall design of the library. It is a suitable introduction for a reader already familiar with effect handlers (for example, as they are usually discussed in the context of functional programming).</p><p>参考资料——图书馆的详细说明&#39；s API和关于库的总体设计的简短讨论。对于已经熟悉效果处理程序的读者来说，这是一个合适的介绍（例如，通常在函数式编程的上下文中讨论效果处理程序）。</p><p> Coming soon: Tutorial - An introduction to programming with effect handlers. Suitable for readers not familiar with handlers.</p><p>即将到来：教程-介绍使用效果处理程序编程。适合不熟悉处理程序的读者。</p><p>  As a sneak preview, we can use effect handlers to define our own tiny library for cooperative lightweight threads. The programmer&#39;s interface will consist of two functions,  yield and  fork, together with a class that implements a scheduler:</p><p>作为一个预览，我们可以使用效果处理程序为协作轻量级线程定义我们自己的小库。程序员&#39；s接口将包括两个函数，yield和fork，以及一个实现调度器的类：</p><p> void  yield();   // Used by a thread to give up control void  fork(std::function&lt; void()&gt; proc);   // Start a new thread class  Scheduler { public:  static  void  Start(std::function&lt; void()&gt; f);};</p><p>空隙率（）；//线程用来放弃控制void fork（std:：function&lt；void（）&gt；proc）；//启动一个新的线程类调度程序{public:static void Start（std:：function&lt；void（）&gt；f）；}；</p><p> The static member function  Start initiates the scheduler with  f as the body of the first thread. It returns when all threads finish their jobs.</p><p>静态成员函数Start以f作为第一个线程的主体启动调度程序。当所有线程完成任务时，它返回。</p><p> To implement this interface, we first define two  commands, which are data structures used for transferring control from the client code to the handler. We implement  yield and  fork to invoke these commands. (The name of the class  OneShot is supposed to remind the programmer that we&#39;re dealing with one-shot handlers only, meaning you cannot resume the same resumption twice).</p><p>为了实现这个接口，我们首先定义两个命令，它们是用于将控制从客户机代码传输到处理程序的数据结构。我们实现了yield和fork来调用这些命令。（OneShot类的名称应该是提醒程序员，我们只处理单次处理程序，这意味着不能两次恢复相同的恢复）。</p><p> # include   &#34;cpp-effects/cpp-effects.h &#34; using  namespace  CppEffects ; struct  Yield : Command&lt; void&gt; { }; struct  Fork : Command&lt; void&gt; { std::function&lt; void()&gt; proc;}; void  yield(){  OneShot::InvokeCmd(Yield{});} void  fork(std::function&lt; void()&gt; proc){  OneShot::InvokeCmd(Fork{{}, proc});}</p><p>#包括&#34；cpp效应/cpp效应。h&#34；使用名称空间效果；结构屈服：命令&lt；void&gt；{ }; struct Fork:Command&lt；void&gt；{std:：function&lt；void（）&gt；proc；}；void yield（）{OneShot:：InvokeCmd（yield{}）；}void fork（std:：function&lt；void（）&gt；proc）{OneShot:：InvokeCmd（Fork{}，proc}）；}</p><p> We define the scheduler, which is a  handler that can interpret the two commands by pushing the resumptions (i.e., captured continuations) to the queue.</p><p>我们定义了调度器，它是一个处理程序，可以通过将恢复（即捕获的继续）推送到队列来解释这两个命令。</p><p> // Res is the type of suspended threads using Res = std::unique_ptr&lt;Resumption&lt; void,  void&gt;&gt;; class  Scheduler :  public  Handler&lt; void,  void, Yield, Fork&gt; { public:  static  void  Start(std::function&lt; void()&gt; f) {  Run(f);  while (!queue. empty()) {   // Round-robin scheduling  auto resumption =  std::move(queue. front()); queue. pop_front();  OneShot::Resume( std::move(resumption)); } } private:  static std::list&lt;Res&gt; queue;  static  void  Run(std::function&lt; void()&gt;) { OneShot:: Handle&lt;Scheduler&gt;(f); }  void  CommandClause(Yield, Res r)  override { queue. push_back( std::move(r)); }  void  CommandClause(Fork f, Res r)  override { queue. push_back( std::move(r)); queue. push_back(OneShot::MakeResumption&lt; void&gt;( std::bind(Run, f. proc))); }  void  ReturnClause()  override { }};std::list&lt;Res&gt; Scheduler::queue;</p><p>//Res是使用Res=std:：unique_ptr&lt；恢复&lt；void，void&gt&gt；；类调度程序：公共处理程序&lt；无效，无效，屈服，分叉&gt；{public:static void Start（std:：function&lt；void（）&gt；f）{Run（f）；while（！queue.empty（））{//循环调度自动恢复=std:：move（queue.front（））；queue.pop_front（）；OneShot:：Resume（std:：move（Resume））；}私有：静态标准：：列表&lt；Res&gt；队列静态void运行（std:：function&lt；void（）&gt；）{OneShot:：Handle&lt；Scheduler&gt；（f）；}void CommandClause（Yield，Res r）重写{queue.push_back（std:：move（r））；}void CommandClause（Fork f，Res r）重写{queue.push_back（std:：move（r））；queue.push_back（OneShot:：makerestoration&lt；void&gt；（std:：bind（Run，f.proc））；}void ReturnClause（）覆盖{}；标准：列表&lt；Res&gt；调度程序：：队列；</p><p> And that&#39;s all it takes! We can now test our library by starting a few threads:</p><p>那&#39；这就是一切！现在，我们可以通过启动几个线程来测试我们的库：</p><p> void  worker( int k){  for ( int i =  0; i &lt;  10; ++i) { std::cout &lt;&lt; k;  yield(); }} void  starter(){  for ( int i =  0; i &lt;  5; ++i) {  fork( std::bind(worker, i)); }} int  main(){  Scheduler::Start(starter);   // Output:   // 01021032104321043210432104321043210432104321432434}</p><p>void worker（intk）{for（inti=0；i&lt；10；++i）{std:：cout&lt；&lt；k；yield（）；}void starter（）{for（int i=0；i&lt；5；++i）{fork（std:：bind（worker，i））；}int main（）{Scheduler:：Start（starter）；//Output://0102103210432104321043210432104321043210432104432434}</p><p>   [1] - In the library handlers are objects, so they can naturally contain any data, auxiliary functions, and additional programmer&#39;s interface.</p><p>[1] -在库中，处理程序是对象，因此它们可以自然地包含任何数据、辅助函数和额外的程序员&#39；s接口。</p><p>  The easiest way to compile the library and the examples is to use  cmake. You will need  cmake and  boost in any non-ancient versions. For example, the following should do the trick on macOS:</p><p>编译库和示例的最简单方法是使用cmake。在任何非古代版本中都需要cmake和boost。例如，以下内容可以在macOS上实现：</p><p>  This will build the library and the examples. You can check that it works by running an example. The following will run the  threads example - you can see the interleaving of threads in the output:</p><p>这将构建库和示例。您可以通过运行一个示例来检查它是否有效。下面将运行线程示例-您可以在输出中看到线程的交错：</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/处理程序/">#处理程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/effect/">#effect</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>