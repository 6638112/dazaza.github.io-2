<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>双线性下采样，对齐像素网格和臭名昭著的半像素偏移 Bilinear downsampling, aligning pixel grids and the infamous half pixel offset</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Bilinear downsampling, aligning pixel grids and the infamous half pixel offset<br/>双线性下采样，对齐像素网格和臭名昭著的半像素偏移 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-25 09:33:21</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/f369cc0d1b9b9138ce316b6551425d09.gif"><img src="http://img2.diglog.com/img/2021/2/f369cc0d1b9b9138ce316b6551425d09.gif" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>It’s been more than two decades of me using bilinear texture filtering, a few months since  I’ve written about bilinear resampling, but only two days since I discovered a bug of mine related to it. 😅 Similarly, just last week a colleague asked for a very fast implementation of bilinear on a CPU and it caused a series of questions “which kind of bilinear?”.</p><p>我使用双线性纹理过滤已经有二十多年了，距离我撰写双线性重采样已经有几个月了，但是距离发现我的一个与之相关的错误只有两天了。 😅同样，就在上周，一位同事要求在CPU上非常快速地实现双线性，这引起了一系列问题“哪种双线性？”。</p><p> So I figured it’s an opportunity for another short blog post – on bilinear filtering, but in context of down/upsampling. We will touch here on  GPU half pixel offsets, aligning pixel grids, a bug / confusion in Tensorflow, deeper signal processing analysis of what’s going on during bilinear operations, and analysis of the magic of the  famous “magic kernel”.</p><p> 因此，我认为这是另一篇简短的博客文章的机会–关于双线性过滤，但涉及下采样/上采样。我们将在这里介绍GPU半像素偏移，对齐像素网格，Tensorflow中的错误/混淆，对双线性操作期间发生的情况进行更深入的信号处理分析，以及对著名的“魔术核”的魔术性进行分析。</p><p> I highly recommend  my previous post as a primer on the topic, as I’ll use some of the tools and terminology from there, but it’s not strictly required. Let’s go!</p><p> 我强烈推荐我的上一篇文章作为该主题的入门，因为我将从那里开始使用一些工具和术语，但这并不是严格要求的。我们走吧！</p><p>  The term bilinear upsampling and downsampling is used a lot, but what does it mean?</p><p>  经常使用术语双线性上采样和下采样，但这是什么意思？</p><p> One of the few ideas I’d like to convey in this post is that  bilinear upsampling / downsampling doesn’t have a single meaning or a consensus around this term use. Which is kind of surprising for a bread and butter type of image processing operation that is used all the time!</p><p> 我想在这篇文章中传达的几个想法之一是，双线性上采样/下采样在此术语的使用上没有单一含义或共识。对于一直使用的面包和黄油类型的图像处理操作来说，这是令人惊讶的！</p><p> It’s also surprisingly hard to get it right even by image processing professionals, and a  source of long standing bugs and confusion in top libraries (and I know of some actual production bugs caused by this  Tensorflow inconsistency)!</p><p> 即使是图像处理专业人员，也很难做到这一点，而且长期存在bug和顶级库的混乱（我知道一些由Tensorflow不一致引起的实际生产bug）！</p><p> Edit: there’s a blog post titled   “How Tensorflow’s tf.image.resize stole 60 days of my life” and it’s describing same issue. I know of some of my colleagues that spent months on fixing it in Tensorflow 2 – imagine effort of fixing incorrect uses and “fixing” already trained models that were trained around this bug…</p><p> 编辑：一篇博客文章标题为“ Tensorflow的tf.image.resize如何偷走了我60天的生命”，并描述了同样的问题。我知道我的一些同事花了几个月的时间在Tensorflow 2中修复它-想像一下如何修复不正确的用法并“修复”已经受过此错误训练的模型。 </p><p>  Some parts of it like phase shifting are so tricky that a famous blog post of  “magic kernel” comes up every few years and again, experts re(read) it a few times to figure out what’s going on there, while the author simply  rediscovered the bilinear! ( Important note: I don’t want to pick on the author, far from it, as he is a super smart and knowledgeable person, and willingness to share insights is always respect worthy. “Magic kernel” is just an example of why it’s so hard and confusing to talk about  “bilinear”. I also respect how he amended and improved the post multiple times. But there is no “magic kernel”.)</p><p>它的某些部分（如相移）是如此棘手，以至于著名的“魔术内核”博客文章每隔几年出现一次，专家们重新阅读了几次以弄清楚到底发生了什么，而作者只是重新发现了双线性！ （重要说明：我不想选择作者，因为他是一个非常聪明和博学的人，并且乐于分享见解总是值得尊重的。“魔术内核”只是为什么它如此很难谈论“双线性”。我也尊重他如何多次修改和改进该职位。但是没有“魔术内核”。）</p><p> So let’s have a look at what’s the problem. I will focus here exclusively on 2x up/downsampling and hope that some thought framework I propose and use here will be beneficial for you to also look at and analyze different (and non-integer factors).</p><p> 因此，让我们看一下问题所在。在这里，我将仅专注于2倍向上/向下采样，并希望在此建议和使用的某些思想框架对您有益，也有助于您研究和分析不同的（和非整数因素）。</p><p> Because of bilinear separability, I will again  abuse the notation and call “bilinear” a filter when applied to 1D signals and generally a lot of my analysis will be in 1D.</p><p> 由于双线性的可分离性，当再次应用于一维信号时，我将再次滥用该表示法并称其为“双线性”滤波器，通常，我的很多分析将在一维中进行。</p><p>   Let’s start with the most simple explanation, without the nitty gritty: it is creating a larger resolution image where every sample is created from bilinear filtering of a smaller resolution image.</p><p>   让我们从最简单的解释开始，而不是一成不变：创建一个分辨率更高的图像，其中每个样本都是通过对分辨率较低的图像进行双线性过滤而创建的。</p><p> For the bilinear downsampling, things get a bit muddy. It is using a bilinear filter to prevent signal aliasing when decimating the input image – ugh, lots of technical terms. I will circle back to it, but first address the first common confusion.</p><p> 对于双线性下采样，情况会变得有些混乱。它使用双线性滤波器来防止在抽取输入图像时出现信号混叠–嗯，很多技术术语。我会回头再说，但首先要解决第一个常见的困惑。</p><p>  When downsampling images by 2, we every often use terms box filter and bilinear filter interchangeably. And both can be correct. How so?</p><p>  当对图像进行2倍降采样时，我们经常互换使用术语盒滤波器和双线性滤波器。两者都是正确的。怎么会这样？</p><p>   We can see that a  2 tap box filter is the same as a 2 tap bilinear filter. The reason for it is that in this case, both filters are centered between the pixels. After discretizing them (evaluating filter weights at sample points), there is no difference, as we no longer know what was the formula to generate them, and how the filter kernel looked outside of the evaluation points.</p><p>   我们可以看到2抽头盒滤波器与2抽头双线性滤波器相同。原因是在这种情况下，两个滤镜都位于像素之间的中心。离散化它们之后（在采样点评估滤波器权重），没有区别，因为我们不再知道生成它们的公式是什么，以及滤波器内核在评估点之外的外观。 </p><p> The most typical way of doing bilinear downsampling is the same as box downsampling. Using those two names for 2x downsampling interchangeably is both correct! (Side note: Things diverge when taking about more than 2x downsampling. This might be a good topic for another blog post.) For 1D signals it means averaging every two elements together, for 2D images averaging 4 elements to produce a single one.</p><p>进行双线性下采样的最典型方法与盒下采样相同。交替使用这两个名称进行2倍下采样都是正确的！ （旁注：当进行大约2倍的下采样时，情况会发散。对于另一篇博客文章，这可能是个不错的话题。）对于1D信号，这意味着将每两个元素平均在一起，对于2D图像，将4个元素平均产生一个。</p><p> You might have noticed something that I implicitly assumed there –  pixel centers there were shifted by half a pixel, and the edges/corners were aligned.</p><p> 您可能已经注意到了我隐含的假设-像素中心偏移了半个像素，并且边缘/角对齐。</p><p>   This one definitely and clearly is also a linear tent, and it doesn’t shift pixel centers. The resulting filter weights of [0.25 0.5 0.25] are also called a [1 2 1] filter, or the simplest case of a  binomial filter, a very reasonable approximation to a  Gaussian filter. (To understand why, see what happens to the binomial distribution as the trial count goes to infinity!). It’s probably the filter I use the most in my work, but I digress. 🙂</p><p>   显然，这也是一个线性帐篷，它不会移动像素中心。所得的滤波器权重[0.25 0.5 0.25]也称为[1 2 1]滤波器，或者是二项式滤波器的最简单情况，非常接近高斯滤波器。 （要了解原因，请查看当试算次数达到无穷大时二项式分布会发生什么！）。这可能是我在工作中使用最多的过滤器，但我离题了。 🙂</p><p> Why this second method is not used that much? This is by design and a reason for half texel shifts in GPU coordinates / samplers, and you might have noticed the problem – the last texel of high resolution array gets discarded. But let’s not get ahead of ourselves, first we can have a look at the relationship with upsampling.</p><p> 为什么第二种方法没有使用太多？这是设计使然，也是GPU坐标/采样器中半像素的像素移动的原因，您可能已经注意到了问题–高分辨率阵列的最后一个像素被丢弃。但是，让我们不要超越自己，首先，我们可以看一下与上采样的关系。</p><p>  If you were to design a bilinear upsampling algorithm, there are a few ways to address it.</p><p>  如果要设计双线性上采样算法，则有几种解决方法。</p><p> Let me start with a “naive” one that can have problems. We can take every original pixel, and between them just place averages of the other ones.</p><p> 让我从一个可能存在问题的“天真”开始。我们可以获取每个原始像素，并在它们之间放置其他像素的平均值。</p><p>  Is it bilinear / tent? Yes, it’s a tent filter on zero-inserted image (more on it later). It has an unusual property; some pixels get blurred, some pixels stay “sharp” (original copied).</p><p>  是双线性/帐篷吗？是的，它是对零插入图像的帐篷过滤器（稍后会详细介绍）。它具有不寻常的特性；一些像素变得模糊，一些像素保持“清晰”（原始复制）。 </p><p> But more importantly, if you do box/bilinear downsampling as described above, and then upsample an image,  it will be shifted:</p><p>但更重要的是，如果您如上所述进行框/双线性下采样，然后对图像进行上采样，则图像会发生偏移：</p><p>  Or rather – it will not correct for the half pixel shift created by downsampling.</p><p>  或更确切地说，它无法校正下采样所造成的半个像素偏移。</p><p> It will work however with downsampling using the second method. The second method interpolates every single output pixel; all are interpolated:</p><p> 但是，使用第二种方法进行下采样也可以。第二种方法是对每个输出像素进行插值；全部插值：</p><p>  This another way of doing bilinear upsampling that might first feel initially  unintuitive: every pixel is 0.75 of one pixel, and 0.25 of another one, alternating “to the left” and “to the right”. This is exactly what a GPU does when you upsample a texture by 2x:</p><p>  进行双线性上采样的另一种方法最初可能最初并不直观：每个像素是一个像素的0.75，另一个像素的0.25，交替“向左”和“向右”。当您将纹理上采样2倍时，GPU正是这样做的：</p><p>  There are two simple explanations for those “alternating” weights. The first, easiest one is just looking at the “tents” in this scheme:</p><p>  对于那些“替代”权重，有两种简单的解释。第一个最简单的方法就是查看此方案中的“帐篷”：</p><p>  I’ll have a look at the second interpretation of this filter –  it’s [0.125 0.375 0.375 0.125] in disguise 🕵️‍♀️, but first with this intro, I think it’s time to make the main claim / statement:  we need to be careful to use same reference coordinate frames when discussing images of different resolutions.</p><p>  我将看看这个过滤器的第二种解释–伪装成[️0.125 0.375 0.375 0.125]，但首先，我想是时候提出主要声明/声明了：我们需要谨慎在讨论不同分辨率的图像时使用相同的参考坐标系。</p><p>  Your upsampling operations should be aware of what downsampling operations are and how they define the pixel grid offset, and the other way around!</p><p>  您的上采样操作应该知道什么是下采样操作，以及它们如何定义像素网格偏移，反之亦然！ </p><p>  One important thing to internalize is that signal filters can have odd or even number of samples. If we have an even number of samples, such a filter doesn’t have a “center”, so it has to shift the whole signal by a half pixel in either direction. By comparison, symmetric odd filters can shift specific frequencies, but don’t shift the whole signal:</p><p>内部化的重要一件事是信号滤波器可以具有奇数或偶数个采样。如果我们有偶数个样本，那么这种滤波器就没有“中心”，因此必须将整个信号沿任一方向移动半个像素。相比之下，对称奇数滤波器可以移动特定频率，但不能移动整个信号：</p><p>  If you know signal processing, those are the type I and II  linear phase filters.</p><p>  如果您知道信号处理，那么它们就是I型和II型线性相位滤波器。</p><p>  Here’s a visual demonstration of why it matters. A Kodak dataset image processed with different sequences, first starting with box downsampling:</p><p>  这是为什么重要的视觉演示。使用不同序列处理的柯达数据集图像，首先从框下采样开始：</p><p>    If there is a single lesson from my post, I would like it to be this one: Both “takes” on the bilinear up/downsampling above can be the valid and correct ones, you simply need to pick the proper one for your use-case and the convention used throughout your code/frameworks/libraries;  always use a consistent coordinate convention for the downsampling and upsampling. When you see term “bilinear”, always double check what it means! Because of it, I actually like to reimplement those and be sure that I’m consistent…</p><p>    如果我的帖子中只有一课，我希望是这样：上面的双线性上/下采样中的两个“取材”都可以是有效和正确的，您只需要选择一个适合您的用途即可：案例和整个代码/框架/库中使用的约定；始终对下采样和上采样使用一致的坐标约定。当您看到“双线性”一词时，请务必仔细检查其含义！因此，我实际上很想重新实现它们，并确保我保持一致…</p><p> That said, I’d argue that the  “box” bilinear downsampling and the “alternating weights” are better for average use-case. The first reason might be somewhat subjective / minor (because bilinear down/upsampling is inherently low quality and I don’t recommend using it when the quality matters more than simplicity / performance). If we visually inspect the upsampling operation, we can see more leftover aliasing (just look at the diagonal edges) in the odd/odd combo:</p><p> 也就是说，我认为对于普通用例而言，“盒式”双线性下采样和“替代权重”是更好的选择。第一个原因可能是主观的/次要的（因为双线性下采样/上采样本质上是低质量的，所以我不建议在质量远不只是简单性/性能时使用它）。如果我们目视检查升采样操作，则可以在奇/奇组合中看到更多的剩余混叠（仅看对角线边缘）：</p><p>  The second reason, IMO a more important one is how easily they align images. And this is why GPU sampling has this “infamous” half a pixel offset.</p><p>  第二个原因，IMO更重要的一个原因是它们对齐图像的容易程度。这就是GPU采样具有“臭名昭著”的半像素偏移的原因。</p><p>  Ok, so my favorite part starts – half pixel offsets! Source of pain, frustration, misunderstanding, but also a super reasonable and robust way of representing texture and pixel coordinates. If you started graphics programming relatively recently (DX10+ era) or are not a graphics programmer – this might be not a big deal for you. But basically, with older graphics APIs framebuffer coordinates didn’t have a half texel offset, while the texture sampler expected it, so you had to add it manually. Sometimes people added it in the vertex shader, sometimes in the pixel shader, sometimes setting up uniforms on the CPU… a complete mess; it was a source of endless bugs found almost every day, especially on video games shipping on multiple platforms / APIs!</p><p>  好的，所以我最喜欢的部分开始了–半像素偏移！痛苦，沮丧，误解的根源，也是表示纹理和像素坐标的一种超级合理而强大的方法。如果您是最近才开始进行图形编程（DX10 +时代）的人，或者您不是图形程序员，那么这对您来说并不重要。但基本上，使用较旧的图形API时，帧缓冲区坐标没有texel偏移的一半，而纹理采样器却希望如此，因此您必须手动添加它。有时人们将其添加到顶点着色器中，有时将其添加到像素着色器中，有时在CPU上设置制服。这几乎是每天都有无尽错误的来源，尤其是在通过多种平台/ API发行的视频游戏中！ </p><p>   They can be [0, 1, 2, 3]. But GPUs use a convention of half pixel offsets, so they end up being [0.5, 1.5, 2.5, 3.5]. This translates to UVs, or “normalized” coordinates [0.5/4, 1.5/4, 2.5/4, 3.5/4], which spans a range of [0.5/width, 1 – 0.5/width].</p><p>它们可以是[0，1，2，3]。但是GPU使用半像素偏移的惯例，因此它们最终为[0.5、1.5、2.5、3.5]。这将转换为UV或“归一化”坐标[0.5 / 4、1.5 / 4、2.5 / 4、3.5 / 4]，其范围为[0.5 / width，1 – 0.5 / width]。</p><p> This representation seems counterintuitive at first, but what it provides us is a guarantee and convention that the  image corners are placed at  [0 and 1] normalized, or [0, width] unnormalized.</p><p> 起初，这种表示方式似乎违反直觉，但是它为我们提供了一个保证和约定，即图像角位于[0和1]归一化，或[0，宽度]未归一化。</p><p>     While the half a pixel align pixel corners,  the other way of down/upsampling comes from aligning the first pixel centers in the image.</p><p>     当半个像素对齐像素角时，向下/上采样的另一种方式来自对齐图像中的第一个像素中心。</p><p> Now, let’s have a look at how we compute the bilinear upsampling weights in the half a pixel shift convention:</p><p> 现在，让我们看一下如何在半像素移位惯例中计算双线性上采样权重：</p><p>  This convention makes it amazingly simple and obvious where the weights come from – and how simple the computation is once we align the grid corners. I personally use it as well even in APIs outside of GPU shader realm – everything is easier. If adding and removing 0.5 adds performance cost, then can be removed at microoptimizations stage, but usually doesn’t matter that much.</p><p>  该约定使权重从何处变得非常简单明了，而且一旦对齐网格角，计算就变得多么简单。即使在GPU着色器领域之外的API中，我也亲自使用它-一切都变得更加容易。如果添加和删除0.5会增加性能成本，则可以在微优化阶段将其删除，但通常没关系。</p><p>  Half a pixel offset for pixel centers used in GPU convention for both pixels and texels is a reasonable default for any image processing code dealing with images of different resolutions.</p><p>  对于处理不同分辨率图像的任何图像处理代码，GPU约定中针对像素和纹理像素使用的像素中心的半个像素偏移是一个合理的默认值。</p><p> This is expecially important when to dealing with textures of different resolutions and for example mip maps of non power of 2 textures. A texture with 9 texels instead of 4? No problem:</p><p> 在处理不同分辨率的纹理（例如，2幂的非幂的mip贴图）时，这特别重要。 9纹素而不是4的纹理？没问题： </p><p>  It makes sure that grids are aligned, and the up/downsampling operations “just work”. To get box/bilinear downsampling, you can just take a single bilinear tap of the source texture, the same with the upsampling.</p><p>它确保网格对齐，并且上/下采样操作“正常工作”。要获得盒/双线性下采样，您只需对源纹理进行一次双线性抽头，与上采样相同。</p><p> So trivial to use it that when you start graphics programming, you rarely think about it. Which is a double edge sword – both great for an easy entry point for beginners, but also a source of confusion once you start getting deeper into it and analyzing what’s going on or do things like fractional or nearest neighbor downsampling (or e.g. create a non-interpolable depth map pyramid…).</p><p> 使用它是如此简单，以至于当您开始图形编程时，您很少考虑它。这是一把双刃剑–既很适合初学者入门，也很容易引起混淆，一旦您开始深入了解它并分析正在发生的事情或进行小数或最近邻降采样（例如创建非采样）。 -可插入的深度图金字塔…）。</p><p> Even if there were no other reasons, this is why I’d recommend treating phase shifting box downsample and the [0.25 0.75] / [0.75 0.25] upsamplers  as your default when talking about bilinear as well.</p><p> 即使没有其他原因，这也是为什么我建议在讨论双线性时将移相箱下采样和[0.25 0.75] / [0.75 0.25]上采样器作为默认设置的原因。</p><p> Bonus advantage: having texel coordinates shifted by 0.5 means that if you want to get an integer coordinate – for example for texelFetch instruction – you don’t need to round. Floor / truncation (which in some settings can be a cheaper operation) gives you the closest pixel integer coordinate to index!</p><p> 优点：将texel坐标偏移0.5意味着如果要获取整数坐标（例如texelFetch指令），则无需四舍五入。地板/截断（在某些设置下可以更便宜的操作）为您提供最接近的像素整数坐标以进行索引！</p><p> Note:  Tensorflow got it wrong. The “align_corners” parameter aligns… centers of the corner pixels??? This is a really bad and weird naming plus design choice, where upsampling a [0.0 1.0] by factor of 2 produces [0, 1/3, 2/3, 1], which is something completely unexpected and different from either of the conventions I described here.</p><p> 注意：Tensorflow弄错了。 “ align_corners”参数对齐…角落像素的中心？？？这是一个非常糟糕的命名加上设计选择，将[0.0 1.0]乘以2会产生[0，1/3，2/3，1]，这是完全出乎意料的，并且与任何一种约定都不同我在这里描述了。</p><p>  I love writing about signal processing and analyzing signals also in the frequency domain, so let me explain here how you can model bilinear up/downsampling in the EE / signal processing framework.</p><p>  我喜欢写关于信号处理和在频域中分析信号的文章，所以让我在这里解释如何在EE /信号处理框架中对双线性上/下采样建模。</p><p>  If you never heard of this way of looking at it (especially the zero insertion), it’s most likely because in practice nobody in practice (at least in graphics or image processing) implements it like this, it would be super wasteful to do it in such a sequence. 🙂</p><p>  如果您从未听说过这种查看方式（尤其是零插入），则很可能是因为实际上没有人（至少在图形或图像处理中）实现这种方式，这样做非常浪费。这样的顺序。 🙂 </p><p>  Zero insertion is an interesting, counter-intuitive operation. You insert zeros between each element (often multiplying the original ones by 2x to preserve the constant/average energy in the signal; or we can fold this multiplication in our filter later) and get 2x more samples, but they are not very “useful”. You have an image consisting of mostly “holes”…</p><p>零插入是一个有趣的，违反直觉的操作。您在每个元素之间插入零（通常将原始元素乘以2x以保留信号中的恒定/平均能量；或者我们可以在以后的滤波器中将此乘积折叠），再获得2x的样本，但它们并不是非常“有用” 。您的图像主要由“孔”组成...</p><p>    From this plot, we can immediately see that with zero insertion, there are many high frequencies that were not there! All of those zeros create lots of high frequency coming from alternating and “oscillating” between the original signal, and zero. Filters that are “dilated” and have zeros in between coefficients (like a-trous / dilated convolution) are called  comb filters – because they resemble a comb teeth!</p><p>    从该图可以立即看到零插入时有很多高频不存在！所有这些零都会由于原始信号和零之间的交替和“振荡”而产生大量高频。被“扩张”并在系数之间为零的滤波器（如a-trous /扩张卷积）被称为梳状滤波器-因为它们类似于梳齿！</p><p> Let’s look at it from the spectral analysis. Zero insertion duplicates the frequency spectrum:</p><p> 让我们从光谱分析来看一下。零插入会复制频谱：</p><p>  Every frequency of the original signal is duplicated, but we know that there were no frequencies like this present in the smaller resolution image; it wasn’t possible to represent anything above its Nyquist! To fix that, we need to filter them out after this operation with a low pass filter:</p><p>  原始信号的每个频率都是重复的，但是我们知道在较小分辨率的图像中不存在这样的频率。奈奎斯特上方不可能代表任何东西！为了解决这个问题，我们需要在此操作之后使用低通滤波器将其过滤掉：</p><p>  I have shown some remainder frequency content on purpose, as it’s generally hard to do “perfect” lowpass filtering (and it’s also questionable if we’d want this – ringing problems etc).</p><p>  我故意显示了一些余下的频率内容，因为通常很难做到“完美”的低通滤波（如果我们想要的话，例如振铃问题，这也值得怀疑）。</p><p> Here is how progressively filtered 1D signal looks like, notice high frequencies and “combs” disappearing:</p><p> 这是经过逐步滤波的一维信号的样子，注意到高频和“梳”消失了：</p><p>  Here’s an animation of blurring/filtering on the 2D image and how there it also causes this zero-inserted image to become more and more like just properly upsampled:</p><p>  这是2D图片上的模糊/过滤动画，以及如何使这张零插入的图片变得越来越像正确地进行过采样处理： </p><p>  Looks like image blending, but it’s just blending filters – imo it’s pretty cool. 😎</p><p>看起来很像图像融合，但它只是融合滤镜-imo非常酷。 😎</p><p>  Obviously, the choice of the blur (or technically – lowpass) filter matters – a lot. Some interesting connection: what if we convolve this zero-inserted signal with a  symmetric [0.5, 0.5] (or 1,1 if we didn’t multiply the signal by 2 when inserting zeros) filter?</p><p>  显然，模糊（或技术上为低通）滤波器的选择非常重要。一些有趣的联系：如果将这个零插入信号与对称[0.5，0.5]（如果在插入零时不将信号乘以2的话，则为1,1）进行卷积该怎么办？</p><p>   The interesting part here is that we kind of  “reinvented” the nearest neighbor filter! After a second of though, this should be intuitive; a sample that is zero gets contributions from the single non-zero neighbor, which is like a copy, while the sample that is non-zero is surrounded by two zeros, and they don’t affect it.</p><p>   有趣的是，我们有点“改造”了最近的邻居过滤器！一秒钟之后，这应该很直观。零样本会从单个非零邻居获得贡献，就像一个副本，而非零样本会被两个零包围，并且它们不会对其产生影响。</p><p> We can see on the spectral / Fourier plot where the nearest neighbor hard edges and post-aliasing comes from (red part of the plot):</p><p> 我们可以在频谱/傅立叶图上看到最近的相邻硬边和后混叠来自哪里（图的红色部分）：</p><p>  The nearest neighbor upsampling is also shifting the signal (because it is even number of samples) and will work well to undo the box downsampling filter, which fits the common intuition of replicating samples being the “reverse” of box filtering and causing no shift problem.</p><p>  最近的邻居上采样也会移动信号（因为它是采样数的偶数），并且可以很好地撤消盒下采样滤波器，这符合复制采样的通常直觉，即盒滤波的“反向”并且不会引起移位问题。</p><p>  Let’s have a look at how the strategy of “keep one sample, interpolate between” can be represented in this framework.</p><p>  让我们看一下如何在此框架中表示“保留一个样本，在两个样本之间进行插值”的策略。</p><p> It’s equivalent to  filtering our zero-upsampled image with a [0.25 0.5 0.25] filter.</p><p> 这等效于使用[0.25 0.5 0.25]过滤器过滤零过采样的图像。 </p><p> The problem is that in such setup, if we multiply the weights two (to keep average signal the same) and then by zeros (where the signal is zero), we get alternating [0.0 1.0 0.0] and [0.5 0.0 0.5] filters, with very different frequency response and variance reduction… I’ll reference you here again to my previous blog post on it, but basically you get  alternating 1.0 and 0.5 of original signal variance (sum of effective weights squared).</p><p>问题在于，在这种设置中，如果我们将权重乘以2（以使平均信号保持相同），然后再乘以零（其中信号为零），则会得到交替的[0.0 1.0 0.0]和[0.5 0.0 0.5]滤波器，具有非常不同的频率响应和方差减小...我将在这里再次参考我以前的博客文章，但是基本上您会交替获得原始信号方差的1.0和0.5（有效权重平方的总和）。</p><p>  The second approach of alternating weights of [0.25 0.75] can be seen as simply: nearest neighbor upsampling – a filter of [0.5 0.5], and then [0.25 0.5 0.25] filtering!</p><p>  权重为[0.25 0.75]的第二种方法可以简单地看做：最近邻居上采样–过滤[0.5 0.5]，然后过滤[0.25 0.5 0.25]！</p><p> This sequence of two convolutions gives us an effective kernel of  [0.125 0.375 0.375 0.125] on the zero inserted image, so if we multiply it by 2 simply alternating [0.25 0.0 0.75 0.0] and [0.0 0.75 0.0 0.25].  Corners aligned bilinear upsampling (standard bilinear upsampling on the GPU) is exactly the same as the “magic kernel”! 🙂 This is also this second, more complicated explanation of bilinear 0.25 0.75 weights I promised.</p><p> 两个卷积的序列在零插入图像上为我们提供了[0.125 0.375 0.375 0.125]的有效核，因此，如果将其乘以2，则只需交替交替[0.25 0.0 0.75 0.0]和[0.0 0.75 0.0 0.25]。角对齐的双线性上采样（GPU上的标准双线性上采样）与“魔术核”完全相同！ also这也是我答应的第二个更复杂的双线性0.25 0.75权重的解释。</p><p> Advantage of it is that with the effective weight of [0.25 0.75] and [0.75 0.25] (ignoring zeros) on alternating pixels, they have the same amount of filtering and  variance reduction of 0.625 – very important!</p><p> 这样做的优点是，在交替像素上的有效权重为[0.25 0.75]和[0.75 0.25]（忽略零），它们具有相同的过滤量和0.625的方差减小–非常重要！</p><p>    Neither is perfect, but the even one will generally cause you less “problems”.</p><p>    两者都不是完美的，但是偶数通常会减少您的“问题”。</p><p>  By comparison, downsampling process should be a bit more familiar to readers who have done some computer graphics or image processing and know of aliasing in this context.</p><p>  相比之下，进行过一些计算机图形或图像处理并了解这种情况下别名的读者应该对下采样过程更为熟悉。</p><p> Downsampling consists of two steps in opposite order:  1. Filtering the signal.  2. Decimating the signal by discarding every other sample.</p><p> 下采样包括两个相反的步骤：1.过滤信号。 2.通过丢弃其他所有样本来抽取信号。 </p><p> The ordering and step no 1 is important, as the second step, decimating is equivalent to (re)sampling. If we don’t filter the signal spectrum above frequencies representible in the new resolution, we are going to end up with aliasing, folding back of frequencies above previous half Nyquist:</p><p>排序和第1步很重要，因为第二步，抽取等效于（重新）采样。如果我们不对新分辨率所能代表的频率之上的信号频谱进行滤波，那么我们将最终产生混叠，将频率回落到前一半奈奎斯特之上：</p><p>     First antialiasing filter we’d want to analyze would be our old friend “linear in box disguise”, [0.5, 0.5] filter. It is definitely imperfect, and we can see  both blurring, and some leftover aliasing:</p><p>     我们要分析的第一个抗锯齿滤波器是我们的老朋友“线性伪装”滤波器[0.5，0.5]。这绝对是不完美的，我们可以看到模糊和残留的混叠：</p><p>  The Graphics community realized this a while ago – when doing a series of downsamples for post-processing,  for example bloom / glare; the default box/tent/bilinear filters are pretty bad in such case. Even small aliasing like this can be really bad when it gets “blown” to the whole screen, and especially in motion. It was even a large chunk of Siggraph presentations, like  this excellent one from my friend Jorge Jimenez.</p><p>  图形社区不久前就意识到了这一点–在进行一系列后期处理的下采样时，例如光晕/眩光；在这种情况下，默认的框/帐篷/双线性过滤器非常糟糕。当这样的小混叠“吹”到整个屏幕时，尤其是在运动中，这种情况确实很糟糕。这甚至是Siggraph演示文稿中的很大一部分，例如我的朋友Jorge Jimenez的出色演讲。</p><p> I also had a personal stab at addressing it early in my career, and even described the idea – weird cross filter (because it was fast on the GPU) – please don’t do it, it’s a bad idea and very  outdated! 🙂</p><p> 在我职业生涯的早期，我也很想解决这个问题，甚至描述了这个想法–奇怪的交叉滤镜（因为它在GPU上速度很快）–请不要这样做，这是一个坏主意，而且已经过时了！ 🙂</p><p>  By comparison the odd bilinear filter (that doesn’t shift the phase) looks like a little different trade-off:</p><p>  相比之下，奇数双线性滤波器（不会移动相位）看起来有点不同：</p><p>  Less aliasing, more blurring. It might be better for many cases, but the trade-offs from breaking the half-pixel / corners aligned convention are IMO unacceptable. And it’s also more costly (not possible to do a single tap 2x downsampling).</p><p>  更少的锯齿，更模糊。在许多情况下可能会更好，但是从破坏半像素/角点对齐约定的取舍是IMO不能接受的。而且价格也更高（无法一次点击2倍下采样）。</p><p> To get better results -&gt; you’ll need more samples, some of them with negative lobes. And you can design an even filter with more samples too, for example even Lanczos:</p><p> 为了获得更好的结果-＆gt;您将需要更多样本，其中一些样本带有负瓣。您还可以设计一个包含更多样本的均匀滤波器，例如Lanczos： </p><p>   One interesting thing that has occurred to me on a few occasions is that the trade-offs for low pass filtering for upsampling and downsampling are different. If you use a “perfect” upsampling lowpass filter, you will end up with nasty ringing.</p><p>在某些情况下，我发生的一件有趣的事情是，对于低采样率和上采样率的权衡取舍是不同的。如果您使用“完美”的上采样低通滤波器，则会导致讨厌的振铃。</p><p> This is typically not the case for downsampling. So you can opt for a sharper filter when downsampling, and a less sharp for upsampling, and this is what Photoshop suggests as well:</p><p> 下采样通常不是这种情况。因此，在降采样时，您可以选择较锐利的滤镜，而在升采样时，则可以选择较不锐利的滤镜，这也是Photoshop的建议：</p><p>   I hope that my blog post helped to clarify some common confusions coming from using the same, very broad terms to represent some different operations.</p><p>   我希望我的博客文章有助于澄清使用相同的非常广泛的术语来表示某些不同操作所引起的一些常见混淆。</p><p>  There are  a few ways of doing bilinear upsampling and downsampling. Make sure that whatever you use uses the same convention and  doesn’t shift your image after down/upsampling.</p><p>  有几种方法可以进行双线性上采样和下采样。确保您使用的任何内容都使用相同的约定，并且在下采样/上采样后不会偏移图像。</p><p> Half pixel center offset is a very convenient convention. It ensures that  image borders and corners are aligned. It is default on the GPU and happens automatically. When working on the CPU/DSP, it’s worth using the same convention.</p><p> 半像素中心偏移是一个非常方便的约定。它可以确保图像的边界和角对齐。它是GPU上的默认设置，并且会自动发生。在CPU / DSP上工作时，值得使用相同的约定。</p><p> Different ways of upsampling/downsampling have different freque</p><p> 不同的上采样/下采样方式具有不同的频率</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bartwronski.com/2021/02/15/bilinear-down-upsampling-pixel-grids-and-that-half-pixel-offset/">https://bartwronski.com/2021/02/15/bilinear-down-upsampling-pixel-grids-and-that-half-pixel-offset/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/像素/">#像素</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pixel/">#pixel</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/采样/">#采样</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>