<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>SWIFT与C++的互操作性</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">SWIFT与C++的互操作性</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-17 19:38:16</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/9288d7ad6e1e89befcae18c6478b039f.png"><img src="http://img2.diglog.com/img/2020/10/9288d7ad6e1e89befcae18c6478b039f.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>We can make changes to the Swift language and the standard library. The proposed changes must fit Swift&#39;s goals and philosophy. In other words,the proposed changes must have a reasonable chance to be accepted by theSwift community. For example, a change that requires an ABI break on Appleplatforms is a non-starter.</p><p>我们可以对SWIFT语言和标准库进行更改。提议的改变必须符合SWIFT的目标和理念。换句话说，提议的改变必须有合理的机会被SWIFT社区接受。例如，在ApplePlatforms上需要ABI中断的更改是不可能的。</p><p> Forking the Swift language or standard library, or creating a dialectwithout a fork (and therefore, being able to make radical changes to Swift&#39;sgoals, philosophy, safety, or ergonomics) are not interesting options, andtherefore, are not considered or discussed.</p><p>派生SWIFT语言或标准库，或者创建没有派生的方言(因此，能够对SWIFT的目标、哲学、安全性或人体工学进行根本改变)都不是有趣的选择，因此不会考虑或讨论。</p><p> We can make limited changes to the C++ code, toolchain, standard libraryimplementation, and runtime environment. The cost of such changes must be taken into account. Changes that require anABI break for C++ might be interesting for users who control the completetoolchain, but are non-starters for the community at large; therefore, suchchanges can only be considered an optimization. Changes that requiresignificant manual work on existing C++ code by end users can also beconsidered only as optimizations or improvements for ergonomics.</p><p>我们可以对C++代码、工具链、标准库实现和运行时环境进行有限的更改。必须考虑到这些变化的成本。对于控制完整链条的用户来说，需要Anabi Break for C++的更改可能会很有趣，但是对于整个社区来说，这些更改是不可能的；因此，这样的更改只能被视为优化。需要终端用户在现有C++代码上进行大量手动工作的更改也只能被认为是对人体工程学的优化或改进。</p><p>   What are the properties of a good interoperability layer? Exercisinginteroperability is not in itself a goal of any Swift or C++ user. Therefore,for API users interoperability should be maximally transparent in all aspects:API design and ergonomics, editor integration and tooling, and performance. ForAPI vendors, interoperability should not be a significant extra burden, whileallowing API vendors to own and curate the imported API surface. Let&#39;s discusswhat these points mean.</p><p>良好的互操作性层的属性是什么？增强互操作性本身并不是任何SWIFT或C++用户的目标。因此，对于API用户来说，互操作性应该在所有方面都最大限度地透明：API设计和人机工程学、编辑器集成和工具，以及性能。对于API供应商来说，互操作性不应该是一个重大的额外负担，同时允许API供应商拥有和管理导入的API图面。让我们讨论一下这几点是什么意思。</p><p> API design and ergonomics. Ideally, users working in Swift should not feelany difference between native Swift APIs and imported C++ APIs.</p><p>API设计和人体工程学。理想情况下，在SWIFT中工作的用户应该不会感觉到本地SWIFT API与导入的C++API之间有任何区别。</p><p> For example, while it is possible to write a custom hashtable in Swift, it isdone extremely rarely, and most code uses the vocabulary types  Set and Dictionary. Therefore, if C++ APIs that used  std::unordered_map or flat_hash_map types, when imported in Swift, would continue using those C++map types, they would look weird and foreign in Swift. Idiomatic Swift code thatuses  Set and  Dictionary will have to convert the data into these foreignhashtable types before calling imported C++ APIs.</p><p>例如，虽然可以在SWIFT中编写自定义哈希表，但很少这样做，而且大多数代码都使用词汇类型Set和Dictionary。因此，如果使用STD：：UNORDERED_MAP或FLAT_HASH_MAP类型的C++API在SWIFT中导入时会继续使用这些C++映射类型，则它们在SWIFT中看起来会很奇怪。使用Set和Dictionary的惯用SWIFT代码在调用导入的C++API之前必须将数据转换为这些外来哈希表类型。</p><p> As another example, C++ functions often receive values by const reference or byconst pointer. Semantically, the closest equivalent in Swift is  UnsafePointer.However,  UnsafePointer is not as common in Swift as const references are inC++; it is not idiomatic for Swift APIs to accept  UnsafePointer outside of acouple exceptional situations (for example, implementations of low-levelfacilities, performance-sensitive code, etc.) Therefore, if C++ APIs, whenimported in Swift, would use  UnsafePointer a lot, they would look weird andforeign in Swift. Imported C APIs, when they are not operating on Objective-Ctypes, already use  UnsafePointer a lot, and look non-idiomatic because ofthat. Swift provides some affordances that make calling them easier.</p><p>又如，C++函数通常通过常量引用或按常量指针接收值。语义上，SWIFT中最接近的等价物是UnsafePointer。但是，UnsafePointer在SWIFT中并不常见，因为常量引用是Inc++；SWIFT API在耦合异常情况(例如，实现低级设施、对性能敏感的代码等)之外接受UnsafePointer是不习惯的。因此，如果C++API在导入SWIFT时会大量使用不安全指针，那么它们在SWIFT中会显得奇怪和陌生。导入的CAPI，当它们不在Objective-Ctype上操作时，已经使用了很多不安全指针，因此看起来不太习惯。SWIFT提供了一些费用，使呼叫他们变得更容易。</p><p> Editor integration and tooling should transparently support code in bothlanguages. To the extent possible, all editor operations should &#34;see through&#34;the interop. For example, if the user invokes the &#34;rename function&#34; refactoring,it should rename all definitions, declarations, and usages across Swift and C++code. This goal has been largely achieved for Swift/Objective-C interop, and weare planning to rely on the same mechanisms for Swift/C++ interop.</p><p>编辑器集成和工具应该透明地支持这两种语言的代码。在可能的范围内，所有的编辑器操作都应该看透互操作。例如，如果用户调用重命名函数重构，它应该重命名SWIFT和C++代码中的所有定义、声明和用法。SWIFT/Objective-C互操作在很大程度上已经实现了这一目标，我们计划依赖于SWIFT/C++互操作的相同机制。</p><p> Performance. C++ APIs, when used from Swift, ideally, should haveperformance characteristics identical to when they are used from C++.</p><p>表演。理想情况下，从SWIFT使用C++API时，其性能特征应与从C++使用时相同。</p><p> Interop must not be a burden for API vendors. Enabling Swift code to call acertain C++ library should create minimal burden for the owners of that C++library. Ideally, it should be possible without any involvement of the owners.</p><p>互操作不能成为API供应商的负担。使SWIFT代码能够调用特定的C++库应该会给该C++库的所有者带来最小的负担。理想情况下，这应该可以在没有业主参与的情况下进行。</p><p> For example, requiring the API owners to create an API description file (like inCLIF for Python), or a glue layer (like in JNI for Java) is a significantburden. Most API owners are not going to do it without specific requests fromusers, and even when such request is received, many API owners will carefullyconsider if they want to take on maintenance of this extra file.</p><p>例如，要求API所有者创建API描述文件(如CLIF for Python)或胶合层(如JNI for Java)是一项重大负担。如果没有用户的具体要求，大多数API所有者是不会这样做的，即使收到这样的请求，许多API所有者也会仔细考虑是否要承担这个额外文件的维护工作。</p><p> It may be possible to allow users to do the work necessary to expose a C++library to Swift, however, that is not a great option either. A C++ librarymight end up with multiple (incompatible) bindings of varying quality, coveringdifferent parts of the API. In addition, the owner of the API loses control ofthe API surface.</p><p>也许可以让用户完成向SWIFT公开C++库所需的工作，但是，这也不是一个很好的选择。一个C++库可能最终会有多个(不兼容的)质量不同的绑定，覆盖API的不同部分。此外，API的所有者将失去对API图面的控制。</p><p> Allow API vendors to own and curate the imported API surface. While theminimal amount of work to expose a C++ library to Swift should be ideally &#34;none&#34;(it should just work), API vendors should own the Swift API surface of their C++libraries, and should be able to adjust it where the automated interop is notsatisfactory.</p><p>允许API供应商拥有和管理导入的API表面。虽然向SWIFT公开C++库的最小工作量理想情况下应该是零(应该可以)，但API供应商应该拥有其C++库的SWIFT API图面，并且应该能够在自动化互操作不能令人满意的地方对其进行调整。</p><p> Tension and conflicts between goals. These goals are conflicting. Forexample, API ergonomics are in conflict with performance: we can provide a moreergonomic API if we automatically bridge C++ types to corresponding Swiftvocabulary types at the API boundary, however, these type conversions will costCPU cycles. The solutions will be designed on a case by case basis: sometimes,we will pick one side of the tradeoff, sometimes we will pick one side but allowthe user to override the default, and sometimes we will add multiple facilitiesthat pick different sides, forcing the user to choose.</p><p>目标之间的紧张和冲突。这些目标是相互冲突的。例如，API人机工程学与性能是冲突的：如果我们在API边界自动将C++类型桥接到相应的SwiftWorldger类型，我们可以提供更符合人机工程学的API，然而，这些类型转换将耗费CPU周期。解决方案将根据具体情况进行设计：有时，我们会选择权衡的一方，有时我们会选择一方但允许用户覆盖默认值，有时我们会添加多个工具来选择不同的一方，迫使用户做出选择。</p><p>  Swift/C++ interoperability builds on top of the Swift/C interoperability, so ithelps to be familiar with  Swift&#39;s strategy for importing Cmodules.</p><p>SWIFT/C++互操作性建立在SWIFT/C互操作性之上，因此熟悉SWIFT导入C模块的策略很有帮助。</p><p>      Member functions with non-identifier names are discussed in the section aboutclasses. Other constructs are discussed in their respective sections.</p><p>具有非标识符名称的成员函数在关于类一节中讨论。其他构造将在其各自的部分中讨论。</p><p>   In C++, there are no language requirements for pointers passed as functionarguments. For example, given a function signature like this:</p><p>在C++中，作为函数参数传递的指针没有语言要求。例如，给定如下的函数签名：</p><p>  C++ as a language poses no requirements for  value to live long enough duringthe function call, or even that  value points to valid memory when thefunction is called;  value can be null or it can be an invalid (for example,freed) pointer. There are also no requirements about the memory pointed to by value being initialized, or valid to dereference without data races. Pointersare also allowed to alias other memory, as long as the types are compatible.Pointers also don&#39;t imply anything about ownership or non-ownership.</p><p>作为一种语言，C++对值在函数调用期间的生存时间没有任何要求，甚至在调用函数时该值也指向有效内存；值可以是空的，也可以是无效的(例如，释放的)指针。对于被初始化的值所指向的内存也没有要求，或者在没有数据争用的情况下对取消引用是有效的。指针也可以作为其他内存的别名，只要它们的类型是兼容的。指针也不暗示任何所有权或非所有权。</p><p> Rules in C++ about references are a bit tighter, but not much. The onlydifferences are that a reference can&#39;t be null, and that it must be bound to avalid object when it is initially created.</p><p>C++中关于引用的规则稍微严格一些，但并不多。唯一的区别是引用不能为空，并且在最初创建时必须绑定到avalid对象。</p><p> In practice, engineers working in C++ often make the following assumptions aboutthird-party APIs, even though these properties are not guaranteed by thelanguage, and are often not explicitly documented by the API:</p><p>在实践中，使用C++的工程师经常对第三方API做出以下假设，即使语言不能保证这些属性，并且API通常没有明确记录这些属性：</p><p> Almost all pointers passed to a function remain valid to dereference while thefunction is running.</p><p>当函数运行时，几乎所有传递给函数的指针对于取消引用都是有效的。</p><p>  Almost all pointers passed to a function point to initialized data. Passing apointer to uninitialized memory and expecting the function to initialize ithappens occasionally, but it is not common.</p><p>几乎所有传递给函数的指针都指向初始化的数据。将apointer传递给未初始化的内存，并期望函数初始化它偶尔会发生，但这种情况并不常见。</p><p> In Swift, passing unsafe pointers as function arguments is not idiomatic.Idiomatic code passes structs by value, and classes by reference.  inoutparameters in Swift allow functions to read and modify storage specified by thecaller. The argument for the  inout parameter must be a storage referenceexpression.</p><p>在SWIFT中，将不安全的指针作为函数参数传递并不是惯用的做法。自然代码按值传递结构，按引用传递类。SWIFT中的INOUT参数允许函数读取和修改调用方指定的存储。InOut参数的实参必须是存储引用表达式。</p><p> func  increment( _  value:  inout  Int) { value  +=  1} struct  TwoInts {  var x :  Int  =  0  var y :  Int  =  0} func  caller() {  var ints  =  TwoInts()  increment( &amp;ints. x)   // ints.x is 1    // ints.y is 0 }</p><p>函数增量(_value：InOut Int){value+=1}struct TwoInts{var x：int=0var y：int=0}Funcc Caller(){var int=TwoInts()Increment(&amp；INT.。X)//ints.x为1//ints.y为0}</p><p> To understand the constraints that Swift puts on  inout parameters, let&#39;s takea look at the mental model for introduced in the  Ownershipmanifesto and in  SE-0176 Enforce Exclusive Access toMemory.When the caller binds a storage reference to an  inout parameter, it starts anon-instantaneous access to the whole value that occupies the storage. Thisaccess ends when the callee returns. Overlapping accesses are not allowed, andtherefore, while an  inout parameter is live, original value may not beaccessed.</p><p>要了解SWIFT对InOut参数施加的约束，让我们看看所有权声明和SE-0176中引入的的心理模型。当调用方将存储引用绑定到InOut参数时，它会立即开始访问占用存储的整个值。此访问在被调用方返回时结束。不允许重叠访问，因此，当InOut参数处于活动状态时，可能无法访问原始值。</p><p> (Note that before the ownership manifesto,  inout parameters were explained interms of a different model that might be easier to understand. Nevertheless,both models are equivalent. The old model stated that on function entry, thevalue is moved from the caller-specified storage reference into the  inoutparameter, and moved from the  inout parameter back into the original storageon function exit. During the execution of the function, the original storageremains uninitialized, and therefore, the whole value that occupied that storageremains inaccessible until the function returns.)</p><p>(请注意，在所有权声明之前，InOut参数使用了一个可能更容易理解的不同模型进行了解释。然而，这两种模式是等价的。旧模型规定，在函数进入时，值从调用方指定的存储引用移到inout参数中，然后从InOut参数移回函数退出时的原始存储中。在函数执行期间，原始存储区未初始化，因此，占用该存储区的整个值在函数返回之前不可访问。)。</p><p> In practice,  inout parameters are implemented as passing a pointer to thestorage that should be mutated, while maintaining behavior identical to themodels explained above. As a consequence of these models,  inout parametersprovide the following guarantees:</p><p>在实践中，InOut参数被实现为传递指向应该改变的存储的指针，同时保持与上面解释的模型相同的行为。作为这些模型的结果，输入输出参数提供以下保证：</p><p> the memory backing an  inout parameter is valid to access throughout theexecution of a function.</p><p>支持INOUT参数的内存在函数执行期间有效访问。</p><p>  inout parameters are valid to read and modify throughout the execution ofa function without data races, unless the function itself has shared theparameter with multiple threads.</p><p>除非函数本身已与多个线程共享参数，否则在函数执行过程中读取和修改In Out参数都是有效的，而不会发生数据争用。</p><p> inout are backed by initialized memory on function entry and function exit(an implication of the copy-in/copy-out semantics). Destroying the object in inout requires using unsafe construts. Therefore, in safe Swift  inoutparameters are backed by initialized memory throughout function execution.</p><p>INOUT由函数进入和函数退出时的初始化内存支持(拷贝入/拷贝出语义的含义)。销毁InOut中的对象需要使用不安全的构造。因此，在安全的SWIFT中，输入输出参数在整个函数执行过程中都由初始化内存提供支持。</p><p> inout parameters don&#39;t alias each other or any other values that program isallowed to access at that point. Remember that the original value that isbound to an  inout parameter is inaccessible for the duration of the  inoutbinding.</p><p>InOut参数不会彼此别名，也不会给程序在该点上允许访问的任何其他值设置别名。请记住，绑定到InOut参数的原始值在inoutbinding期间是不可访问的。</p><p> In practice, non-const pointers and references in function parameters are mostoften used for the same purpose as Swift&#39;s  inout, so it is desirable to mapthem to each other.</p><p>在实践中，函数参数中的非常数指针和引用通常用于与SWIFT的InOUT相同的目的，因此最好将它们相互映射。</p><p>  // C++ header imported in Swift (possible mapping).  func  incrementBoth( _  value1:  inout  Int,  _  value2:  inout  Int)</p><p>//SWIFT中导入的C++头(可能是映射)。函数增量Both(_value1：InOut Int，_Value2：InOut Int)。</p><p> The  incrementBoth function imported like this has more restrictions in Swiftthan in C++ (for example, arguments may not alias). Calling this C++ functionfrom Swift does not create a new kind of safety issues in Swift, because alanguage with more restrictions calls a language with fewer restrictions. Fromthe API point of view, it should not be a problem either, unless the callerneeds to pass arguments that alias (Swift&#39;s enforcement of exclusivity willprevent that).</p><p>这样导入的incrementBoth函数在SWIFT中比在C++中有更多的限制(例如，参数可能没有别名)。从SWIFT调用此C++函数不会在SWIFT中产生新的安全问题，因为限制较多的语言调用限制较少的语言。从API的观点来看，这也不应该是问题，除非调用者需要传递别名的参数(SWIFT对排他性的强制执行将阻止这一点)。</p><p> Based on the comparison above, it looks like Swift&#39;s  inout provides strictlymore guarantees than C++&#39;s non-const pointers and references. Therefore, it isnot safe to map them to each other in all cases. For example, we can&#39;t applythis mapping when Swift is implementing a function exposed to C++, for example:</p><p>基于以上比较，看起来SWIFT的InOut提供的保证比C++的非常数指针和引用严格得多。因此，在所有情况下将它们相互映射是不安全的。例如，当SWIFT实施向C++公开的函数时，我们不能应用此映射，例如：</p><p>  // C++ header imported in Swift (possible mapping).  protocol  Incrementer {  func  incrementBoth( _  value1:  inout  Int,  _  value2:  inout  Int)} struct  MyIncrementer:  Incrementer {  func  incrementBoth( _  value1:  inout  Int,  _  value2:  inout  Int) {   // The language requires that `value1` and `value2` don&#39;t alias.  }}</p><p>//SWIFT中导入的C++头(可能是映射)。Protocol Incrementer{func incrementBoth(_value1：InOut Int，_value2：InOut Int)}struct MyIncrementer：Incrementer{func incrementBoth(_value1：InOut Int，_value2：InOut Int){//语言要求`value1`和`value2`不使用别名。}}。</p><p> It would be unsafe to expose an Swift implementation of Incrementer.incrementBoth through the C++ signature, unless the C++ functionalready has Swift-like preconditions for pointer arguments. For true inoutparameters in C++, those preconditions should in fact hold, even if the C++function does not formally document them.</p><p>通过C++签名公开Incrementer.incrementBoth的SWIFT实现是不安全的，除非C++函数已经具有类似SWIFT的指针参数前提条件。对于C++中真正的inout参数，这些前提条件实际上应该成立，即使C++函数没有正式记录它们。</p><p>  In C++, const references in function arguments are most often used to avoidcopying objects passed to functions. Swift solves this problem in two ways:</p><p>在C++中，函数参数中的常量引用最常用于避免复制传递给函数的对象。SWIFT通过两种方式解决此问题：</p><p> by providing language features that allow the engineer to introduceindirections (for example, reference types, existential types, indirect enumcases, tools for defining copy-on-write types),</p><p>通过提供允许工程师引入间接地址的语言特征(例如，引用类型、存在类型、间接枚举情况、用于定义写入时复制类型的工具)，</p><p> It is not feasible to automatically map C++ const references to Swift-specificindirections like class types, because that would require changing the memorylayout through non-trivial bridging.</p><p>将C++常量引用自动映射到特定于SWIFT的间接指令(如类类型)是不可行的，因为这需要通过非常重要的桥接来更改内存布局。</p><p>  We can easily map C++ const references in function parameters to UnsafePointer&lt;T&gt; in Swift, however, the resulting APIs will not lookidiomatic. They will be usable from Swift, because Swift code can make an unsafepointer with the  &amp; operator, however, it can only be applied to mutablestorage locations. Therefore, more variables will be mutable in Swift thannecessary. Furthermore, to make some values mutable, the code will need tomake a copy that will be stored in a mutable variable -- defeating the point ofthe C++ API taking a const reference.</p><p>我们可以很容易地将函数参数中的C++常量引用映射到SWIFT中的UnsafePointer&lt；T&gt；，但是，生成的API看起来不那么地道。它们将可从SWIFT使用，因为SWIFT代码可以使用&amp；运算符创建不安全指针，但是，它只能应用于可变存储位置。因此，在SWIFT中有更多变量是可变的，这是不必要的。此外，要使某些值可变，代码将需要创建一个副本，该副本将存储在可变变量中--这与C++API采用常量引用的观点不符。</p><p>   // Usage example. void  caller() {  var x  =  42  printInt( &amp;x)   // OK   let y  =  42  printInt(y)   // error: type mismatch: `Int` is not an `UnsafePointer&lt;Int&gt;`   printInt( &amp;y)   // error: can&#39;t apply `&amp;` to an immutable value }</p><p>//使用示例。Void caller(){var x=42 printInt(&amp；x)//OK let y=42 printInt(Y)//错误：类型不匹配：`Int`不是`UnsafePointer&lt；Int&gt；`printInt(&amp；y)//错误：可以&#39；t将`&amp；`应用到不可变值}。</p><p>  To eliminate the extra copies that the code would have to perform to make somevalues mutable, we could extend the Swift language to allow applying  &amp; toimmutable values, producing an  UnsafePointer&lt;T&gt;.</p><p>要消除代码为使某些值可变而必须执行的额外副本，我们可以扩展SWIFT语言，以允许将&amp；应用于不可变值，从而生成一个不安全的指针T&gt；。</p><p>   A more ergonomic approach would be to import C++ const references to value typesas values, but still use a by-reference calling convention behind the scenes.</p><p>一种更符合人体工程学的方法是将C++常量引用导入到值类型as值，但仍在幕后使用按引用调用约定。</p><p>    The imported  printInt function that takes an  Int by value would be a thunkthat calls the actual C++ entry point that takes an  Int by a const reference.A mandatory optimization pass would inline that thunk into its callers, andeliminate the copies that now became unnecessary.</p><p>导入的接受Int by值的printInt函数将是调用实际C++入口点的thunk，该入口点通过常量引用接受Int。强制优化传递会将该thunk内联到其调用方，并消除现在变得不必要的副本。</p><p> It is important to understand that this approach only works in cases where thecompiler can insert a thunk. Here&#39;s an example where the compiler can&#39;ttransparently wrap a function pointer into a thunk, and therefore can&#39;t import const int&amp; as  Int32:</p><p>重要的是要理解，这种方法只有在编译器可以插入thunk的情况下才有效。以下是编译器可以透明地将函数指针包装到thunk中的一个示例，因此不能将const int导入为Int32：</p><p>   One disadvantage is that this approach provides less control: the caller can&#39;tspecify or predict the exact address that is passed to the C++ function (becauseSwift can make copies of values or move them around in memory). Most functionsreceiving  const T&amp; parameters should not care about the exact address, butsome might.</p><p>一个缺点是，这种方法提供的控制较少：调用者可以指定或预测传递给C++函数的确切地址(因为SWIFT可以复制或在内存中移动它们)。大多数接收常量T&amp；参数的函数不应该关心确切的地址，但有些函数可能会关心。</p><p> Another disadvantage of this approach is that it is safe in many cases inpractice, but users can construct unsafe cases. Specifically, if the C++ codebeing called persists the reference that was passed by Swift beyond the durationof the function call, that reference can become invalid (because Swift codecould pass an address of a temporary, implicitly materialized by the compiler).The nature of unsafety is identical between option 1, option 2, and existingSwift/C interop, however, in option 2, where we import C++ references as Swiftvalues, it is not visible to the Swift programmer that the function being calledaccepts an address.</p><p>这种方法的另一个缺点是，在实践中，它在许多情况下是安全的，但是用户可以构造不安全的案例。具体地说，如果被调用的C++代码将SWIFT传递的引用持久化到函数调用的持续时间之外，则该引用可能无效(因为SWIFT编解码器可以传递由编译器隐式物化的临时地址)。选项1、选项2和现有的SWIFT/C互操作的不安全性质是相同的，但是，在选项2中，我们将C++引用作为SWIFT值导入，被调用的函数接受地址对于SWIFT程序员来说是不可见的。</p><p>  C++ has complex overload resolution rules, in part to support certain API designpatterns. Some API design patterns appeared as a consequence of overloadresolution rules. Therefore, in C++ an &#34;API atom&#34; is an an overload set, not anindividual function ( CppCon 2018: Titus Winters &#34;Modern C++ Design (part 1 of2)&#34;). The same is also the case inSwift, so, fundamentally, there is no impedance mismatch here.</p><p>C++具有复杂的重载解析规则，部分原因是为了支持某些API设计模式。一些API设计模式作为重载解决规则的结果出现。因此，在C++中，API ATOM&#34；是一个重载集合，而不是单个函数(CppCon 2018：Ttus Winters&#34；Modern C++Design(Part 1 Of 2)&#34；)。SWIFT的情况也是如此，因此，从根本上说，这里不存在阻抗失配。</p><p> However, C and Objective-C interoperability imports each function and methodseparately. For C++ interoperability, we should recognize design patterns thatuse overload sets, and map them appropriately to Swift.</p><p>但是，C和Objective-C互操作性分别导入每个函数和方法。对于C++互操作性，我们应该识别使用重载集的设计模式，并将它们适当地映射到SWIFT。</p><p> One such C++ pattern is providing two overloads: one that takes a  const T&amp; andanother that takes a  T&amp;&amp;. If we attempt to naively map them to Swift, theywould map to the same signature. If we import just one of them and ignore theother, we would be leaving performance on the table.</p><p>一种这样的C++模式提供了两个重载：一个接受常量T&amp；，另一个接受T&amp；。如果我们试图天真地将它们映射到SWIFT，它们就会映射到相同的签名。如果我们只导入其中一个，而忽略另一个，我们将把性能放在桌面上。</p><p> The easiest way to map such overload sets is to import the  T&amp;&amp; overload as afunction that takes the argument by value, and ignore the  const T&amp; overload.This approach does create a small amount of performance overhead (an extramove), but does not require changing the Swift language or type checker torecognize the concept of temporaries. The SIL optimizer seems like theappropriate place to opportunistically reclaim that performance, by removingunnecessary moves of temporaries where possible, and replacing calls to thethunk with calls to the most appropriate C++ entry point.</p><p>映射此类重载集的最简单方法是将T&amp；&amp；重载作为按值接受参数的函数导入，并忽略常量T&amp；重载。此方法确实会产生少量的性能开销(Extra Move)，但不需要更改SWIFT语言或类型检查器来识别临时的概念。SIL优化器似乎是机会主义地回收性能的合适位置，它在可能的情况下删除了不必要的临时移动，并将对thunk的调用替换为对最合适的C++入口点的调用。</p><p>  // C++ header imported in Swift.  struct  Tensor {  ... } func  processTensor(  _: Tensor) {   // call `void processTensor(Tensor&amp;&amp;)` }</p><p>//SWIFT中导入的C++头。Struct张量{...}函数process张量(_：张量){//调用`void process张量(张量&amp；&amp；)`}。</p><p>  // Equivalent of SIL code after optimizations.   // void processTensor(const Tensor&amp;);  func  processTensorByConstRef(  _:  UnsafePointer&lt;Tensor&gt;)  // void processTensor(Tensor&amp;&amp;);  func  processTensorByRvalueRef(  _:  UnsafeMutablePointer&lt;Tensor&gt;) func  useTensor() {  var x  =  Tensor()  processTensorByConstRef(x)  processTensorByRvalueRef(x)   // Automatically move the value because it is obviously not used anymore. }</p><p>//优化后的SIL代码的等价物。//void process张量(Const张量&amp；)；func processTensorByConstRef(_：UnsafePointer&lt；张量&gt；)//void processTensorByRvalueRef(_：UnsafeMutablePointer&lt；Tvar&gt；)func processTensorByRvalueRef(_：UnsafeMutablePointer&lt；Tvar&gt；)func processTensorByConstRef(X)processTensorByRvalueRef(X)//自动移动值，因为它显然不再使用。}。</p><p> Once move-only types are added to Swift, the same mapping technique becomesapplicable to C++ move-only value types as well, with the only difference thatargument of the imported function would be marked as being consumed.</p><p>一旦将仅移动类型添加到SWIFT中，同样的映射技术也适用于C++仅移动值类型，唯一的区别是导入函数的参数将被标记为正在使用。</p><p>  Inline functions (both free and member functions) are used in C++ a lot morethan inline functions in C. For inline functions in C++, Swift should use thesame strategy as it uses currently for C: use Clang&#39;s CodeGen libraries toemit definitions of inline functions into one LLVM module together with Swiftcode.</p><p>与C中的内联函数相比，C++中使用内联函数(自由函数和成员函数)的次数要多得多。对于C++中的内联函数，SWIFT应使用它目前在C中使用的相同策略：使用Clang的CodeGen库将内联函数的定义与SWIFT代码一起发送到一个LLVM模块中。</p><p>  Namespaces and modules in C++ are orthogonal concepts. Namespaces in C++ canspan multiple modules; C++ namespaces can also be nested. In Swift, modules arenamespaces.</p><p>C++中的命名空间和模块是正交概念。C++中的命名空间可以跨越多个模块；C++命名空间也可以嵌套。在SWIFT中，模块是命名空间。</p><p>  There are precedents for using empty enums as namespaces in Swift (for example, CommandLine,  Unicode,  Unicode.UTF8 in the standard library).However, empty enums are not a perfect substitute for C++ namespaces:</p><p>在SWIFT中使用空枚举作为命名空间是有先例的(例如，标准库中的CommandLine、Unicode、Unicode.UTF8)。但是，空枚举不是C++命名空间的完美替代品：</p><p> Swift has no  using-like construct that allows code to avoid qualifying namesnested in an enum (in other words, names nested within an enum must be alwaysqualified with the name of that enum when used).</p><p>SWIFT没有允许代码避免限定嵌套在枚举中的名称的类Using-Like构造(换句话说，在使用枚举时，嵌套在枚举中的名称必须始终使用该枚举的名称)。</p><p> C++ namespaces can span multiple modules. We don&#39;t want every imported C++module to define its own empty enum, as that will lead to name collisions,which will require even more qualification from users.</p><p>C++命名空间可以跨越多个模块。我们不希望每个导入的C++模块都定义自己的空枚举，因为这将导致名称冲突，这将需要用户进行更多的限定。</p><p>     // Usage example: everything works well when we import only `CppButton`.  import  CppButton func  makeButton() {  var b1  =  Button()   // error: no such type   var b2  = widgets. Button()   // OK }</p><p>//用法示例：只导入`CppButton`，一切正常。导入CppButton函数makeButton(){var b1=Button()//错误：没有这样的类型var b2=widgets。按钮()//确定}。</p><p> // Usage example: ambiguities when we import both `CppButton` and `CppTextbox`.  import  CppButton import  CppTextbox func  makeButton() {  var b1  =  Button()   // error: no such type   var b2  = widgets. Button()   // error: name `widgets` is ambiguous, did you mean `CppButton.widgets` or `CppTextbox.widgets`?   var b3  = CppButton. widgets. Button()}</p><p>//用法示例：同时导入`CppButton`和`CppTextbox`时的歧义。Import CppButton import CppTextbox func makeButton(){var b1=Button()//错误：没有这样的类型var b2=widgets。Button()//错误：`widgets`名称不明确，是指`CppButton.widgets`还是`CppTextbox.widgets`？Var b3=CppButton。小工具。按钮()}。</p><p>  We could fix the ambiguity between same-named namespace enums defined bymultiple C++ modules by synthesizing an extra Swift module that will containonly the enums that make up the namespace structure, and then making all otherC++ modules define extensions for those enums.</p><p>我们可以解决由多个C++模块定义的同名命名空间枚举之间的歧义，方法是合成一个额外的SWIFT模块，该模块将只包含组成命名空间结构的枚举，然后使所有其他C++模块定义这些枚举的扩展。</p><p>    // Usage example.  import  CppButton import  CppTextbox  // Implicitly injected: import CppNamespaces  func  makeButton() {  var b1  =  Button()   // error: no such type   var b2  = widgets. Button()   // OK }</p><p>//使用示例。Import CppButton import CppTextbox//隐式注入：import CppNamespaces func makeButton(){var b1=Button()//错误：没有这样的类型var b2=widgets。按钮()//确定}</p><p> An incidental readability advantage of using enum extensions is that thepretty-printed module interface for C++ modules will use the keyword  extensionfor namespaces instead of  enum, reducing the confusion potential.</p><p>使用枚举扩展的一个附带的可读性优势是，C++模块的Pretty打印模块接口将使用名称空间的关键字扩展，而不是枚举，从而减少混淆的可能性。</p><p>  Some C++ libraries define namespaces with long names, or deeply nestednamespaces. C++ users of such libraries often prefer to avoid typing and seeingsuch namespace qualifiers in their code. To help use these libraries in Swift,we could add a construct similar to C++  using, that would expand the namelookup into the given empty enum.</p><p>一些C++库使用长名称或深度嵌套的名称空间来定义名称空间。这类库的C++用户通常倾向于避免在他们的代码中键入和看到这样的命名空间限定符。为了帮助在SWIFT中使用这些库，我们可以添加一个类似于C++Using的构造，将namelLookup扩展到给定的空枚举。</p><p> // Usage example.  import  CppButton import  CppTextbox  // Implic</p><p>//使用示例。导入CppButton导入CppTextBox//含义。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/apple/swift/blob/main/docs/CppInteroperabilityManifesto.md">https://github.com/apple/swift/blob/main/docs/CppInteroperabilityManifesto.md</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/swift/">#swift</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>