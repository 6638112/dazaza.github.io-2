<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>带NestJS#17的API。带PostgreSQL和TypeORM的偏移量和键集分页</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">带NestJS#17的API。带PostgreSQL和TypeORM的偏移量和键集分页</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-10 06:54:23</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/6f3b96d2ad61f228c83dd05b83adaee2.png"><img src="http://img2.diglog.com/img/2020/11/6f3b96d2ad61f228c83dd05b83adaee2.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>As our database grows, so do the results of our queries. Returning a lot of data in our API might not be the best approach performance-wise. Dividing our content into multiple pages and solutions like infinite scrolling have been around for quite some time. In this article, we explore ways of implementing pagination and point out their pros and cons.</p><p>随着我们数据库的增长，我们的查询结果也在增长。在我们的API中返回大量数据可能不是性能方面的最佳方法。将我们的内容分成多个页面和无限滚动这样的解决方案已经存在很长一段时间了。在本文中，我们将探索实现分页的方法，并指出它们的优缺点。</p><p>     The above returns all of the records from the    post table. To be sure about the order of the results, we sort them by id.</p><p>上面的代码返回POST表中的所有记录。为了确定结果的顺序，我们按id对它们进行排序。</p><p> The first step in implementing pagination would be to limit the number of results. We can do that using the    LIMIT statement.</p><p>实现分页的第一步是限制结果的数量。我们可以使用LIMIT语句来实现这一点。</p><p>  Now, instead of getting all of the posts, we get just the first ten of them. This results in getting elements with ids from 1 to 10.</p><p>现在，我们没有得到所有的帖子，而是只得到了前十个帖子。这将导致获得ID从1到10的元素。</p><p> To have fully functional pagination, we need to specify the starting point of our query. To do that, we can use the    OFFSET keyword. With it, we can say how many rows we want to skip.</p><p>要实现全功能分页，我们需要指定查询的起点。为此，我们可以使用OFFSET关键字。有了它，我们可以说我们想跳过多少行。</p><p>  We omit the first ten posts with the above while still getting just ten posts as a result. This gives us elements with ids from 11 to 20.</p><p>我们省略了上面的前十个帖子，结果仍然只得到了十个帖子。这给我们提供了ID从11到20的元素。</p><p> If we would like to change the way we order elements while paginating, we need to modify our    ORDER  BY clause.</p><p>如果我们希望在分页时更改元素的排序方式，则需要修改ORDER BY子句。</p><p>  We want the users to provide the offset and the limit through query params. To implement this, let’s use the knowledge we’ve gained in previous parts of this series. This includes the usage of the    class - validator and the    class - transformer.</p><p>我们希望用户通过查询参数提供偏移量和限制。为了实现这一点，让我们使用我们在本系列前面部分中学到的知识。这包括类验证器和类转换器的使用。</p><p>  We can now use the    @ Query ( ) decorator to inject the above parameters into our controller.</p><p>现在，我们可以使用@Query()修饰符将上述参数注入控制器。</p><p>  Implementing offset-based pagination is very easy with TypeORM. Aside from returning an array of posts, we also want to return a number of them. Thanks to that, our frontend can estimate the number of pages available.</p><p>使用TypeORM实现基于偏移量的分页非常容易。除了返回一组帖子之外，我们还想返回一些帖子。多亏了这一点，我们的前端可以估计出可用页面的数量。</p><p> Although we could use the    postsRepository . count ( ) and    postsRepository . find ( ) methods separately, this would result in making two queries to the database. We can improve that by using    postsRepository . findAndCount.</p><p>虽然我们可以使用postsRepository。Count()和postsRepository。方法，这将导致对数据库进行两次查询。我们可以通过使用postsRepository来改进这一点。FindAndCount。</p><p>    In  one of the previous parts of this series, we’ve integrated our posts with Elasticsearch. Fortunately, it is effortless to add the offset-based pagination to it. We need to pass the additional    offset and    size parameters.</p><p>在本系列的前一部分中，我们已经将我们的帖子与Elasticsearch集成在一起。幸运的是，添加基于偏移量的分页非常容易。我们需要传递额外的偏移量和大小参数。</p><p>    The solution with offset and limit seems to be the most widely used. Unfortunately, its performance might fall short of our expectations.</p><p>具有偏移量和限制值的解决方案似乎是使用最广泛的。不幸的是，它的表现可能达不到我们的预期。</p><p> An essential thing to keep in mind is that the database still needs to compute the rows skipped by the    OFFSET. First, the database sorts all of the rows according to our    ORDER  BY clause. Then, Postgres drops the number of rows specified in the    OFFSET. This might require quite a bit of work.</p><p>需要记住的一件重要事情是，数据库仍然需要计算偏移量跳过的行。首先，数据库根据ORDER BY子句对所有行进行排序。然后，Postgres删除偏移量中指定的行数。这可能需要相当多的工作。</p><p> Aside from the performance, another important thing to consider is consistency. We want an element to appear in the results exactly once. Let’s imagine the following situation:</p><p>除了表现之外，另一件需要考虑的重要事情是一致性。我们希望一个元素在结果中只出现一次。让我们设想一下以下情况：</p><p> meanwhile, the second user creates a new post – after sorting, it ends up on page number one</p><p>同时，第二个用户创建了一个新帖子--排序后，它会出现在第一页</p><p> The last element of the first page is now again seen on the second page because of the above. What’s even worse, the user missed the element that has been added to the first page.</p><p>由于上述原因，第一页的最后一个元素现在再次出现在第二页上。更糟糕的是，用户错过了添加到第一页的元素。</p><p>  While the offset approach has its cons, it is still common. Due to its simplicity, it is straightforward to implement. Also, it is easy to change the column that we use for sorting, including the usage of multiple columns. Because of that, it is a viable solution in many cases. Especially if the offset is expected not to be big, and the result inconsistencies are acceptable.</p><p>虽然补偿方法有其缺点，但它仍然很常见。由于其简单性，它的实现非常简单。此外，更改用于排序的列也很容易，包括使用多个列。正因为如此，在许多情况下，这是一个可行的解决方案。特别是如果预计偏移量不会很大，结果不一致是可以接受的。</p><p>  While the offset-based pagination can be useful, its performance might not be the best. Sometimes we might want to avoid it.</p><p>虽然基于偏移量的分页可能很有用，但其性能可能不是最好的。有时我们可能想要避免它。</p><p> One of the ways to do so is to implement keyset pagination. Instead of using the    OFFSET clause, we use the    WHERE command to select the data we haven’t fetched yet.</p><p>实现这一点的方法之一是实现键集分页。我们不使用OFFSET子句，而是使用WHERE命令来选择尚未获取的数据。</p><p>   The above query gets us the first ten posts. Let’s assume that the id of the last post was  20. With this assumption, we can run this query:</p><p>上面的查询为我们提供了前十个帖子。让我们假设最后一篇帖子的id是20。在这个假设下，我们可以运行以下查询：</p><p>  The above query gets us ten posts with id bigger than 20. Now, we can take the last post and rerun the query, changing the id. Doing that creates us simple and efficient pagination mechanism.</p><p>上面的查询得到了10个id大于20的帖子。现在，我们可以使用最后一个帖子并重新运行查询，更改id。这样做可以创建简单高效的分页机制。</p><p> This exposes the biggest drawback of the keyset pagination, though. To get a page, we need to know the last element of the previous set of results. This makes traversing multiple pages at once impossible.</p><p>不过，这暴露了键集分页的最大缺点。要获得一个页面，我们需要知道前一组结果的最后一个元素。这使得一次遍历多个页面变得不可能。</p><p> Fortunately, most of the time, the users got straight to the next page. To cover all of the cases, we can implement both the offset-based approach and the keyset pagination.</p><p>幸运的是，大多数情况下，用户会直接转到下一页。为了涵盖所有情况，我们可以实现基于偏移量的方法和键集分页。</p><p> If we would like to change the column that we order our elements by, we need to change both the    ORDER  BY and    WHERE clauses.</p><p>如果我们想要更改元素的排序依据列，则需要同时更改ORDER BY和WHERE子句。</p><p>  Adding keyset pagination is not difficult with TypeORM. First, let’s add another query parameter called    startId to our    PaginationParams.</p><p>使用TypeORM添加键集分页并不困难。首先，让我们向PaginationParams添加另一个名为startid的查询参数。</p><p>  Along the way, we will face a small issue with the count of our elements. The    postsRepository . findAndCount with a    WHERE clause will return only the number of matching posts. We need to count them separately.</p><p>在此过程中，我们将面临一个关于我们的元素数量的小问题。PostsRepository。带有WHERE子句的findAndCount将只返回匹配的帖子数。我们需要分开数一数。</p><p>    We can also achieve the above result with Elasticsearch by adding the id of a post to our query.</p><p>我们还可以使用Elasticsearch将帖子的ID添加到我们的查询中，从而实现上述结果。</p><p> In this very simple example, we separately count the matching posts. If you feel like using other pagination approaches due to performance reasons, Elasticsearch has  other built-in methods of pagination.</p><p>在这个非常简单的例子中，我们分别计算匹配的帖子。如果您出于性能原因想使用其他分页方法，Elasticsearch有其他内置的分页方法。</p><p>      The most apparent drawback of the keyset pagination is that we need to know the element that we want to start with. Fortunately, we can overcome it by mixing in some offset-base pagination as in the examples above.</p><p>键集分页最明显的缺点是我们需要知道要从哪个元素开始。幸运的是，我们可以通过混合一些基于偏移量的分页来克服它，如上面的例子所示。</p><p> Another consideration is that the column we use in the    WHERE clause should have an index to experience an extra performance boost. Fortunately,  in the documentation, we can see that Postgres creates an index for every primary key constraint automatically. Therefore, the keyset pagination should be fast with ids out of the box.</p><p>另一个注意事项是，我们在WHERE子句中使用的列应该有一个索引，以获得额外的性能提升。幸运的是，在文档中，我们可以看到Postgres自动为每个主键约束创建索引。因此，使用开箱即用的ID，键集分页应该很快。</p><p> If you want to know more about creating indexes, check out  API with NestJS #14. Improving performance of our Postgres database with indexes</p><p>如果您想了解有关创建索引的更多信息，请查看NestJS#14的API。使用索引提高Postgres数据库的性能</p><p> Also, ordering the results by text fields might be tricky if we want to implement  natural sorting. If you want to read more about using the    &lt; operator with strings, read  this answer on StackOverflow.</p><p>此外，如果我们想要实现自然排序，按文本字段对结果进行排序可能会很麻烦。如果您想阅读有关将&lt；运算符与字符串一起使用的更多信息，请阅读StackOverflow上的以下答案。</p><p>  One of the main advantages of keyset pagination is a performance improvement over the offset-based approach. Also, it solves the inconsistency issue that we experience with the offset-based approach. If the user adds or removes elements between fetching pages, it does not cause element duplicates or omissions.</p><p>与基于偏移量的方法相比，键集分页的主要优势之一是提高了性能。此外，它还解决了我们在基于偏移量的方法中遇到的不一致问题。如果用户在取数页之间添加或删除元素，则不会导致元素重复或遗漏。</p><p>  In this article, we’ve implemented two types of pagination with PostgreSQL and TypeORM. We’ve pointed out the advantages and disadvantages of both the offset-based approach and the keyset pagination. While neither of them are ideal, they make a good combination that covers a variety of cases.</p><p>在本文中，我们使用PostgreSQL和TypeORM实现了两种类型的分页。我们已经指出了基于偏移量的方法和键集分页的优缺点。虽然它们都不是理想的，但它们是一个很好的组合，涵盖了各种情况。</p><p> Since in this series we’ve also used Elasticsearch, we didn’t forget about it when implementing the pagination. While keyset pagination might not be a perfect fit with Elasticsearch, it also has  other built-in methods of pagination.</p><p>因为在本系列中我们还使用了Elasticsearch，所以在实现分页时我们没有忘记它。虽然键集分页可能不是Elasticsearch的完美匹配，但它也有其他内置的分页方法。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://wanago.io/2020/11/09/api-nestjs-offset-keyset-pagination-postgresql-typeorm/">https://wanago.io/2020/11/09/api-nestjs-offset-keyset-pagination-postgresql-typeorm/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/和键/">#和键</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/keyset/">#keyset</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>