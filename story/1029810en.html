<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>SQLite开始并发</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">SQLite开始并发</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-19 22:56:14</div><div class="page_narrow text-break page_content"><p>Usually, SQLite allows at most one writer to proceed concurrently. TheBEGIN CONCURRENT enhancement allows multiple writers to process writetransactions simultanously if the database is in &#34;wal&#34; or &#34;wal2&#34; mode,although the system still serializes COMMIT commands.</p><p>通常，SQLite最多允许一个编写器并发进行。如果数据库处于&#34；wal&34；或&#34；wal2&34；模式，则BEGIN并发增强功能允许多个编写器同时处理写事务，尽管系统仍会序列化COMMIT命令。</p><p> When a write-transaction is opened with &#34;BEGIN CONCURRENT&#34;, actually locking the database is deferred until a COMMIT is executed. This meansthat any number of transactions started with BEGIN CONCURRENT may proceedconcurrently. The system uses optimistic page-level-locking to preventconflicting concurrent transactions from being committed.</p><p>当使用&#34；BEGIN CONTRENT&#34；打开写事务时，实际锁定数据库将推迟到执行COMMIT之后。这意味着使用BEGIN CURRENT启动的任意数量的事务可以并发进行。系统使用乐观页级锁定来防止冲突的并发事务被提交。</p><p> When a BEGIN CONCURRENT transaction is committed, the system checks whether or not any of the database pages that the transaction has read have beenmodified since the BEGIN CONCURRENT was opened. In other words - it asks if the transaction being committed operates on a different set of data thanall other concurrently executing transactions. If the answer is &#34;yes, thistransaction did not read or modify any data modified by any concurrenttransaction&#34;, then the transaction is committed as normal. Otherwise, if thetransaction does conflict, it cannot be committed and an SQLITE_BUSY_SNAPSHOTerror is returned. At this point, all the client can do is ROLLBACK thetransaction.</p><p>提交BEGIN CURRENT TRANSACTION时，系统会检查自打开BEGIN CURRENT以来，该事务已读取的任何数据库页是否已被修改。换句话说，它询问正在提交的事务是否操作与所有其他并发执行的事务不同的数据集。如果答案是&#34；是，则该事务没有读取或修改任何并发事务&#34；修改的任何数据，则事务照常提交。否则，如果事务确实发生冲突，则无法提交，并返回SQLITE_BUSY_SNAPSHOT错误。此时，客户端所能做的就是回滚事务。</p><p> If SQLITE_BUSY_SNAPSHOT is returned, messages are output via the sqlite3_logmechanism indicating the page and table or index on which the conflictoccurred. This can be useful when optimizing concurrency.</p><p>如果返回SQLITE_BUSY_SNAPSHOT，则通过sqlite3_log机制输出消息，指示发生冲突的页和表或索引。这在优化并发性时很有用。</p><p>  In order to serialize COMMIT processing, SQLite takes a lock on the databaseas part of each COMMIT command and releases it before returning. At most onewriter may hold this lock at any one time. If a writer cannot obtain the lock,it uses SQLite&#39;s busy-handler to pause and retry for a while:</p><p>为了序列化提交处理，SQLite将数据库锁作为每个提交命令的一部分，并在返回之前将其释放。一次最多只能有一个写入者持有此锁。如果写入器无法获得锁，它会使用SQLite的忙处理程序暂停并重试一段时间：</p><p>  If there is significant contention for the writer lock, this mechanism can beinefficient. In this case it is better for the application to use a mutex orsome other mechanism that supports blocking to ensure that at most one writeris attempting to COMMIT a BEGIN CONCURRENT transaction at a time. This isusually easier if all writers are part of the same operating system process.</p><p>如果存在严重的写入器锁争用，则此机制可能效率低下。在这种情况下，应用程序最好使用互斥或其他支持阻塞的机制，以确保一次最多有一个写入器尝试提交一个BEGIN CONTRENT TRANSACTION。如果所有编写器都是同一操作系统进程的一部分，这通常会更容易。</p><p> If all database clients (readers and writers) are located in the same OSprocess, and if that OS is a Unix variant, then it can be more efficient tothe built-in VFS &#34;unix-excl&#34; instead of the default &#34;unix&#34;. This is because ituses more efficient locking primitives.</p><p>如果所有数据库客户端(读取器和写入器)都位于同一OS进程中，且该操作系统是Unix变体，则使用内置VFS&#34；unix-excl&34；而不是默认的unix&34；会更高效。这是因为它使用了更高效的锁定原语。</p><p> The key to maximizing concurrency using BEGIN CONCURRENT is to ensure thatthere are a large number of non-conflicting transactions. In SQLite, eachtable and each index is stored as a separate b-tree, each of which isdistributed over a discrete set of database pages. This means that:</p><p>使用BEGIN CURRENT最大化并发的关键是确保有大量无冲突的事务。在SQLite中，每个表和每个索引都存储为单独的b树，每个b树分布在一组离散的数据库页上。这意味着：</p><p> Two transactions that write to the same tables or indexes only conflict if the values of the keys (either primary keys or indexed rows) are fairly close together. For example, given a large table with the schema:</p><p>仅当键(主键或索引行)的值相当接近时，写入相同表或索引的两个事务才会冲突。例如，给定一个具有模式的大表：</p><p>  writing two rows with adjacent values for &#34;a&#34; probably will cause aconflict (as the two keys are stored on the same page), but writing tworows with vastly different values for &#34;a&#34; will not (as the keys will liklybe stored on different pages).</p><p>为&#34；a&#34；写两行相邻的值可能会导致冲突(因为这两个键存储在同一页上)，但是用非常不同的值为&#34；a&#34；写两行则不会(因为键很可能存储在不同的页上)。</p><p> Note that, in SQLite, if values are not explicitly supplied for an INTEGERPRIMARY KEY, as for example in:</p><p>请注意，在SQLite中，如果没有为INTEGERPRIMARY键显式提供值，例如：</p><p>  then monotonically increasing values are assigned automatically. This isterrible for concurrency, as it all but ensures that all new rows are added to the same database page. In such situations, it is better toexplicitly assign random values to INTEGER PRIMARY KEY fields.</p><p>然后自动分配单调递增的值。这不利于并发性，因为它几乎可以确保将所有新行添加到同一数据库页。在这种情况下，最好将随机值显式分配给整型主键字段。</p><p> This problem also comes up for non-WITHOUT ROWID tables that do not have anexplicit INTEGER PRIMARY KEY column. In these cases each table has an implicitINTEGER PRIMARY KEY column that is assigned increasing values, leading to thesame problem as omitting to assign a value to an explicit INTEGER PRIMARY KEYcolumn.</p><p>对于没有显式整数主键列的非无ROWID表，也会出现此问题。在这些情况下，每个表都有一个隐式INTEGER主键列，该列被分配递增的值，导致与省略为显式整数主KEY列赋值相同的问题。</p><p> For both explicit and implicit INTEGER PRIMARY KEYs, it is possible to haveSQLite assign values at random (instead of the monotonically increasingvalues) by writing a row with a rowid equal to the largest possible signed64-bit integer to the table. For example:</p><p>对于显式和隐式整数主键，都可以让SQLite随机赋值(而不是单调递增的值)，方法是将rowid等于可能的最大签名64位整数的行写入表。例如：</p><p>   The nature of some types of indexes, for example indexes on timestamp fields,can also cause problems (as concurrent transactions may assign similartimestamps that will be stored on the same db page to new records). In thesecases the database schema may need to be rethought to increase the concurrencyprovided by page-level-locking.</p><p>某些类型的索引(例如，时间戳字段上的索引)的性质也可能导致问题(因为并发事务可能会将将存储在同一DB页上的相似标记分配给新记录)。在这些情况下，可能需要重新考虑数据库模式，以提高页级锁定提供的并发性。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://sqlite.org/src/doc/begin-concurrent/doc/begin_concurrent.md">https://sqlite.org/src/doc/begin-concurrent/doc/begin_concurrent.md</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/sqlite/">#sqlite</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/并发/">#并发</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>