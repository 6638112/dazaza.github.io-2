<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>如何在ECTO（2019）中撰写查询 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">如何在ECTO（2019）中撰写查询 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-20 09:10:52</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/ee381a199a4607d39a26980fd4d9884d.png"><img src="http://img2.diglog.com/img/2021/3/ee381a199a4607d39a26980fd4d9884d.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>我现在一直在使用Ecto，我一直发现让​​我的疑问可以是非常有帮助的。由此，我的意思是创建在查询中取出的函数并返回查​​询，以便我可以将这些查询函数的倍数在一起。</p><p> 最近，我遇到了一个问题，我以前没见过，带我走了一些时间来完成。该问题是我的查询的多个部分加入不同的表（甚至通过同一个表！）。如果您想跳过那个，只需跳转到博客文章的结尾，编写多个连接。</p><p> TL; DR使用AS：选项在加入和检查时查看是否已查询已具有has_named_binding的连接？/ 2允许您撰写需要执行的多个查询</p><p> 对于其他人来说，我将通过在这篇文章中的一个查询中建立可协调的疑问。为此，让我们看看一些汽车。</p><p>  我将在为我为这个名为Ectocars的博客文章而制作的项目上运行我的疑问。按照Repo Readme的入门部分的步骤进行操作，如果您要遵循！</p><p>  此图像是帮助您了解我们将要查询的数据库域。有不同的传输（自动，手动）和发动机（120hp，250hp）。规格具有传输和发动机。一辆汽车有一个规范，一种颜色，VIN号码（我们不需要这个，但它只是一个唯一的标识符）和一个名称。</p><p>  好吧，让我们用一个很好的简单查询开始这个。让我们找到所有的蓝色汽车。为此，我们真的只需要ecto.query.where / 3。我喜欢使用表达式语法而不是关键字语法进行漂亮的管道能力，所以我们将看看向前移动的示例。现在我说我想找到所有的蓝色车，但是让这函数一点可重复使用，以便它可以采用任何颜色。为此，我们可以有这样的东西： </p><p>现在要尝试一下，让我们跳进入我们的IEX会话，让我们通过运行异常ex.car.with_color（“blue”）|＆gt; ectocars.repo.all（）：</p><p> IEX（1）＆gt; ectocars.car.with_color（＆＃34;蓝色＆＃34;）|＆gt; Ectocars.repo.all（）18：07：08.057 [Debug]查询OK源=＆＃34;汽车＆＃34; DB = 0.6ms解码= 1.1ms队列= 1.1ms选择C0。＆＃34; ID＆＃34;，C0。＆＃34;颜色＆＃34;，C0。＆＃34; VIN_NUMBER＆＃34;，C0。＆C0。＆＃34; 34;规格_id＆＃34;来自＆＃34;汽车＆＃34;作为C0哪里（C0.＆＃34;颜色＆＃34; = $ 1）[＆＃34;蓝色＆＃34;] [％ectocars.car {__meta__：＃ecto.schema.metadata＆lt;：loaded，＆＃34;汽车＆ ＃34;＆gt;，颜色：＆＃34;蓝色＆＃34; ID：1，规范：＃ecto.association.notloaded＆lt;关联：规范未加载和gt; specification_id：3，vin_number：＆＃34; somall＆＃34; 34; }，％ectocars.car {__meta__：#eco.schema.metadata＆lt;：加载，＆＃34;汽车＆＃34;＆gt;＆gt;颜色：＆＃34;蓝色＆＃34;，ID：3，规格：#ecto。协会.Notloaded＆lt;关联：规范未加载，gt; specification_id：1，vin_number：＆＃34; my_dream_car＆＃34; }，％ectocars.car {__meta__：＃ecto.schema.metadata＆lt;：加载，＆＃34;汽车＆＃34;＆gt;颜色：＆＃34;蓝色＆＃34;，ID：4，规格：#ecto。协会.Notloaded＆lt;关联：规范未加载，规范_ID：2，Vin_number：＆＃34; cant_drive_this＆＃34; }]</p><p> 这看起来很棒，但我真的只想要一个理想的汽车给我，而不是三辆。继续，如果您愿意，请使用其他颜色尝试查询！</p><p>   现在让我们让我们的查询更加复杂。我真的无法驾驶一辆手动车（我最后一次尝试用一辆带着一辆带有死亡电池的汽车和那个那么多的那家伙，不想出去跳到这么多次......），所以这可能是最好的如果我寻找自动车。</p><p> 为实现这一目标，我们将通过我们的规格表加入我们的传输表：</p><p>  你会在这里注意到我们实际上必须加入两次来实现这一目标。一旦通过规范，然后再次传输。我们再次通过接受作为参数的传输类型然后在末尾的WHERE子句中使用该查询功能可重新使用此查询功能。</p><p> 一件事要肯定会意识到我们使用的是要加入的第三个参数的字母列表只是绑定的变量。例如，在第二个连接中，使用[C，S]没有什么特别的。那些字母对我们有意义，因为它们是先前函数调用中使用的相同字母。如果我们在第二个连接到另一个字母中将s更改为时，它根本不会更改查询。 （这将更加重要！） </p><p>IEX（3）＆gt; ectocars.car.with_transmission（＆＃34;自动＆＃34;）|＆gt; ectocars.repo.all（）16：33：16.127 [debug]查询ok源=＆＃34;汽车＆＃34; db = 3.3ms解码= 1.4ms队列= 2.8ms选择c0。＆＃34; id＆＃34;，c0。＆＃34;颜色＆＃34;，c0。＆＃34; vin_number＆＃34;，c0。＆＃34; 34;规格_id＆＃34;来自＆＃34;汽车＆＃34;作为C0左外加入＆＃34;规格＆＃34;作为C0上的S1。＆＃34; specification_id＆＃34; = S1。＆＃34; ID＆＃34;左外加入＆＃34;传输＆＃34;在S1上的T2。＆＃34;传输 - ＆＃34; = T2。＆＃34; ID＆＃34;在哪里（T2。＆＃34;类型＆＃34; = $ 1）[＆＃34;自动＆＃34;] [％ectocars.car {__meta__：＃ecto.schema.metadata＆lt;：加载，＆＃34;汽车＆＃34 ;＆gt;，颜色：＆＃34;蓝色＆＃34;，ID：3，规范：＃ecto.association.notloaded＆lt;关联：规范没有加载，规范，specification_id：1，vin_number：＆＃34; my_dream_car＆＃34; }，％ectocars.car {__meta__：＃ecto.schema.metadata＆lt;：加载，＆＃34;汽车＆＃34;＆gt;＆gt;颜色：＆＃34;红色＆＃34; id：2，规格：#ecto。协会.Notloaded＆lt;关联：规范未加载，规范，规格_id：1，Vin_number：＆＃34;错误_color＆＃34; }，％ectocars.car {__meta__：＃ecto.schema.metadata＆lt;：加载，＆＃34;汽车＆＃34;＆gt;颜色：＆＃34;蓝色＆＃34;，ID：1，规格：#ecto。协会.Notloaded＆lt;关联：规范未加载＆gt;，specification_id：3，vin_number：＆＃34; som_small＆＃34; }]</p><p> 完美的！只是我们在寻找的东西，所有的自动汽车。虽然，太多的汽车可供选择。</p><p>   现在，如果我真的在寻找具有蓝色的自动变速器的所有汽车。好吧，而不是写一个全新的查询，如果我们可以重复使用两个现有的那些，这将是很棒的。</p><p> 为此，我们将不得不重构函数一点，不仅仅是掌握类型/颜色的参数，还可以将现有查询添加到：</p><p>  通过使第一个参数可选，我们可以选择在Query中传递我们在建设过程中，或者我们将默认默认为汽车表询问。我们现在可以将这些仿佛刚刚构建一个长的Ecto查询：Ectocars.car |＆gt; ectocars.car.with_color（“蓝色”）|＆gt; Ectocars.car.with_transmission（“自动”）|＆gt; ectocars.repo.all（）：</p><p> IEX（5）＆gt; Ectocars.car |＆gt; ectocars.car.with_color（＆＃34;蓝色＆＃34;）|＆gt; ectocars.car.with_transmission（＆＃34;自动＆＃34;）|＆gt; ectocars.repo.all（）16：43：18.287 [debug]查询ok source =＆＃34;汽车＆＃34; DB = 4.0ms Queue = 9.5ms选择C0。＆＃34; ID＆＃34;，C0。＆＃34;颜色＆＃34;，C0。＆＃34; Vin_number＆＃34;，C0。＆＃34; specification_id＆＃34; 34;来自＆＃34;汽车＆＃34;作为C0左外加入＆＃34;规格＆＃34;作为C0上的S1。＆＃34; specification_id＆＃34; = S1。＆＃34; ID＆＃34;左外加入＆＃34;传输＆＃34;在S1上的T2。＆＃34;传输 - ＆＃34; = T2。＆＃34; ID＆＃34;在哪里（C0。＆＃34;颜色＆＃34; = $ 1）和（t2。＆＃34;类型＆＃34; $ 2; $ 2）[＆＃34;蓝色＆＃34 ;,＆＃34;自动＆＃34;] [ ％Eectocars.car {__meta__：＃ecto.schema.metadata＆lt;：加载，＆＃34;汽车＆＃34;＆gt;颜色：＆＃34;蓝色＆＃34; id：1，规格：＃ecto.association。未载荷＆lt;关联：规范未加载，规范，规格_id：3，Vin_number：＆＃34; too_small＆＃34; }，％ectocars.car {__meta__：#eco.schema.metadata＆lt;：加载，＆＃34;汽车＆＃34;＆gt;＆gt;颜色：＆＃34;蓝色＆＃34;，ID：3，规格：#ecto。协会.Notloaded＆lt;关联：规范未加载，gt; specification_id：1，vin_number：＆＃34; my_dream_car＆＃34; }]</p><p> 我们终于得到它了！一个可协议的查询，找到我正在寻找的汽车。但是汽车引擎呢？也许我想要一辆拥有超过200马力的汽车。 </p><p>因此，随着我们之前所做的操作，让我们为引擎创建一个查询函数：</p><p>   IEX（10）＆gt; Ectocars.car |＆gt; ectocars.car.with_color（＆＃34;蓝色＆＃34;）|＆gt; ectocars.car.with_transmission（＆＃34;自动＆＃34;）|＆gt; Ectocars.car.with_engine_horse_power（200）|＆gt; ectocars.repo.all（）**（ecto.queryError）lib / ecto_cars / cars / car.ex：37：Field`hife_power`在schema fectocars中不存在的地方。查询中的转发：从C0中的C0。 CAR，LEFT_JOIN：S1在ECTOCARS.Pecification，ON：C0.Specification_ID == S1.ID，left_join：T2在Ectocars.transmission中，on：s1.transmission_id == t2.id，left_join：s3在fectocars.pecification中，ON： c0.specification_id == s3.id，left_join：e4在ectocars.engine中，on：s1.engine_id == e4.id，其中：c0.color == ^＆＃34;蓝色＆＃34;，其中：t2.type == ^＆＃34;自动＆＃34;，其中：t2.horse_power＆gt; ^ 200，选择：c0（elixir）lib / enum.ex：1925：枚举。＆＃34; -reduce / 3列表^ foldl / 2-0  - ＆＃34; / 3（elixir）lib / enum.ex ：1418：枚举。＆＃34; -map_reduce / 3-lists ^ mapfoldl / 2-0  - ＆＃34; / 3（elixir）lib / enum.ex：1418：枚举。＆＃34; -map_reduce / 3-列表^ mapfoldl / 2-0  - ＆＃34; / 3</p><p>   让我们看看我们是否可以分解在此发生的事情。查看错误，这就是传输模式不存在Horse_Power。足够公平，但我以为我们在这里查询发动机架构，对吧？好吧，如果我们通过查询浏览查询，我们可以看到更多发生的事情。首先，我们加入规范（S1），然后转到传输（T2），然后再次调整（S3）（这似乎没有很大......），然后到发动机（E4）。现在在马力的Where条款中，我们正在看T2而不是E4！</p><p> 要更好地理解这一点，让我们解开所有这些查询的作品，并在其功能之外将它们一起写在一起：</p><p>  也许它更容易看到这里。由于默认方式绑定与加入的关系，所引用的表与该列表中的位置完全是相关的。所以在第8行时，我们打算在引擎表上查询时，我们真的在此查询中查询第三表...传输！要获得此项工作，我们必须执行以下操作：</p><p>  首先，我删除了双重加入来规范，因为真的，谁需要那个。我还将加入和查询更新为引擎，以便绑定列表了解与传输的现有绑定。在加方面，这将在下方工作，这真的杀死了我们的可组合性。正如它所致，此查询现在依赖于已完成的先前查询（指定），并且在调用此之前将相同精确的表格连接到查询。这里必须更好的方式，以便我们可以保持生活在我们的超级酷炫的世界中......</p><p>  命名绑定！必须完全依靠我们加入不同表的顺序是香蕉。要使用命名绑定，请在调用Join时通过AS选项：加入（查询，：左，[C]，S规范，AS：：规范，ON：C.Specification_ID == S.ID）。然后，我们可以通过使用关键规格稍后绑定我们的规格变量：：：加入（查询，：左，[c，规格：s]，t在传输中，如下：：传输，on：s.transmission_id == T.ID）。现在让我们继续前进并重新编写我们的函数来使用命名绑定： </p><p>我不会将输出显示出来的每个单独测试，但我保证他们的工作;）但是当我们再次尝试链接时，有趣的事情就会发生......</p><p> IEX（16）＆gt; Ectocars.car |＆gt; ectocars.car.with_color（＆＃34;蓝色＆＃34;）|＆gt; ectocars.car.with_transmission（＆＃34;自动＆＃34;）|＆gt; Ectocars.car.with_engine_horse_power（200）|＆gt; ectocars.repo.all（）**（ecto.query.compileError）别名`：规格`已存在（EECTO_CARS）lib / ecto_cars / cars / car.ex：35：Eectocars.car.with_engine_horse_power / 2</p><p>  好的，一个新的错误！它看起来我们无法重新绑定相同的键（有意义......）。一个简单的解决方案是用_engine_horse_power函数中的连接到规范，但随后我们再次被困在一个地方只有在调用连接到规范的函数之后只能调用此功能。</p><p> 我认为这里的最佳选择是要检查并查看查询是否已加入特定表，并且如果它没有，只会重新加入。我们可以用has_named_binding整理完成此功能？此功能允许我们执行此操作，检查并查看查询是否已具有该绑定。通过制作较小的辅助功能，我们应该处于良好状态。让我们看看重构看起来的样子是什么：</p><p>  Join_Specifications Helper功能负责检查连接并在需要时将其添加到查询。我们现在可以终于编写一个不依赖于任何特定顺序或依赖于一个功能的可协调查询，始终需要在第二个可以调用之前调用！</p><p> IEX（17）＆gt; Ectocars.car |＆gt; ectocars.car.with_color（＆＃34;蓝色＆＃34;）|＆gt; ectocars.car.with_transmission（＆＃34;自动＆＃34;）|＆gt; Ectocars.car.with_engine_horse_power（200）|＆gt; ectocars.repo.all（）17：31：25.303 [debug]查询ok source =＆＃34;汽车＆＃34; DB = 2.6ms队列= 3.8ms选择C0。＆＃34; ID＆＃34;，c0。＆＃34;颜色＆＃34;，c0。＆＃34; Vin_number＆＃34;，c0。＆＃34; specification_id＆＃ 34;来自＆＃34;汽车＆＃34;作为C0左外加入＆＃34;规格＆＃34;作为C0上的S1。＆＃34; specification_id＆＃34; = S1。＆＃34; ID＆＃34;左外加入＆＃34;传输＆＃34;在S1上的T2。＆＃34;传输 - ＆＃34; = T2。＆＃34; ID＆＃34;左外加入＆＃34;发动机＆＃34;作为S1上的E3。＆＃34; Engine_ID＆＃34; = E3。＆＃34; ID＆＃34;在哪里（C0。＆＃34;颜色＆＃34; = $ 1）和（t2。＆＃34;类型＆＃34; = $ 2）和（e3.＆＃34;马_power＆＃34;＆gt; $ 3）[＆＃34 ;蓝色＆＃34 ;,＆＃34;自动＆＃34;，200] [％ectocars.car {__meta__：＃ecto.schema.metadata＆lt;：加载，＆＃34;汽车＆＃34;＆gt;，颜色：＆＃ 34;蓝色＆＃34;，ID：3，规范：＃ecto.association.notloaded＆lt;关联：规范没有加载，规范，规格_id：1，Vin_number：＆＃34; my_dream_car＆＃34; }]</p><p>  我们终于得到它了！在可协调的疑问，我发现了我完美的汽车。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://medium.com/flatiron-labs/how-to-compose-queries-in-ecto-b71311729dac">https://medium.com/flatiron-labs/how-to-compose-queries-in-ecto-b71311729dac</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/撰写/">#撰写</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/queries/">#queries</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/查询/">#查询</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1042796.html"><img src="http://img2.diglog.com/img/2021/1/thumb_845dd0bcc7432824362f95444548de9a.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1042796.html">您在互联网上阅读的大部分内容都是由疯狂的人撰写的 </a></div><span class="my_story_list_date">2021-1-1 10:49</span></div><div class="col-sm"><div><a target="_blank" href="/story/1037432.html"><img src="http://img2.diglog.com/img/2020/12/thumb_bf170a727d67697a1019f1cf5b55bd11.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1037432.html">撰写2020年数学 </a></div><span class="my_story_list_date">2020-12-4 20:27</span></div><div class="col-sm"><div><a target="_blank" href="/story/1010510.html"><img src="http://img.diglog.com/img/2020/7/thumb_c67fc288c5ded665b2188566586562a7.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1010510.html">
英国的Farewill为其在线遗嘱撰写、葬礼和其他死亡服务的新方式筹集了2500万美元</a></div><span class="my_story_list_date">2020-7-8 17:16</span></div><div class="col-sm"><div><a target="_blank" href="/story/1000285.html"><img src="http://img.diglog.com/img/2020/5/thumb_3a44a1681773875b26ef96cd11fbf63e.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1000285.html">我是如何撰写和策划这份周刊的。</a></div><span class="my_story_list_date">2020-5-2 18:4</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>