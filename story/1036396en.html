<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>彩虹桌如何运作How Rainbow Tables Work</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">How Rainbow Tables Work<br/>彩虹桌如何运作</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-25 03:51:03</div><div class="page_narrow text-break page_content"><p>I found the creator of Rainbow Table&#39;s paper, aimed at cryptanalysts,was pretty inaccessible considering the simplicity and elegance ofRainbow Tables, so this is an overview of it for a layman.</p><p>考虑到彩虹表的简单性和优雅性，我发现了彩虹表针对密码分析人员的论文的创建者很难接近，因此这是外行的概述。</p><p>  Hash functions map plaintext to hashes so that you can&#39;t tell aplaintext from its hash.</p><p>  哈希函数将纯文本映射为哈希，因此您无法从其哈希中分辨出aplaintext。</p><p> If you want to find a given plaintext for a certain hash there are twosimple methods: - Hash each plaintext one by one, until you find the hash. - Hash each plaintext one by one, but store each generated hash in asorted table so that you can easily look the hash up later withoutgenerating the hashes again</p><p> 如果要查找特定哈希的给定纯文本，则有两种简单的方法：-逐个哈希每个纯文本，直到找到哈希。 -逐个散列每个纯文本，但是将每个生成的散列存储在分类表中，以便以后可以轻松查找散列而无需再次生成散列</p><p> Going one by one takes a very long time, and storing each hash takes anamount of memory which simply doesn&#39;t exist (for all but the smallest ofplaintext sets). Rainbow tables are a compromise between pre-computationand low memory usage.</p><p> 一张一张地花费很长时间，并且存储每个散列会占用相当数量的内存，而该内存根本不存在（除了最小的纯文本集以外的所有内存）。 Rainbow表是预计算和低内存使用之间的折衷方案。</p><p> The key to understanding rainbow tables is understanding the(unhelpfully named) reduction function. A hash function maps plaintexts to hashes, the reduction function mapshashes to plaintexts.</p><p> 理解Rainbow表的关键是理解（无用命名）归约函数。哈希函数将纯文本映射为哈希，归约函数将哈希映射为纯文本。</p><p> It&#39;s important to note that it does the reverse of a hash function(mapping hashes to plaintexts), but it is /not/ an inverse hashfunction. The whole purpose of hash functions is that inverse hashfunctions can&#39;t be made. If you take the hash of a plaintext, and takethe reduction of the hash, it will not give you the original plaintext;but some other plaintext.</p><p> 重要的是要注意，它与哈希函数（将哈希映射到纯文本）相反，但它是/ not /反向哈希函数。散列函数的全部目的是无法实现逆散列函数。如果您采用纯文本的哈希值，并进行哈希值的缩减，它将不会给您原始的纯文本；而是其他一些纯文本。</p><p> If the set of plaintexts is [0123456789]{6} (we want a rainbow table ofall numeric passwords of length 6), and the hashing function is MD5(), ahash of a plaintext might be MD5(&#34;493823&#34;) -&gt;&#34;222f00dc4b7f9131c89cff641d1a8c50&#34;. In this case the reduction function R() might be as simple as taking thefirst six numbers from the hash; R(&#34;222f00dc4b7f9131c89cff641d1a8c50&#34;)-&gt; &#34;222004&#34;. We now have generated another plaintext from the hash of the previousplaintext, this is the purpose of the reduction function.</p><p> 如果明文集是[0123456789] {6}（我们希望彩虹表包含所有长度为6的数字密码），并且哈希函数是MD5（），则明文的ahash可能是MD5（“ 493823”）->“ 222f00dc4b7f9131c89cff641d1a8c50”。在这种情况下，约简函数R（）可能就像从哈希中获取前六个数字一样简单； R（“ 222f00dc4b7f9131c89cff641d1a8c50”）->“ 222004”。现在，我们从先前纯文本的哈希中生成了另一个纯文本，这是归约函数的目的。</p><p> Hashes are one-way functions, and so are reduction functions. The chainswhich make up rainbow tables are chains of one way hash and reductionfunctions starting at a certain plaintext, and ending at a certain hash.A chain in a rainbow table starts with an arbitrary plaintext, hashesit, reduces the hash to another plaintext, hashes the new plaintext, andso on. The table only stores the starting plaintext, and the final hashyou choose to end with, and so a chain &#34;containing&#34; millions of hashescan be represented with only a single starting plaintext, and a singlefinishing hash.</p><p>散列是单向函数，归约函数也是如此。组成彩虹表的链是单向哈希和归约函数的链，它们从某个纯文本开始，并以某个哈希结束。彩虹表中的链以任意明文开头，哈希表将哈希简化为另一个明文，然后对哈希表进行哈希处理。新的明文，依此类推。该表仅存储起始明文，以及您选择结束的最终哈希，因此仅包含一个起始明文和一个结束哈希就可以表示“包含”数百万个hashe的链。</p><p> After generating many chains the table might look something like: iaisudhiu -&gt; 4259cc34599c530b1e4a8f225d665802 oxcvioix -&gt; c744b1716cbf8d4dd0ff4ce31a177151 9da8dasf -&gt; 3cd696a8571a843cda453a229d741843 [...] sodifo8sf -&gt; 7ad7d6fa6bb4fd28ab98b3dd33261e8f</p><p> 生成许多​​链后，表可能看起来像：iaisudhiu-> 4259cc34599c530b1e4a8f225d665802 oxcvioix-> c744b1716cbf8d4dd0ff4ce31a177151 9da8dasf-> 3cd696a8571a843cda453a229d741843 [...] sodifo8d</p><p>  The chains are now ready to be used. We have a certain hash with anunknown plaintext, and we want to check to see whether it is inside anyof the generated chains.</p><p>  现在可以使用链条了。我们有一个带有未知明文的哈希值，我们想检查它是否在生成的链中。</p><p> The algorithm is:  Look for the hash in the list of final hashes, if it is there breakout of the loop.</p><p> 算法为：如果存在哈希循环，请在最终哈希列表中查找哈希。</p><p>   If the hash matches one of the final hashes, the chain for which thehash matches the final hash contains the original hash.</p><p>   如果哈希值与最终哈希值之一匹配，则哈希值与最终哈希值匹配的链包含原始哈希值。</p><p>You can now get that chain&#39;s starting plaintext, and start hashing andreducing it, until you come to the known hash along with its secretplaintext.</p><p>现在，您可以获取该链的起始纯文本，并开始对其进行哈希处理和归约，直到您知道已知的哈希及其秘密纯文本为止。</p><p> In this way you check through the hashes in the chains, which aren&#39;tactually stored anywhere on disk, by iterating column by column throughthe table of chains, backwards from the last column in the chain, to thestarting plaintext.</p><p> 通过这种方式，您可以遍历链表中的散列，这些散列实际上并没有存储在磁盘上的任何地方，方法是从链表的最后一列开始，从链的最后一列向后遍历，直到起始的明文，然后逐列进行迭代。</p><p>  If you wanted to check whether the hash exists in the last column of any of the chains you reduce and hash the given hash once, then check the generated hash against the chain end hashes.</p><p>如果要检查所减少的任何链的最后一列中是否存在哈希，然后对给定的哈希进行一次哈希，请对照链末哈希检查生成的哈希。</p><p> You can check the second last column by reducing and hashing twice, then check the generated hash against the chain end hashes.</p><p> 您可以通过减少和哈希两次来检查倒数第二列，然后根据链端哈希检查生成的哈希。</p><p> And the third is checked by reducing and hashing three times, then check the generated hash against the chain end hashes.</p><p> 然后通过减少和哈希三次来检查第三个，然后对照链端哈希检查生成的哈希。</p><p> Supposinga chain ending matches the generated hash the matching chain end mightcontain the hash. The starting plaintext which was stored with the ending hash can be reduced and hashed until the correct plaintext is found within the chain.</p><p> 假设一个链的末端匹配生成的哈希，匹配的链末端可能包含该哈希。可以减少和散列与结束哈希一起存储的起始明文，直到在链中找到正确的明文为止。</p><p>  Collisions are the only problem with Rainbow Tables. Ironicallycollisions are seen as a bad thing for hashing algorithms, but in thecase of Rainbow Tables a hashing algorithm which generates collisionsfairly regularly will be more secure.    A given hash may be generated by multiple plaintexts (this is called acollision), which is a big problem for chains because it causes chainswhich start different to converge into one. Also you get loops, whichare caused when a hash is reduced to a plaintext that was hashed at aprevious point in the chain.</p><p>  碰撞是Rainbow Tables唯一的问题。具有讽刺意味的是，对于哈希算法而言，冲突被认为是一件坏事，但是在Rainbow Tables的情况下，定期生成冲突的哈希算法将更加安全。给定的散列可能由多个纯文本生成（这称为冲突），这对于链来说是个大问题，因为它会导致开始时不同的链会聚为一个。此外，您还会得到循环，这是将散列简化为在链中上一个点进行散列的纯文本时引起的。</p><p> Because of these collision problems there is no guarantee that therewill be a hash of a plaintext that will reduce to some other givenplaintext. If you have a simple list of hashes and corresponding plaintexts forevery plaintext in a set you will know that if you have not found thehash in the generated hashes the plaintext that generated the hash isnot in the set. If you have a table of chains where the reduction function reduceshashes into the set of plaintexts you could have trillions of chainsgenerated but you still may not have generated every plaintext in theset you want to check. You can only say how probable it is that a tableof chains contains a certain plaintext, and this can approach 1 but willprobably never reach 1. If you have a rainbow table with 10 chains of length 100 you have hashed1000 plaintexts, but even if there are only 100 plaintexts in the set ofdesired plaintexts the 1000 hashes you have in the chains may notcontain all the desired hashes.</p><p> 由于存在这些冲突问题，因此无法保证会有纯文本的散列减少到其他给定的纯文本。如果您有一个哈希表和对应的明文的简单列表，那么集合中的每个明文都将知道，如果您在生成的哈希表中找不到哈希，则生成哈希的明文不在集合中。如果您有一个链表，其中归约函数将阴影减少到纯文本集中，则可能会生成数万亿条链，但是您可能仍未生成要检查的每个明文。您只能说一个链表包含某个明文的可能性有多大，它可以接近1，但可能永远不会达到1。如果您的彩虹表有10个链，长度为100，则您可以散列1000个明文，即使存在一组所需的纯文本中只有100个纯文本，您在链中拥有的1000个哈希可能未包含所有所需的哈希。</p><p>  The way collisions are handled is what sets Rainbow Tables apart fromits predecessor which was developed in 1980.</p><p>  处理碰撞的方式使Rainbow Tables与1980年开发的前身有所不同。</p><p> The predecessor solved the problem of certain plaintexts never beingreduced to by using many small tables. Each small table uses a differentreduction function. This doesn&#39;t solve the problem completely, but itdoes help. To solve chain merges and loops each chain ended at a &#34;distinct point&#34;;a hash which was unique in some way, eg hashes where the first 4characters are 0. The chains keep on going until it reaches a distinctpoint. If two chains end up at the same distinct point then there hasbeen a collision somewhere in the chain, and one of the chains isdiscarded. If a chain is generated for an unusually long time withoutreaching a distinct point a loop is suspected (where a chain of hashesends up reducing and hashing to a previous hash in the chain).The problem with this is that if there is a collision there ispotentially a whole branch which has to be cut off and won&#39;t make itinto the chains, and a loop will cause all the hashes which came beforethe loop in the chain to be discarded.    Also all the time spend generating that chain will be wasted, and byending only at distinct points you have chains of variable length. Thismeans that you may have to keep checking for a hash within especiallylong chains long after the other chains have ended.</p><p>以前的版本解决了某些明文从未通过使用许多小表而减少的问题。每个小表使用不同的归约函数。这不能完全解决问题，但可以帮上忙。为了解决链合并和循环，每个链都以“不同点”结尾；该散列在某种程度上是唯一的，例如散列，其中前4个字符为0。这些链一直持续到到达一个不同点为止。如果两个链条在相同的不同点结束，则该链条中的某处会发生碰撞，并且丢弃其中一个链条。如果生成链的时间异常长而没有到达一个明确的点，则可能会怀疑存在循环（哈希链会减少并哈希到链中的前一个哈希）。如果存在冲突，则可能存在冲突整个分支，必须将其切断，并且不能将其插入链中，而循环将导致丢弃链中循环之前的所有哈希。而且，花费在生成该链上的所有时间都将被浪费，并且仅通过在不同点结束，您就拥有了可变长度的链。这意味着您可能必须在其他链结束后很长的一段时间内继续检查哈希是否特别长。</p><p>  Rainbow tables differ in that they don&#39;t use multiple tables withdifferent reduction functions, they only use one table. However inRainbow Tables a different reduction function is used for each column.This way different tables with different reduction functions aren&#39;tneeded, because different reduction functions are used within the sametable. It is still unlikely that all plaintexts in the desired set willbe hashed, but the chances are higher for a given number of chains.Chain merges are much, much rarer, because collisions have to occur onthe same column. For a chain of length l the chance of a collisioncausing a merge is reduced to 1/l. Loops are also solved, because if ahash in a chain is the same as a previous hash it won&#39;t reduce to thesame plaintext.</p><p>  Rainbow表的不同之处在于，它们不使用具有不同归约功能的多个表，而仅使用一个表。但是，在彩虹表中，每列使用不同的归约函数。这样就不需要具有不同归约函数的不同表，因为在同一表中使用了不同的归约函数。希望的集合中的所有纯文本都不太可能被散列，但是对于给定数量的链，机会更大。链合并要少得多，因为冲突必须发生在同一列上。对于长度为l的链，导致合并的碰撞几率减少到1 / l。循环也得到了解决，因为如果链中的ahash与先前的哈希相同，则不会减少为相同的明文。</p><p> The reason they&#39;re called Rainbow Tables is because each column uses adifferent reduction function. If each reduction function was a differentcolor, and you have starting plaintexts at the top and final hashes atthe bottom, it would look like a rainbow (a very vertically long andthin one). By using Rainbow Tables the only problem that remains is that you cannever be certain that the chains contain all the desired hashes, to gethigher success rates from a given Rainbow Table you have to generatemore and more chains, and get diminishing returns.</p><p> 之所以将它们称为Rainbow Tables是因为每一列都使用不同的归约函数。如果每个归约函数是不同的颜色，并且您在顶部具有开始的纯文本，在底部具有最终的哈希，则它看起来像彩虹（垂直方向很长很细）。通过使用Rainbow Tables，剩下的唯一问题是您无法确定链条包含所有所需的哈希值，要从给定的Rainbow Table获得更高的成功率，您必须生成越来越多的链条，并获得递减的收益。</p><p>  I hope by explaining the Rainbow Table I haven&#39;t made them any less wonderful ...</p><p>  我希望通过解释彩虹桌，我并没有让他们变得更美好...</p><p>    This section probably goes a bit beyond where a layman would be comfortable, but if you&#39;re interested in the practical applications of the above theory or have some interest in cryptography read on..</p><p>    本节可能会超出一些门外汉所熟悉的范围，但是如果您对以上理论的实际应用感兴趣或对密码学有兴趣的话。</p><p> The rainbowcrack application is how most people come to learn about Rainbow Tables, because it is the application which puts the theory above into code. It has been very successful, with many websites dedicated to generating rainbowcrack hash tables and letting users search them.</p><p> Rainbowcrack应用程序是大多数人了解Rainbow Tables的方式，因为正是这种应用程序将上述理论纳入了代码。它已经非常成功，许多网站致力于生成Rainbowcrack哈希表并允许用户搜索它们。</p><p> However there is a pretty clear way this application could be improved, very easily, in the sense that the generated tables would take up a lot lessdisk space, but be equally as effective for breaking hashes:</p><p> 但是，从某种意义上来说，可以很轻松地改进此应用程序的一种很明显的方法，即所生成的表将占用更少的磁盘空间，但在打破哈希值方面同样有效：</p><p> Remember above that when you want to generate a certain chain you start from an arbitrary hash. This just means it doesn&#39;t matter where you choose to start from. The rainbowcrack application starts from a randomly generated 64-bit number. This number is then used to generate a chain which ultimately ends with a 128-bit hash, which is reduced to another 64-bit number.</p><p>记住上面，当您想要生成某个链时，您将从任意哈希开始。这只是意味着选择从哪里开始都没有关系。 rainbowcrack应用程序从随机生成的64位数字开始。然后使用该数字生成一条链，该链最终以128位哈希结束，该哈希被减少为另一个64位数字。</p><p> Why use a randomly generated number as the starting point? A pseudo-random number generator can generate a fantastic amount of seemingly random numbers from a single input number. Why not make a single random input number, and then store the index of the number which generates the pseudo-random number?</p><p> 为什么要使用随机生成的数字作为起点？伪随机数生成器可以从单个输入数字生成大量看似随机的数字。为什么不制作一个随机输入数字，然后存储生成伪随机数的数字索引呢？</p><p> So for example a cipher like RC4 is a pseudo-random number generator. Say the single input number (the &#34;seed&#34;, as it&#39;s called) was 18092398. The first 64-bits the RC4generates might give a number of &#34;091358029384092&#34;, to start the chain off. The second 64-bits might give a number of &#34;123793582983480&#34;, to start the second chain off. The third64-bits might give &#34;1089324083486&#34;, for the third chain, and so on potentially for billions of chains.</p><p> 因此，例如，像RC4这样的密码就是伪随机数生成器。假设单个输入数字（即“种子”）为18092398。RC4生成的前64位可能会给出一个数字“ 091358029384092”，以启动链接。第二个64位可能会给出多个“ 123793582983480”，以启动第二个链接。对于第三条链，third64位可能会给出“ 1089324083486”，对于数十亿条链来说可能依此类推。</p><p> What is the difference between this and storing a random 64-bit number for each chain, as rainbowcrack does? Simply that a start-point in a rainbowcrack table must be stored as the randomly generated 64-bit number. A start-point using a random-number generator needs only the single input number (the &#34;seed&#34;)and the chain number. So when referring to the third chain in the example above, if you wanted to know the start point of &#34;1089324083486&#34;, you would only need to know the &#34;seed&#34; number, and that it was the third 64-bit number generated. That&#39;s the number &#34;18092398&#34;, and the number &#34;3&#34;. To know the start-point for the fourth chain you only need to know the &#34;seed&#34; (&#34;18092398&#34;), and the number &#34;4&#34;.</p><p> 就像Rainbowcrack一样，这与为每个链存储一个随机的64位数字有什么区别？只需简单地将Rainbowcrack表中的起点存储为随机生成的64位数字即可。使用随机数生成器的起点仅需要单个输入数字（“种子”）和链号。因此，在上面的示例中引用第三条链时，如果您想知道“ 1089324083486”的起点，则只需要知道“种子”号，它是生成的第三个64位号。那就是数字“ 18092398”和数字“ 3”。要知道第四条链的起点，您只需要知道“种子”（“ 18092398”）和数字“ 4”即可。</p><p> If you have 2^64 chains (1,844,674,407,370,955,616) then it wouldn&#39;t make any difference, but that would be 4194304 terrabytes, far larger than any Rainbow Table ever generated. For a more realistic rainbow table with, say, 2^28 (268,435,456) chains you would only need a 28-bit number instead of storing a 64-bit number, as rainbowcrack currently does. That&#39;s an improvement from (64-bit+64-bit) per chain to (28-bit+64-bit) per chain, plus a single 64-bit &#34;seed&#34; number per table. When you&#39;re talking about millions of chains that&#39;s a very significant reduction of data for the same hash-breaking ability.</p><p> 如果您有2 ^ 64个链（1,844,674,407,370,955,616,616），则不会有任何区别，但这将是4194304 terrabytes，远大于曾经生成的任何Rainbow Table。对于具有2 ^ 28（268,435,456）链的更现实的Rainbow表，您只需要一个28位数字，而不是像Rainbowcrack当前那样存储64位数字。从每条链的（64位+64位）到每条链（28位+64位），再加上每张表一个64位“种子”数，这是一个改进。当您谈论数百万条链时，对于具有相同散列破坏能力的数据，这是非常大的减少。</p><p> In this example a rainbowcrack table would be 2^28 * ( 64-bit random start number + 64-bit chain-end number) (4096 MB). Using a pseudo-random number generator the table would be 2^28 * ( 28-bit non-random start number + 64-bit chain-end number) + 64-bit &#34;seed&#34; number (3264 MB)</p><p> 在此示例中，rainbowcrack表将为2 ^ 28 *（64位随机起始编号+ 64位链结束编号）（4096 MB）。使用伪随机数生成器，该表将为2 ^ 28 *（28位非随机起始数字+ 64位链结束数字）+ 64位“种子”数字（3264 MB）</p><p> When you scale that difference up to the huge sizes rainbowcrack tables can reach the savings become massive, and you end up with whole hard-disk arrays of randomly-generated chain-start number data that is pure waste, not to mention the bandwidth used moving the data around. A huge waste considering the trivial code changes.</p><p> 当您将差异扩大到巨大尺寸时，Rainbowcrack表可以节省大量资金，并且最终得到整个硬盘阵列的纯随机产生的chain-start数字数据，更不用说移动使用的带宽了。周围的数据。考虑到琐碎的代码更改，这是一个巨大的浪费。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://kestas.kuliukas.com/RainbowTables/">http://kestas.kuliukas.com/RainbowTables/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/彩虹/">#彩虹</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tables/">#tables</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/生成/">#生成</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>