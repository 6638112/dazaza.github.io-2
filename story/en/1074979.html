<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>压缩剪贴板历史记录的日志存储Compacting log storage for clipboard history</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Compacting log storage for clipboard history<br/>压缩剪贴板历史记录的日志存储</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-25 21:07:02</div><div class="page_narrow text-break page_content"><p>Blog   Published Feb 24, 2022 • Last updated Feb 24, 2022 • 6 min read Gnome Clipboard History (GCH) is a Gnome extension that saves what you’ve copied into an easily accessible, searchable history panel. The primary innovation over existing clipboard managers is the use of a compacting log for persistent storage.   GCH is a rewrite of  Clipboard Indicator and had the original goal of upstreaming any changes. This meant GCH needed feature parity with Clipboard Indicator. Of those existing features, the following have performance implications that influenced the rewrite’s design decisions: Any history changes (including newly copied entries) are immediately written to disk. Previously copied items are resurfaced instead of creating duplicates (implying the need to search through the history to know if what has just been copied is a new or existing entry).</p><p>博客发布于2022年2月24日•最近更新于2022年2月24日•6分钟读取Gnome剪贴板历史（GCH）是一个Gnome扩展，它可以将您复制的内容保存到一个易于访问、可搜索的历史面板中。与现有剪贴板管理器相比的主要创新是使用压缩日志进行持久存储。GCH是对剪贴板指示器的重写，最初的目标是向上更新任何更改。这意味着GCH需要与剪贴板指示器的功能奇偶性。在这些现有功能中，以下性能影响了重写的设计决策：任何历史更改（包括新复制的条目）都会立即写入磁盘。以前复制的条目将重新显示，而不是创建副本（这意味着需要搜索历史记录，以了解刚刚复制的条目是新条目还是现有条目）。</p><p> Given those features’ performance implications, several data structure choices naturally emerged: An append-only persistent storage structure (i.e. a log) A linked list to store in-memory entries A map and reverse lookup index that stores entries keyed by transient, globally unique IDs</p><p>考虑到这些特性对性能的影响，自然会出现几种数据结构选择：仅附加的持久存储结构（即日志）链表存储内存条目映射和反向查找索引存储由瞬态全局唯一ID键入的条目</p><p> On copy, the reverse lookup index minimizes the work done to find duplicates while the log minimizes the work done to store new entries. The log also minimizes the work done when modifying arbitrary entries. Similarly, the linked list minimizes the in-memory work done to add/remove/move those entries. Search is still an open problem, but I discuss that  later.  GCH uses a relatively simple binary encoding to store copied entries:  The first byte of an operation is always its type while the succeeding bytes are whatever an operation desires. For example, an add operation looks like this: UTF-8 data bytes ∨00000000 01 49 20 77 61 73 20 63 6f 70 69 65 64 21 00 |.I was copied!.| ∧ ∧ Add op type NUL terminator</p><p>在复制时，反向查找索引最小化了查找重复项所做的工作，而日志最小化了存储新条目所做的工作。该日志还可以最大限度地减少修改任意条目时所做的工作。类似地，链表最小化了在内存中添加/删除/移动这些条目所做的工作。搜索仍然是一个悬而未决的问题，但我稍后会讨论这个问题。GCH使用一种相对简单的二进制编码来存储复制的条目：一个操作的第一个字节总是它的类型，而后面的字节则是一个操作想要的任何字节。例如，添加操作如下所示：UTF-8数据字节∨00000000 01 49 20 77 61 73 20 63 6f 70 69 65 64 21 00 |。我被复制了！|∧ ∧ 添加op类型NUL终止符</p><p> It would be preferable to store the length of the text instead of a NUL terminator, but no Gnome API exists to read N bytes. Now let’s see what happens when you favorite that entry, delete it, and then copy and favorite another entry: Favorite op type ∨00000000 01 49 20 77 61 73 20 63 6f 70 69 65 64 21 00 03 |.I was copied!..| 4-byte Little Endian ID (=1) ∨00000010 01 00 00 00 02 01 00 00 00 01 4d 65 20 74 6f 6f |..........Me too| ∧ ∧ Delete op type 4-byte Little Endian ID (=1)00000020 00 03 02 00 00 00 |......| ∧ ∧ Favorite op 4-byte Little Endian ID (=2)</p><p>最好存储文本的长度，而不是NUL终止符，但不存在读取N字节的Gnome API。现在让我们看看当你喜欢这个条目，删除它，然后复制并喜欢另一个条目时会发生什么：favorite op type∨00000000 01 49 20 77 61 73 20 63 6f 70 69 65 64 21 00 03 |。我被复制了！。|4字节小尾端ID（=1）∨000000 10 01 00 00 02 00 00 01 4d 65 20 74 6f 6f |。。。。。。。。。。我也是∧ ∧ 删除op类型4字节小尾端ID（=1）000000 20 00 03 02 00 00 00 00 |∧ ∧ 最喜欢的op 4字节小端点ID（=2）</p><p> There’s a lot going on, so let’s break it down. First, you’ll notice the implicit creation of IDs for the two items. Since the log is append-only and always read in its entirety on start, globally unique IDs can be inferred based the position of added entries. Furthermore, because the log is append-only, deleting entries doesn’t actually delete anything (that’s where  compaction comes in). Instead, entries are simply marked as having been deleted — in the exact same way an entry is marked as being favorited. When parsing the log, deleted items are appended to the in-memory linked list and later deleted when the delete operation is reached. The IDs are monotonically increasing and stored in Little Endian because I expect most people to be using x86, thus saving some bit manipulation. I could have gotten a little fancier by using varints instead, but fighting JavaScript didn’t seem worth it. Future research: using mmap (or seek) to start reading somewhere near the end of the file. Supporting arbitrary starting decoding positions would require self-synchronization, but lets the decoder only read the last N entries (until the user requests more).</p><p>有很多事情要做，所以让我们把它分解一下。首先，您会注意到为这两个项目隐式创建了ID。由于日志是仅附加的，并且总是在开始时读取整个日志，因此可以根据添加的条目的位置推断出全局唯一的ID。此外，由于日志是仅附加的，删除条目实际上不会删除任何内容（这就是压缩的原因）。相反，条目被简单地标记为已被删除，就像条目被标记为被偏爱一样。解析日志时，已删除的项目会附加到内存中的链表中，然后在执行删除操作时删除。ID是单调递增的，并存储在Little Endian中，因为我希望大多数人使用x86，从而节省一些位操作。我本可以通过使用Variant来让自己变得更时尚，但与JavaScript抗争似乎并不值得。未来的研究：使用mmap（或seek）开始读取文件末尾附近的某个地方。支持任意起始解码位置需要自同步，但解码器只能读取最后N个条目（直到用户请求更多）。</p><p> That’s about it! There are a few other operations, but they all work similarly.  This is arguably the most interesting part of the log: compaction is what allows it to stay append-only. On compaction, the entire log is deleted and recreated from scratch with inverting operations removed. Inverting operations are those that cancel each other out. For example, adding and deleting an item can be replaced with doing nothing. After compaction, the example from above looks like this: 00000000 01 4d 65 20 74 6f 6f 00 03 01 00 00 00 |.Me too......|</p><p>就这样！还有一些其他操作，但它们的工作原理都类似。这可以说是日志中最有趣的部分：压缩是让它保持只附加的功能。压缩时，将删除整个日志并从头开始重新创建，同时删除反转操作。反转操作是指相互抵消的操作。例如，添加和删除项目可以替换为不做任何事情。压实后，上面的示例如下所示：00000000 01 4d 65 20 74 6f 6f 00 03 01 00 00 |。我也是|</p><p> All traces of the  I was copied! entry have been removed and  Me too’s ID has been shifted down. IDs are therefore globally unique only between compaction intervals, meaning in-memory data structures must be updated after each compaction. Upon reflection, I probably should have stored the ID with the add operation to minimize the work done on compaction. The only issue would be ID overflow, but that can be handled by keeping the set of active IDs to know if one has already been used. In any case, the current approach has the benefit of minimizing wasted space since add is the primary operation.</p><p>我的所有痕迹都被复制了！条目已被删除，我的身份证也已下移。因此，ID仅在压缩间隔之间是全局唯一的，这意味着内存中的数据结构必须在每次压缩后更新。经过深思熟虑，我可能应该用add操作存储ID，以最小化压缩工作。唯一的问题是ID溢出，但这可以通过保留一组活动ID来处理，以了解是否已经使用了一个ID。在任何情况下，由于add是主要操作，因此当前的方法都有最大限度地减少浪费空间的好处。</p><p>  Since compaction is expensive and requires rewriting the entire history, we’d ideally like to perform compaction… well, never! Unfortunately, never compacting means your on-disk history will grow forever and parsing the log will become increasingly slow due to the number of inverting operations. On the other hand, we could perform compaction anytime something changes, thereby resulting in the minimal log size and no inverting operations. Thus, the goal is to strike a balance between the number of compactions and the number of wasted (i.e. inverting) operations. Surprisingly, it’s very easy to keep track of wasted operations: if you delete something, then you’ve wasted two operations (one for the add and one for the delete). Similar logic follows for other operations. Next, pick some threshold for the number of wasted operations and perform compaction if the threshold is exceeded. Easy!  In memory, the clipboard history is stored in a doubly linked list, allowing for instant deletion and easy pagination. Pagination is important for GCH because Gnome does not have a UI list API (like a RecyclerView) that is capable of scaling to the history sizes I wanted to support. The biggest challenge is in trying to minimize iteration since linked lists have such terrible memory access patterns.  The index (from text to entry ID) is implemented as a fairly standard chaining hash table. To maximize hashing performance while minimizing collisions, a special hashing function is used that takes advantage of assumptions about our corpus. Notably, long strings are unlikely to have length collisions (e.g. why would someone copy two  different strings that are exactly 30224 characters long?) whereas short strings are (e.g. someone copies “abc” and “123”). We therefore arrive at the following hash function:   Search uses regex queries and returns paginated results sorted by recency to try and perform the minimal number of matches. While ok, this is clearly suboptimal as a proper index should be used instead. That said, I found performance to be adequate and decided to let it be.  GCH is written in JavaScript because it is the only language supported by Gnome extensions. As a performance-minded individual, I’ve found the Gnome extension developer experience to be deeply dissatisfactory: the language choice makes it impossible to do certain things. Of note (non-exhaustive): The linked list could have been optimized to store nodes as cache-line-sized blocks. A proper map implementation could have been used instead of my poorly optimized version, but the JS Map does not support custom hash functions. A proper serialization library could have been used (like Serde) which would have made the initial implementation much easier. Anything to do with multi-threading (such as running search in a background thread) is impossible. The log uses an op queue to ensure serializability — this would have been trivial to implement in a language that supports single-threaded executors.</p><p>由于压缩成本很高，需要重写整个历史记录，所以理想情况下，我们希望执行压缩…嗯，永远不会！不幸的是，从不压缩意味着磁盘上的历史记录将永远增长，并且由于反转操作的数量，解析日志的速度将变得越来越慢。另一方面，我们可以随时进行压缩，从而使日志大小最小，并且不进行反转操作。因此，目标是在压实数量和浪费（即反转）操作数量之间取得平衡。令人惊讶的是，跟踪浪费的操作非常容易：如果删除某个内容，那么就浪费了两个操作（一个用于添加，一个用于删除）。其他操作也遵循类似的逻辑。接下来，为浪费的操作数选择一些阈值，如果超过该阈值，则执行压缩。容易的在内存中，剪贴板历史记录存储在双链接列表中，允许即时删除和轻松分页。分页对于GCH来说很重要，因为Gnome没有一个UI列表API（比如RecyclerView），它能够扩展到我想要支持的历史大小。最大的挑战是尽量减少迭代，因为链表的内存访问模式非常糟糕。索引（从文本到条目ID）被实现为一个相当标准的链接哈希表。为了最大限度地提高哈希性能，同时最小化冲突，使用了一个特殊的哈希函数，该函数利用了关于语料库的假设。值得注意的是，长字符串不太可能有长度冲突（例如，为什么有人会复制两个长度正好为30224个字符的不同字符串？）而短字符串是（例如，有人复制“abc”和“123”）。因此，我们得到了以下哈希函数：Search使用regex查询并返回按最近程度排序的分页结果，以尝试执行最小数量的匹配。虽然可以，但这显然是次优的，因为应该使用适当的索引。也就是说，我发现性能是足够的，并决定让它成为现实。GCH是用JavaScript编写的，因为它是Gnome扩展支持的唯一语言。作为一个注重性能的人，我发现Gnome扩展开发人员的体验非常令人不满意：语言的选择使得做某些事情变得不可能。注意（非穷举）：链表可以优化为将节点存储为缓存线大小的块。可以使用适当的映射实现，而不是我的优化效果不佳的版本，但JS映射不支持自定义哈希函数。可以使用一个合适的序列化库（比如Serde），这将使初始实现更加容易。任何与多线程有关的事情（比如在后台线程中运行搜索）都是不可能的。日志使用一个op队列来确保可序列化性——在支持单线程执行器的语言中实现这一点很简单。</p><p> In brief, while I’m pleased with what I have been able to do given present limitations, I’m very excited to see what APIs Pop!_OS will offer in their  COSMIC DE.</p><p>简而言之，虽然我对自己在目前的限制下所做的事情感到满意，但我很高兴看到API流行起来了_操作系统将提供他们的宇宙DE。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/剪贴板/">#剪贴板</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/log/">#log</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/存储/">#存储</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>