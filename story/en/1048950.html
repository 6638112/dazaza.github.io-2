<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>向后教授编制者 Teaching Compilers Backward</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Teaching Compilers Backward<br/>向后教授编制者 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-24 21:57:50</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/932aecf5e920ef33444d8ee2ec6a420d.jpg"><img src="http://img2.diglog.com/img/2021/2/932aecf5e920ef33444d8ee2ec6a420d.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Compiling a program is a fascinating, complex journey through which a high-level program becomes lower-level executable code. How is such a journey planned and realized? After developing the techniques, how to teach them to others?</p><p>编译程序是一个引人入胜的复杂过程，高级程序通过该程序成为低级可执行代码。如何规划和实现这样的旅程？开发技术后，如何教给别人？</p><p>  There is lately much  discussion of the pedagogy of compiler classes. In this blog post we would like to spotlight one design of compiler construction classes: the presentation order of the material. Usually, compiler classes present a compiler’s phases in the order they’re performed. We call this the “forward” direction. At Tel Aviv University, we’ve experimented with teaching compilers  “backward”. This post presents this approach and describes what we see as its key benefits.</p><p>  最近有很多关于编译器类的教学法的讨论。在此博客文章中，我们将重点介绍编译器构造类的一种设计：材料的表示顺序。通常，编译器类按执行顺序显示编译器的阶段。我们称此为“前进”方向。在特拉维夫大学，我们尝试了“向后”教学编译器。这篇文章介绍了这种方法，并描述了我们认为其主要优点。</p><p>    Let’s first briefly describe, in the “forward” fashion, how a compiler operates. First, the input program’s text is converted, through  lexical and syntactic analysis, to an  abstract syntax tree (AST), a representation that’s easy to manipulate. Second, the compiler performs a series of  semantic checks, ensuring that the program “makes sense” – variables are defined before they’re used, types add up, etc. In the process the compiler constructs a  symbol table, and attributes a type to every expression, ingredients which are also used in later stages. The compiler then proceeds to the third stage of  generating code in a low-level intermediate representation (IR), using the symbol table and typing information from before. Finally, the IR code is translated to the target language (say, x86 assembly).</p><p>    首先，以“转发”方式简要介绍编译器的工作方式。首先，通过词法和句法分析，将输入程序的文本转换为抽象的语法树（AST），这是一种易于操作的表示形式。其次，编译器执行一系列语义检查，以确保程序“有意义” –变量在使用前定义，类型加总等。在此过程中，编译器构造符号表，并将类型归因于每个表达式，也将在以后的阶段中使用的成分。然后，编译器使用符号表并键入之前的信息，进入以低级中间表示（IR）生成代码的第三阶段。最后，将IR代码转换为目标语言（例如x86汇编）。</p><p>    The  backward order teaches these phases in reverse: first, code generation; then semantic analysis; and then syntactic analysis. (Ours is not the first class to attempt the backward order – see the acknowledgments for an elaboration.)</p><p>    反向顺序以相反的顺序教授这些阶段：首先是代码生成；然后是代码生成。然后进行语义分析；然后进行句法分析。 （我们不是第一个尝试倒序的类–请参阅致谢以进行详细说明。）</p><p>    The first and foremost conceptual challenge in a compiler class is to understand how high-level code can be mapped to low-level code. The backward order first clarifies the compiler’s goal, the “what” of compiled programs before the “how” of the various compilation phases; and it’s useful to know where you’re going to understand how to get there.</p><p>    编译器类中的首要概念挑战是了解如何将高级代码映射到低级代码。反向顺序首先阐明了编译器的目标，即在各个编译阶段的“方式”之前，已编译程序的“内容”。并且知道您将要去哪里知道如何到达那里很有用。</p><p>  After setting the goal, the backward order works back from this less-familiar end to the more-familiar means. This is a common problem-solving strategy. Some studies have shown that a backward heuristic is preferred by novices when they solve problems which experts solve forward ( Larkin et al. 1980,  Simon &amp; Simon 1978). Crucially, we feel that studying the compiler’s stages backward better motivates each of them. (This is similar to the approach of the famous  Nand to Tetris class.)</p><p>  设定目标后，后序将从这个不太熟悉的一端返回到更加熟悉的方式。这是一种常见的解决问题的策略。一些研究表明，当新手解决专家们向前解决的问题时，他们倾向于使用向后启发式方法（Larkin等，1980； Simon＆amp; Simon，1978）。至关重要的是，我们认为研究编译器的后退阶段可以更好地激励他们。 （这类似于著名的Nand到Tetris类的方法。）</p><p>    How does the backward order work? In our class, the students develop a compiler that translates from  MiniJava – a subset of Java – to the  LLVM low-level intermediate representation (LLVM-IR), based on materials kindly provided by  Jens Palsberg,  Hal Perkins, and  Yannis Smaragdakis.</p><p>    落后订单如何运作？在我们的课程中，学生将根据Jens Palsberg，Hal Perkins和Yannis Smaragdakis提供的资料，开发一种编译器，该编译器将从MiniJava（Java的子集）转换为LLVM低级中间表示（LLVM-IR）。 </p><p>    Variable and method renaming: The input is a program’s AST, and the task is to rename a variable or method; that is, to produce a new AST with the new name in the declaration and uses. The renaming has to take into account scoping, variable hiding, the class hierarchy, and inheritance. This exercise is not part of the compiler per se, but develops basic skills that are necessary for the next exercises (rather than bundling them with the later exercises): implementing passes over the AST using  visitors, and constructing a symbol table. The analysis assumes that the input AST represents a program that is semantically valid, including typing rules and rules for valid inheritance.</p><p>变量和方法重命名：输入是程序的AST，任务是重命名变量或方法;也就是说，在声明和用途中以新名称生成新的AST。重命名必须考虑到范围，可变隐藏，类层次结构和继承。本练习不是编译器本身的一部分，但是开发了下一个练习所必需的基本技能（而不是用后来的练习捆绑它们）：使用访问者实现通过AST的传递，并构建符号表。分析假定输入AST表示语义有效的程序，包括键入有效继承的规则和规则。</p><p>  LLVM-IR code generation: The input is a program’s AST, and the task is to produce equivalent code in  LLVM-IR. Students generate low-level translations of high-level constructs while employing the symbol table they implemented in the previous exercise. All this under the assumption – to be enforced in the next exercise – that the input AST represents a program that’s semantically valid, including typing rules; the translation relies on the declared static types (without additional checking) to choose storage type and low-level instructions. Thus, if the input program doesn’t conform to the semantic rules, the translation may fail to generate code, or generate incorrect code. This observation leads to the next exercise.</p><p>  LLVM-IR代码生成：输入是程序的AST，任务是在LLVM-IR中生成等效代码。学生在采用他们在上一个练习中实现的符号表产生高级构造的低级翻译。所有这些都在假设下 - 在下一个练习中强制执行 - 输入AST表示一个语义有效的程序，包括输入规则;翻译依赖于声明的静态类型（无需额外检查）以选择存储类型和低级指令。因此，如果输入程序不符合语义规则，则转换可能无法生成代码，或者生成错误的代码。这种观察结果导致下一个练习。</p><p>  Semantic analysis: The input is a program’s AST, and the task is to decide whether it conforms to a list of semantic rules. We derived the list from the assumptions we made during code generation (including those we at first forgot we’d assumed…).</p><p>  语义分析：输入是程序的AST，任务是决定它是否符合语义规则列表。我们从我们在代码生成期间所做的假设（包括我们第一次忘记的假设中获取了列表，我们假设......）。</p><p>  Syntactic analysis: Finally, the input is a program code in text, and the task is to generate an AST that captures it, or report an error if the program doesn’t match the language’s grammar. This accounts to both lexical analysis and parsing, using lexer and parser generators.</p><p>  句法分析：最后，输入是文本中的程序代码，任务是生成捕获它的AST，或者如果程序与语言的语法不匹配，则报告错误。使用Lexer和Parser生成器来解析此帐户。</p><p>    AST input: In all but the last exercise, the input is not a usual textual representation of programs, but ASTs. We used an XML encoding of a specific AST structure we chose, and supplied code to decode XML files into a Java class hierarchy which students’ code manipulates. This way we could defer parsing until the last exercise, but it meant that students had to directly encode the ASTs of their test programs. Students weren’t exactly thrilled about the prospect of writing ASTs by hand, but it mostly worked out OK.</p><p>    AST输入：除了最后一项练习中，输入不是常规的文本表示程序，但ASTS。我们使用了我们选择的特定AST结构的XML编码，并提供了将XML文件解码为学生代码操纵的Java类层次的代码。这样我们就可以推迟解析直到最后一次练习，但这意味着学生必须直接编码他们的测试程序的AST。学生对手工编写ASTS的前景并不完全令人惊讶，但它主要效果正常。</p><p>  Simplified typing: The first two exercises were assigned before we discussed type analysis, which is part of the third exercise. But type information is essential for both these tasks (as outlined above). We found that relying on the static type definitions – of which Java has plenty – suffices, if we adopt another restriction: that method calls are disallowed on the result of a method call (x.f().g() is an error). We included this restriction in the semantic checks students had to verify. (In principle code can be automatically transformed to obey this rule via variable extraction.) Overall, in this way, types can be  used before they’re  validated.</p><p>  简化打字：在我们讨论的类型分析之前分配了前两个练习，这是第三次练习的一部分。但是类型信息对于这两项任务至关重要（如上所述）。我们发现依赖静态类型定义 - 如果我们采用另一个限制我们包括在语义检查中的这种限制学生必须验证。 （在原则上可以自动转换为通过变量提取遵守此规则。）总体而言，通过这种方式，可以在验证之前使用类型。</p><p>      There’s more to a program than its syntax This is a mental barrier to overcome. Working solely with an AST representation of programs until very late helps with that.</p><p>      程序比其语法更多，这是一个克服的精神障碍。直到非常迟到的节目的AST代表性的帮助。 </p><p>  Lowering in the spotlight  In the backward approach, the correspondence between the high-level code students write and a low-level code implementation is already the topic of the second exercise, which is the first exercise that is part of the compiler itself. We think that this is a good focus.</p><p>在落后方法中降低了聚光灯，高级代码学生写作的对应关系和低级代码实现已经是第二次练习的主题，这是第一练习是编译器本身的一部分。我们认为这是一个很好的焦点。</p><p>  “Well-typed programs cannot go wrong” The way we pitched the exercise on semantic checks earlier, the role of the semantic checks is to ensure that the input program satisfies all the assumptions employed in the code generation phase. Since students have already implemented code generation and used the assumptions, this ascribes meaning to the long and seemingly-pointless list of semantic checks. This is because we expect from the compiler to generate correct code for every program that passes the semantic checking phase – a very tangible manifestation of the type safety principle that  well-typed programs cannot go wrong.</p><p>  “良好类型的程序不能出错”我们之前在语义检查上投球的方式，语义检查的作用是确保输入程序满足代码生成阶段中所采用的所有假设。由于学生已经实现了代码生成并使用了假设，因此这归因于长期且看似无意义的语义检查列表。这是因为我们期望编译器为传递语义检查阶段的每个程序生成正确的代码 - 良好类型的程序类型的安全原理的一个非常有形的表现出来不会出错。</p><p>  Parsing is well-motivated  Parsing constructs an AST. How ASTs facilitate the compiler’s analysis, and that they are preferable to manipulating the program text, should be well understood at this point, after implementing multiple analyses in the various exercises.</p><p>  解析是激烈的解析构建AST。 ASTS如何促进编译器的分析，并且在在各种练习中实施多次分析之后，在这一点上，应当很好地理解，它们是如何操纵程序文本的。</p><p>  There and back again One of our takeaways from this experience is that compilation is best understood holistically; the interfaces between compilation phases and their interdependencies are truly understood only when taken as a whole. It’s an interesting thought experiment, then, to consider these dependencies in both directions, rather than only in the usual, forward, way.</p><p>  从这种经历中，我们的外卖之一再次回来的是，编辑最好是全面了解;编译阶段和它们的相互依赖之间的接口只有在作为整体上时才真实地理解。这是一个有趣的思想实验，然后，在两个方向上考虑这些依赖性，而不是仅在通常的前进的方式。</p><p>    We enjoyed teaching the class backward, but also found that some aspects were harder to explain in this workflow.</p><p>    我们享受落后的课堂，但也发现某些方面在这个工作流程中难以解释。</p><p>  Where does assembly generation fit in? We were uncertain about when to teach the translation from IR to assembly, with the special challenge of  activation records. Asking students to tackle these first, as a “pure” backward approach mandates, is to start with what may be considered less-central themes. (We taught assembly generation but didn’t ask students to implement it, due to time constraints.) An alternative is to pose assembly generation as a concluding project of yet another  full compiler, this time of IR to assembly. Similar questions arise for when to teach compiler optimizations.</p><p>  装配一代在哪里适合？我们不确定何时教导IR到集会的翻译，具有激活记录的特殊挑战。要求学生首先解决这些，作为“纯粹”的落后方法任务，是从可能被认为是较少的中央主题的。 （我们教会组装生成，但由于时间限制，没有要求学生实施它。）另一种方法是将集合生成作为另一个完整编译器的结论项目构成，这次IR对装配的这一时期。何时教授编译器优化时出现类似的问题。</p><p>  What are static types? Code generation in an object-oriented language builds on the difference between static and dynamic types. We assumed familiarity with these concepts would come from a prior class on object-oriented programming, but for students who struggled with this we found the distinction hard to explain before discussing type checking.</p><p>  什么是静态类型？面向对象语言的代码生成构建了静态和动态类型之间的差异。我们熟悉这些概念将来自上课，以对面向对象的编程，但对于在讨论类型检查之前，我们发现难以解释的学生。 </p><p>  The other role of semantic checks?  Semantic checks are not only important for the compiler, to guarantee the validity of code generation; they have another role: alerting the programmer to nonsensical code (even if the compiler can somehow “overcome” the error and generate code!). This other role may seem secondary when teaching backward.</p><p>语义检查的其他作用？语义检查不仅对于编译器很重要，还可以确保代码生成的有效性；它们还有另一个作用：警告程序员注意不合理的代码（即使编译器可以某种方式“克服”错误并生成代码！）。向后教学时，该其他角色似乎是次要的。</p><p>  Why runtime checks?  When implementing code generation, students must generate code to perform runtime checks, but other checks are “deferred” to the earlier stage of semantic checks. The reasoning behind the stage at which each check is performed doesn’t become clear until the discussion of semantic checks and static analysis.</p><p>  为什么要运行时检查？在实现代码生成时，学生必须生成代码以执行运行时检查，但是其他检查将“推迟”到语义检查的早期阶段。在讨论语义检查和静态分析之前，不清楚执行每个检查的阶段的原因。</p><p>  Why this specific AST structure?  In our current structure, “programs” are synonymous with “ASTs” until very late, in the parsing exercise. This may give the illusion that our choice of AST is intrinsic to the language. We feel that students cannot be expected to make informed choices when designing the AST before seeing a full compiler, whichever direction used, but alluding to a fixed AST structure is sometimes too easy (we were sorely tempted when we explained the difference between semantic and syntactic errors). Also, not constantly referring to the language’s grammar made it harder for students to become accustomed to the syntactic subset of the language they were compiling.</p><p>  为什么使用这种特定的AST结构？在我们目前的结构中，在分析过程中，直到很晚，“程序”还是“ AST”的同义词。这可能会给人一种幻想，即我们对AST的选择是该语言固有的。我们认为，在设计AST之前，不希望学生在看到完整的编译器之前就做出明智的选择，无论使用哪种方向，但是提到固定的AST结构有时都太容易了（当我们解释了语义和句法之间的区别时，我们非常感兴趣。错误）。另外，由于不经常提及该语言的语法，这使得学生更难于习惯他们所编译语言的语法子集。</p><p>    An altogether different course structure is when  the compiler is built incrementally to support more and more language features; where applicable, it solves the question of order by working on all phases together. In a more traditional structure, a “backward approach” to teaching compilers is just one possible answer to several questions, most prominent of which are how to make the compiler’s end-goal tangible, and how to motivate parsing and semantic checks as effectively as possible. The experience of implementing a code analysis outside the traditional compiler setting, in the exercise on variable renaming, is a cool bonus. The backward approach also raises questions of its own, particularly along the axis of how the compiler filters invalid programs, which may benefit from the forward, operational direction. We hope to see further ideas on achieving a synthesis of these approaches.</p><p>    完全不同的课程结构是编译器以增量方式构建以支持越来越多的语言功能时的情况。在适用的情况下，它通过共同努力解决所有阶段的秩序问题。在更传统的结构中，向编译器教学的“向后方法”只是对以下几个问题的一种可能的答案，其中最突出的是如何使编译器的最终目标切实可行，以及如何尽可能有效地激发解析和语义检查。在变量重命名的练习中，在传统的编译器设置之外执行代码分析的经验是很不错的选择。向后方法也提出了自己的问题，特别是沿着编译器如何过滤无效程序的轴，这可能会受益于向前的操作方向。我们希望看到关于实现这些方法综合的更多想法。</p><p>  Bio :   Yotam Feldman  is a PhD student at Tel Aviv University, working on formal methods, hence talking about forward and backward (reachability) on most days.   Mooly Sagiv  is a professor of Computer Science at Tel Aviv University and the CEO of   Certora .  Mooly’s hobbies include Program Analysis, Program Verification, and Running.</p><p>  简介：Yotam Feldman是特拉维夫大学的一名博士生，致力于形式方法的研究，因此大多数时候都在谈论前进和后退（可达性）。 Mooly Sagiv是特拉维夫大学计算机科学教授，也是Certora的首席执行官。 Mooly的爱好包括程序分析，程序验证和运行。</p><p>  Acknowledgments : Our class was inspired by   Steve Zdancewic’s class at UPenn  (which was inspired by Greg Morrisett’s class at Harvard and Andrew Myers’s class at Cornell), and drew on materials for compiling MiniJava graciously provided by   Jens Palsberg ,   Hal Perkins , and   Yannis Smaragdakis . A back-to-front approach to compiler classes was employed in   other classes  as well, and also discussed in a   previous PL Perspective by Lindsey Kuper .</p><p>  致谢：我们的课堂受到UPenn的Steve Zdancewic的课堂的启发（哈佛的Greg Morrisett的课堂和Cornell的Andrew Myers的课堂的启发），并借鉴了Jens Palsberg，Hal Perkins和Yannis Smaragdakis提供的MiniJava编译材料。其他类也采用了从后到前的编译器方法，Lindsey Kuper在先前的PL Perspective中也进行了讨论。</p><p>  We thank Oren Ish-Shalom, Jens Palsberg, Hila Peleg, Hal Perkins, and Steve Zdancewic for graciously lending us their materials, Oren Ish-Shalom and Hila Peleg for consulting on project design, and Oren Ish-Shalom, Jens Palsberg, James R. Wilcox, and Steve Zdancewic for comments and suggestions on a draft of this post.</p><p>  我们感谢Oren Ish-Shalom，Jens Palsberg，Hila Peleg，Hal Perkins和Steve Zdancewic慷慨地向我们提供了他们的材料，Oren Ish-Shalom和Hila Peleg为项目设计提供了咨询，以及Oren Ish-Shalom，Jens Palsberg，James R Wilcox和Steve Zdancewic对这篇文章的草稿提出了意见和建议。 </p><p>  Disclaimer:  These posts are written by individual contributors to share their thoughts on the SIGPLAN blog for the benefit of the community. Any views or opinions represented in this blog are personal, belong solely to the blog author and do not represent those of ACM SIGPLAN or its parent organization, ACM.</p><p>免责声明：这些职位是由个别贡献者撰写的，以分享他们关于社区利益的履行委员会的思想。 本博客中代表的任何观点或意见都是个人的，属于博客作者，并且不代表ACM Sigplan或其父组织，ACM。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.sigplan.org/2021/02/23/teaching-compilers-backward/">https://blog.sigplan.org/2021/02/23/teaching-compilers-backward/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/教授/">#教授</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/teaching/">#teaching</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译器/">#编译器</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>