<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>让Web应用程序是文件处理程序 Let web applications be file handlers</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Let web applications be file handlers<br/>让Web应用程序是文件处理程序 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-14 21:35:34</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/5d877a67bad78b45d6558c50a9945946.jpg"><img src="http://img2.diglog.com/img/2021/6/5d877a67bad78b45d6558c50a9945946.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The File Handling API is part of the  capabilities project and is currently in development. This post will be updated as the implementation progresses.</p><p>文件处理API是功能项目的一部分，当前正在开发中。这篇文章将在执行进展情况时更新。</p><p> Now that web apps are  capable of reading and writing files, the next logical step is to let developers declare these very web apps as file handlers for the files their apps can create and process. The File Handling API allows you to do exactly this. After registering a text editor app as a file handler, you can right-click a  .txt file on macOS and select &#34;Get Info&#34; to then instruct the OS that it should always open  .txt files with this app as default.</p><p> 现在，Web应用程序能够读写文件，下一个逻辑步骤是让开发人员将这些非常Web应用程序声明为文件处理程序，因为他们的应用程序可以创建和进程。文件处理API允许您完成此操作。将文本编辑器应用程序注册为文件处理程序后，您可以在麦斯斯上单击.txt文件，然后选择＆＃34;获取信息＆＃34;然后指示操作系统，它应该始终将此应用程序默认打开.txt文件。</p><p>        To experiment with the File Handling API locally, without an origin trial token, enable the  #file-handling-api flag in  about://flags.</p><p>        要在本地进行文件处理API，而无需源性试用令牌，请启用A //标志中的#file-handling-API标志。</p><p>  The File Handling API per se cannot be polyfilled. The functionality of opening files with a web app, however, can be achieved through two other means:</p><p>  无法聚合使用文件处理API本身。然而，使用Web应用程序打开文件的功能可以通过另外两种方式实现：</p><p> The  Web Share Target API lets developers specify their app as a share target so files can be opened from the operating system&#39;s share sheet.</p><p> Web Share Target API允许开发人员将其应用程序指定为共享目标，因此可以从操作系统和＃39; S共享表中打开文件。</p><p> The  File System Access API can be integrated with file drag and drop, so developers can handle dropped files in the already opened app.</p><p> 文件系统访问API可以与文件拖放集成，因此开发人员可以在已打开的应用程序中处理丢弃的文件。</p><p>       As a first step, web apps need to declaratively describe in their  web app manifest what kind of files they can handle. The File Handling API extends web app manifest with a new property called  &#34;file_handlers&#34; that accepts an array of, well, file handlers. A file handler is an object with two properties:</p><p>       作为第一步，Web应用程序需要在他们的Web应用程序中声明地描述他们可以处理的文件是什么样的文件。文件处理API扩展了使用名为＆＃34; file_handlers＆＃34的新属性的Web应用程序清单;接受一系列，井文件处理程序。文件处理程序是具有两个属性的对象： </p><p> An  &#34;action&#34; property that points to a URL within the scope of the app as its value.</p><p>一个＆＃34;行动＆＃34;要指向应用范围内的URL的属性为其价值。</p><p> An  &#34;accept&#34; property with an object of MIME-types as keys and lists of file extensions as their values.</p><p> AN＆＃34;接受＆＃34;具有MIME类型对象的属性作为作为其值的文件扩展名称和文件扩展名单。</p><p> The example below, showing only the relevant excerpt of the web app manifest, should make it clearer:</p><p> 下面的示例，仅显示Web应用程序清单的相关摘录，应更清晰：</p><p>  {  …   &#34;file_handlers&#34; :  [   {   &#34;action&#34; :  &#34;/open-csv&#34; ,   &#34;accept&#34; :  {   &#34;text/csv&#34; :  [ &#34;.csv&#34; ]   }   } ,   {   &#34;action&#34; :  &#34;/open-svg&#34; ,   &#34;accept&#34; :  {   &#34;image/svg+xml&#34; :  &#34;.svg&#34;   }   } ,   {   &#34;action&#34; :  &#34;/open-graf&#34; ,   &#34;accept&#34; :  {   &#34;application/vnd.grafr.graph&#34; :  [ &#34;.grafr&#34; ,  &#34;.graf&#34; ] ,   &#34;application/vnd.alternative-graph-app.graph&#34; :  &#34;.graph&#34;   }   }   ] ,  …  }</p><p>  {...＆＃34; file_handlers＆＃34; ：[{＆＃34;行动＆＃34; ：＆＃34; / Open-CSV＆＃34; ，＆＃34;接受＆＃34; ：{＆＃34;文本/ csv＆＃34; ：[＆＃34; .csv＆＃34; ]}}，{＆＃34;动作＆＃34; ：＆＃34; /开放式SVG＆＃34; ，＆＃34;接受＆＃34; ：{＆＃34;图像/ svg + XML＆＃34; ：＆＃34; .svg＆＃34; }}，{＆＃34;动作＆＃34; ：＆＃34; / open-graf＆＃34; ，＆＃34;接受＆＃34; ：{＆＃34;应用程序/ vnd.grafr.graph＆＃34; ：[＆＃34; .grafr＆＃34; ，＆＃34; .graf＆＃34; ]，＆＃34;应用程序/ vnd.alternative-graph-app.graph＆＃34; ：＆＃34; .Graph＆＃34; }}]，...}</p><p> This is for a hypothetical application that handles comma-separated value ( .csv) files at  /open-csv, scalable vector graphics ( .svg) files at  /open-svg, and a made-up Grafr file format with any of  .grafr,  .graf, or  .graph as the extension at  /open-graf.</p><p> 这是一个假设的应用程序，它处理/ Open-CSV，可缩放的矢量图形（.csv）文件处的逗号分隔值（.csv）文件，可在/ open-svg和与.grafr中的任何一个组成的grafr文件格式，.graf，或.graph作为/开放地区的延伸。</p><p> For this declaration to have any effect, the application must be installed. You can learn more in an article series on this very site on  making your app installable.</p><p> 对于此声明有任何效果，必须安装应用程序。您可以在本网站上的文章系列中了解更多内容，让您的应用程序可安装。</p><p>   Now that the app has declared what files it can handle at which in-scope URL in theory, it needs to imperatively do something with incoming files in practice. This is where the  launchQueue comes into play. To access launched files, a site needs to specify a consumer for the  window.launchQueue object. Launches are queued until they are handled by the specified consumer, which is invoked exactly once for each launch. In this manner, every launch is handled, regardless of when the consumer was specified.</p><p>   既然该应用程序已声明它可以在理论上掌握范围内网址的文件中的哪些文件，它需要在实践中致命地进行传入文件。这是发射曲线发挥作用的地方。要访问启动文件，站点需要为window.launchqueue对象指定消费者。启动是排队，直到它们由指定的消费者处理，这是每次启动的一次才能调用一次。以这种方式，无论在指定消费者时，处理每次发布。 </p><p>  if  ( &#39;launchQueue&#39;  in window )  {  launchQueue . setConsumer ( ( launchParams )  =&gt;  {   // Nothing to do when the queue is empty.   if  ( !launchParams .files .length )  {   return ;   }   for  ( const fileHandle  of launchParams .files )  {   // Handle the file.   }   } ) ;  }</p><p>if（＆＃39; Labledutue＆＃39;在窗口中）{LabrowQueue。 setConsumer（（LaunchParams）=＆gt; {//当队列为空时，无需任何操作。如果（！启动日常.length）{return;} for（launchpeperams .files的const filehandle）{//处理文件。} }）; }</p><p>  There is no DevTools support at the time of this writing, but I have filed a  feature request for support to be added.</p><p>  在本文的时候，没有DevTools支持，但我已经提交了一个要添加的支持的功能请求。</p><p>  I have added file handling support to  Excalidraw, a cartoon-style drawing app. When you create a file with it and store it somewhere on your file system, you can open the file via a double click, or a right click and then select &#34;Excalidraw&#34; in the context menu. You can check out the  implementation in the source code.</p><p>  我已添加文件处理支持，以Excalidraw，卡通风格的绘图应用程序。当您使用它创建文件并将其存储在文件系统上的某个位置时，您可以通过双击或右键打开文件，然后选择＆＃34; Excalidraw＆＃34;在上下文菜单中。您可以查看源代码中的实现。</p><p>    The Chrome team has designed and implemented the File Handling API using the core principles defined in  Controlling Access to Powerful Web Platform Features, including user control, transparency, and ergonomics.</p><p>    Chrome Team使用控制权限，包括用户控制，透明度和人体工程学，包括控制访问功能的核心原则，设计和实现了文件处理API。</p><p>  To ensure user trust and the safety of users&#39; files when the File Handling API is used to open a file, a permission prompt will be shown before a PWA can view a file. This permission prompt will be shown right after either of the following scenarios:</p><p>  确保用户信任和用户的安全性＆＃39;文件在文件处理API用于打开文件时，将在PWA可以查看文件之前显示权限提示。在以下任一种方案之后将在以下任一种方案之后显示此权限提示：</p><p> The user selects the PWA to open a file, so that the permission is tightly coupled to the action of opening a file using the PWA, making it more understandable and relevant.</p><p> 用户选择PWA以打开文件，以便权限紧密地耦合到使用PWA打开文件的动作，使其更加理解和相关。</p><p> The site loads without the file, so that the user has an expectation of what the PWA is and why it would like to view the file.</p><p> 没有文件的站点加载，以便用户期望PWA是什么以及为什么要查看文件。 </p><p> This permission will show every time until the user clicks to  Allow or  Block file handling for the site, or ignores the prompt three times (after which Chromium will embargo and block this permission). The selected setting will persist across the PWA closing and reopening.</p><p>此许可每次都会显示，直到用户点击以允许或阻止该站点的文件处理，或忽略提示三次（之后，铬将禁运并阻止此许可）。所选设置将涵固PWA关闭和重新开放。</p><p> When the manifest updates and changes in the  &#34;file_handlers&#34; section are detected, the permissions will be reset.</p><p> 当清单更新和更改和＃34; file_handlers＆＃34;部分检测到，权限将被重置。</p><p>  There is a large category of attack vectors that are opened by allowing websites access to files. These are outlined in the  article on the File System Access API. The additional security-pertinent capability that the File Handling API provides over the File System Access API is the ability to grant access to certain files through the operating system&#39;s built-in UI, as opposed to through a file picker shown by a web application.</p><p>  通过允许网站访问文件，存在大类攻击向量。这些在文件系统访问API上的文章中概述。文件处理API提供的额外安全相关性能提供文件系统访问API是能够通过操作系统＆＃39; S内置UI授予某些文件的访问权限，而不是通过A显示的文件选择器Web应用程序。</p><p> There is still a risk that users may unintentionally grant a web application access to a file by opening it. However, it is generally understood that opening a file allows the application it is opened with to read and/or manipulate that file. Therefore, a user&#39;s explicit choice to open a file in an installed application, such as via an &#34;Open with…&#34; context menu, can be read as a sufficient signal of trust in the application.</p><p> 仍然存在用户可能无意中通过打开它来对文件访问文件的风险。然而，通常可以理解，打开文件允许应用程序被打开，以便读取和/或操纵该文件。因此，用户＆＃39; s明确的选择要在安装的应用程序中打开文件，例如通过AN＆＃34;与...＆＃34打开;上下文菜单可以读取应用程序中的足够信任信号。</p><p>  The exception to this is when there are no applications on the host system for a given file type. In this case, some host operating systems may automatically promote the newly registered handler to the default handler for that file type, silently and without any intervention by the user. This would mean if the user double clicks a file of that type, it would automatically open in the registered web app. On such host operating systems, when the user agent determines that there is no existing default handler for the file type, an explicit permission prompt might be necessary to avoid accidentally sending the contents of a file to a web application without the user&#39;s consent.</p><p>  对此的例外是当主机系统上没有用于给定文件类型的应用程序。在这种情况下，某些主机操作系统可以自动将新注册的处理程序推广到该文件类型的默认处理程序，默默地，默默地，没有用户的任何干预。这将意味着用户双击该类型的文件，它将在注册的Web应用程序中自动打开。在这样的主机操作系统上，当用户代理确定没有文件类型的现有默认处理程序时，可能需要显式权限提示以避免意外地将文件的内容发送到没有用户的Web应用程序。同意。</p><p>  The spec states that browsers should not register every site that can handle files as a file handler. Instead, file handling registration should be gated behind installation and never happen without explicit user confirmation, especially if a site is to become the default handler. Rather than hijacking existing extensions like  .json that the user probably already has a default handler registered for, sites should consider crafting their own extensions.</p><p>  规范指出，浏览器不应注册可以将文件处理为文件处理程序的每个站点。相反，文件处理登记应该在安装后面门控，而不会发生没有明确的用户确认，特别是如果站点是成为默认处理程序。而不是劫持像.json，而用户可能已经有一个默认处理程序注册，则站点应该考虑制作自己的扩展。</p><p>  All operating systems allow users to change the present file associations. This is outside the scope of the browser.</p><p>  所有操作系统允许用户更改当前文件关联。这超出了浏览器的范围。 </p><p>    Is there something about the API that doesn&#39;t work like you expected? Or are there missing methods or properties that you need to implement your idea? Have a question or comment on the security model?</p><p>是否有关于API的事情，这也像你一样的工作？或者是否缺少履行您的想法的方法或属性？有一个问题或评论安全模型？</p><p> File a spec issue on the corresponding  GitHub repo, or add your thoughts to an existing issue.</p><p> 在相应的github repo上提交规格问题，或将您的想法添加到现有问题。</p><p>  Did you find a bug with Chrome&#39;s implementation? Or is the implementation different from the spec?</p><p>  你有没有找到镀铬的错误＆＃39的实施？或者与规范不同吗？</p><p> File a bug at  new.crbug.com. Be sure to include as much detail as you can, simple instructions for reproducing, and enter  UI&gt;Browser&gt;WebAppInstalls&gt;FileHandling in the  Components box.  Glitch works great for sharing quick and easy repros.</p><p> 在new.crbug.com上提交错误。请务必与您提供尽可能多的细节，简单的再现说明，进入UI＆gt;浏览器＆gt; webappinstalls＆gt; filehandling在组件框中。毛刺很高兴分享快速和简单的Repros。</p><p>  Are you planning to use the File Handling API? Your public support helps the Chrome team to prioritize features and shows other browser vendors how critical it is to support them.</p><p>  您是否计划使用文件处理API？您的公共支持帮助Chrome团队能够优先考虑功能，并显示其他浏览器供应商支持它们是多么关键。</p><p> Send a tweet to  @ChromiumDev using the hashtag   #FileHandling and let us know where and how you are using it.</p><p> 使用Hashtag将Tweet发送到@ChromiumDev #fileHandling并告诉我们您使用它的位置以及如何使用它。</p><p>      The File Handling API was specified by  Eric Willigers,  Jay Harris, and  Raymes Khoury. This article was reviewed by  Joe Medley.</p><p>      文件处理API由Eric Walligers，Jay Harris和Raymes Khoury指定。这篇文章由Joe Medley审查。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://web.dev/file-handling/">https://web.dev/file-handling/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/应用程序/">#应用程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文件/">#文件</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>