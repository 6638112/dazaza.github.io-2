<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>平滑体素地形，第2部分（2012年） Smooth Voxel Terrain, Part 2 (2012)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Smooth Voxel Terrain, Part 2 (2012)<br/>平滑体素地形，第2部分（2012年） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-09 14:18:58</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/1/e8210b279e82685000dfd9f41d2ab7fd.png"><img src="http://img2.diglog.com/img/2021/1/e8210b279e82685000dfd9f41d2ab7fd.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Last time we formulated the problem of isosurface extraction and discussed some general approaches at a high level.  Today, we’re going to get very specific and look at meshing in particular.</p><p>上一次，我们提出了等值面提取问题，并在较高级别上讨论了一些通用方法。今天，我们将变得非常具体，特别是网格。</p><p> For the sake of concreteness, let us suppose that we have approximated our potential field   by sampling it onto a cubical grid at some fixed resolution.  To get intermediate values, we’ll just interpolate between grid points using the standard  trilinear interpolation.  This is like a   generalization of Minecraft-style voxel surfaces.  Our goal in this article is to figure out how to extract a mesh of the implicit surface (or zero-crossings of  ).  In particular, we’re going to look at three different approaches to this problem:</p><p> 为了具体起见，让我们假设我们已经通过以某个固定分辨率将其采样到立方网格上来近似势场。为了获得中间值，我们将使用标准三线性插值在网格点之间进行插值。这就像Minecraft样式体素曲面的一般化。本文的目标是弄清楚如何提取隐式曲面的网格（或的零交叉点）。特别是，我们将研究解决此问题的三种不同方法：</p><p>  By far the most famous method for extracting isosurfaces is the  marching cubes algorithm.  In fact, it is so popular that the term `marching cubes’ is even more popular than the term `isosurface’ (at least according to Google)!   It’s quite a feat when an algorithm becomes more popular than the problem which it solves!  The history behind this method is very interesting.  It was originally  published back in SIGGRAPH 87, and then summarily patented by the Lorensen and Cline.  This fact has caused a lot of outrage, and is been widely cited as one of the classic examples of patents hampering innovation.  Fortunately, the patent on marching cubes expired back in 2005 and so today you can freely use this algorithm in the US with no fear of litigation.</p><p>  到目前为止，提取等值面最著名的方法是行进立方体算法。实际上，它是如此流行，以至于术语“前进立方体”比术语“等值面”更受欢迎（至少根据Google而言）！当算法变得比解决的问题更受欢迎时，这真是一项壮举！此方法的历史非常有趣。它最初在SIGGRAPH 87中发布，然后由Lorensen和Cline获得了专利。这一事实引起了很多愤慨，被广泛引用为阻碍创新的专利的经典例子之一。幸运的是，行军立方体的专利于2005年到期，因此今天您可以在美国自由使用此算法，而不必担心诉讼。</p><p> Much of the popularity of marching cubes today is due in no small part to a famous article written by  Paul Bourke.  Back in 1994 he made a webpage called  “Polygonizing a Scalar Field”, which presented a short, self-contained reference implementation of marching cubes (derived from some earlier work by Cory Gene Bloyd.)  That tiny snippet of a C program is possibly   the most copy-pasted code of  all time.  I have seen some variation of Bloyd/Bourke’s code in  every implementation of marching cubes that I’ve ever looked at, without exception.  There are at least a couple of reasons for this:</p><p> 如今，行军的流行很大程度上归功于保罗·伯克（Paul Bourke）撰写的著名文章。早在1994年，他制作了一个名为“多边形化标量场”的网页，该网页介绍了行进立方体的简短，自包含的参考实现（摘自Cory Gene Bloyd的早期工作。）C程序的这一小片段可能是一直是大多数复制粘贴的代码。在我看过的每一个行进多维数据集实现中，我都看到了Bloyd / Bourke代码的一些变体，无一例外。至少有两个原因：</p><p> Paul Bourke’s exposition is really good.  Even today, with many articles and tutorials written on the technique, none of them seem to explain it quite as well.  (And I don’t have any delusions that I will do any better!)</p><p> 保罗·伯克（Paul Bourke）的展览真是太好了。即使在今天，有关该技术的文章和教程也很多，但似乎都没有人对此做充分的解释。 （而且我没有任何错觉，我会做得更好！）</p><p> Also their implementation is very small and fast.  It uses some clever tricks like a precalculated edge table to speed up vertex generation.  It is difficult to think of any non-trivial way to improve upon it.</p><p> 而且它们的实现非常小且快速。它使用了一些巧妙的技巧，例如预先计算的边表，以加快顶点生成。很难想到任何非平凡的方法来改进它。</p><p> This last point needs some explaining,  Conceptually, marching cubes is rather simple.  What it does is sample the implicit function along a grid, and then checks the sign of the potential function at each point (either +/-).  Then, for every edge of the cube with a sign change, it finds the point where this edge intersects the volume and adds a vertex (this is just like ray casting a bunch of tiny little segments between each pair of grid points).  The hard part is figuring out how to stitch some surface between these intersection points.  Up to the position of the zero crossings, there are   different possibilities, each of which is determined by the sign of the function at the 8 vertices of the cube:</p><p> 最后一点需要一些解释。从概念上讲，前进立方体非常简单。它的作用是沿网格对隐式函数进行采样，然后在每个点（+/-）上检查潜在函数的符号。然后，对于具有符号变化的立方体的每个边缘，它找到该边缘与体积相交的点并添加一个顶点（这就像射线在每对网格点之间投射一堆微小的小段一样）。困难的部分是弄清楚如何在这些交叉点之间缝一些表面。直到零交叉点的位置，都有不同的可能性，每种可能性都由立方体的8个顶点处的函数的符号决定： </p><p>   Even worse, some of these cases are ambiguous!  The only way to resolve this is to somewhat arbitrarily break the symmetry of the table based on a case-by-case analysis. What a mess!  Fortunately, if you just download Bloyd/Bourke’s code, then you don’t have to worry about any of this and everything will just work.  No wonder it gets used so much!</p><p>更糟糕的是，其中一些情况是模棱两可的！解决此问题的唯一方法是基于个案分析在某种程度上任意打破表格的对称性。真是一团糟！幸运的是，如果您只是下载Bloyd / Bourke的代码，则不必担心任何这些，一切都将正常工作。难怪它被大量使用了！</p><p>  Both the importance of isosurface extraction and the perceived shortcomings of marching cubes motivated the search for alternatives.  One of the most popular was the  marching tetrahedra, introduced by Doi and Koide.  Besides the historical advantage that marching tetrahedra was not patented, it does have a few technical benefits:</p><p>  等值面提取的重要性和行进立方体的缺点都促使人们寻找替代方案。最受欢迎的作品之一是Doi和Koide推出的行进四面体。除了行军四面体没有专利的历史优势外，它还有一些技术优势：</p><p> Marching tetrahedra does not have ambiguous topology, unlike marching cubes.  As a result, surfaces produced by marching tetrahedra are always manifold.</p><p> 行进四面体与行进立方体不同，它没有模棱两可的拓扑。结果，四面体行进产生的表面总是多面体。</p><p> The amount of geometry generated per tetrahedra is much smaller, which might make it more suitable for use in say a geometry shader.</p><p> 每个四面体生成的几何图形的数量要小得多，这可能使其更适合用于几何图形着色器。</p><p> Finally, marching tetrahedra has only   cases, a number which can be further reduced to just 3 special cases by symmetry considerations.  This is enough that you can work them out by hand.</p><p> 最后，行进四面体只有一些情况，考虑到对称性，这个数目可以进一步减少为3种特殊情况。这足以使您可以手工解决它们。</p><p> Exercise:  Try working out the cases for marching tetrahedra yourself.  (It is really not bad.)</p><p> 练习：尝试找出自己行进四面体的情况。 （真的不错）。</p><p> The general idea behind marching tetrahedra is the same as marching cubes, only it uses a tetrahedral subdivision.  Again, the standard reference for practical implementation is Paul Bourke ( same page as before, just scroll down a bit.)  While there is a lot to like about marching tetrahedra, it does have some draw backs.  In particular, the meshes you get from marching tetrahedra are typically about 4x larger than marching cubes.  This makes both the algorithm and rendering about 4x slower.  If your main consideration is performance, you may be better off using a cubical method.  On the other hand, if you really need a manifold mesh, then marching tetrahedra could be a good option.  The other nice thing is that if you are obstinate and like to code everything yourself, then marching tetrahedra may be easier since there aren’t too many cases to check.</p><p> 行进四面体的总体思路与行进立方体相同，只是行进使用四面体细分。再次，实际实现的标准参考是Paul Bourke（与以前相同的页面，请向下滚动一点。）尽管行进四面体有很多优点，但确实有一些缺点。特别是，从行进的四面体获得的网格通常比行进的立方体大约4倍。这使得算法和渲染速度都降低了约4倍。如果您主要考虑性能，那么使用三次方方法可能会更好。另一方面，如果您确实需要流形网格，则行进四面体可能是一个不错的选择。另一个好处是，如果您固执己见并且喜欢自己编写所有代码，那么进行四面体操作可能会比较容易，因为不需要检查太多情况。 </p><p>  By now, both marching cubes and tetrahedra are quite old.  However, research into isosurface extraction hardly stopped in the 1980s.  In the intervening years, many new techniques have been developed.  One general class of methods which has proven very effective are the so-called `dual’ schemes.  The first dual method, surface nets, was proposed by Sarah Frisken Gibson in 1999:</p><p>到目前为止，行进的立方体和四面体都已经很老了。但是，等面萃取的研究在1980年代几乎没有停止。在随后的几年中，已经开发了许多新技术。一种被证明非常有效的通用方法是所谓的“双重”方案。 Sarah Frisken Gibson在1999年提出了第一种对偶方法，即表面网：</p><p> S.F. Gibson, (1999) “ Constrained Elastic Surface Nets”  Mitsubishi Electric Research Labs, Technical Report.</p><p> 顺丰吉布森（Gibson），（1999年）“约束弹性表面网”，三菱电机研究实验室，技术报告。</p><p> The main distinction between dual and primal methods (like marching cubes) is the way they generate surface topology.  In both algorithms, we start with the same input: a volumetric mesh determined by our samples, which I shall take the liberty of calling a  sample complex for lack of a better term.  If you’ve never heard of the word  cell complex before, you can think of it as an n-dimensional generalization of a triangular mesh, where the `cells’ or facets don’t have to be simplices.</p><p> 对偶方法和原始方法（例如行进立方体）之间的主要区别是它们生成表面拓扑的方式。在这两种算法中，我们都从相同的输入开始：一个由我们的样本确定的体积网格，由于缺乏更好的术语，我将自由地调用一个样本复合体。如果您以前从未听说过“单元复合物”一词，可以将其视为三角形网格的n维概括，其中“单元”或小平面不必是简单的。</p><p> In the sample complex, vertices (or 0-cells) correspond to the sample points; edges (1-cells) correspond to pairs of nearby samples; faces (2-cells) bound edges and so on:</p><p> 在样本复合物中，顶点（或0像元）对应于样本点。边缘（1个单元）对应于附近的样本对；面（2个单元）绑定的边缘等：</p><p>  Here is an illustration of such a complex.  I’ve drawn the vertices where the potential function is negative black, and the ones where it is positive white.</p><p>  这是这种复杂情况的说明。我绘制了顶点，其中势函数为负黑色，而顶点为正白色。</p><p> Both primal and dual methods walk over the sample complex, looking for those cells which cross the 0-level of the potential function.  In the above illustration, this would include the following faces:</p><p> 原始方法和对偶方法都遍历样本复合物，寻找与潜在功能的0级交叉的单元。在上图中，这将包括以下面孔：</p><p>   Primal methods, like marching cubes, try to turn the cells crossing the bounary into an isosurface using the following recipe:</p><p>   原始方法（例如，行进立方体），尝试使用以下配方将越过边界的细胞转变为等值面： </p><p>  One way to construct a primal mesh for our sample complex would be the following:</p><p>为我们的样本复合体构造原始网格的一种方法如下：</p><p>  This is pretty nice because it is easy to find intersection points along edges.  Of course, there is some topological ambiguity in this construction.  For non-simplicial cells crossing the boundary it is not always clear how you would glue the cells together:</p><p>  这很不错，因为很容易沿边缘找到相交点。当然，此构造中存在一些拓扑歧义。对于跨越边界的非简单单元，并不总是清楚如何将单元粘合在一起：</p><p>  As we have seen, these ambiguities lead to exponentially many special cases, and are generally a huge pain to deal with.</p><p>  如我们所见，这些歧义导致了许多特殊情况的成倍增加，并且通常很难解决。</p><p>  Dual methods on the other hand use a very different topology for the surface mesh.  Like primal methods, they only consider the cells which intersect the boundary, but the rule they use to construct surface cells is very different:</p><p>  另一方面，对偶方法对曲面网格使用非常不同的拓扑。像原始方法一样，它们仅考虑与边界相交的单元格，但用于构造表面单元格的规则却大不相同：</p><p>    The nice thing about this construction is that unlike primal methods, the topology of the dual isosurface mesh is completely determined by the sample complex (so there are no ambiguities).  The disadvantage is that you may sometimes get non-manifold vertices:</p><p>    这种构造的好处在于，与原始方法不同，双等值面网格的拓扑结构完全由样本复合物确定（因此没有歧义）。缺点是您有时可能会得到非流形顶点：</p><p>     The second item is the tricky part, and much of the research into dual methods has focused on exploring the possibilities.  It is interesting to note that this is the opposite of primal methods, where finding vertices was pretty easy, but gluing them together consistently turned out to be quite hard.</p><p>     第二项是棘手的部分，对双重方法的许多研究都集中在探索可能性上。有趣的是，这与原始方法相反，在原始方法中，找到顶点非常容易，但始终将它们粘合在一起非常困难。</p><p>  Here’s a neat puzzle: what happens if we apply the dual recipe to a regular, cubical grid (like we did in marching cubes)?  Well, it turns out that you get the same boxy, cubical meshes that you’d make in a Minecraft game (topologically speaking)!</p><p>  这是一个整洁的难题：如果将双重配方应用于规则的立方网格会怎样？好吧，事实证明，您会获得与Minecraft游戏（从拓扑上来说）相同的方型立方体网格！ </p><p>  Left: A dual mesh with vertex positions snapped to integer coordinates.  Right: A dual mesh with smoothed vertex positions.</p><p>左：顶点位置对齐到整数坐标的双网格。右：具有平滑顶点位置的双网格。</p><p> So if you know how to  generate Minecraft meshes, then you already know how to make smooth shapes!  All you have to do is squish your vertices down onto the isosurface somehow.  How cool is that?</p><p> 因此，如果您知道如何生成Minecraft网格，那么您已经知道如何制作平滑形状！您要做的就是以某种方式将顶点压缩到等值面上。多么酷啊？</p><p> This technique is called “surface nets” (remember when we mentioned them before?)  Of course the trick is to figure out where you place the vertices.  In Gibson’s original paper, she formulated the process of vertex placement as a type of global energy minimization and applied it to arbitrary smooth functions.  Starting with some initial guess for the point on the surface (usually just the center of the box), her idea is to perturb it (using gradient descent) until it eventually hits the surface somewhere.  She also adds a spring energy term to keep the surface nice and globally smooth.  While this idea sounds pretty good in theory, in practice it can be a bit slow, and getting the balance between the energy terms just right is not always so easy.</p><p> 这项技术称为“曲面网”（记得我们之前提到过它们吗？）当然，诀窍是弄清楚放置顶点的​​位置。在吉布森（Gibson）的原始论文中，她将顶点放置的过程描述为一种全局能量最小化的方法，并将其应用于任意平滑函数。从对表面上的点（通常只是盒子的中心）的一些初步猜测开始，她的想法是干扰它（使用梯度下降），直到最终撞到某个地方的表面。她还添加了一个春季能量术语，以保持表面美观和整体光滑。虽然这个想法在理论上听起来不错，但在实践中可能有点慢，并且要正确地找到能量项之间的平衡并不总是那么容易。</p><p>  Of course we can often do much better if we make a few assumptions about our functions.  Remember how I said at the beginning that we were going to suppose that we approximated   by trilinear filtering?  Well, we can exploit this fact to derive an optimal placement of the vertex in each cell —  without having to do any iterative root finding!  In fact, if we expand out the definition of a trilinear filtered function, then we can see that the 0-set is always a hyperboloid.  This suggests that if we are looking for a 0-crossings, then a good candidate would be to just pick the vertex of the hyperboloid.</p><p>  当然，如果对功能进行一些假设，我们通常会做得更好。还记得我一开始说过要假设我们通过三线性过滤近似吗？好吧，我们可以利用这一事实来得出顶点在每个单元格中的最佳位置-无需进行任何迭代的根查找！实际上，如果我们扩展三线性滤波函数的定义，那么我们可以看到0集始终是一个双曲面。这表明如果我们正在寻找0交叉，那么一个很好的选择就是选择双曲面的顶点。</p><p> Unfortunately, calculating this can be a bit of a pain, so let’s do something even simpler: Rather than finding the optimal vertex, let’s just compute the edge crossings (like we did in marching cubes) and then take their center of mass as the vertex for each cube.  Surprisingly, this works pretty well, and the mesh you get from this process looks similar to marching cubes, only with fewer vertices and faces.  Here is a side-by-side comparison:</p><p> 不幸的是，计算该值可能会有些麻烦，所以让我们做些更简单的事情：与其查找最佳顶点，不如寻找最佳顶点，而是仅计算边缘交叉（就像我们在行进立方体中所做的那样），然后将其质心作为顶点对于每个立方体。出乎意料的是，此方法效果很好，并且从此过程中获得的网格看起来与行进立方体相似，但顶点和面较少。这是一个并排比较：</p><p>   Another advantage of this method is that it is really easy to code (just like the naive/culling algorithm for generating Minecraft meshes.)  I’ve not seen this technique published or mentioned before (probably because it is too trivial), but I have no doubt someone else has already thought of it.  Perhaps one of you readers knows a citation or some place where it is being used in practice?  Anyway, feel free to steal this idea or use it in your own projects.  I’ve also got a  javascript implementation that you can take a look at.</p><p>   这种方法的另一个优点是它非常容易编码（就像生成Minecraft网格的朴素/剔除算法一样）。我以前没有看过这种技术的发表或提及（可能是因为它太琐碎了），但是我有毫无疑问，其他人已经想到了。也许你们中的某个读者知道引用或在实践中使用该引用的地方？无论如何，随时可以窃取这个想法或在您自己的项目中使用它。我还有一个JavaScript实现，您可以看一下。</p><p>  Say you aren’t happy with a mesh that is bevelled.  Maybe you want sharp features in your surface, or maybe you just want some more rigorous way to place vertices.  Well my friend, then you should take a look at dual contouring:</p><p>  假设您对带有斜角的网格不满意。也许您想要在表面上具有尖锐的特征，或者您只是想要一些更严格的方式来放置顶点。好吧，我的朋友，那么您应该看一下双重轮廓： </p><p> T. Ju, F. Losasso, S. Schaefer, and J. Warren.  (2004)  “ Dual Contouring of Hermite Data”  SIGGRAPH 2004</p><p>T. Ju，F。Losasso，S。Schaefer和J. Warren。 （2004）“ Hermite数据的双重轮廓” SIGGRAPH 2004</p><p> Dual contouring is a very clever solution to the problem of where to place vertices within a dual mesh.  However, it makes a very big assumption.  In order to use dual contouring you need to know not only the value of the potential function but also its gradient!  That is, for each edge you must compute the point of intersection AND a normal direction.  But if you know this much, then it is possible to reformulate the problem of finding a nice vertex as a type of linear least squares problem.  This technique produces very high quality meshes that can preserve sharp features.  As far as I know, it is still one of the best methods for generating high quality meshes from potential fields.</p><p> 对于在双网格中的何处放置顶点的​​问题，双轮廓是非常聪明的解决方案。但是，这是一个很大的假设。为了使用双重轮廓，您不仅需要知道势函数的值，还需要知道其梯度！也就是说，对于每个边，您必须计算相交点和法线方向。但是，如果您知道的那么多，那么就有可能将找到一个好的顶点的问题重新构造为一种线性最小二乘问题。该技术可产生可以保留清晰特征的非常高质量的网格。据我所知，它仍然是从潜在场中生成高质量网格物体的最佳方法之一。</p><p> Of course there are some downsides.  The first problem is that you need to have Hermite data, and recovering this from an arbitrary function requires using either numerical differentiation or applying some clunky automatic differentiator.  These tools are nice in theory, but can be difficult to use in practice (especially for things like noise functions or interpolated data).  The second issue is that solving an overdetermined linear least squares problem is much more expensive than taking a few floating point reciprocals, and is also more prone to blowing up unexpectedly when you run out of precision.  There is some discussion in the paper about how to manage these issues, but it can become very tricky.  As a result, I did not get around to implementng this method in javascript (maybe later, once I find a good linear least squares solver…)</p><p> 当然也有一些缺点。第一个问题是您需要拥有Hermite数据，并且要从任意函数中恢复该数据需要使用数值微分或应用一些笨拙的自动微分器。这些工具在理论上很好，但是在实践中可能很难使用（特别是对于诸如噪声函数或内插数据之类的东西）。第二个问题是，解决一个预先确定的线性最小二乘问题比获取几个浮点数倒数要昂贵得多，并且当精度不够用时，也更容易发生意外爆炸。本文中有一些有关如何处理这些问题的讨论，但是这可能会变得非常棘手。结果，我没办法在javascript中实现此方法（也许以后，一旦我找到了一个好的线性最小二乘法求解器……）</p><p>  As usual, I made a WebGL widget to try all this stuff out (caution: this one is a bit browser heavy):</p><p>  像往常一样，我制作了一个WebGL小部件来尝试所有这些东西（警告：此浏览器有点繁琐）：</p><p>  This tool box lets you compare marching cubes/tetrahedra and the (naive) surface nets that I described above.  The Perlin noise examples use the javascript code written by  Kas Thomas.  Both the marching cubes and marching tetrahedra algorithms are direct ports of Bloyd/Bourke’s C implementation.  Here are some side-by-side comparisons.</p><p>  这个工具箱可让您比较行军立方体/四面体和我上面描述的（原始）表面网。 Perlin噪声示例使用Kas Thomas编写的javascript代码。行进立方体和行进四面体算法都是Bloyd / Bourke C实现的直接端口。这是一些并排比较。</p><p>   MC: 15268 verts, 7638 faces. MT: 58580 verts, 17671 faces. SN: 3816 verts, 3701 faces.</p><p>   MC：15268个顶点，7638个面。 MT：58580个顶点，17671个面。 SN：3816个字，3701个面。</p><p>  MC: 1140 verts, 572 faces.  MT: 4200 verts, 1272 faces. SN: 272 verts, 270 faces.</p><p>  MC：1140个顶点，572个面。 MT：4200个顶点，1272个面。 SN：272个顶点，270个面。 </p><p>  MC: 80520 verts, 40276 faces. MT: 302744 verts, 91676 faces. SN: 20122 verts, 20130 faces.</p><p>MC：80520点，40276面MT：302744 verts，91676 faces。 SN：20122个版本，20130个面孔。</p><p>  MC: 172705 verts, 88071 faces. MT: 639522 verts, 192966 faces. SN: 41888 verts, 40995 faces.</p><p>  MC：172705个顶点，88071个面。 MT：639522个顶点，192966个面。 SN：41888个版本，40995个面。</p><p>  The controls are left mouse to rotate, right mouse to pan, and middle mouse to zoom.  I have no idea how this works on Macs.</p><p>  控件为：鼠标左键旋转，鼠标右键平移，鼠标中键缩放。我不知道这在Mac上如何运作。</p><p> I decided to try something different this time and put a little timing widget so you can see how long each algorithm takes.  Of course you really need to be skeptical of those numbers, since it is running in the browser and timings can fluctuate quite randomly depending on totally arbitrary outside forces.  However, it does help you get something of a feel for the relative performance of each method.</p><p> 这次我决定尝试一些不同的方法，并放置一个小计时部件，以便您可以看到每种算法需要多长时间。当然，您确实需要对这些数字表示怀疑，因为它正在浏览器中运行，并且时间可能会根据完全任意的外力而随机波动。但是，它确实可以帮助您对每种方法的相对性能有所了解。</p><p> In the marching tetrahedra example there are frequently many black triangles.  I’m not sure if this is because there is a bug in my port, or if it is a problem in three.js.  It seems like the issue might be related to the fact that my implementation mixes quads and triangles in the mesh, and that three.js does not handle this situation very well.</p><p> 在行进的四面体示例中，经常有许多黑色三角形。我不确定这是因为端口中有错误还是在three.js中出现问题。似乎该问题可能与以下事实有关：我的实现在网格中混合了四边形和三角形，并且three.js不能很好地处理这种情况。</p><p> I also didn’t implement dual contouring.  It isn’t that much different than surface nets, but in order to make it work you need to get Hermite data and solve some linear least squares problems, which is hard to do in Javascript due to lack of tools.</p><p> 我也没有实现双重轮廓。它与曲面网没有太大区别，但是要使其正常工作，您需要获取Hermite数据并解决一些线性最小二乘问题，由于缺少工具，在Javascript中很难做到这一点。</p><p>  To compare the relative performance of each method, I adapted the experimental protocol described in my  previous post.  As before, I tested the experiments on a sample sinusoid, varying the frequency over time.  That is, I generated a volume   volume plot of</p><p>  为了比较每种方法的相对性能，我采用了我以前的文章中描述的实验方案。和以前一样，我在样品正弦波上测试了实验，并随时间变化了频率。也就是说，我生成了一个 </p><p>    By far marching tetrahedra is the slowest method, mostly on account of it generating an order of magnitude more triangles.  Marching cubes on the other hand, despite generating nearly 2x as many primitives was still pretty quick.  For small geometries both marching cubes and surface nets perform comparably.  However, as the isosurfaces become more complicated, eventually surface nets win just on account of creating fewer primitives.  Of course this is a bit like comparing apples-to-oranges, since marching cubes generates triangles while surface nets generate quads, but even so surface nets still produce slightly less than half as many facets on the benchmark.  To see how they stack up, here is a side-by-side comparison of the number of primitives each method generates for the benchmark:</p><p>到目前为止，四面体是最慢的方法，主要是因为它产生了更多数量级的三角形。另一方面，行进多维数据集尽管生成了几乎两倍的原语，但仍然相当快。对于较小的几何形状，行进立方体和曲面网的性能相当。但是，随着等值面变得越来越复杂，最终由于仅创建较少的图元而最终获得了面网。当然，这有点像将苹果与橙色进行比较，因为行进的多维数据集生成三角形，而表面网生成四边形，但是即使如此，表面网生成的面仍然略小于基准面的一半。要查看它们如何堆叠，下面是每种方法为基准测试生成的原语数量的并排比较：</p><p>   Each of the isosurface extraction methods has their relative strengths and weaknesses.  Marching cubes is nice on account of the free and easily usable implementations, and it is also pretty fast.  (Not to mention it is also the most widely known.)  Marching tetrahedra solves some issues with marching cubes at the expense of being much slower and creating far larger meshes.  On the other hand surface nets are much faster and can be extended to generate high quality meshes using more sophisticated vertex selection algorithms.  It is also easy to implement and produces slightly smaller meshes.  The only downside is that it can create non-manifold vertices, which may be a problem for some applications.  I unfortunately never got around to properly implementing dual contouring, mostly because I’d like to avoid having to write a robust linear least squares solver in javascript.  If any of you readers wants to take up the challenge, I’d be interested to see what results you get.</p><p>   每种等值面提取方法都有其相对的优点和缺点。基于免费且易于使用的实现，行进多维数据集非常不错，而且运行速度也非常快。 （更不用说它也是最广为人知的）。行进四面体解决了行进立方体的一些问题，但代价是速度慢得多并且创建了更大的网格。另一方面，表面网要快得多，并且可以使用更复杂的顶点选择算法进行扩展以生成高质量的网格。它也很容易实现，并会产生较小的网格。唯一的缺点是它可以创建非流形顶点，这对于某些应用程序可能是个问题。不幸的是，我一直未能正确实现双重轮廓，主要是因为我想避免必须用JavaScript编写健壮的线性最小二乘法求解器。如果您有任何读者想接受挑战，我很想知道您获得了什么结果。</p><p>  I’ve been messing around with the wordpress theme a lot lately.  For whatever reason, it seems like the old one I was using would continually crash Chrome.  I’ve been trying to find something nice and minimalist.  Hopefully this one works out ok.</p><p>  最近，我一直在谈论wordpress主题。无论出于何种原因，看来我使用的旧版本会不断使Chrome崩溃。我一直在尝试寻找一些美好而简约的东西。希望这个可以解决。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://0fps.net/2012/07/12/smooth-voxel-terrain-part-2/">https://0fps.net/2012/07/12/smooth-voxel-terrain-part-2/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/体素/">#体素</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/voxel/">#voxel</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/网格/">#网格</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>