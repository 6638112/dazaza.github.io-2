<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Wordlexpr：C++20中的编译时WordleWordlexpr: Compile-Time Wordle in C++20</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Wordlexpr: Compile-Time Wordle in C++20<br/>Wordlexpr：C++20中的编译时Wordle</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-03-01 22:07:56</div><div class="page_narrow text-break page_content"><p>It felt wrong to not participate in the Wordle craze, and what better way of doing so than by creating a purely compile-time version of the game in C++20? I proudly present to you…  Wordlexpr!</p><p>不参与Wordle热潮是不对的，还有什么比在C++20中创建一个纯编译时版本的游戏更好的方法呢？我很自豪地向你们展示…Wordlexpr！</p><p>            Wordlexpr is played entirely at compile-time as no executable is ever generated – the game is experienced through compiler errors. Therefore, we need to solve a few problems to make everything happen:</p><p>Wordlexpr完全是在编译时玩的，因为从来没有生成过任何可执行文件——游戏是通过编译器错误体验的。因此，我们需要解决几个问题来实现一切：</p><p>      In order to abuse the compiler into outputting errors with an arbitrary string of our own liking, let’s start by trying to figure out how to make it print out a simple string literal. The first attempt,  static_assert, seems promising:</p><p>为了滥用编译器，以我们自己喜欢的任意字符串输出错误，让我们首先尝试找出如何让它打印出一个简单的字符串文字。第一次尝试，静态_断言，似乎很有希望：</p><p>    error: static assertion failed: Welcome to Wordlexpr! 1 | static_assert(false, &#34;Welcome to Wordlexpr!&#34;); | ^^^^^</p><p>错误：静态断言失败：欢迎使用Wordlexpr！</p><p>  However, our delight is short-lived, as  static_assert only accepts a string literal – a  constexpr array of characters or  const char* will not work as an argument:</p><p>然而，我们的喜悦是短暂的，因为static_assert只接受字符串文字——字符的constexpr数组或const char*将不会用作参数：</p><p>      So, how about storing the contents of our string as part of the type of a  struct, then produce an error containing such type?</p><p>那么，将字符串的内容存储为结构类型的一部分，然后生成包含此类类型的错误，怎么样？</p><p>    error: variable &#39;print&lt;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;&gt; _&#39; has initializer but incomplete type 3 | print&lt;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;&gt; _{}; |</p><p>错误：变量&#39；打印&lt&#39;a&#39&#39;b&#39&#39;c&#39&#39;d&#39&gt_&#39;</p><p>  Nice! We are able to see our characters in the compiler output, and we could theoretically mutate or generate the sequence of characters to our liking at compile-time. However, working with a  char... template parameter pack is very cumbersome, and the final output is not very readable.</p><p>美好的我们可以在编译器输出中看到我们的字符，理论上我们可以在编译时根据自己的喜好修改或生成字符序列。然而，使用字符。。。模板参数包非常繁琐，最终输出的可读性不强。</p><p>  C++20’s  P0732R2:  “Class Types in Non-Type Template Parameters” comes to the rescue here! In short, we can use any  literal type as a non-type template parameter. We can therefore create our own little compile-time string literal type:</p><p>C++20的P0732R2：“非类型模板参数中的类类型”在这里起到了解救作用！简而言之，我们可以使用任何文本类型作为非类型模板参数。因此，我们可以创建自己的小编译时字符串文本类型：</p><p>  struct ct_str  {    char _data[ 512]{};    std::size_t _size{ 0};      template &lt; std::size_t N&gt;    constexpr ct_str( const  char (&amp;str)[N]) : _data{}, _size{N -  1}   {    for( std::size_t i =  0; i &lt; _size; ++i)   _data[i] = str[i];   }  };</p><p>结构ct_str</p><p>  We can then accept  ct_str as a template parameter for  print, and use the same idea as before:</p><p>然后，我们可以接受ct_str作为打印的模板参数，并使用与之前相同的想法：</p><p>    error: variable &#39;print&lt;ct_str{&#34;Welcome to Wordlexpr!&#34;, 21}&gt; _&#39; has initializer but incomplete type 22 | print&lt;&#34;Welcome to Wordlexpr!&#34;&gt; _{}; |</p><p>错误：变量&#39；打印&lt；ct#u str{&#34；欢迎来到Wordlexpr！&#34；，21}&gt_&#39; 有</p><p>  Now we have a way of making the compiler emit whatever we’d like as an error. In fact, we can perform string manipulation at compile-time on  ct_str:</p><p>现在我们有了一种方法，可以让编译器发出任何我们想要的错误。事实上，我们可以在编译时对ct_str执行字符串操作：</p><p>  constexpr ct_str test()  {   ct_str s{ &#34;Welcome to Wordlexpr!&#34;};   s._data[ 0] =  &#39;w&#39;;   s._data[ 11] =  &#39;w&#39;;   s._data[ 20] =  &#39;.&#39;;    return s;  }    print&lt;test()&gt; _{};</p><p>constexpr ct_str test（）</p><p>  error: variable &#39;print&lt;ct_str{&#34;welcome to wordlexpr.&#34;, 20}&gt; _&#39; has initializer but incomplete type 33 | print&lt;test()&gt; _{}; | ^</p><p>错误：变量&#39；打印&lt；ct#u str{&#34；欢迎来到wordlexpr.&#34；，20}&gt_&#39; 有</p><p>  By extending  ct_str with functionalities such as  append,  contains,  replace, etc… we will end up being able to create any sort of string at compile-time and print it out as an error.</p><p>通过使用append、contains、replace等功能扩展ct_str，我们最终将能够在编译时创建任何类型的字符串，并将其作为错误打印出来。</p><p>      This is really not a big deal, if we allow our users to provide a seed on the command line via preprocessor defines. Pseudo-random number generation is always deterministic, and the final result only depends on the state of the RNG and the initially provided seed.</p><p>如果我们允许用户通过预处理器定义在命令行上提供种子，这真的不是什么大事。伪随机数的生成总是确定性的，最终结果只取决于RNG的状态和最初提供的种子。</p><p>    It is fairly easy to port a common RNG engine such as Mersenne Twister to C++20  constexpr. For the purpose of Wordlexpr, the modulo operator ( %) was enough:</p><p>将诸如Mersenne Twister这样的通用RNG引擎移植到C++20 constexpr是相当容易的。就Wordlexpr而言，模运算符（%）足够：</p><p>        If we allow the user to give us a seed via preprocessor defines, why not also allow the user to make progress in the same game session by telling us where they left off last time they played? Think of it as any save file system in a modern game – except that the “save file” is a short string which is going to be passed to the compiler:</p><p>如果我们允许用户通过预处理器定义给我们一个种子，为什么不允许用户在同一个游戏会话中通过告诉我们他们上次玩的地方来取得进展呢？可以将其视为现代游戏中的任何保存文件系统，但“保存文件”是一个短字符串，将被传递给编译器：</p><p>    The user doesn’t have to come up with the state string themselves – it will be generated by Wordlexpr on every step:</p><p>用户不必自己提出状态字符串——它将由Wordlexpr在每一步生成：</p><p>  error: variable &#39;print&lt;ct_str{&#34;You guessed `crane`. Outcome: `x-xx-`. You guessed `white`. Outcome: `xxox-`. You guessed `black`. Outcome: `xoxxx`. You guessed `tower`. Outcome: `xxxoo`. To continue the game, pass `-DSTATE=EJYHULDOPALISHJRAVDLYWAEIM` alongside a new guess.&#34;, 242}&gt; _&#39; has initializer but incomplete type 2612 | print&lt;make_full_str(SEED, guess, s)&gt; _{}; | ^</p><p>错误：变量&#39；打印&lt；ct_str{&#34；你猜到了‘crane’。结果是：'x-xx-'。</p><p>      All that’s left to do is to define encoding and decoding functions for the state:</p><p>剩下要做的就是为状态定义编码和解码函数：</p><p>    In Wordlexpr, I used a simple Caesar cipher to encode the guesses into the string without making them human-readable. It is not really necessary, but generally speaking another type of compile-time game might want to hide the current state by performing some sort of encoding.</p><p>在Wordlexpr中，我使用了一个简单的Caesar密码将猜测编码到字符串中，而不使其可读。这并不是真的必要，但一般来说，另一种编译时游戏可能希望通过执行某种编码来隐藏当前状态。</p><p>      I hope you enjoyed this brief explanation of how Wordlexpr works. Remember that you can play it yourself and see the entire source code  on Compiler Explorer. Feel free to reach out to ask any question!</p><p>我希望你喜欢这个关于Wordlexpr工作原理的简短解释。请记住，您可以自己播放，并在编译器资源管理器上查看整个源代码。请随意提出任何问题！</p><p>    My book   “Embracing Modern C++ Safely” is now available on all major resellers. Please consider purchasing it and share the news with your friends and colleagues – that helps a lot!</p><p>我的书“拥抱现代C++安全”现在在所有主要经销商上都可以使用。请考虑购买它并与你的朋友和同事分享这个消息，这很有帮助！</p><p>  For more information, read the following interview:  “Why 4 Bloomberg engineers wrote another C++ book”</p><p>欲了解更多信息，请阅读以下采访：“为什么4个彭博工程师写了另一本C++书”</p><p>  If you are a fan of fast-paced open-source arcade games that allow user-created content, check out   Open Hexagon, my first fully-released game  available on Steam and  on itch.io.</p><p>如果你喜欢快节奏的开源街机游戏，它允许用户创建内容，那就看看open Hexagon吧，这是我在Steam和itch上推出的第一款完全发布的游戏。伊奥。</p><p>  Open Hexagon is a spiritual successor to the critically acclaimed Super Hexagon by Terry Cavanagh.  Terry fully supports my project! Thanks!</p><p>Open Hexagon是Terry Cavanagh备受好评的Super Hexagon的精神继承者。特里完全支持我的项目！谢谢</p><p>  I offer 1-1 C++ mentoring and consulting sessions in my spare time. If it’s something you are interested in, feel free to reach out at  mail (at) vittorioromeo (dot) com or  on Twitter.</p><p>我在业余时间提供1-1个C++辅导和咨询课程。如果你对它感兴趣，可以通过mail（在）vittorioromeo（点）com或Twitter联系。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/c++/">#c++</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/wordlexpr/">#wordlexpr</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/compile/">#compile</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/字符串/">#字符串</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>