<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>数据差异：解释数据集中发生了什么变化的算法Data diffs: Algorithms for explaining what changed in a dataset</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Data diffs: Algorithms for explaining what changed in a dataset<br/>数据差异：解释数据集中发生了什么变化的算法</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-21 08:45:48</div><div class="page_narrow text-break page_content"><p>tl;dr:  part 1 explains what an explanation algorithm is, and  part 2 describes an open source SQL data differ.</p><p>tl；dr：第1部分解释了什么是解释算法，第2部分描述了一个开放源码的SQL数据模型。</p><p>  In the data world, most reporting starts by asking  how much?: “how many new customers purchase each week?” or “what is the monthly cost of medical care for this group?”</p><p>在数据世界中，大多数报告都是从问多少开始的：“每周有多少新客户购买？”或者“这个群体每月的医疗费用是多少？”</p><p> Inevitably the initial reports result in questions about  why?: “why did we see less purchases last week?” and “why are the medical costs for this group increasing?”</p><p>最初的报告不可避免地会引发关于为什么的问题：“为什么我们上周看到的购买量减少了？”“为什么这一群体的医疗费用在增加？”</p><p> The academic community has an answer to such  why? questions: explanation algorithms. An explanation algorithm looks at columns/properties of your dataset and identifies high-likelihood explanations (called “predicates” in database-speak). For example, the algorithms might find that you got less customers in the segment of people who saw a new marketing campaign, or that the medical costs for the group you’re studying can largely be attributed to costly treatments in a subgroup.</p><p>学术界对此有一个答案：为什么？问题：解释算法。解释算法查看数据集的列/属性，并识别高可能性解释（在数据库中称为“谓词”）。例如，算法可能会发现，在看到新营销活动的人群中，你得到的客户较少，或者你正在研究的群体的医疗成本在很大程度上可以归因于某个亚群体的昂贵治疗。</p><p> The academic interest is founded in real pain. When a journalist, researcher, or organization asks  why?, the resulting data anlysis largely goes into issuing ad hoc GROUP BY queries or unscientifically creating pivot tables to try to slice and dice datasets to explain some change in a dataset over time. Companies like  Sisu (founded by Peter Bailis, one of the authors of the DIFF paper discussed below) are built on the premise that data consumers are increasingly asking  why?</p><p>学术兴趣建立在真正的痛苦中。当记者、研究人员或组织问为什么时？，由此产生的数据分析主要用于通过查询发布特设分组，或不科学地创建数据透视表，试图对数据集进行切片和切分，以解释数据集随时间的变化。像Sisu这样的公司（由下面讨论的DIFF论文的作者之一Peter Bailis创建）是建立在这样一个前提之上的：数据消费者越来越问为什么？</p><p> You can rephrase lots of different questions in the form of an explanation question. This is an area I’ve been interested in for a while, especially as it might help people like journalists and social scientists better identify interesting trends. In  A data differ to help journalists (2015), I said:</p><p>你可以用解释性问题的形式重新表述许多不同的问题。这是一个我一直感兴趣的领域，尤其是因为它可能会帮助像记者和社会科学家这样的人更好地识别有趣的趋势。在《帮助记者的数据不同》（2015）一书中，我说：</p><p> It would be nice to have a utility that, given two datasets (e.g., two csv files) that are schema-aligned, returns a report of how they differ from one-another in various ways. The utility could take hints of interesting grouping or aggregate columns, or just randomly explore the pairwise combinations of (grouping, aggregate) and sort them by various measures like largest deviation from their own group/across groups.</p><p>如果有一个实用程序，在给定两个与模式对齐的数据集（例如，两个csv文件）的情况下，它会返回一个报告，说明它们在不同方面的差异，这将是一件好事。该实用工具可以对有趣的分组或聚合列进行提示，或者只是随机探索（分组、聚合）的成对组合，并通过各种度量对它们进行排序，比如与自己的组/跨组的最大偏差。</p><p> At the time of that post, I hadn’t yet connected the dots between the desire for such a system and the active work going on in the research world. Thanks to database researchers, that connection now exists! In this post, I’ll first cover two approaches to explanation algorithms, and then introduce an open source implementation of one of them in my  datools library.</p><p>在那篇文章发表的时候，我还没有把对这样一个系统的渴望和研究界正在进行的积极工作联系起来。多亏了数据库研究人员，这种联系现在已经存在了！在本文中，我将首先介绍两种解释算法的方法，然后在我的datools库中介绍其中一种算法的开源实现。</p><p>  In 2013, Eugene Wu and Sam Madden introduced  Scorpion, a system that explains why an aggregate (e.g., the customer count last week) is higher or lower than other example data. Figure 1 in their paper explains the problem quite nicely. They imagine a user looking at a chart, in this case of aggregate temperatures from a collection of sensors, and highlighting some outliers to ask “compared to the other points on this chart, why are these points so high?”</p><p>2013年，尤金·吴（Eugene Wu）和山姆·马登（Sam Madden）引入了Scorpion，这一系统解释了为什么总数据（例如上周的客户数量）高于或低于其他示例数据。他们论文中的图1很好地解释了这个问题。他们想象一个用户在看一张图表，在这种情况下，是一组传感器的总温度，并突出显示一些异常值，问“与图表上的其他点相比，这些点为什么这么高？”</p><p> A figure that shows how a user might highlight outliers on a chart (source: Scorpion paper)</p><p>图中显示了用户如何在图表上突出显示异常值</p><p> Scorpion has two nice properties. First, it operates on aggregates: it’s not until you look at some weekly or monthly statistics that you notice that something is off and search for an explanation. Second, it’s performant on a pretty wide variety of aggregates, with optimizations for the most common ones (e.g., sums, averages, counts, standard deviations). I believe that of all the explanation algorithms, Scorpion pairs the most intuitive phrasing of the question (“why so high/low?”) with the most intuitive experience (highlighting questionable results on a visualization).</p><p>蝎子有两个优点。首先，它是以总量为基础的：直到你看了一些每周或每月的统计数据后，你才注意到有什么不对劲，并寻找一个解释。其次，它适用于各种各样的聚合，并对最常见的聚合进行了优化（例如，总和、平均值、计数、标准差）。我相信在所有的解释算法中，Scorpion配对是问题最直观的措辞（“为什么这么高/低？”）最直观的体验（在可视化上突出可疑的结果）。</p><p> The challenge in implementing Scorpion is that, as presented, it does its processing outside of the database that stores the data. Specifically, the way Scorpion partitions and merges subsets of the data to identify an explanation requires decision trees and clustering algorithms that traditionally execute outside of the database  1. It is also specific to aggregates, which are commonly the source of  why questions, but aren’t the only places that question arises.</p><p>实现Scorpion的挑战在于，如前所述，它在存储数据的数据库之外进行处理。具体来说，Scorpion划分和合并数据子集以确定解释的方式需要决策树和聚类算法，这些算法通常在数据库1之外执行。它还特别适用于聚合，聚合通常是问题的来源，但不是问题出现的唯一地方。</p><p> This is where  DIFF comes in . In 2019, Firas Abuzaid, Peter Kraft, Sahaana Suri, Edward Gan, Eric Xu, Atul Shenoy, Asvin Ananthanarayan, John Sheu, Erik Meijer, Xi Wu, Jeff Naughton, Peter Bailis, and Matei Zaharia introduced an explanation algorithm in the form of a database operator called DIFF that can be expressed in SQL. If you’re so inclined, here’s the syntax for the DIFF operator:</p><p>这就是DIFF的用武之地。在2019，Firas Abuzaid、Peter Kraft、Sahaana Suri、Edward Gan、Eric Xu、Autul-ShanOy、Asvin Ananthanarayan、John Sheu、Py、Y、Y、Y和Mati ZHaARi引入了一种解释算法，称为DIFF的数据库操作符，可以用SQL表示。如果你这么想，下面是DIFF操作符的语法：</p><p>    In this example, the DIFF operator compares the crash logs of an application from this week to those of last week, considering columns like application version, device, and operating system for an explanation. The most likely explanation happened 20x more this week than last week ( risk_ratio = 20.0), and explains 75% of this week’s crashes ( support = 75%).</p><p>在本例中，DIFF操作符比较了一个应用程序本周的崩溃日志和上周的崩溃日志，并考虑了应用程序版本、设备和操作系统等列来进行解释。最有可能的解释是本周发生的事故比上周多20倍（风险率=20.0），并解释了本周75%的事故（支持率=75%）。</p><p> DIFF requires that we do some mental gymnastics to transform “why was X so high?” into “how are these two groups different?”. It also requires the user to wrap their head around statistics like risk ratios and support. In exchange for that mental overhead, DIFF is exciting for its praticality. As the example shows, DIFF’s authors envision it being expressed in SQL, which means it could be implemented on top of most relational databases. While a contribution of the paper is a specialized and efficient implementation of DIFF that databases don’t have today, it can also be implemented entirely in the database as a series of SQL GROUP BY/JOIN/WHERE operators.</p><p>DIFF要求我们做一些心理体操来改变“为什么X这么高？”进入“这两个群体有何不同？”。它还要求用户对风险比率和支持率等统计数据保持头脑清醒。作为精神开销的交换，DIFF因其实用性而令人兴奋。正如示例所示，DIFF的作者设想它用SQL表示，这意味着它可以在大多数关系数据库上实现。虽然本文的一个贡献是对DIFF进行了专门而高效的实现，但它也可以作为一系列SQL GROUP BY/JOIN/WHERE操作符完全在数据库中实现。</p><p> If you have a relational database, love SQL, and want to run an explanation algorithim, DIFF is exciting because those three things are all you need. Luckily for you, dear reader, I had a relational database, loved SQL, and wanted to run an explanation algorithm.</p><p>如果你有一个关系数据库，喜欢SQL，并且想运行一个解释算法，DIFF是令人兴奋的，因为这三样东西就是你所需要的。亲爱的读者，幸运的是，我有一个关系数据库，喜欢SQL，想运行一个解释算法。</p><p>  Over the past few months, I’ve been implementing DIFF as a thin Python wrapper that generates the SQL necessary to compute the difference between two schema-aligned queries.  The core of the implementation to do this, including comments, requires a little under 300 lines of code. To see a full example of the tool in action, you can check out this  Jupyter Notebook, but I’ll show snippets below to give you a sense of how it works.</p><p>在过去几个月里，我一直将DIFF实现为一个精简的Python包装器，它生成计算两个与模式对齐的查询之间差异所需的SQL。实现这一点的核心，包括注释，需要不到300行代码。要查看该工具的完整示例，您可以查看这个Jupyter笔记本，但我将在下面展示一些片段，让您了解它是如何工作的。</p><p> First, we need a dataset. For that, I took inspiration from the Scorpion paper’s experiments, one of which relied on  sensor data from Intel collected by my grad school advisor Sam Madden (and a few collaborators). Using Simon Willison’s excellent  sqlite-utils library, I load the data into SQLite and inspect it:</p><p>首先，我们需要一个数据集。为此，我从Scorpion论文的实验中获得了灵感，其中一个实验依赖于我的研究生院顾问萨姆·马登（Sam Madden）和一些合作者从英特尔收集的传感器数据。使用Simon Willison优秀的sqlite utils库，我将数据加载到sqlite并检查它：</p><p> # Retrieve and slightly transform the datawget http://db.csail.mit.edu/labdata/data.txt.gz gunzip data.txt.gz sed  -i  &#39;1s/^/day time_of_day epoch moteid temperature humidity light voltage\n/&#39; data.txt head data.txt # Get it in SQLitepip  install sqlite-utilssqlite-utils insert intel-sensor.sqlite readings data.txt  --csv  --sniff  --detect-typessqlite-utils schema intel-sensor.sqlite</p><p>#检索并稍微转换数据集http://db.csail.mit.edu/labdata/data.txt.gzgunzip数据。txt。gz sed-i&#39；1s/^/天时间_天纪元汽车旅馆温度湿度光电压\n/#39；数据txt头部数据。txt#在SQLitepip中获取它安装sqlite utilssqlite utils插入英特尔传感器。sqlite读取数据。txt--csv--sniff--detect typessqlite utils schema英特尔传感器。sqlite</p><p>  CREATE  TABLE  &#34;readings&#34;  (  [ day ]  TEXT ,  [ time_of_day ]  TEXT ,  [ epoch ]  INTEGER ,  [ moteid ]  INTEGER ,  [ temperature ]  FLOAT ,  [ humidity ]  FLOAT ,  [ light ]  FLOAT ,  [ voltage ]  FLOAT );</p><p>创建表&#34；阅读&#34；（[day]文本，[time_of_day]文本，[epoch]整数，[moteid]整数，[temperature]FLOAT，[湿度]FLOAT，[light]FLOAT，[voltage]FLOAT]；</p><p> OK! So we have a row for each sensor reading, with the  day and  time_of_day it happened, an  epoch to time-align readings from different sensors, a  moteid (the ID of the sensor, otherwise known as a mote), and then the types of things that sensors tend to sense:  temperature,  humidity,  light, and  voltage.</p><p>好啊因此，我们为每个传感器的读数设置了一行，包括发生的日期和时间，不同传感器的时间对齐读数的历元，一个moteid（传感器的ID，也称为mote），然后是传感器倾向于感测的类型：温度、湿度、光照和电压。</p><p> In the Scorpion paper (Sections 8.1 and 8.4), a user notices that various sensors placed throughout a lab detect too-high temperature values (reading  the experiment code, this happens in the days between 2004-03-01 and 2004-03-10). A natural question is why this happened. The Scorpion algorithm discovers that  moteid = 15 (a sensor with ID 15) was having a bad few days.</p><p>在Scorpion论文（第8.1节和第8.4节）中，用户注意到整个实验室中放置的各种传感器检测到过高的温度值（读取实验代码，这种情况发生在2004-03-01和2004-03-10之间）。一个自然的问题是为什么会发生这种情况。Scorpion算法发现moteid=15（ID为15的传感器）这几天过得不好。</p><p> Can we replicate this result with DIFF? Let’s see! The DIFF implementation is part of a library I’ve been building called  datools, which is a collection of tools I use for various data analyses. Let’s install datools:</p><p>我们能用DIFF复制这个结果吗？让我看看！DIFF实现是我一直在构建的一个名为datools的库的一部分，它是我用于各种数据分析的工具集合。让我们安装datools：</p><p>   from  sqlalchemy  import  create_engine from  datools.explanations  import  diff from  datools.models  import  Column from  datools.sqlalchemy_utils  import  query_results_pretty_print engine  =  create_engine ( &#39;sqlite:///intel-sensor.sqlite&#39; ) candidates  =  diff (  engine = engine ,  test_relation = &#39;SELECT moteid, temperature, humidity, light, voltage FROM readings WHERE temperature &gt; 100 AND day &gt; &#34;2004-03-01&#34; and day &lt; &#34;2004-03-10&#34;&#39; ,  control_relation = &#39;SELECT moteid, temperature, humidity, light, voltage FROM readings WHERE temperature &lt;= 100 AND day &gt; &#34;2004-03-01&#34; and day &lt; &#34;2004-03-10&#34;&#39; ,  on_column_values = { Column ( &#39;moteid&#39; ),},  on_column_ranges = {},  min_support = 0.05 ,  min_risk_ratio = 2.0 ,  max_order = 1 ) for  candidate  in  candidates :  print ( candidate )</p><p>从sqlalchemy导入从datools创建引擎。解释从数据工具导入差异。模型从数据工具导入列。sqlalchemy_utils导入查询_结果_漂亮_打印引擎=创建_引擎（&#39；sqlite:///intel-sensor.sqlite&#39; ) 候选人=差异（引擎=引擎，测试关系=&#39；从温度大于100和白天的读数中选择汽车旅馆、温度、湿度、光线、电压；从温度小于100和白天的读数中选择汽车旅馆、温度、湿度、光线、电压；从温度小于100和白天的读数中选择汽车旅馆、温度、湿度、光线、电压。）;2004-03-01&#34; 和day&lt&#34;2004-03-10&#34;&#39; ,  在_column_values={column（&#39；moteid&#39；），}，在候选项中的候选项的列上，最小支持度=0.05，最小风险比率=2.0，最大顺序=1）打印（候选项）</p><p>   Wow!  moteid = 15 is the top predicate that  datools.diff identified as being the difference between the  test_relation and  control_relation! With a  risk_ratio = 404.83, we learn that sensor 15 is about 400 times more likely to appear in the set of records with high temperature readings than in the set of records with low temperature readings. Hooray for replicating the Scorpion result! Poor sensor 15!</p><p>哇！moteid=15是datools的顶级谓词。差异被认为是测试关系和控制关系之间的差异！在risk_ratio=404.83的情况下，我们了解到，传感器15出现在高温读数记录集中的可能性大约是低温读数记录集中的400倍。复制蝎子的结果，万岁！糟糕的传感器15！</p><p> Let’s break that call to  diff down a bit so we understand what’s going on:</p><p>让我们把这个电话打断一下，让我们了解一下发生了什么：</p><p> engine: a  SQLAlchemy engine that’s connected to some database, in this case the SQLite database.</p><p>引擎：连接到某个数据库的SQLAlchemy引擎，在本例中是SQLite数据库。</p><p>  test_relation: the “test set,” which is a query with records that show a particular condition. In our case, it’s the higher-temperature records during the period of interest. This could alternatively be a SQL query for “patients with high medical costs” or “customers who purchased.”</p><p>test_关系：“test set”，这是一个查询，其中包含显示特定条件的记录。在我们的例子中，这是感兴趣的时期内的高温记录。这也可以是针对“医疗费用高的患者”或“购买的客户”的SQL查询</p><p>  control_relation: the “control set,” which is a query with records that don’t show that particular condition. In our case, it’s the lower-temperature records during the period of interest. This could alternatively be a SQL query for “patients who don’t have high medical costs” or “leads who haven’t purchased.”</p><p>控制关系：“控制集”，这是一个查询，其中的记录没有显示特定的条件。在我们的例子中，是感兴趣时期的低温记录。这也可以是“医疗费用不高的患者”或“尚未购买的潜在客户”的SQL查询</p><p>  on_column_values: these are set-valued columns you want to consider as explanations. In our case, we’re considering the  moteid column, so we can identify a specific sensor thats misbehaving.</p><p>On.CulnNoxValue:这些是要考虑的集合值列作为解释。在我们的例子中，我们考虑的是moteid列，所以我们可以确定一个特定的传感器有问题。</p><p>  on_column_ranges: these are range-valued columns you want to consider as explanations.  diff will bucket these columns into 15 equi-sized buckets, which works well for continuous variables like  {Column(&#39;humidity&#39;), Column(&#39;light&#39;), Column(&#39;voltage&#39;),}. In this example, we don’t provide any (more on why later), but in the Jupyter Notebook, you can see this in action.</p><p>On.CulnNoLang:这些是你想考虑的范围值列。diff将这些列装入15个大小相等的桶中，这对{Column（&#39；湿度&#39；）、等连续变量非常有效，柱子（&#39；灯&#39；），列（&#39；电压&#39；），}。在本例中，我们不提供任何内容（稍后将详细说明原因），但在Jupyter笔记本中，您可以看到这一点。</p><p>  min_support: The smallest fraction ([0, 1]) of the test set that the explanation should explain. For example,  min_support=0.05 says that if an explanation doesn’t include at least 5% of the test set, we don’t want to know about it.</p><p>min_support：解释应该解释的测试集的最小部分（[0,1]）。例如，min_support=0.05表示，如果一个解释不包括至少5%的测试集，我们就不想知道它。</p><p>  min_risk_ratio: The smallest risk ratio that the explanation should cover. For example,  min_risk_ratio=2.0 says that if an explanation isn’t at least 2 times as likely to appear in the test set than in the control set, we don’t want to know about it.</p><p>_min：风险比率应涵盖的最小解释。例如，min_risk_ratio=2.0表示，如果一个解释在测试集中出现的可能性不是在对照集中出现的至少两倍，我们就不想知道它。</p><p>  max_order: How many columns to consider for a joint explanation. For example, in the Scorpion paper, the authors find that not just sensor 15 (one-column explanation), but sensor 15 under certain light and voltage conditions (three column-explanation), is the best explanation for outlier readings. To analyze three-column explanations, you’d set  max_order=3. Sadly and hopefully temporarily, while  max_order is the most fun, interesting, and challenging-to-implement parameter of the DIFF paper,  datools.diff only supports  max_order=1 for now.</p><p>Max命令：一个联合解释要考虑多少列。例如，在Scorpion的论文中，作者发现，不只是传感器15（一栏解释），而且在某些光线和电压条件下（三栏解释），传感器15是异常读数的最佳解释。要分析三列解释，可以将max_order设置为3。不幸的是，希望是暂时的，而max_order是实现DIFF paper的参数datools最有趣、最有趣、最具挑战性的。diff目前只支持max_order=1。</p><p> An astute reader will note that I coaxed the results in my example a bit by asking DIFF to consider only  moteid explanations ( on_column_values={Column(&#39;moteid&#39;),}). The Scorpion paper considers the other columns as well and still gets the strongest signal from  moteid. In the  Jupyter Notebook, we dive into this more deeply and run into an issue replicating the Scorpion results with  diff. I offer some hypotheses for this in the notebook, but to have a more informed opinion, we’ll have to wait until  datools.diff supports  max_order &gt; 1.</p><p>一个精明的读者会注意到，在我的例子中，我通过让DIFF只考虑MuteID解释（OnthCulnNuxValue= {列（＆39；MoTeID和α39；）}）来哄骗我的例子中的结果。Scorpion的论文也考虑了其他栏目，但仍然从moteid获得了最强的信号。在Jupyter笔记本中，我们更深入地探讨了这一点，并遇到了一个用diff复制蝎子结果的问题。我在笔记本中提供了一些关于这一点的假设，但要获得更明智的意见，我们必须等到datools。diff支持最大订单&gt；1.</p><p>  Before we go off and celebrate the replication of the Scorpion paper’s findings with the DIFF paper’s algorithm, you should know that it’s not all roses. Luckily, I’m just as excited about improving  datools.diff as I was when I first wrote it, so consider the list below to be both limitations of the current version and a roadmap for the library. If you’re curious,  this project board tracks the things I’m working on most actively.</p><p>在我们开始用DIFF paper的算法复制Scorpion paper的发现之前，你应该知道这并不全是好事。幸运的是，我对改进数据工具同样感到兴奋。当我第一次写它的时候，我觉得下面的列表既是当前版本的限制，也是图书馆的路线图。如果你好奇的话，这个项目板会追踪我最积极的工作。</p><p> Make  diff work on more than just SQLite.  diff generates SQL, and I’d love for that SQL to run on any database. This is largely a matter of improving the test harness to provision other databases and fixing whatever breaks. The next few databases I’m targeting are DuckDB, Postgres, and Redshift, but if you’re interested in collaborating on something else, I’d love to help.</p><p>让diff不仅仅在SQLite上工作。diff生成SQL，我希望该SQL能在任何数据库上运行。这在很大程度上是一个改进测试工具以提供其他数据库和修复任何中断的问题。接下来我要针对的几个数据库是DuckDB、Postgres和Redshift，但如果你有兴趣在其他方面进行合作，我很乐意提供帮助。</p><p>  Support  max_order &gt; 1. One of the DIFF paper’s contributions is in how to spar with the combinatorial explosion you encounter in looking for multi-column explanations. I’d love to support at least 2- or 3-column explanations.</p><p>支持最大订单&gt；1.DIFF论文的贡献之一是如何应对你在寻找多栏解释时遇到的组合爆炸。我想支持至少两列或三列的解释。</p><p>  Use  diff on more datasets. If you’ve got a dataset (especially a public one) you’re hoping to try this on, let me know!</p><p>在更多数据集上使用diff。如果你有一个数据集（特别是一个公共数据集），你希望尝试这个，让我知道！</p><p>  Replicate  diff on Scorpion’s analysis after implementing higher-order explanations. The full Jupyter Notebook shows that  diff can’t yet replicate Scorpion’s results when we ask it to consider more columns than  moteid. The notebook offers explanations ranging from “DIFF and Scorpion are different algorithms and have different tradeoffs” to “Why are we considering an output measure as an explanation?” I think it’s worth revisiting this after implementing  max_order &gt; 1, so that we can see how  datools.diff handles more complex explanations.</p><p>在实施高阶解释后，复制蝎子的差异分析。完整的JUJYTER笔记本显示，当我们要求它考虑比MyTID更多的列时，DIFF还不能复制蝎子的结果。笔记本提供了从“DIFF和Scorpion是不同的算法，有不同的权衡”到“为什么我们要考虑输出度量作为解释？”我认为在实施max_order&gt；1，这样我们就可以看到datools是如何工作的。diff处理更复杂的解释。</p><p>  Share more about  datools.  diff is part of the  datools package, but I haven’t told you much about  datools. Countless words have been spilled about how SQL, despite being here to stay, also has its rough edges.  datools smooths some of these rough edges out  3.</p><p>分享更多关于datools的信息。diff是datools软件包的一部分，但我没有告诉你太多关于datools的事情。关于SQL（尽管将继续存在）如何也有其粗糙的边缘，人们已经说了无数的话。datools会平滑其中一些粗糙的边缘。</p><p>  Eugene Wu not only introduced me to the concept of explanation algorithms, but also patiently guided me through starts and stops as I tried to implement various papers.  Peter Bailis not only showed that the need for explanation algorithms is felt broadly, but also supportively contextualized DIFF relative to even more recent state-of-the-art solutions. I’m grateful to both of them for their feedback.</p><p>Eugene Wu不仅向我介绍了解释算法的概念，还耐心地指导我完成各种论文的开头和结尾。Peter Bailis不仅表明对解释算法的需求得到了广泛的感受，而且还支持了与最新最先进的解决方案相比的情境化差异。我很感谢他们两人的反馈。</p><p>  Strictly speaking, it doesn’t have to be the case that more complex analytics or machine learning algorithms have to be run outside the database.  MADlib speaks to this nicely, although in practice the approach hasn’t taken off as widely as I wish it did.  ↩</p><p>严格来说，不一定要在数据库之外运行更复杂的分析或机器学习算法。MADlib很好地说明了这一点，尽管在实践中，这种方法并没有像我希望的那样广泛。  ↩</p><p>    As an example, not every database (I’m looking at you, SQLite and Redshift) supports things like grouping sets and data cubes, but these operators are critical for making tools like DIFF-in-SQL work effectively.  datools offers wrappers that, if a database supports grouping sets, will use the native functionality, but if the database doesn’t,  will do the next best thing.  ↩</p><p>例如，并不是每个数据库（我在看你们，SQLite和Redshift）都支持分组集和数据立方体之类的东西，但这些操作符对于让DIFF之类的工具在SQL中有效工作是至关重要的。datools提供的包装器，如果数据库支持分组集，将使用本机功能，但如果数据库不支持，则将使用次优功能。  ↩</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/算法/">#算法</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/diffs/">#diffs</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解释/">#解释</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>