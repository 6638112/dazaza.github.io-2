<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Go程序结束时会发生什么？ （带字幕的播客） What happens when Go programs end? (Podcast with transcript)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">What happens when Go programs end? (Podcast with transcript)<br/>Go程序结束时会发生什么？ （带字幕的播客） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-10 01:10:38</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/c1dc2ce4ad482e2cce78558d5c8c98d2.png"><img src="http://img2.diglog.com/img/2021/2/c1dc2ce4ad482e2cce78558d5c8c98d2.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Hello, and welcome to Go Time. I’m Mat Ryer. Today we’re talking about what happens when Go programs end. What happens when the func main returns. What happens to goroutines that might already still be running, or… Remember those deferred statements? What’s happening with them? How are they gonna go? What about open files? Do they get closed for me, or do I have to do that? And what about those HTTP response bodies? We’re supposed to be closing them; everyone’s been remembering to close response bodies, but what happens to those when you exit? Well, there’s loads of questions, and we’re gonna find out the answer to all of them on this deep dive, forensic analysis breakdown edition, super-cool, where we look at what happens when Go programs end. So yeah, a very dramatic intro for what could be a very mundane subject, but I don’t think it’s gonna be.</p><p>您好，欢迎来到Go Time。我是Mat Ryer。今天我们在谈论Go程序结束时会发生什么。 func main返回时会发生什么。可能仍在运行的goroutine会发生什么，或者…还记得那些延迟的语句吗？他们怎么了？他们怎么走？那打开文件呢？他们会为我关闭吗，还是我必须这样做？那些HTTP响应主体又如何呢？我们应该关闭它们；每个人都记得关闭响应机构，但是当您退出响应机构时会发生什么呢？好吧，这里有很多问题，我们将在这个超深入的法医分析细分版（超酷）中找到所有问题的答案，我们将研究Go程序结束时发生的情况。是的，这是一个非常戏剧性的介绍，可能是一个非常平凡的话题，但我认为这不会。</p><p>        You told me earlier you’ve never had a Go program end, so this is uncharted–</p><p>        您之前曾告诉我您从未经历过Go程序结束，所以这是未知的–</p><p>    [ ] I didn’t say that… [laughs] I said most of my programs aren’t designed to end. So when they end, what happens is I’m trying to make sure my server gets it back up.</p><p>    []我没那么说……[笑]我说我的大多数程序并不是为了结束而设计的。因此，当它们结束时，我正在尝试确保服务器将其备份。</p><p>    Right. Interesting. Okay, I’m sure we’ll talk more about that. We’re also joined by a member of the Go team who’s been working on the runtime for the last 2.3 years, he told me. Welcome to the show, Michael Knyszek. Hello!</p><p>    对。有趣。好的，我敢肯定，我们会谈更多。他告诉我，Go团队的成员也加入了其中，他在过去2.3年中一直致力于运行时。欢迎来到展览，Michael Knyszek。你好！</p><p>                        Okay. They’re similar things. Okay, well let’s start, maybe right at the beginning then, for someone new to Go, what happens – I mean, ultimately, a program at the end will stop running… So what happens there? What’s going on?</p><p>                        好的。它们是类似的东西。好的，让我们开始吧，也许就在刚开始的时候，对于刚接触Go的人，会发生什么–我的意思是，最终，最后一个程序将停止运行...那么在那里发生了什么？这是怎么回事？</p><p>    Well, I guess basically Go itself is just gonna sort of – this is gonna come out the wrong way; hopefully, we’ll dive deeper and explain why and what, but Go kind of just leaves a mess behind and calls directly into the operating system, just like “We’re done with everything.” And everything dies and gets cleaned up; the operating system goes and cleans everything up, and if that running Go program had a parent process – well, on Linux all the processes have parents… Then it gives that parent a return code. On Linux I believe there’s just some value between 0 and 255. For compatibility reasons, Go’s os.Exit – well, I won’t get into os.Exit yet, but basically Go by default returns zero, which means all good. Returning anything non-zero effectively means something went wrong. Some programs like to use a different number for different meanings of something went wrong, but generally, that’s the pattern… Just, everything went fine, and something went wrong.</p><p>    好吧，我想基本上Go本身就是这样–这将以错误的方式出现；希望我们会做得更深入，并解释原因和原因，但是Go只会给您带来混乱，并直接调用操作系统，就像“我们完成了所有事情”一样。一切都死了，被清理了。操作系统运行并清理所有内容，并且如果正在运行的Go程序具有父进程，那么，在Linux上，所有进程都具有父进程……然后它将给该父进程一个返回代码。在Linux上，我相信只有一个介于0到255之间的值。出于兼容性的原因，Go是os.Exit –好吧，我不会进入os.Exit，但是Go基本上默认返回零，这意味着一切都很好。有效地返回非零值意味着出现了问题。有些程序喜欢对不同的含义使用不同的数字，但总的来说，这就是模式……只是，一切都很好，而且出了问题。</p><p>    Okay, great. And are they like HTTP status codes, those exit codes? Are there any standards, or is it just zero means it was a success, and everything else is then defined by the program?</p><p>    好的，太好了。它们像HTTP状态代码一样，是退出代码吗？是否有任何标准，或者仅仅是零就意味着成功，然后程序定义了其他所有内容？ </p><p>    I think that’s the only thing you can actually rely on. If you’re dealing with a specific program, like you’re writing a wrapper script for and you wanna [unintelligible  ] another error message come out, or log that somewhere, then it can be useful. I feel like I know a few programs that define in a big table what all the different values mean… But I think in general, the only thing you can rely on is zero or non-zero.</p><p>我认为这是您唯一可以依靠的东西。如果您要处理的是特定程序，例如您正在为其编写包装器脚本，并且想要[无法理解]出现另一条错误消息，或者将其记录在某个地方，那么它会很有用。我觉得我知道一些程序可以在一个大表中定义所有不同值的含义……但是我认为通常来说，您可以依靠的唯一东西是零或非零。</p><p>    Right. So in Go, a main function, when that returns – there’s no return argument, so it just returns by falling out the back of the block. That will just by default return zero then, would it?</p><p>    对。因此，在Go中，一个主函数会在返回时–没有return参数，因此它只是通过退出代码块的后面而返回。那默认情况下会返回零，是吗？</p><p>        And then if you do want to return something non-zero, that’s when we need to look at os.Exit.</p><p>        然后，如果您确实想返回非零值，那就是我们需要查看os.Exit的时候。</p><p>        Okay, we’ll get into that later… But you mentioned that everything gets cleaned up by the operating system, and Go kind of leaves a mess… What things get cleaned up specifically there?</p><p>        好的，我们稍后再讨论……但是您提到了操作系统已清除了所有内容，而Go有点混乱……在那里专门清除了哪些内容？</p><p>    Basically, Go asks the operating system for a bunch of memory. The most obvious thing is all that memory gets collected. All of the memory-related resources that the [unintelligible  ] in the application get reclaimed. Other things include if there are any open file handles… So this extends quite broadly. But in the simple case, you just have a file on your local hard disk, or what you usually think of as a file - basically, the OS will close that file handle for you. It keeps track of all of them, and once your program exits, it goes over all of them and just says “Okay, this process is no longer using this file.”</p><p>    基本上，Go向操作系统请求一堆内存。最明显的是收集所有的内存。回收应用程序中[unintelligible]的所有与内存相关的资源。其他事情包括是否有任何打开的文件句柄……因此，它的范围很广。但是在简单的情况下，您仅在本地硬盘上有一个文件，或者您通常认为的文件-基本上，操作系统会为您关闭该文件句柄。它会跟踪所有这些文件，一旦您的程序退出，它就会遍历所有这些文件，并说：“好的，此过程不再使用此文件。”</p><p>    That’s cool then. Reclaiming the memory is nice… So then if we’ve got some program that has a massive map of data, before we return we don’t have to go through and delete all that data, do we? We don’t have to go and do that sort of cleaning up, releasing memory. That will just happen automatically, right? Yeah.</p><p>    那太酷了回收内存是一件很不错的事情……那么，如果我们有一些程序具有庞大的数据映射，那么在返回之前，我们不必遍历并删除所有这些数据，对吧？我们不必去做这种清理，释放内存。那会自动发生，对吗？是的</p><p> [ ] And then the files one is an interesting one. If you open a file in Go, and normally we defer the close of that file, or we might have some other mechanism for closing that… If you don’t close that file and the program exits, does that leak a file handle, or does the operating system clean that up?</p><p> []然后是一个有趣的文件。如果您在Go中打开文件，通常我们会推迟该文件的关闭，否则我们可能会有其他机制来关闭该文件……如果您不关闭该文件而程序退出，是否会泄漏文件句柄，或者操作系统会清理吗？ </p><p>    No, the operating system cleans that up. Files on most systems are pretty – the concept of a file goes pretty deep into the OS. It actually just keeps track of these things and says “Okay, this process exited”, and it usually keeps a reference count for these files, if I recall [unintelligible  ]</p><p>否，操作系统会对此进行清理。大多数系统上的文件都很漂亮–文件的概念已深入操作系统。实际上，它只是跟踪这些事情并说“好，此过程已退出”，并且如果我记得[无法理解]，它通常会为这些文件保留引用计数。</p><p>            Of course. But if you’ve got that code in a loop or something, then it’s important to remember to close files as you go. You can’t rely on that program ending. Yeah, very cool. Jon, how do you normally exit and deal with cancelation and things in your programs? If you ran a command line tool, how would you do it?</p><p>            当然。但是，如果您使该代码处于循环中或类似的状态，那么记住随时随地关闭文件很重要。您不能依赖该程序的结尾。是的，非常酷。乔恩，您通常如何退出并处理程序中的取消事项？如果您运行命令行工具，您将如何做？</p><p>    The most common way you see is using context and sort of handling it that way… But I can definitely say I’m guilty of not doing that all the time, especially when it’s – you know, if I’m writing just a quick tool for myself or whatever, and I don’t expect it to take very long, if it’s only gonna grab three files, parse them real quick, do something and be done, usually if I wanted to cancel it, the program would be done before it ended anyway, so it really doesn’t make much of a difference.</p><p>    您看到的最常见的方式是使用上下文并以这种方式对其进行处理……但是我可以肯定地说，我一直以来都没有这样做，这是我的内，尤其是当它–您知道，如果我只是在编写一个快速工具对于我自己还是其他人，我不希望它花费很长时间，如果它只能获取三个文件，快速地真正解析它们，然后执行某些操作并完成，通常，如果我想取消它，则程序会在无论如何它都结束了，所以实际上并没有太大的区别。</p><p> Now, if I had something more long-running, then maybe it makes more sense. I guess it depends on what you’re doing and whether or not stopping the middle of something is actually really bad or not… So that’s kind of like the determining factor for me, is does it actually matter if it just stops.</p><p> 现在，如果我有更长时间的工作，那么也许更有意义。我猜这取决于您在做什么，以及停止某件事的中间是否真的很糟糕……所以这就像对我来说是决定性的因素，它是否真的停下来真的很重要。</p><p>    Yeah, that’s interesting - does it matter if this program just stops. And you could imagine programs - and I’ve written one recently that was processing files, and it would open another file to generate some data basically from the first file. So it would create a new file for each file that it found. Because it was a small, hacky thing, it was relying on the existence of that file for state, to see whether it’d been processed or not. So in this case, if the program just ended in the middle of all that somewhere, I could end up in a state on disk that wasn’t desirable and didn’t reflect the reality of it. That leads us into talking about graceful shutdown as well, where we notice that a program wants to end, or the operating system or somebody wants to end this program, but we’ve got some work to do before… So what are our options for doing something like that? How do we know that the program is gonna end, and how can we then do some work before?</p><p>    是的，这很有趣-该程序是否停止才重要。您可以想象程序-我最近写了一个正在处理文件的程序，它将打开另一个文件，基本上从第一个文件生成一些数据。因此，它将为找到的每个文件创建一个新文件。因为这是一件小巧的事情，所以它依赖于该文件的状态来查看其是否已被处理。因此，在这种情况下，如果程序只是在某个地方的所有地方结束，那么我可能会处于磁盘上的状态，这是不希望的，并且无法反映现实。这也导致我们谈论正常关闭，在这里我们注意到某个程序想要结束，或者操作系统或某人想要结束该程序，但是我们之前需要做一些工作……因此，我们的解决方案是什么？做这样的事情？我们怎么知道该程序将要结束，又该如何做一些工作呢？</p><p>    Programs can really end – I mean, broadly speaking, can end in two ways. Either something tells the program to end, or it decides “I’m done” and closes itself out. In the context of something external, you might see something like Ctrl+C. If you type Ctrl+C in your command line, what basically happens is Linux sends what’s called a signal, which are surprisingly difficult to work with correctly outside of Go. Go actually makes this quite nice to use, because it wraps the whole thing in a channel. But once your program receives a signal, it needs to handle it in some way. So with Go, you can use the os/signal package to get notified about when you get something like Ctrl+C. Something wants to end your program, and so using the os/signal package lets you capture that and say “Okay, let me do the cleanup that I need to do, so that I can get my graceful shutdown.”</p><p>    程序可以真正结束–从广义上讲，我可以以两种方式结束。要么告诉程序结束，要么决定“我完成了”并自行关闭。在外部环境中，您可能会看到类似Ctrl + C的窗口。如果您在命令行中输入Ctrl + C，则基本上会发生Linux发送所谓的信号的情况，这令人惊讶地难以在Go之外正确使用。 Go实际上使它非常好用，因为它将整个内容包装在一个通道中。但是一旦程序接收到信号，就需要以某种方式进行处理。因此，使用Go，您可以使用os / signal包来获取有关何时获得Ctrl + C之类的通知。某人想结束您的程序，因此使用os / signal包可以使您捕获并说：“好吧，让我进行所需的清理，以使我能够正常关机。”</p><p> [ ] If the program wants to end internally, there’s more of an assumption that the program as a whole would know that, and if it wants to gracefully shut down, then it has to provide its own mechanism for doing so.</p><p> []如果程序要在内部结束，则有更多的假设，即程序作为一个整体会知道这一点，并且如果要正常关闭，则必须提供自己的机制来完成。 </p><p>    Right. That makes sense. So is that quite messy in the runtime code there? Because I imagine there’s lots of edge cases that it’s dealing with, and lots of different operating systems, right?</p><p>对。那讲得通。那么那里的运行时代码是否很混乱？因为我想它正在处理许多极端情况，并且有许多不同的操作系统，对吗？</p><p>    Well, signal handling is notoriously difficult, because a signal handler can run just about any time, on any thread. A signal can land when you’re right in the middle of holding several locks, and you’re like “Okay, is it safe to do anything?” Yeah, that part of the runtime is actually quite tricky and difficult to get right. It’s also a complicated part of the OS, too.</p><p>    好吧，信号处理非常困难，因为信​​号处理程序几乎可以在任何时间在任何线程上运行。当您正好拿着几把锁的中间时，一个信号会降落，并且您就像“好吧，做任何事安全吗？”是的，运行时的那部分实际上非常棘手，很难正确处理。它也是操作系统的一个复杂部分。</p><p> Austen on the Go team found a bug in the Linux Kernel related to signals in the Go 1.14 release cycle… So you know, it’s tough.</p><p> Go小组的奥斯汀（Austen）在Linux内核中发现了与Go 1.14发行周期中的信号有关的错误……所以，这很艰难。</p><p>    Yeah, it’s old tech really, isn’t it? Because it’s really core, so it’s really deep somehow in amongst this.</p><p>    是的，这确实是旧技术，不是吗？因为它是真正的核心，所以在其中确实很深。</p><p>    Yeah, yeah. But the signal package does really give you a very nice wrapper around this. It’s very safe, and much easier to use than a regular signal handler.</p><p>    是啊是啊。但是信号包确实为您提供了一个非常不错的包装器。与常规信号处理程序相比，它非常安全，并且使用起来更容易。</p><p>    So let’s say I’m jumping into this and I want to figure out how to capture signals… Do I have to learn about a bunch of different signals? If somebody is using kill in the Linux terminal to drop the process, versus Ctrl+C, versus a bunch of different ways you can try to stop a program… Or is this kind of you pick one or two signals and go from them? Where does somebody start if they wanna get started with this?</p><p>    因此，假设我正在跳入这一步，并且想弄清楚如何捕获信号……我是否需要学习一堆不同的信号？如果有人在Linux终端中使用kill来删除进程，而不是Ctrl + C，而是使用多种方法来尝试停止程序…还是这种选择是从一个或两个信号中去除？如果有人想从这里开始，该从哪里开始？</p><p>    I think the os/signal package documentation does describe the difference with those pretty well. It’s funny you mentioned kill, because if I recall correctly, kill is one of those signals that you just simply can’t catch. That’s what’s kind of dangerous about kill - if you send kill to a process, it never gets the opportunity to clean up. It’s like a force-force-force-force quit. There’s no opportunity.</p><p>    我认为os / signal软件包文档确实很好地描述了它们之间的区别。您提到杀死很有趣，因为如果我没记错的话，杀死只是您根本无法捕捉到的信号之一。那就是杀死的危险-如果将杀死发送到进程，它将永远没有机会进行清理。这就像是强制退出强制退出。没有机会。 </p><p> The other two that I’m aware of are SIGINT, so that’s interrupt, that’s Ctrl+C. And SIGABRT is kind of interesting, because that will cause the Go runtime to basically dump a bunch of goroutine stack traces… But SIGABRT is another one that is sometimes useful to handle explicitly. But Ctrl+C is the big one.</p><p>我知道的其他两个是SIGINT，因此是中断，即Ctrl + C。 SIGABRT很有意思，因为这将导致Go运行时基本上转储一堆goroutine堆栈跟踪…但是SIGABRT是另一个有时对显式处理有用的代码。但是Ctrl + C是最大的功能。</p><p> I do think the os/signal package provides some pretty good documentation on this, because it’s also wrapping around the fact that you have lots of different – Go supports lots of different platforms; of course, this is going to work slightly differently on Windows, and stuff… So I defer to the os/signal documentation for precise semantics.</p><p> 我确实认为os / signal软件包为此提供了一些很好的文档，因为它还包裹了您拥有许多不同的事实– Go支持许多不同的平台；当然，这在Windows和其他东西上的工作方式会稍有不同。因此，我遵循os / signal文档中的精确语义。</p><p>    Fair enough. And since Go 1.16, we actually also have a NotifyContext helper too, in the signal package… Which will cancel a context on a signal. So that’s kind of like nice. If you’re using context for cancelation across your program - and this is essentially the pattern for anyone unfamiliar, where you pass in a context argument as the first argument through the chain of all your programs, and then whenever you’ve got loops within that, of work, or maybe you’re iterating over a set of data, you can just periodically, i.e. at the start of each loop, check to see if that context is finished, and there’s either a channel that will be closed, or you can check to see if there’s an error being returned. And then you can abort that operation. So that’s a nice way to do graceful shutdown, or at least “I’ll finish what I’m currently doing, and then I’ll stop.” It gives you that sort of graceful shutdown, and you can do that quite nicely with context. But you used to have to write that signal code yourself; with the addition of NotifyContext, you don’t need to anymore. You can just wire it up to a context and it will be canceled for you when the program is interrupted.</p><p>    很公平。从Go 1.16开始，我们实际上在信号包中也有一个NotifyContext帮助器……它将取消信号上的上下文。这有点不错。如果您要在整个程序中使用上下文进行取消-这本质上是不熟悉任何人的模式，您可以在所有程序链中将上下文参数作为第一个参数传递，然后在循环内进行传递工作，或者正在遍历一组数据，您可以定期进行操作，即在每个循环的开始，检查该上下文是否已完成，并且有一个要关闭的通道，或者您可以检查是否返回了错误。然后您可以中止该操作。因此，这是进行正常关机的一种好方法，或者至少是“我将完成当前正在执行的操作，然后再停止操作。”它为您提供了一种正常的关闭方式，并且您可以通过上下文很好地做到这一点。但是您曾经不得不自己编写该信号代码。加上NotifyContext，您就不需要了。您可以将其连接到上下文，并且在程序中断时将为您取消它。</p><p> [ ] I think it’s a good practice - this is something I always do… If you get a second interrupt signal, then it’s worth doing a more serious exit. Sometimes I think operating systems will send that kill as the second signal. But if it’s just a command line and you press Ctrl+C and something’s wrong in your logic somewhere, you can easily hang, because you’ve caught that signal. So it can be good practice to look for a second one and to do an immediate os.Exit, and that way you never get caught having to go and try to force-quit your own business. So yeah, graceful shutdown I think is very cool.</p><p> []我认为这是一个好习惯-这是我一直在做的事情...如果您收到第二个中断信号，则值得更认真地退出。有时，我认为操作系统会将秒杀作为第二个信号发送。但是，如果这只是命令行，并且按Ctrl + C组合键，但逻辑上某处出现问题，则很容易挂起，因为您已捕获到该信号。因此，寻找第二个人并立即退出操作系统是一种好习惯，这样一来，您就不必陷入强迫退出自己的生意的困境。是的，我认为正常关机非常酷。</p><p> Another way to get a kind of form of graceful shutdown, or at least a cleaning up after you, is with a defer statement. In the func main function, when you defer things in there, they do get called before the function exits, and therefore before the program exits. But that’s not true for os.Exit, is it, Michael?</p><p> 获得某种形式的正常关机或至少在您执行清理操作后的另一种方法是使用defer语句。在func主函数中，当您将其中的内容延迟时，它们确实会在函数退出之前（因此在程序退出之前）被调用。但这对os而言并非如此。出口，迈克尔吗？</p><p>    No. So os.Exit is a hard exit. It basically does the minimal amount of cleanup necessary, which basically for the Go runtime just means if you’re running with a race detector enabled, it’ll do some cleanup with the race detector, so try to signal that “Oh, if you have a racy program, it’s gonna make sure its exit code is non-zero”, for instance. But otherwise - yeah, it basically just does a hard exit. It doesn’t bother trying to run deferred functions; it also doesn’t bother trying to run finalizers, if you’re aware of those. Kind of a dark, dark corner, but worth mentioning.</p><p>    不，所以OS.Exit是一个硬出口。它基本上完成了最少的清理工作，这对于Go运行时基本上意味着，如果您在启用了种族检测器的情况下运行，它将使用种族检测器进行一些清理，因此请尝试发出“哦，如果您例如，有一个恶意程序，它将确保其退出代码不为零。但是否则-是的，它基本上只是硬性退出。它不会尝试运行延迟的功能；如果您知道这些终结器，也不必费心尝试运行终结器。有点阴暗的角落，但值得一提。</p><p>    Yes. Okay, so os.Exit is a very immediate stop, and you’re not gonna have the nice things that Go would give you; you do have to bear that in mind.</p><p>    是。好吧，os.Exit是一个非常紧急的停留，您不会拥有Go会给您带来的好处。您必须牢记这一点。 </p><p> Another thing that’s quite interesting is what happens to the standard in and out streams, and standard error? For example, will just standard out receive an io.EOF at the end of it? Does it do something to close the pipe? What’s actually going on there? Is that operating system-dependent, too?</p><p>有趣的是，标准输入和输出流会发生什么，以及标准错误？例如，仅标准输出会在末尾收到io.EOF吗？它会做些关闭管道的事情吗？那里到底发生了什么？那也取决于操作系统吗？</p><p>    This might be somewhat system-dependent. I’m thinking more in terms of the Linux/Unix philosophy, where pipes are just files. To the operating system, it uses the same sort of resources, [unintelligible  ] And these standard out, standard error, standard in - they all get closed in exactly the same way as any other file.</p><p>    这可能与系统有关。我考虑的是Linux / Unix理念，管道只是文件。对于操作系统，它使用相同类型的资源，[无法理解]，并且这些标准输出，标准错误，标准输入-它们以与任何其他文件完全相同的方式关闭。</p><p> I will note that the moment you do this sort of exit call, whether or not code runs is sort of completely up in the air. Some Go code may run in that few milliseconds before the process gets taken down, or rather its thread stops… But you can’t rely on that. So there’s no EOF propagated through, because there’s no code to even process that io.EOF, if that makes sense. The code is not guaranteed to run at all.</p><p> 我将注意到，无论您是否执行代码，执行此类退出调用的那一刻都是悬而未决的。某些Go代码可能会在该进程停止运行之前的几毫秒内运行，或者它的线程停止了……但是您不能依靠它。因此，没有EOF传播出去，因为没有任何代码可以处理io.EOF（如果可行）。该代码不能保证完全运行。</p><p>    So when we call os.Exit, you can just assume that from that point on it’s like somebody just walked away, and whatever happens, happens, but it’s all tumbling down at some point…</p><p>    因此，当我们称之为os.Exit时，您可以假设从那时起就像有人刚走开一样，无论发生什么事，都发生了，但是在某个时候一切都翻滚了……</p><p>        And that’s actually the only way you can return an exit code that’s non-zero, isn’t it?</p><p>        这实际上是返回非零退出代码的唯一方法，不是吗？</p><p>        That’s interesting then… So you have to be careful with that. But you may well want your program to exit with a specific status code. But if you’re doing that deep somewhere in your program, it’s possible other things aren’t happening… So you probably would only want to use os.Exit right at the top in the main, or very near there, based on probably the return from some other functions that you’re creating as part of your application.</p><p>        那时很有趣……所以您必须小心一点。但是您可能希望您的程序以特定的状态代码退出。但是，如果您正在程序的某个深处进行操作，则可能未发生其他事情……因此，您可能只想使用os.Exit，就在主程序顶部或附近，基于从您作为应用程序一部分创建的其他函数返回。</p><p>    [ ] Yeah, that’s generally a good pattern. Basically, what I see is you have main, and if you just return cleanly from main, then that’s your exit zero… Because interestingly enough, if you look under the hood, when you return from main, all it does is to a very tiny bit of cleanup, which is that race detector stuff… And then it calls the same exit system call. It does exactly the same thing that os.Exit does.</p><p>    []是的，通常这是一个很好的模式。基本上，我所看到的是您拥有main，如果您从main干净地返回，那就是零出口...因为有趣的是，如果您在引擎盖下查看，从main返回时，它所做的只是很小的事情清理一下，这就是种族检测器的东西……然后它调用相同的退出系统调用。它与os.Exit完全相同。 </p><p> So that’s sort of also just the right point to put the exit, because it’s basically like saying “Well, if I return for main, it will just call os.Exit zero effectively, so now is a good point to run os.Exit one.” That being said, it depends on the program. I could certainly imagine a program where you get to a point when you’re like “There is no way I can proceed. Even if other things are still running, there’s absolutely no way I can proceed. Maybe it just makes sense to drop everything on the floor.”</p><p>所以这也是退出的正确点，因为这基本上就像在说：“好吧，如果我返回main，它只会调用os。有效退出零，所以现在是运行os的好点。退出一个。”话虽如此，这取决于程序。我当然可以想象一个程序，当您感觉到“我无法继续。即使其他事情仍在进行，我也绝对无法继续。也许把所有东西都扔在地板上是有意义的。”</p><p>    Yeah. And we have panics in Go for situations like that. That is interesting. Panics themselves are quite an interesting case then here, because they can occur anywhere in the program… And if uncaught, they have the effect of ending the program. But defers do run with panics, don’t they? We know that because that’s how you recover from panics - you run code in a defer function.</p><p>    是的对于这种情况，我们在Go中会感到恐慌。这太有趣了。那时恐慌本身就是一个很有趣的情况，因为它们可能会出现在程序中的任何地方……而且，如果未被捕获，它们会导致程序终止。但是，延误确实会引起恐慌，不是吗？我们知道，因为这是您从恐慌中恢复的方法-您可以在defer函数中运行代码。</p><p>    Precisely. Panics are going to run defers, and that’s actually not the only thing that’s going to run defers. If you do runtime.Goexit, like a goroutine calls runtime.Goexit, it will also have its defers executed. And this is totally safe to do, because basically the goroutine itself is synchronously – we know we’re stopping execution of the goroutine at this point, and we’re sort of walking back and running all of the defers.</p><p>    恰恰。恐慌将导致延误，实际上，这并不是唯一要推迟的事情。如果您执行runtime.Goexit，就像goroutine调用runtime.Goexit一样，它也会执行其延迟。这是完全安全的，因为goroutine本身基本上是同步的–我们知道我们现在要停止执行goroutine，并且我们有点后退并运行所有延迟。</p><p>        So if you’re doing runtime.Goexit for a goroutine, I assume that you don’t have the same cleanup guarantees that you would have with a os.Exit call… Like, how you said all the files and all the other stuff from the OS gets handled. I’m assuming that the goroutines files aren’t kept track of separately.</p><p>        因此，如果您正在为goroutine执行runtime.Goexit，那么我假设您没有像使用os.Exit调用那样具有相同的清除保证……例如，您怎么说所有文件和所有其他内容操作系统得到处理。我假设没有单独跟踪goroutines文件。</p><p>    No, no. That’s handled at a much lower level. If one goroutine exits - unless it’s the last goroutine, of course - then that says nothing about the rest of the resources that program might be building onto.</p><p>    不，不。那是在低得多的水平上进行的。如果一个goroutine退出了-当然，除非最后一个goroutine退出-但这并不能说明程序可能要建立的其余资源。</p><p>    Yeah, that’s interesting, when you think about things like HTTP response bodies, it’s very important you get a read closer when you get one of these. You get it if you make a request using an HTTP client; you get back a response, and that response may or may not have a body. And we are responsible for closing those bodies to clean up memory, and things. Presumably, that gets sorted out for us if the program ends, things like that… Because they sort of rely on the underlying operating system for managing resources, right?</p><p>    是的，这很有趣，当您考虑诸如HTTP响应正文之类的内容时，当您了解其中之一时，请务必仔细阅读。如果使用HTTP客户端发出请求，则会得到该消息；您得到响应，并且该响应可能有也可能没有身体。我们负责关闭这些主体以清理内存和其他东西。大概，如果程序结束，对我们来说就是这样，诸如此类的事情……因为它们某种程度上依赖底层操作系统来管理资源，对吗？</p><p>    [ ] Right. Again, in the Unix philosophy of “Everything is a file. So is an internet connection, so is a TCP/IP connection”, which sort of underlies all of HTTP – it’s the backbone that most operating systems build right into the operating system, and it’s usually exposed through an interface that looks like a socket… And the interface for this in Go looks like a [unintelligible  ] That sort of represents the underlying connection. So basically, if you os.Exit, it’s gonna close that socket like it was any other file. So if you have a client on the other side listening on that connection, then it’s going to be the same thing as if the connection was abruptly ended. So it’s the same sort of failure mode.</p><p>    [ ] 对。同样，在Unix哲学中，“一切都是文件。 “ Internet连接也是如此，TCP / IP连接也是如此”，它是所有HTTP的基础–它是大多数操作系统直接构建在操作系统中的骨干结构，并且通常通过看起来像套接字的接口公开… Go中的接口看起来像[unintelligible]，表示基础连接。因此，基本上，如果您使用os.Exit，它将像其他任何文件一样关闭该套接字。因此，如果您的另一端有一个客户端在监听该连接，则就像连接突然终止一样。因此，这是相同的故障模式。 </p><p>    The cool thing about some of these is you can actually test them if you go write a little program that just has a web server and just sits there and sleeps for ten seconds, and you curl into it or whatever just to make a connection, and then close the server and see what happened, you can kind of see what’s going on.</p><p>关于其中一些的最酷的事情是，如果您去编写一个只有网络服务器的小程序，然后坐在那里睡觉十秒钟，然后弯腰进入其中或只是建立连接，就可以实际测试它们。然后关闭服务器，看看发生了什么，您可以看到发生了什么。</p><p>        Yeah. Like, if you just use curl as the client to connect to your server, and you’re running a local host or whatever, and your server is just like doing a sleep for 10 seconds before it responds, and you Ctrl+C it or kill it before it’s actually done, you can kind of see [unintelligible  ]</p><p>        是的就像，如果您只是使用curl作为客户端来连接到服务器，并且您正在运行本地主机或其他设备，并且服务器就像在响应之前先睡眠10秒钟，然后按住Ctrl + C或在实际完成之前将其杀死，您可以看到[无法理解]</p><p>    Quite a cool API, that – just sort of restful mindfulness. Not RESTful, but mindfulness of just sleeping; a little API that just sleeps. I think that’s a great idea, especially in today’s world, where everything is going fast outside, like in a film.</p><p>    相当酷的API –只是一种宁静的正念。不是RESTful的，而是只睡觉的正念；一个刚刚睡觉的小API。我认为这是个好主意，尤其是在当今世界，一切都在快速发展，就像在电影中一样。</p><p>    It’s perfect. People call it to see if a web request has timed out.</p><p>    这是完美的。人们称它为Web请求是否超时。</p><p>    Yeah, there you go. It’s nice. Michael, how did y</p><p>    是的，你去了。这真好。迈克尔，你怎么样</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://changelog.com/news/Wy0J/visit">https://changelog.com/news/Wy0J/visit</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/播客/">#播客</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/字幕/">#字幕</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/podcast/">#podcast</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>