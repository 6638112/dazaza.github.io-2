<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>IPv6是一场彻头彻尾的噩梦--这就是为什么</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">IPv6是一场彻头彻尾的噩梦--这就是为什么</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-05 20:09:40</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/75570ac22da8e65c8779e6efddcf4579.png"><img src="http://img2.diglog.com/img/2020/11/75570ac22da8e65c8779e6efddcf4579.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>So this is just going to be a total rant.IPv6 is, in theory, a solution to many things, including the dwindling IPv4 address space.IPv6 was a draft in 1997(!), and became a real  Internet Standard in 2017.And, quite frankly, it’s one of those things that just adds too much hassle for not enough benefit.</p><p>理论上，IPv6是解决很多问题的解决方案，包括不断缩小的IPv4地址空间。IPv6是1997年的草案(！)，并于2017年成为真正的互联网标准。坦率地说，它只是在没有足够好处的情况下增加了太多麻烦的事情之一。</p><p>  Okay, yes, IPv6’s address space is   massive.IPv4 uses 32-bit addresses, allowing for 4,294,967,296 total addresses.IPv6 uses 128-bit addresses, meaning… 340,282,366,920,938,463,463,374,607,431,768,211,456 addresses.  1The entire v4 space could fit into the v6 space $7.922816251426434 \times 10^{28}$ times over.  2The default allocation to people, a  /64, meaning the first half of the addresses is fixed and the entire second half is the part unique to the network, means that most people have 18,446,744,073,709,551,616 addresses to play with at home.  3Compared to v4, where  most networks are around  /24, meaning the first three groupings are fixed, you get… 254 addresses.Again, context, a standard  /64 allocation can,  again, fit the entire v4 address space inside itself 4,294,967,296 times. (Yes, that’s the number of addresses  in the IPv4 address space. That’s what happens when you divide a power by half of that power.)</p><p>好吧，是的，IPV6的地址空间很大。IPV4使用32位地址，总共有4,294,967,296个地址。IPV6使用128位地址，这意味着…。340,282,366,920,938,463,463,374,607,431,768,211,456地址。1整个v4空间可以放入v6空间$7.922816251426434\x 10^{28}$。2分配给人的默认地址为a/64，这意味着前一半的地址是固定的，而整个后半部分是网络唯一的部分，这意味着大多数人在家里有18,446,744,073,709,551,616个地址可以玩。3与v4相比，在v4中，大多数网络都在/24左右，这意味着前三个分组是固定的，您得到的是…。254个地址。另外，在上下文中，标准/64分配可以再次将整个v4地址空间放入其内部4,294,967,296次。(是的，这是IPv4地址空间中的地址数量。这就是当你将一个权力除以一半的权力时会发生的事情。)。</p><p> IPv4 addresses are, well, sparse, given that most high-level authorities have already run out of addresses, but because CIDR and NAT are a thing, we’ve really started compacting down our usage. My entire house of easily over 60 IPs takes up… 2, according to the rest of the world.</p><p>考虑到大多数高级管理机构已经用完了地址，IPv4地址是稀疏的，但是因为CIDR和NAT是一种东西，我们真的已经开始压缩我们的使用了。我的整个房子有60多个IP，占据了…。2，根据世界其他地区的说法。</p><p>  One thing that people have criticized IPv4 for is that the allocations are just horrible.For example,  anything starting with  127 is  localhost.normally this is  127.0.0.1, but anything from  127.0.0.0 to  127.255.255.255 all mean the  exact same thing.That’s 16,777,216 addresses all  literally for  localhost.By numbers, 0.39% of the address space, but just keep this in mind.</p><p>人们批评IPv4的一件事是分配太糟糕了。例如，任何以127开头的地址都是本地主机。通常情况下是127.0.0.1，但从127.0.0.0到127.255.255.255的任何地址都意味着完全相同的东西。那就是16,777,216个地址，字面上都是本地主机地址。按数字计算，地址空间的0.39%，但请记住这一点。</p><p> Similarly, anything starting with a  0, is effectively “current network” (only valid as source), again, another 16 million addresses.</p><p>同样，任何以0开头的地址实际上都是“当前网络”(仅作为源地址有效)，也就是另外1600万个地址。</p><p> There’s also multiple blocks for private networks,  10.0.0.0/8,  172.16.0.0/12, and  192.168.0.0/16.In total, 17,891,328 addresses.</p><p>私有网络还有多个地址块，10.0.0.0/8、172.16.0.0/12和192.168.0.0/16，总共有17,891,328个地址。</p><p> Compared to IPv6, yes, IPv6 is much better… in theory.There’s only  one loopback address,  ::1.At the same time…  fc00::/7 (26,58,455,991,569,831,745,807,614,120,560,689,152 addresses) is the private address space (more on that later),  fe80::/10 (332,306,998,946,228,968,225,951,765,070,086,144 addresses) is the  local address space, and  ff00::/8 (1,329,227,995,784,915,872,903,807,060,280,344,576 addresses.) is multicast.yes, do you see a recurring pattern?Even though the entire “special” address assignments are exactly 1.271% of the entire IPv6 address space, we’re still allocating  giant swathes of addresses.History repeats itself, you can see that  right here.</p><p>是的，与IPV6相比，IPV6是更好的…。在理论上。只有一个环回地址，：：1。同时…。FC00：：/7(26，58,455,991,569,831,745,807,614,120,560,689,152地址)是私有地址空间(稍后将详细介绍)，FE80：：/10(332,306,998,946,228,968,225,951,765,070,086,144地址是本地地址空间，FF00：：/8(1,329,227,995,784,915,872,903,807,060,280,344,576地址。)。是组播。是的，你看到一种重复出现的模式吗？尽管整个“特殊”地址分配恰好占整个IPV6地址空间的1.271，但我们仍然在分配大量的地址。历史会重演，你可以在这里看到这一点。</p><p> And I will admit, that multicast in IPv6 is special since some bits in the address are special flags, and one form of multicast actually includes a response node’s address, so it’s not  just an arbitrary number, but… come on, that’s a little uncalled for, having  that much space.</p><p>我承认，IPV6中的多播是特殊的，因为地址中的一些位是特殊标志，而且一种形式的多播实际上包括响应节点的地址，所以它不只是一个任意数字，而是…。得了吧，有这么大的空间，这有点不必要。</p><p>  We all know what an IPv4 address looks like, right?Four dotted-decimal grouping in the range from 0–255.For example,  192.168.5.225.IPv6 uses  eight groupings of four  hex digits, colon-separated.For example,  2607:f0d0:1002:0051:0000:0000:0000:0004.That’s… very unweildy, so we have a few shortening rules.Any zeros that  lead the droup can be dropped, giving us this:  2607:f0d0:1002:51:0:0:0:4.And since  that is still repetitive, you can replace  exactly one sequence of  more than one group of all zeros with an empty:  2607:f0d0:1002:51::4.For the record this is why the loopback address is  ::1.The full address is  0000:0000:0000:0000:0000:0000:0000:0001.Even with those methods, they’re still  much longer, harder to remember, and harder to even say than IPv4 addresses.</p><p>我们都知道IPV4地址是什么样子的，对吧？0-255范围内的四个点分十进制分组。例如，192.168.5.225。IPv6使用八个分组，每组四个十六进制数字，用冒号分隔。例如，2607:f0d0:1002:0051:0000:0000:0000:0004.That’s…。非常不好用，所以我们有几条缩写规则。可以删除组前的任何零，结果是：2607：f0d0：1002：51：0：0：0：4。由于这仍然是重复的，您可以用空的：2607：f0d0：1002：51：：4替换一个包含多组全零的序列。为了记录，这就是环回地址为：：1的原因。完整地址为0000。而且比IPv4地址更难说。</p><p>  And remember that this address violates the URL spec, since the  : character is specifically to be used to separate the  host portion (e.g.,  google.com) from the  port to connect to (assuming nonstandard).As an example, I can reach my torrent client via  http://192.168.5.43:9091.See that  : there?Because Transmission listens on port 9091, not port 80.How do we fix this?Well, by breaking it again, naturally.To connect to a raw IPv6 address, you wrap it in square brackets.To connect to  2607:f0d0:1002:51::4 directly, that’s  http://[2607:f0d0:1002:51::4]/ Why is this a thing?!.</p><p>请记住，此地址违反了url规范，因为：字符专门用于将主机部分(例如，google.com)与要连接的端口(假设是非标准的)分开。例如，我可以通过http://192.168.5.43:9091.See到达我的Torrent客户端：那里？因为传输侦听的是端口9091，而不是端口80。我们如何解决这个问题？好的，通过自然地再次断开它。要连接到原始的IPV6地址，你把它包在方括号里。要直接连接到2607：f0d0：1002：51：：4，那是http://[2607:f0d0:1002:51：：4]/为什么这是一件事？！</p><p>  okay, admittedly, IPv6 kinda relies on DNS since… just about everything uses DNS, and of course, actual names are more memorable than 32 hexadecimal digits, but DNS isn’t magic.Unless you have your own DNS server (actually not that hard) that’s configured, you’re still manually typing addresses.Of course if you have, say, pfSense managing your network, every static DHCP lease will be registered in DNS, but it has to take a DHCP lease.And if this device doesn’t… well, I hope you don’t mind typing that out by hand to connect so you can configure it.</p><p>好吧，诚然，自从…以来，IPV6有点依赖于域名系统。几乎所有东西都使用dns，当然，实际名称比32位十六进制数字更容易记住，但dns并不神奇。除非你有自己的dns服务器(实际上没有那么难)，否则你仍然需要手动输入地址。当然，如果你有pfense来管理你的网络，每个静态dhcp租约都会在dns中注册，但它必须占用dhcp租约。如果这个设备不能…，那么你还是需要手动输入地址。当然，如果你有pfense来管理你的网络，每个静态的dhcp租约都会在dns中注册，但它必须占用dhcp租约。如果这个设备不能pfense。好吧，我希望你不介意手动打出来连接，这样你就可以配置它了。</p><p> Even better, rDNS.rDNS, or Reverse DNS, is where a DNS query is performed  with an IP address that returns the hostname associated, in a  PTR record.For example, the IPv4 that  google.com resolves to,  216.58.192.142, can be queried as  142.192.58.216.in-addr.arpa to get it’s “real” name, a  PTR record for  ord36s01-in-f142.1e100.net.With  dig, specifying a  -x and then the IP will convert it to the correct format.And if you look close, the query name is the IP, backwards, with  in-addr.arpa at the front.It’s backwards because of the hierarchical nature of DNS, which runs right to left, the opposite of IPs.Of course, there’s also rDNS for IPv6:</p><p>更棒的是，rDNS.rDNS，或反向DNS，是使用在PTR记录中返回相关主机名的IP地址执行的DNS查询。例如，google.com解析到的IPv4,216.58.192.142，可以被查询为142.192.58.216.in-addr.arpa以获得它的“真实”名称，这是ord36s01-in-f142.1e100.net的PTR记录。前面有in-addr.arpa。它是向后的，因为DNS的分层性质，它从右到左运行，与IP相反。当然，还有用于IPv6的RDNS：</p><p> $ dig -x 2607:f0d0:1002:51::4; &lt;&lt;&gt;&gt; DiG 9.11.3-1ubuntu1.12-Ubuntu &lt;&lt;&gt;&gt; -x 2607:f0d0:1002:51::4;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 22821;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 65494;; QUESTION SECTION:;4.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1.5.0.0.2.0.0.1.0.d.0.f.7.0.6.2.ip6.arpa. IN PTR;; ANSWER SECTION:4.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1.5.0.0.2.0.0.1.0.d.0.f.7.0.6.2.ip6.arpa. 3600 IN PTR 4000.0000.0000.0000.1500.2001.0d0f.7062.ip6.static.sl-reverse.com.;; Query time: 731 msec;; SERVER: 127.0.0.53#53(127.0.0.53);; WHEN: Sun Aug 30 00:52:50 EDT 2020;; MSG SIZE rcvd: 180</p><p>$Dig-x 2607：f0d0：1002：51：：4；&lt；&lt；&gt；dig9.11.3-1ubuntu1.12-Ubuntu&lt；&lt；&gt；-x 2607：f0d0：1002：51：：4；；全局选项：+cmd；；得到答案：；；-&gt；&gt；Header&lt；&lt；OPT PSEUDOSECTION：；EDNS：版本：0，标志：；UDP：65494；；问题SECTION：；4.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1.5.0.0.2.0.0.1.0.d.0.f.7.0.6.2.ip6.arpa.。在Ptr；中；回答SECTION:4.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1.5.0.0.2.0.0.1.0.d.0.f.7.0.6.2.ip6.arpa.。3600in PTR 4000.0000.0000.0000.1500.2001.0d0f.7062.ip6.static.sl-reverse.com.；；查询时间：731毫秒；服务器：127.0.0.53#53(127.0.0.53)；；时间：美国东部时间2020年8月30日00：52：50；消息大小接收：180。</p><p> That is   insane.The IPv6 rDNS  TLDis just  ip6.arpa, and the IP part is…every single hex digit, reversed.</p><p>这太疯狂了。IPV6RDNS TLD只有ip6.arpa，而IP部分是…。每一个十六进制数字，颠倒过来。</p><p>   One of the core pillars of IPv6 is that most of the processing of traffic should happen at the endpoints — routers don’t do much besides read, and forward, with very little actual data processing.The IPv6 header while being  gargantuan in comparison (because the giant addresses), is also much simpler.A fixed version code (6), the traffic class ( DiffServ+  ECN), a  flow label which is effectively a random value that’s constant for every packet that’s part of the same logical connection, length, type of next header, and a TTL (then addresses, obviously).That is  it.The IPv4 header contains 13 fields plus optional sections, and the IPv6 header contains a flat 8.Of course, you may actually need other details, and that’s where the  next header field comes in.Instead of packing all sorts of options into the standard, global header, IPv6 uses additional header  extensions that can get tacked on one after another to provide that information, say for fragmentation or IPsec.  4The value in the next header field identifies what’s going to come next, and the final header in the line will use this field to indicate the contained protocol, be it TCP, UDP, or something else.</p><p>IPv6的核心支柱之一是大多数流量的处理应该发生在端点-路由器除了读取和转发之外不做太多的工作，实际的数据处理很少。IPv6报头虽然比较庞大(因为巨大的地址)，但也简单得多。固定的版本代码(6)，流量类别(DiffServ+ECN)，流标签，它实际上是一个随机值，对于每个属于相同逻辑连接的数据包、长度、下一个报头类型和TTL来说都是恒定不变的。它是一个固定的版本代码(6)、流量类别(DiffServ+ECN)、流标签(Flow Label)，对于属于相同逻辑连接、长度、下一个报头类型和TTL的每个数据包来说，该值是恒定的。显然)。就是这样。IPv4报头包含13个字段外加可选部分，而IPv6报头包含平面8。当然，您实际上可能需要其他细节，这就是下一个报头字段的用武之地。IPv6不是将各种选项打包到标准的全局报头中，而是使用附加的报头扩展，这些扩展可以一个接一个地附加以提供信息，比如用于分段或IPsec。4Next Header字段中的值标识下一步的内容，该行中的最后一个Header将使用该字段指示包含的协议，可以是TCP、UDP或其他协议。</p><p> Also note there’s no checksum anymore.I mean, just about every device uses Ethernet, which has a Frame Check Sequence (FCS), UDP has a checksum option, TCP has a required checksum…If we want to simply packet processing, drop the sum.And really, it does make sense, in a way.Even without that one, that means that most programs have two checksums: the Ethernet FCS as the frame gets transmitted point to point, and the transport layer checksum, making sure the entire packet is still valid.Also, the IPv4 checksum also included the TTL (max number of hops in the path before the packet is dropped), meaning that at  every stop along the way, the checksum had to be recalculated.</p><p>我的意思是，几乎每个设备都使用以太网，以太网有帧校验序列，udp有校验和选项，tcp有必需的校验和…。如果我们想要简单地处理数据包，丢弃总和。确实，在某种程度上这是有意义的。即使没有这个，这也意味着大多数程序都有两个校验和：帧传输时的以太网FCS</p><p> As a final point, this also does bring a change to another protocol: UDP.With IPv4, the UDP checksum field can (and often would) be left blank as all zeros, meaning “no checksum”.In IPv6, this is now disallowed, and a all zero checksum will still be checked… and then found invalid.All UDP packets over IPv6  must have a valid checksum calculated.</p><p>最后一点是，这也给另一个协议带来了变化：UDP。在IPv4中，UDP校验和字段可以(通常也会)留空为全零，这意味着“没有校验和”。在IPv6中，这现在是不允许的，并且仍然会对全零校验和进行…检查。然后发现无效。所有IPv6上的UDP数据包都必须计算有效的校验和。</p><p>  So every link between devices has an MTU, the Maximum Transmission Unit.For normal Ethernet links, minus the frame overhead, this is 1500 bytes.If your equipment supports jumbo frames, that’s closer to 9000 bytes.Well not all links are equal.Some devices might have a high-MTU link on one end, and a lower MTU link on the other.For example, my router might support jumbo frames internally, but the WAN side doesn’t allow that.To deal with, this, we have  fragmentation.</p><p>因此，设备之间的每条链路都有MTU(最大传输单位)。对于普通的以太网链路，减去帧开销，这是1500字节。如果您的设备支持巨型帧，则接近9000字节。并不是所有的链路都是相等的。有些设备可能一端具有高MTU链路，而另一端具有较低的MTU链路。例如，我的路由器可能在内部支持巨型帧，但广域网端不允许这样做。为了解决这个问题，我们有碎片。</p><p> If a router is unable to forward a frame due to MTU differences, it will, if allowed, split the packet into multiple chunks, using the More Fragments flag and the Fragment Offset field of the IPv4 header, and send the packet in multiple frames piece by piece, which the other end can reassemble.Note that I said “if allowed.”There is a Don’t Fragment flag in the IPv4 header, and if this is set by the sending device, a router that cannot support a packet of that size will send back an  ICMP“packet too big” message which bounces back along the chain.Any node in the network path can perform this, meaning that for sending data, the only MTU you care about is the MTU of the device you’re directly connected to; your own link.</p><p>如果路由器由于MTU差异而无法转发帧，则在允许的情况下，它将使用IPv4报头的More Fragments标志和片段偏移量字段将数据包分成多个块，并将数据包分成多个帧逐个发送，另一端可以重新组装。请注意，我说的是“如果允许”。IPv4报头中有一个“不要分片”标志，如果发送设备设置了该标志，则不能支持这种大小的数据包的路由器将发回ICMP“Packet Too Large”(数据包太大)消息，该消息会弹回。这意味着，在发送数据时，您唯一关心的MTU是您直接连接的设备的MTU；你自己的链接。</p><p> IPv6 does not allow this.Intermediate routers are  not allowed to fragment a packet, and instead will send back an ICMP error.If you’re going to fragment a packet (which is also heavily discouraged), then the sending device can add a  Fragmentation header extension.So, either packets are not fragmented at all, or packets are fragmented from the originating device.IPv6 also expects senders to perform  Path MTU discovery, by actually listening to ICMP packet too big messages, which contains the MTU of that node.The sender is expected to read this, and then adjust accordingly, repeating this in a loop until the packet can pass just fine.Alternatively… don’t exceed the IPv6 minimum MTU, 1280 bytes.</p><p>IPv6不允许这样做。中间路由器不允许对数据包进行分段，而是会发回ICMP错误。如果您要对数据包进行分段(这也是非常不鼓励的)，则发送设备可以添加分段报头扩展。因此，要么根本不对数据包进行分段，要么从始发设备对数据包进行分段。IPv6还希望发送者通过实际侦听ICMP数据包太大的消息来执行路径MTU发现，该消息包含该节点的MTU。因此，IPv6还希望发送者执行路径MTU发现，方法是实际侦听包含该节点MTU的ICMP数据包太大的消息。因此，IPv6不允许对数据包进行分段，而是将其发回ICMP错误。如果您要对数据包进行分段(这也是非常不鼓励的)，则发送设备可以添加分段报头扩展。不要超过IPv6的最小MTU，即1280字节。</p><p>  If you know me, you know I always say that computer networking is a miracle that only holds together by duct tape, prayers of engineers, and dumb luck.Nowhere does this hold true more than the introduction of IPv6 into a network, where just about everyone that I talk to has flat out disabled IPv6 on everything that gives them the option — it’s just way too much headache to have to deal with it all, and if it’s enabled, 90% of your new network problems become the fact that devices are now doing unexpected IPv6 things that you never thought of.</p><p>如果你了解我，你就知道我总是说，计算机网络是一个奇迹，只有通过胶带、工程师的祈祷和愚蠢的运气才能维系在一起。没有什么比将IPv6引入网络更正确的了，在这个网络中，几乎每个与我交谈的人都在为他们提供选择的所有东西上彻底禁用了IPv6-这太令人头疼了，不得不处理所有这些-如果它被启用，90%的新网络问题变成了这样一个事实，即设备现在正在做你从未想过的意想不到的IPv6事情。这是一个令人头疼的问题，如果它被启用，90%的新网络问题变成了这样一个事实，即设备现在正在做你从未想过的意想不到的IPv6事情。</p><p> but besides that point, if you want to run a network with IPv6, you’re likely going to have to operate both 4 and 6 just because IPv4 is still going strong.So that means for every firewall rule that involves a specific host or network, you need two: one for the IPv4 block, and one for the IPv6 block.And heaven forbid if you change one and forget the other.</p><p>但除此之外，如果你想用IPv6运行网络，你可能不得不同时运行4和6，因为IPv4仍然很强大。这意味着对于涉及特定主机或网络的每条防火墙规则，你都需要两条：一条用于IPv4块，另一条用于IPv6块。如果你改变了一个，而忘记了另一个，那是不可能的。</p><p>  Does not exist.Generally when you get an IP address, that address will be globally routable — anyone can access it, from anywhere, Hollywood style.</p><p>一般情况下，当你得到一个IP地址后，这个地址就可以在全球范围内进行路由了--任何人都可以从任何地方访问它，就像好莱坞式的那样。</p><p> However, if you want a private network, there is  one prefix for that: anything from  fc00:0000:0000:0000:0000:0000:0000:0000 to  fdff:ffff:ffff:ffff:ffff:ffff:ffff:ffff ( fc00::/7) is considered non-routable for private networks. Technically the first bit here you’re allowed to modify should  always be 1, meaning your  actually RFC compliant range is  fd00::/8, which is  fd00:0000:0000:0000:0000:0000:0000:0000 to  fdff:ffff:ffff:ffff:ffff:ffff:ffff:ffff.half the addresses, but still plenty.Yes, the actual spec is more complicated and defines a few parts in the “network” area, but… well, you get the point.</p><p>但是，如果您想要私有网络，有一个前缀：从fc00：0000：0000：0000：0000：0000：0000：0000：0000：0000：0000：0000到fdff：ffff：ffff(fc00：：/7)之间的任何内容都被认为是私有网络不可路由的。从技术上讲，这里允许您修改的第一位应该始终是1，这意味着您实际的rfc兼容范围是fd00：：/8，即fd00：0000：0000：0000：0000：0000：0000：0000到fdff：ffff：fff。地址的一半，但仍然很多。是的，实际的规范更复杂，并且在“网络”区域定义了几个部分，但是…。好吧，你明白我的意思了。</p><p> So here’s the question: Say you’ve done that.How do you route packets to these private IPs?The answer is Network  Address  Prefix Translation.Wait… what?</p><p>所以现在的问题是：假设你已经做到了这一点。你如何将数据包路由到这些私有IP？答案是网络地址前缀转换。等待…。什么？</p><p> Yes. NAT is an IPv4 thing. NPt is an IPv6 thing.With IPv4, you can scan for packets and, if they match certain criteria (say, going to a known address, like your WAN address, on a known port), swap the destination (or source) address with a new one.This is how I am using just  one IP for all my services: the destination port decides what server your request gets routed to.In this sense, all unknown traffic is dropped, and traffic that I have NAT rules for are also allowed pas the firewall.This is a “default drop” system.Nothing gets through unless I say so.</p><p>是。NAT是一种IPv4协议。NPT是一种IPv6技术。使用IPv4，你可以扫描信息包，如果它们符合一定的标准(比如，去往已知地址，比如你的广域网地址)，就用一个新的地址交换目的地(或源)地址。这就是我对我的所有服务只使用一个IP的方式：目的地端口决定你的请求被路由到哪个服务器。从这个意义上说，所有未知的流量都会被丢弃，我对其有NAT规则的流量也会被允许通过防火墙。这是一个“默认丢弃系统”(Default Drop System)。这是一个“默认丢弃系统”(Default Drop System)。从这个意义上说，所有未知的流量都会被丢弃，而我对其有NAT规则的流量也会被允许通过防火墙。</p><p>  Say, for example, I have a host at the private address of  fd2c:a7c6:2aae:ef93::41.I could then add an NPt rule for to transform  fd2c:a7c6:2aae:ef93:: into  2607:f0d0:1002:51::.This is effectively a 1:1 mapping, meaning that it works both ways, both inbound and outbound will be translated.</p><p>例如，假设我在私有地址fd2c：a7c6：2aae：ef93：：41上有一个主机，然后我可以为添加一个npt规则，将fd2c：a7c6：2aae：ef93：：转换为2607：f0d0：1002：51：：。这实际上是1：1的映射，这意味着它是双向的，入站和出站都将被转换。</p><p> For this, I could then, say, advertise (with an  AAAA record, perhaps) the public IP of the server as  2607:f0d0:1002:51::41, and when the packet comes in…</p><p>为此，我可以(也许使用aaaa记录)将服务器的公共IP通告为2607：f0d0：1002：51：：41，当数据包以…格式传入时。</p><p>  Which not  only means that I’m exposing my  entire network, but I  need a different IP for every different destination, and, additionally, I’m also giving away the internal structure of my network!You may not know the prefix but you’ll know the  exact subnet address since I’m   only translating a prefix!!!</p><p>这不仅意味着我暴露了我的整个网络，而且我需要为每个不同的目的地提供不同的IP，此外，我还会泄露我的网络的内部结构！你可能不知道前缀，但你会知道确切的子网地址，因为我只翻译一个前缀！</p><p> That “different IPs” bit may sound a bit… duh, then remember that for some systems I run (like this blog, with NNTP), the  port number alone is what decides the destination, you could even still go to the  same domain name and it counts.With NPt, you  cannot do this, you’d have to have an  additional device like a layer 7 proxy (like HAProxy) to take in everything and send it to the correct destination, meaning I need a dedicated host to do the thing that  IPv4 NAT  could already do natively!</p><p>那个“不同的IP”位听起来可能有点…。嗯，那么请记住，对于我运行的一些系统(比如这个博客，使用NNTP)，端口号本身就决定了目的地，你甚至仍然可以使用相同的域名进行计数。使用NPT，你无法做到这一点，你必须有一个额外的设备，如第7层代理(如HAProxy)来接收所有内容并将其发送到正确的目的地，这意味着我需要一台专用主机来做IPv4 NAT本来就可以做的事情！</p><p> And  it gets better.Remember, this will  blindly just swap prefixes in and out.Gone are the days of “only the traffic I explicitly create a rule for can get in”.See, now, just adding that  one step will, be default, expose your  entire network!You now need firewall rules to block what you don’t want and add explicit allows, this time manually as an additional step.This is more of a “default pass” routing — unless I tell you not to, let it through.Now, most firewalls do by default drop unknown traffic, but with NAT, if there’s no NAT rule for something it literally has no clue where to route it even if it  is allowed through.With NPt, you don’t have that layer of security, the firewall is the  only thing between the outside world, and your network.</p><p>而且情况会变得更好。记住，这将会盲目地交换前缀。过去的日子是“只有我显式地为其创建规则的流量才能进入”。现在，只需添加一个步骤，就可以默认地暴露您的整个网络！现在，您需要防火墙规则来拦截您不想要的内容，并添加显式允许，这一次是手动作为额外的步骤。这更像是一种“默认通过”路由--除非我告诉您不要这样做，否则就让它通过。现在，大多数防火墙都是这样做的。如果某个东西没有NAT规则，那么即使它被允许通过，它实际上也不知道路由到哪里。有了《不扩散核武器条约》，你就没有了那层安全层，防火墙是外部世界和你的网络之间唯一的东西。</p><p> Really if you remember  one thing about IPv6, it’s  this. right. here.And this  alone is the reason that for the time being I will  never start running IPv6 networks.</p><p>如果你还记得关于IPv6的一件事，那就是这件事。正确的。这就是我暂时不会开始运行IPv6网络的原因。</p><p> But  I’m not done yet.The entire practice is… just flat out discouraged.The pfSense manual even says that what I just said might also not work correctly, so,  nice, but also, the entire  point of IPv6 is that all nodes are globally routable, you don’t  need special private address spaces or translation of any kind, it  just works.And if you want, hah,  privacy, that’s what firewalls are for.It’s… okay, seriously, it’s like a group of people that have no clue how tech  should work were asked to design something that the tech-illiterate can actually understand and use fluently, and we have…  this.Like, really now, was the IETF watching some cybercrime flicks as they wrote the RFC?Every computer just  by default accessible  anywhere in the world unless you  specifically firewall things?I get that even with IPv4 that’s how things worked  until you set up a subnet boundary, but here, in v6, it’s either a firewall or no protection.This whole “end-to-end” focus nature really feels poorly thought out, from a techie perspective.And, as data shows, the kind of devices that  do actively use IPv6 (mobile devices, mainly), are able to just zeroconf themselves perfectly, which is nice from a “just works” perspective, but like many things recently, the “well it needs to work seamlessly” side  seriously clashes with the “actual useful functionality” side.</p><p>但我还没做完，整个实践都是…。PfSense手册甚至说，我刚才说的可能也不能正确工作，所以，不错，但同时，ipv6的全部要点是所有节点都是全球可路由的，你不需要特殊的私有地址空间或任何类型的转换，它就可以工作。如果你想，哈，隐私，这就是防火墙的用途。这就是…。好的，说真的，这就像是一群不知道技术应该如何工作的人被要求设计一种技术文盲可以真正理解和流利使用的东西，我们有…。这个。就像现在，IETF在写RFC时是不是看了一些网络犯罪电影？世界上任何地方的每台计算机默认情况下都是可以访问的，除非你特别防火墙。我知道即使是在IPv4中，事情也是这样运作的，直到你设置了一个子网边界，但在V6中，它要么是防火墙，要么是没有保护。从技术角度来看，这种端到端的焦点性质真的是考虑不周。而且，正如数据显示的那样，那些积极使用IPv6的设备。从“只是工作”的角度来看，这是不错的，但就像最近的许多事情一样，“好的，它需要无缝工作”这一方面与“实际有用的功能”这一方面严重冲突。</p><p>   Client sends out a  DHCPDISCOVER packet from a source of  0.0.0.0 to the broadcast address</p><p>客户端从源0.0.0.0向广播地址发送一个DHCPDISCOVER数据包。</p><p> Server sends a  DHCPOFFER to broadcast IP (but destination MAC) with the offered client IP, subnet mask, DNS servers, lease time, and other information</p><p>服务器向广播IP(但目的MAC)发送一个DHCPOFFER，其中包含提供的客户端IP、子网掩码、DNS服务器、租用时间和其他信息。</p><p>  Server sends a  DHCPACK with the same information in the offer, thus confirming the IP assignment</p><p>服务器发送带有提议中相同信息的DHCPACK，从而确认IP分配。</p><p> DHCP here also includes a lot of data in the form of numbered options, but here’s some common values:</p><p>这里的DHCP还包括大量编号选项形式的数据，但以下是一些常见的值：</p><p>  Some additional values like the default MTU (option 26) can also be sent.There’s 254 valid options, as  0x00 is padding and  0xff marks the end of the message.</p><p>还可以发送一些额外的值，比如默认的MTU(选项26)。有254个有效选项，0x00是填充，0xff是消息的结尾。</p><p> In just four UDP messages, a host just powering on can gain just about  every bit of information that it may need.</p><p>在短短四个UDP消息中，一台主机只需开机就可以获得它可能需要的几乎每一位信息。</p><p> DHCPv6… not so much.The protocol  is split in two, and let’s go over DHCPv6 first.This is, again, a four step process:</p><p>DHCPv6…。不是很多。协议一分为二，让我们先来看看DHCPv6。这也是一个四步过程：</p><p> Client sends a  SOLICIT from its link-local to the “All DHCP” multicast address,  ff02::1:2</p><p>客户端从其本地链路向“All DHCP”组播地址ff02：：1：2发送请求。</p><p>   Some obsolete options like WINS servers are removed, but you’ll notice some things like the  network gateway are completely missing.Also the DHCP server just provides the local part of the address, it doesn’t even give out the network prefix.But before we get into  that, here’s something fun:DHCP(v4) uses the MAC address of the client as it’s identifier, IPs are leased to a particular MAC.DHCPv6 uses a DHCP Unique Identifier (DUID), which is  usually the MAC address, with other things.There’s four types: one for the MAC + timestamp, a unique enterprise number based DUID, just the MAC, and a UUID based one.IPs are leased out to  DUIDs not  MACs, and so it’s actually  really difficult to make reservations ahead of time.The easiest course of action is to wait for the client to grab a lease, then upgrade that to a static assignment.Oh, and yes, of course, here’s an example MAC + time DUID:  00-01-00-01-18-BA-30-56-D8-9D-67-C9-FA-33.Are you noticing a pattern here with IPv6?Everything is just getting long, unwieldy, and, in my opinion, creates needless complexity  in the interest of simplicity in one of the most ironic twists I’ve seen in computing and networking.</p><p>一些过时的选项，比如WINS服务器被移除了，但是你会注意到一些东西完全丢失了，比如网络网关。同样，DHCP服务器只提供地址的本地部分，它甚至不提供网络前缀。但是在我们开始之前，这里有一些有趣的东西：DHCP(V4)使用客户端的MAC地址作为它的标识符，IP被租给特定的MAC。DHCPv6使用一个DHCP唯一标识符(DUID)，通常是MAC地址，还有其他东西。DUID(Duid)，通常是MAC地址。在我们开始之前，这里有一些有趣的事情：DHCP(V4)使用客户端的MAC地址作为它的标识符，IP被租给特定的MAC。DHCPv6使用一个DHCP唯一标识符(DUID)，通常是MAC地址，还有其他东西。基于UUID。IP租给DUID而不是Mac，所以实际上很难提前预订。最简单的做法是等待客户端获得租约，然后将其升级为静态分配。哦，当然，这里有一个MAC+Time DUID的示例：00-01-00-01-18-BA-30-56-D8-9D-67-C9-FA-33。您注意到这里的模式了吗。为了简单起见，创造了不必要的复杂性，这是我在计算和网络领域看到的最具讽刺意味的转折之一。</p><p> Also note that  this also doesn’t happen by default either.DHCP will only be used  if SLAAC / RA permits.And while I’ll get to SLAAC in a second, let’s talk about the Neighbor DIscovery Protocol, and Router Advertisements.</p><p>还要注意的是，这在默认情况下也不会发生。只有在SLAAC/RA允许的情况下才会使用DHCP。虽然我马上就会讲到SLAAC，但让我们来谈谈邻居发现协议和路由器通告。</p><p>  When an IPv6 capable host joins a network, it will send out  Router Solicitation (hmm, I’m seeing “solicit” as a verb here a few times, I think I found everyone’s new favorite word) message.Available IPv6 gateways that can forward frames will periodically send out  Router Advertisement messages, or, if they see a solicitation, will immediately send out an advert.</p><p>当一台支持IPv6的主机加入网络时，它将发送路由器请求(嗯，我在这里几次看到“Solicate”作为动词，我想我找到了每个人最喜欢的新单词)。可转发帧的可用的IPv6网关将定期发送路由器通告消息，或者，如果它们看到请求，将立即发出广告。</p><p> The advertisements contain the M and O flags (hold on), a lifetime for which the advert should be considered valid, up to three DNS servers, a search list (same as DHCP), and the network prefix.The advert also contains a priority, one of low, normal, or high, for that particular router.Why only three? Beats me.And no, it’s  not usually a giid idea to have more than one router on the same priority level.If you have more than three gateways on a network (because  of course thats a thing you can do now), have fun.Anyways, the Managed and “Other stateful” flags control the behavior of hosts a bit more in-depth.There’s even  more flags concerning the prefix dat</p><p>通告包含M和O标志(等待)、最多三个DNS服务器、一个搜索列表(与DHCP相同)和网络前缀。通告包含M和O标志(等待)、最多三个DNS服务器、搜索列表(与DHCP相同)和网络前缀。通告还包含该特定路由器的优先级(低、正常或高)之一。为什么只有三个？问倒我了。不，在同一优先级上有多个路由器通常不是一个简单的想法。如果一个网络上有三个以上的网关(因为这是你现在可以做的事情)，那就玩得开心。不管怎么说，托管的和其他有状态的标志可以更深入地控制主机的行为。还有更多关于前缀dat的标志。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://teknikaldomain.me/post/ipv6-is-a-total-nightmare/">https://teknikaldomain.me/post/ipv6-is-a-total-nightmare/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/彻头彻尾/">#彻头彻尾</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/total/">#total</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/地址/">#地址</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>