<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>负载测试很困难，工具也不是很好。 但为什么？ Load testing is hard, and the tools are not great. But why?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Load testing is hard, and the tools are not great. But why?<br/>负载测试很困难，工具也不是很好。 但为什么？ </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-05 15:24:00</div><div class="page_narrow text-break page_content"><p>If you&#39;re building an application that needs to scale—and we all tell ourselves that we are—then at some point you have to figure out if it  does or not. This is where load testing comes in: if you want to see whether or not your application can handle scale, just  generate scale and see if it can handle it! It sounds straightforward enough.</p><p>如果您正在构建需要扩展的应用程序-我们都告诉我们自己是这样-那么在某个时候，您必须确定它是否可以扩展。这就是进行负载测试的地方：如果要查看应用程序是否可以处理规​​模，只需生成规模并查看它是否可以处理！听起来很简单。</p><p> Then you try to actually generate load. This is straightforward if your application is dead simple, because you can use something like  Apache JMeter to generate repeated requests. If you can do this, I envy you: every system I&#39;ve worked on is more complicated and requires a more intricate testing plan.</p><p> 然后，您尝试实际产生负载。如果您的应用程序非常简单，那么这很简单，因为您可以使用Apache JMeter之类的东西来生成重复请求。如果您可以这样做，我会羡慕您：我处理过的每个系统都更加复杂，并且需要更复杂的测试计划。</p><p> Your application gets slightly more complicated, so you then turn to tools like  Gatling. These let you simulate virtual users going through scenarios, which is a lot more helpful than just  besieging one or a handful of URLs. Even this isn&#39;t sufficient if you&#39;re writing an application that uses both WebSockets  and HTTP calls, over a long-lived session, and requires certain actions repeated on a timer. Unless I severely missed something in the documentation, I cannot see a way to, say, setup a heartbeat that runs ever 30 seconds, do certain actions upon response to a WebSocket message, and also do some other HTTP actions, all with the same HTTP session. I haven&#39;t found a way to do that in  any load testing tool (which is why I wrote my own at work, which I hope to open source if I can make the time to clean it up and separate out proprietary bits).</p><p> 您的应用程序变得稍微复杂一些，因此您需要使用诸如Gatling之类的工具。这些功能使您可以模拟虚拟用户在各种情况下的浏览情况，这比围困一个或几个URL有用得多。如果您编写的应用程序在长期存在的会话中同时使用WebSocket和HTTP调用，并且还需要在计时器上重复某些操作，那么即使这还不够。除非我严重错过了文档中的内容，否则无法看到一种方法，例如设置运行30秒的心跳信号，在响应WebSocket消息时执行某些操作以及执行一些其他HTTP操作（所有操作都使用相同的HTTP）会议。我尚未在任何负载测试工具中找到一种方法来做到这一点（这就是为什么我在工作中编写自己的工具的原因，如果我能抽出时间清理并分离出专有位，我希望将其开源） 。</p><p> But let&#39;s suppose you  do have a tool that works, out of the box, like Gatling or Locust, and it fits your needs. Great! Now let&#39;s write that test. In my experience, this is the hardest bit yet, because you have to first figure out what realistic load looks like — welcome to a day or three of dredging through logs and taking notes while you peer at the network tools in your browser as you click around in your web application. And then after you know what realistic load looks like, you get to write what boils down to a subset of your application to pretend to be a user, hit the API, and do the things your user would do.</p><p> 但是让我们假设您确实有一个像盖特林或蝗虫这样的开箱即用的工具，它可以满足您的需求。大！现在让我们编写该测试。以我的经验，这是最难的一点，因为您必须首先弄清楚实际负载是什么样的—欢迎您在浏览日志时做一两天的疏through日志并记笔记，同时单击浏览器中的网络工具在您的Web应用程序中。然后，在知道实际负载是什么样之后，您就可以将其归结为应用程序的一个子集，以假装自己是用户，点击API，然后执行用户会做的事情。</p><p> And we&#39;re not done yet! This is fine, we have our load test written and it&#39;s realistic. But this is a moving target, because updates keep going out. So now you have the maintenance problem, too: as your application changes, how do you keep your load test up to date? There isn&#39;t great tooling to do this, there is little out there to help you. You have to make this part of your process and hope you don&#39;t miss things. This is not a satisfying answer, and that&#39;s why this is also one of the hardest parts of load testing an application.</p><p> 而且我们还没有完成！很好，我们已经编写了负载测试并且很现实。但这是一个移动的目标，因为更新会不断更新。因此，现在您也遇到了维护问题：随着应用程序的更改，如何使负载测试保持最新状态？没有很好的工具可以做到这一点，几乎没有什么可以帮助您的。您必须将其作为过程的一部分，并希望您不要错过任何事情。这不是一个令人满意的答案，这就是为什么这也是负载测试应用程序中最困难的部分之一的原因。</p><p> We&#39;ll just skip the whole &#34;running it&#34; part, because honestly, if you&#39;ve gotten this far through a load test, then running it shouldn&#39;t be the hardest part.</p><p> 我们将跳过整个＆＃34;运行它部分，因为说实话，如果您已经通过负载测试走了那么远，那么运行它就不是最困难的部分。</p><p>   Most load testing tools support simplistic workloads, and even the complex ones don&#39;t let you do everything that&#39;s realistically needed to simulate  real usage of a web application.</p><p>   大多数负载测试工具都支持简单的工作负载，即使是复杂的工作负载也不能让您完成模拟Web应用程序的实际使用所需的所有工作。 </p><p> Writing the test with a simulation of real usage is the hardest part, even if the tools do support what you need.</p><p>即使实际工具支持您所需的内容，编写具有真实使用情况的模拟的测试也是最困难的部分。</p><p> Maintaining the test is the second hardest part, and the tooling here does not help you in the slightest.</p><p> 维护测试是第二困难的部分，此处的工具丝毫没有帮助您。</p><p> Let&#39;s look at these in detail and see how much complexity we can pare away.</p><p> 让我们详细研究这些内容，看看我们可以减少多少复杂性。</p><p>  I&#39;m a &#34;yes&#34; here, although it might depend on your application. And for these purposes, we&#39;re talking about the user  of a service; if you have a monolith, this is your users as a whole, but if you have microservices the &#34;user&#34; might be another one of your services! For the applications I&#39;ve worked on, I have had minor success with targeted tests of specific endpoints. But these end up requiring such complicated setup that you aren&#39;t better off than you were with the load test itself! And while it may yield some results and improvements, it doesn&#39;t get to everything (you may have endpoints that interact) and you don&#39;t get a realistic workload.</p><p>  我是＆yes＆＃34;在这里，尽管它可能取决于您的应用程序。出于这些目的，我们正在谈论服务的用户；如果您拥有整体，则这是您的整体用户，但如果您有微服务，则＆＃34;用户＆＃34;可能是您的另一项服务！对于我从事的应用程序，在针对特定端点的目标测试中，我取得了较小的成功。但是这些最终都需要如此复杂的设置，以至于您不比负载测试本身更好！尽管它可能会产生一些结果和改进，但并不能解决所有问题（您可能具有交互的端点），并且无法获得实际的工作负载。</p><p> &#34;When do you  not need to simulate users?&#34; is probably a better question. Seems to me like this is when you  know that your endpoints are all independent in performance, you don&#39;t have any stateful requests, and the ordering of requests does not impact performance. These are big things to assume and it&#39;s hard to have confidence in them without testing their independence, at which point, we&#39;re back to writing that whole dang test.</p><p> ＆＃34;何时不需要模拟用户？＆＃34;可能是一个更好的问题。在我看来，这是当您知道端点在性能上都是独立的，没有任何有状态的请求，并且请求的顺序不会影响性能时。这些都是要承担的大事，如果不测试其独立性就很难对它们充满信心，这时，我们将重新编写整个测试。</p><p> The best you can do here is probably at the API and system design time, not at your test time. If you design a simpler API, you&#39;re going to have far less surface area to test. If you design a system with more certainly independent pieces (distinct databases per service, for example) then it&#39;s easier to test them in isolation than in a monolith. Doing this also lets you use a tool that is simpler, so you get two wins!</p><p> 您在此处可能要做的最好的事情是在API和系统设计时，而不是在测试时。如果您设计一个更简单的API，您将需要更少的表面积进行测试。如果您设计的系统中肯定有独立的部分（例如，每个服务的数据库不同），那么独立进行测试要比独立测试更容易。这样做还可以使您使用更简单的工具，从而获得两次胜利！</p><p>  Creating a load test is hard because you have to do a few things: you have to understand what the flow through  usage of your API is, and you have to write a simulation of that usage. Understanding that flow means understanding other systems than the one under test and since your system is presumably not the focus of their documentation, there is not going to be a super clear diagram of when and how it&#39;s called; this often looks like sifting logs until you figure out what the representative usage is. And then writing that simulation is certainly not trivial, because you need to manage the state for a large number of actors representing users of your API!</p><p>  创建负载测试非常困难，因为您必须做一些事情：必须了解API使用的流向，以及必须编写对该使用的模拟。理解该流程意味着要理解除被测系统之外的其他系统，并且由于您的系统可能不是其文档的重点，因此不会有一个何时何地被调用的超清晰图；这通常看起来像筛选日志，直到您弄清楚代表性的用法是什么。然后编写该模拟当然不是一件容易的事，因为您需要管理代表API用户的大量参与者的状态！ </p><p>  There&#39;s some research out there on how to make some of these tasks easier. You can figure out what you need for the initial test, and detect regressions (missing new workloads) from automated analysis of the logs, for example. But as far as I can tell, there is no software on GitHub, let alone a product I can buy, that&#39;s going to do that for me. So it doesn&#39;t seem like it has much of any traction in industry. It would be a big project to implement it on your own, which might be why it has languished (or is done at big companies, and is not spoken of).</p><p>有一些关于如何使其中一些任务更容易的研究。例如，您可以找出进行初始测试所需的条件，并通过对日志的自动分析来检测回归（缺少新的工作负载）。但是据我所知，GitHub上没有软件，更不用说我可以购买的产品了，它将为我做到这一点。因此，它似乎在行业中没有任何吸引力。自行实施将是一个很大的项目，这可能就是为什么它表现不佳（或在大公司完成，却没有被提及）的原因。</p><p>  There&#39;s a lot of complexity in load tests, and there is not a lot of tooling to help you with it. So maybe the answer is: write fewer of these types of tests, and don&#39;t expect them to give you all the answers to how your system performs.</p><p>  负载测试有很多复杂性，并且没有太多工具可以帮助您。因此，答案可能是：减少此类测试的编写，不要期望它们会为您提供有关系统性能的所有答案。</p><p> You have a few options for getting a great picture of how your system performs:</p><p> 您可以通过以下几种方法来大致了解系统的性能：</p><p> Good old analysis. Sit down with a notebook, a pen, an understanding of your systems as a whole, and an afternoon to spare, and you can figure out with some napkin math what the general parameters and bounds of scaling on your system are. When you find the bottleneck, or you have some unknowns (how many transactions per second  can our database support? how many do we generate?) then you can go test those specifically!</p><p> 好的旧分析。坐下来用笔记本，笔，对系统的整体了解以及一个下午的时间，您可以通过一些餐巾纸算出系统的一般参数和扩展范围。当您发现瓶颈时，或者您有一些未知数（我们的数据库每秒可以支持多少个事务？我们可以生成多少个事务？），您就可以进行专门的测试了！</p><p> Feature rollouts. If you can roll out features slowly across your users, then you don&#39;t necessarily have to do any load testing at all! You can measure performance experimentally and see if it&#39;s good enough. Good? Roll forward. Bad? Roll back.</p><p> 功能推出。如果您可以在整个用户中缓慢推出功能，那么您根本不必进行任何负载测试！您可以通过实验评估效果，看看效果是否足够好。好？前滚。坏？回滚。</p><p> Traffic replay. This doesn&#39;t help at all with new features (see feature rollouts ten words ago for that) but it does help with understanding your system breaking points for existing features without as much development. You can take the traffic you saw before and replay it (multiple times over, even, by combining multiple different periods&#39; traffic) and see how the system performs! (Side note: I would  love tooling to help with this, and with amplifying traffic when doing this, so if anyone has a recommendation... hit me up.)</p><p> 流量重播。这对新功能完全没有帮助（有关此功能，请参见十个单词前的功能介绍），但这确实有助于在不进行过多开发的情况下了解现有功能的系统突破点。您可以将以前看到的流量重新播放（甚至通过组合多个不同的时间段来进行多次播放），然后查看系统的性能！ （旁注：我很乐意使用工具来帮助解决此问题，并在这样做时增加流量，因此，如果有人提出建议，请来我这里。）</p><p>  If you have some silver bullet I&#39;ve missed, or a fantastic research paper in this area you&#39;d recommend reading, or a story of terrible times with scaling that you want to share with me, please email them to  me@ntietz.com.</p><p>  如果您错过了一些银弹，或者在该领域有出色的研究论文，则建议阅读，或者想要与我分享分享有关缩放的可怕故事，请通过电子邮件将它们发送给我@ ntietz.com。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://ntietz.com/tech-blog/load-testing-is-hard-but-why/">https://ntietz.com/tech-blog/load-testing-is-hard-but-why/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/负载/">#负载</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/testing/">#testing</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/测试/">#测试</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>