<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>JavaScript性能超出捆绑包大小 JavaScript performance beyond bundle size</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">JavaScript performance beyond bundle size<br/>JavaScript性能超出捆绑包大小 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-01 02:11:48</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/3/62d2811e9884847bee91074836281240.png"><img src="http://img2.diglog.com/img/2021/3/62d2811e9884847bee91074836281240.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>There’s  an old story about a drunk trying to find his keys in the streetlight. Why? Well, because that’s where it’s the brightest. It’s a funny story, but also relatable, because as humans we all tend to take the path of least resistance.</p><p>有一个古老的故事，关于一个醉汉试图在路灯下找到他的钥匙。为什么？好吧，因为那是最亮的地方。这是一个有趣的故事，但也是相关的，因为作为人类，我们所有人都倾向于走阻力最小的道路。</p><p> I think we have the same problem in the web performance community. There’s a huge focus recently on JavaScript bundle size: how big are your dependencies? Could you use a smaller one? Could you lazy-load it? But I believe we focus on bundle size first and foremost because it’s easy to measure.</p><p> 我认为我们在网络性能社区中存在同样的问题。最近，人们非常关注JavaScript包的大小：您的依赖项有多大？你能用一个较小的吗？您可以延迟加载吗？但是我相信我们首先要重点关注捆绑商品的尺寸，因为它很容易衡量。</p><p> That’s not to say that bundle size isn’t important! Just like how you  might have left your keys in the streetlight. And heck, you might as well check there first, since it’s the quickest place to look. But here are some other things that are harder to measure, but can be just as important:</p><p> 并不是说捆绑包的大小并不重要！就像您可能将钥匙遗留在路灯中一样。而且，您最好先检查一下那里，因为它是最快的查找地点。但是，还有其他一些事情很难衡量，但可能同样重要：</p><p>  A JavaScript dependency can affect all of these metrics. But they’re less discussed than bundle size, and I suspect it’s because they’re less straightforward to measure. In this post, I want to talk about how I approach bundle size, and how I approach the other metrics too.</p><p>  JavaScript依赖关系可能会影响所有这些指标。但是，与讨论包大小相比，对它们的讨论较少，我怀疑这是因为它们的度量不那么直接。在这篇文章中，我想谈谈我如何处理捆绑商品规模，以及我如何也应对其他指标。</p><p>  When talking about the size of JavaScript code, you have to be precise. Some folks will say “my library is 10 kilobytes.” Is that minified? Gzipped? Tree-shaken? Did you use the highest Gzip setting (9)? What about Brotli compression?</p><p>  在谈论JavaScript代码的大小时，您必须精确。有些人会说“我的图书馆有10 KB。”缩小了吗？压缩吗？摇树？您是否使用了最高的Gzip设置（9）？ Brotli压缩又如何呢？</p><p> This may sound like hair-splitting, but the distinction actually matters, especially between compressed and uncompressed size. The compressed size affects how fast it is to send bytes over the wire, whereas the uncompressed size affects how long it takes the browser to parse, compile, and execute the JavaScript. (These tend to correlate with code size, although it’s not a perfect predictor.)</p><p> 这听起来像头发劈开，但是区别实际上很重要，尤其是在压缩尺寸和未压缩尺寸之间。压缩后的大小会影响通过网络发送字节的速度，而未压缩后的大小会影响浏览器解析，编译和执行JavaScript所花费的时间。 （尽管这并不是一个完美的预测指标，但它们往往与代码大小相关。）</p><p> The most important thing, though, is to be consistent. You don’t want to measure Library A using unminified, uncompressed size versus Library B using minified and compressed size (unless there’s a real difference in how you’re serving them).</p><p> 不过，最重要的是保持一致。您不想使用最小化和未压缩的大小来衡量库A，而不想使用最小化和压缩的大小来衡量库B（除非在服务方式上存在真正的差异）。 </p><p>  For me,  Bundlephobia is the Swiss Army knife of bundle size analysis. You can look up any dependency from npm and it will tell you both the minified size (what the browser parses and executes) as well as the minified and compressed size (what the browser downloads).</p><p>对我来说，Bundlephobia是瑞士军团尺寸分析的利器。您可以从npm查找任何依赖项，它将告诉您最小大小（浏览器解析和执行的内容）以及最小和压缩大小（浏览器下载的内容）。</p><p> For instance, we can use this tool to see that   react-dom weighs 121.1kB minified, but   preact weighs 10.2kB. So we can confirm that Preact  really is the honest goods – a React-compatible framework at a fraction of the size!</p><p> 例如，我们可以使用此工具来查看最小反应作用权重为121.1kB，而预先执行权重为10.2kB。因此，我们可以确认Preact确实是诚实的货–一个与React兼容的框架，尺寸很小！</p><p> In this case, I don’t get hung up on exactly which minifier or exactly what Gzip compression level Bundlephobia is using, because at least it’s using the same system everywhere. So I know I’m comparing apples to apples.</p><p> 在这种情况下，我不会迷上确切的Minifier或Bundlephobia所使用的Gzip压缩级别，因为至少它在所有地方都使用相同的系统。所以我知道我在比较苹果与苹果。</p><p>  It doesn’t tell you the tree-shaken cost. If you’re only importing one part of a module, the other parts may be tree-shaken out.</p><p>  它并没有告诉您巨额的费用。如果您仅导入模块的一部分，则其他部分可能会被树遮盖掉。</p><p> It won’t tell you about subdirectory dependencies. So for instance, I know how expensive it is to  import &#39;preact&#39;, but  import &#39;preact/compat&#39; could be literally anything –  compat.js could be a huge file, and I’d have no way to know.</p><p> 它不会告诉您有关子目录的依赖性。因此，举例来说，我知道导入preact / compat多么昂贵，但导入preact / compat＆compat＆＃39;几乎可以是任何东西– compat.js可能是一个巨大的文件，我无法知道。</p><p> If there are polyfills involved (e.g. your bundler injecting a polyfill for Node’s  Buffer API, or for the JavaScript  Object.assign() API), you won’t necessarily see it here.</p><p> 如果涉及到polyfill（例如，捆绑程序为Node的Buffer API或JavaScript Object.assign（）API注入了polyfill），则您不一定会在这里看到它。</p><p> In all the above cases, you really just have to run your bundler and check the output. Every bundler is different, and depending on the configuration or other factors, you might end up with a huge bundle or a tiny one. So next, let’s move on to the bundler-specific tools.</p><p> 在上述所有情况下，您实际上只需要运行捆绑程序并检查输出即可。每个捆绑器都不同，根据配置或其他因素，您可能最终会得到一个巨大的捆绑包或一个很小的捆绑包。接下来，让我们继续使用捆绑程序专用的工具。 </p><p>  I love  Webpack Bundle Analyzer. It offers a nice visualization of every chunk in your Webpack output, as well as which modules are inside of those chunks.</p><p>我喜欢Webpack Bundle Analyzer。它提供了Webpack输出中每个块的漂亮可视化，以及这些块中的哪些模块。</p><p>  In terms of  the sizes it shows, the two most useful ones are “parsed” (the default) and “Gzipped”. “Parsed” essentially means “minified,” so these two measurements are roughly comparable with what Bundlephobia would tell us. But the difference here is that we’re actually running our bundler, so we know that the sizes are accurate for our particular application.</p><p>  就显示的大小而言，两个最有用的大小是“解析”（默认）和“压缩”。 “已解析”本质上是指“最小化”，因此，这两个度量与Bundlephobia告诉我们的大致可比。但是这里的区别在于我们实际上是在运行捆绑程序，因此我们知道大小对于我们的特定应用程序是准确的。</p><p>  For Rollup, I would really love to have a graphical interface like Webpack Bundle Analyzer. But the next best thing I’ve found is  Rollup Plugin Analyer, which will output your module sizes to the console while building.</p><p>  对于汇总，我真的很想拥有一个图形界面，例如Webpack Bundle Analyzer。但是，我发现的下一个最好的东西是Rollup Plugin Analyer，它将在构建时将模块大小输出到控制台。</p><p> Unfortunately, this tool doesn’t give us the minified or Gzipped size – just the size  as seen by Rollup before such optimizations occur. It’s not perfect, but it’s great in a pinch.</p><p> 不幸的是，此工具并没有为我们提供缩小的尺寸或压缩的尺寸-只是在进行此类优化之前Rollup看到的尺寸。它并不完美，但紧要关头很棒。</p><p>      As I mentioned, though, I don’t think JavaScript bundle size is everything. It’s great as a first approximation, because it’s (comparatively) easy to measure, but there are plenty of other metrics that can impact page performance.</p><p>      但是，正如我所提到的，我认为JavaScript包的大小并不决定一切。第一次比较好，因为它比较容易衡量，但是还有很多其他指标会影响网页性能。</p><p>  The first and most important one is the runtime cost. This can be broken into a few buckets:</p><p>  第一个也是最重要的一个是运行时成本。这可以分为几个部分：</p><p>  These three phases are basically the end-to-end cost of calling  require(&#34;some-dependency&#34;) or  import &#34;some-dependency&#34;. They may correlate with bundle size, but it’s not a one-to-one mapping.</p><p>  这三个阶段基本上是调用require（＆＃34; some-dependency＆＃34;）或导入＆＃34; some-dependency＆＃34;的端到端成本。它们可能与捆绑商品的大小相关，但这不是一对一的映射。 </p><p> For a trivial example, here is a (tiny!) JavaScript snippet that consumes a ton of CPU:</p><p>举一个简单的例子，这是一个（小小的！）JavaScript代码段，它消耗大量的CPU：</p><p>  This snippet would get a great score on Bundlephobia, but unfortunately it will block the main thread for 5 seconds. This is a somewhat absurd example, but in the real world, you can find small libraries that nonetheless hammer the main thread. Traversing through all elements in the DOM, iterating through a large array in LocalStorage, calculating digits of pi… unless you’ve hand-inspected all your dependencies, it’s hard to know what they’re doing in there.</p><p>  此代码片段在Bundlephobia上得分很高，但不幸的是它将阻塞主线程5秒钟。这是一个有点荒谬的示例，但是在现实世界中，您会找到小型库，但是它们仍然会破坏主线程。遍历DOM中的所有元素，遍历LocalStorage中的一个大型数组，计算pi的位数……除非您亲自检查了所有依赖项，否则很难知道它们在其中所做的工作。</p><p> Parsing and compilation are both really hard to measure. It’s easy to fool yourself, because browsers have lots of optimizations around  bytecode caching. For instance, browsers might not run the parse/compile step on second page load, or  third page load (!), or when the JavaScript is cached in a Service Worker. So you might think a module is cheap to parse/compile, when really the browser has just cached it in advance.</p><p> 解析和编译都非常难以衡量。愚弄自己很容易，因为浏览器在字节码缓存方面做了很多优化。例如，浏览器可能不会在第二页加载或第三页加载（！）时，或者在Service Worker中缓存JavaScript时不运行解析/编译步骤。因此，当浏览器确实预先缓存了模块时，您可能会认为模块的解析/编译便宜。</p><p>  The only way to be 100% safe is to completely clear the browser cache and measure first page load. I don’t like to mess around, so typically I will do this in a private/guest browsing window, or in a completely separate browser. You’ll also want to make sure that any browser extensions are disabled (private mode typically does this), since those extensions can impact page load time. You don’t want to get halfway into analyzing a Chrome trace and realize that you’re measuring your password manager!</p><p>  保证100％安全的唯一方法是完全清除浏览器缓存并衡量首页加载。我不想四处乱逛，因此通常我会在私人/访客浏览窗口或完全独立的浏览器中执行此操作。您还需要确保禁用所有浏览器扩展程序（通常使用私有模式），因为这些扩展程序可能会影响页面加载时间。您不想半途而废地分析Chrome跟踪并意识到自己正在测量密码管理器！</p><p> Another thing I usually do is set Chrome’s CPU throttling to 4x or 6x. I think of 4x as “similar enough to a mobile device,” and 6x as “a super-duper slowed-down machine that makes the traces much easier to read, because everything is bigger.” Use whichever one you want; either will be more representative of real users than your (probably) high-end developer machine.</p><p> 我通常要做的另一件事是将Chrome的CPU限制设置为4倍或6倍。我将4x视为“与移动设备足够相似”，将6x视为“一种超高速减慢的机器，它使迹线更容易阅读，因为所有内容都更大。”使用您想要的任何一种；与您的（可能是）高端开发人员计算机相比，这两种方法都更能代表实际用户。</p><p> If I’m concerned about network speed, this is the point where I would turn on network throttling as well. “Fast 3G” is usually a good one that hits the sweet spot between “more like the real world” and “not so slow that I start yelling at my computer.”</p><p> 如果我担心网络速度，那么在这一点上我也将打开网络限制。 “快速3G”通常是一个不错的选择，它会达到“更像现实世界”和“不慢到我开始对计算机大吼大叫”之间的甜蜜点。</p><p>  Navigate to  about:blank if necessary (you don’t want to measure the  unload event for your browser home page).</p><p>  如有必要，请导航至about：blank（您不想衡量浏览器主页的卸载事件）。 </p><p>  Now you have a performance trace (also known as a “timeline” or “profile”), which will show you the parse/compile/execution times for the JavaScript code in your initial page load. Unfortunately this part can end up being pretty manual, but there are some tricks to make it easier.</p><p>现在，您有了性能跟踪（也称为“时间轴”或“配置文件”），它将向您显示初始页面加载中JavaScript代码的解析/编译/执行时间。不幸的是，这部分最终可能是相当手工的，但是有一些技巧可以使它变得更容易。</p><p> Most importantly, use the  User Timing API (aka performance marks and measures) to mark parts of your web application with names that are meaningful to you. Focus on parts that you worry will be expensive, such as the initial render of your root application, a blocking XHR call, or bootstrapping your state object.</p><p> 最重要的是，使用User Timing API（也称为性能标记和度量）使用对您有意义的名称来标记Web应用程序的各个部分。专注于您担心会很昂贵的部分，例如根应用程序的初始渲染，阻塞的XHR调用或引导状态对象。</p><p> You can strip out  performance.mark/ performance.measure calls in production if you’re worried about the (small) overhead of these APIs. I like to turn it on or off  based on query string parameters, so that I can easily turn on user timings in production if I want to analyze the production build. Terser’s   pure_funcs option can also be used to remove  performance.mark and  performance.measure calls when you minify. (Heck, you can remove  console.logs here too. It’s very handy.)</p><p> 如果您担心这些API的（少量）开销，可以在生产中删除Performance.mark / Performance.measure调用。我喜欢根据查询字符串参数打开或关闭它，这样，如果我想分析生产版本，就可以轻松地打开生产中的用户计时。缩小时，Terser的pure_funcs选项还可用于删除performance.mark和performance.measure调用。 （哎呀，您也可以在此处删除console.logs。非常方便。）</p><p> Another useful tool is   mark-loader, which is a Webpack plugin that automatically wraps your modules in mark/measure calls so that you can see each dependency’s runtime cost. Why try to puzzle over a JavaScript call stack, when the tool can tell you exactly which dependencies are consuming exactly how much time?</p><p> 另一个有用的工具是mark-loader，它是一个Webpack插件，可以自动将模块包装在mark / measure调用中，以便您可以查看每个依赖项的运行时成本。当工具可以确切告诉您哪些依赖项正在消耗多少时间时，为什么还要对JavaScript调用栈感到困惑呢？</p><p>  One thing to be aware of when measuring runtime performance is that the costs can vary between minified and unminified code. Unused functions may be stripped out, code will be smaller and more optimized, and libraries may define  process.env.NODE_ENV === &#39;development&#39; blocks that don’t run in production mode.</p><p>  衡量运行时性能时要注意的一件事是，成本在最小化代码和未最小化代码之间可能会有所不同。未使用的功能可能会被删除，代码会更小，更优化，并且库可能会定义process.env.NODE_ENV ===＆＃39; development＆＃39;不在生产模式下运行的块</p><p> My general strategy for dealing with this situation is to treat the minified, production build as the source of truth, and to use marks and measures to make it comprehensible. As mentioned, though,  performance.mark and  performance.measure have their own small overhead, so you may want to toggle them with query string parameters.</p><p> 我处理这种情况的一般策略是将缩小的生产结构视为真理的来源，并使用标记和措施使之易于理解。但是，如上所述，performance.mark和performance.measure都有自己的小开销，因此您可能需要使用查询字符串参数进行切换。</p><p>  You don’t have to be an environmentalist to think that minimizing power use is important. We live in a world where people are increasingly browsing the web on devices that aren’t plugged into a power outlet, and the last thing they want is to run out of juice because of a misbehaving website.</p><p>  您不必是环保主义者，就认为最大限度地减少用电很重要。我们生活在一个世界上，人们越来越多地在未插入电源插座的设备上浏览网络，而他们想要做的最后一件事就是因为网站行为不当而用光了果汁。 </p><p> I tend to think of power usage as a subset of CPU usage. There are some exceptions to this, like  waking up the radio for a network connection, but most of the time, if a website is consuming excessive power, it’s because it’s consuming excessive CPU on the main thread.</p><p>我倾向于将功耗作为CPU使用率的一个子集。这有一些例外，例如唤醒无线电以建立网络连接，但是大多数情况下，如果网站消耗过多的电量，那是因为它在主线程上消耗了过多的CPU。</p><p> So everything I’ve said above about improving JavaScript parse/compile/execute time will also reduce power consumption. But for long-lived web applications especially, the most insidious form of power drain comes after first page load. This might manifest as a user suddenly noticing that their laptop fan is whirring or their phone is growing hot, even though they’re just looking at an (apparently) idle webpage.</p><p> 因此，我上面提到的有关改善JavaScript解析/编译/执行时间的所有内容，也将减少功耗。但是，特别是对于寿命长的Web应用程序，最隐蔽的功耗形式是在第一页加载之后出现的。这可能表现为用户突然注意到他们的笔记本电脑风扇在呼or或手机变热，即使他们只是看着一个（显然）空闲的网页。</p><p> Once again, the tool of choice in these situations is the Chrome DevTools Performance tab, using essentially the same steps described above. What you’ll want to look for, though, is repeated CPU usage, usually due to timers or animations. For instance, a poorly-coded custom scrollbar, an  IntersectionObserver polyfill, or an animated loading spinner may decide that they need to run code in every  requestAnimationFrame or in a  setInterval loop.</p><p> 在这种情况下，再次选择的工具是“ Chrome DevTools性能”选项卡，使用与上述基本相同的步骤。不过，您要查找的是重复使用CPU，通常是由于计时器或动画引起的。例如，编码不良的自定义滚动条，IntersectionObserver polyfill或动画加载微调器可能会决定他们需要在每个requestAnimationFrame或setInterval循环中运行代码。</p><p>  Note that this kind of power drain can also occur due to unoptimized CSS animations – no JavaScript required! (In that case, it would be purple peaks rather than yellow peaks in the Chrome UI.) For long-running CSS animations, be sure to always prefer  GPU-accelerated CSS properties.</p><p>  请注意，由于未优化的CSS动画，也可能发生这种耗电–不需要JavaScript！ （在那种情况下，在Chrome UI中将是紫色峰而不是黄色峰。）对于长时间运行的CSS动画，请确保始终喜欢GPU加速的CSS属性。</p><p> Another tool you can use is Chrome’s  Performance Monitor tab, which is actually different from the Performance tab. I see this as a sort of heartbeat monitor of how your website is doing perf-wise, without the hassle of manually starting and stopping a trace. If you see constant CPU usage here on an otherwise inert webpage, then you probably have a power usage problem.</p><p> 您可以使用的另一个工具是Chrome的“效果监视器”标签，该标签实际上与“性能”标签不同。我认为这是一种对您的网站性能进行监控的心跳监视器，而无需手动启动和停止跟踪。如果您在其他网页上看到的CPU使用率稳定，则可能是电源使用问题。</p><p>  Also: hat tip to the WebKit folks, who added an explicit  Energy Impact panel to the Safari Web Inspector. Another good tool to check out!</p><p>  另外：向WebKit专家介绍技巧，后者向Safari Web Inspector添加了显式的Energy Impact面板。签出的另一个好工具！</p><p>  Memory usage is something that used to be much harder to analyze, but the tooling has improved a lot recently.</p><p>  内存使用情况以前很难分析，但是最近工具有了很大的改进。 </p><p> I already wrote  a post about memory leaks last year, but it’s important to remember that memory  usage and memory  leaks are two separate problems. A website can have high memory usage without explicitly leaking memory. Whereas another website could start small, but eventually balloon to a huge size due to runaway leaks.</p><p>去年，我已经写了一篇有关内存泄漏的文章，但是请记住，内存使用和内存泄漏是两个独立的问题，这一点很重要。网站可以具有较高的内存使用率，而不会显式泄漏内存。另一个网站可能从很小的地方开始，但由于失控的泄漏，最终使网站膨胀到了巨大的规模。</p><p> You can read the above blog post for how to analyze memory leaks. But in terms of memory usage, we have a new browser API that helps quite a bit with measuring it:   performance.measureUserAgentSpecificMemory (formerly  performance.measureMemory, which sadly was much less of a mouthful). There are several advantages of this API:</p><p> 您可以阅读上面的博客文章，了解如何分析内存泄漏。但是就内存使用而言，我们有一个新的浏览器API，它在测量方面有很大帮助：performance.measureUserAgentSpecificMemory（以前称为performance.measureMemory，可悲的是，它要少很多）。此API有几个优点：</p><p> It returns a promise that automatically resolves  after garbage collection. (No more need for  weird hacks to force GC!)</p><p> 它返回一个在垃圾回收后自动解决的承诺。 （不再需要使用奇怪的技巧来强制执行GC！）</p><p> It measures more than just JavaScript VM size – it also includes DOM memory as well as memory in web workers and iframes.</p><p> 它不仅测量JavaScript VM的大小，还包括DOM内存以及Web Worker和iframe中的内存。</p><p> In the case of cross-origin iframes, which are process-isolated due to  Site Isolation, it will break down the attribution. So you can know exactly how memory-hungry your ads and embeds are!</p><p> 如果是跨网站的iframe（由于网站隔离而被流程隔离），则会破坏归因。因此，您可以确切地知道广告和嵌入的存储空间多么庞大！</p><p>   In this case,  bytes is the banner metric you’ll want to use for “how much memory am I using?” The  breakdown is optional, and the spec explicitly notes that  browsers can decide not to include it.</p><p>   在这种情况下，字节是您要用于“我正在使用多少内存？”的标语指标。细分是可选的，规范明确指出浏览器可以决定不包括它。</p><p> That said, it can still be finicky to use this API. First off, it’s only available in Chrome 89+. (In slightly older releases, you can set the “enable experimental web platform features” flag and use the old  performance.measureMemory API.) More problematic, though, is that due to the potential for abuse, this API has been limited to  cross-origin isolated contexts. This effectively means that you have to set some  special headers, and if you rely on any cross-origin resources (external CSS, JavaScript, images, etc.), they’ll need to set some special headers too.</p><p> 也就是说，使用此API可能仍然很挑剔。首先，它仅在Chrome 89+中可用。 （在稍早的发行版中，您可以设置“启用实验性Web平台功能”标志并使用旧的performance.measureMemory API。）但更多的问题是，由于存在滥用的可能性，该API仅限跨平台使用。起源隔离的上下文。这实际上意味着您必须设置一些特殊的标头，并且如果您依赖任何跨域资源（外部CSS，JavaScript，图像等），它们也需要设置一些特殊的标头。 </p><p> If that sounds like too much trouble, though, and if you only plan to use this API for automated testing, then you can run Chrome with the   --disable-web-security flag. (At your own risk, of course!) Note, though, that measuring memory currently  doesn’t work in headless mode.</p><p>但是，如果这听起来太麻烦了，并且仅打算使用此API进行自动化测试，则可以使用--disable-web-security标志运行Chrome。 （当然，后果自负！）但是请注意，目前在无头模式下无法测量内存。</p><p> Of course, this API also doesn’t give you a great level of granularity. You won’t be able to figure out, for instance, that React takes up X number of bytes, and Lodash takes up Y bytes, etc. A/B testing may be the only effective way to figure that kind of thing out. But this is still much better than the older tooling we had for measuring memory (which is so flawed that it’s really not even worth describing).</p><p> 当然，此API也无法为您提供更高的粒度。例如，您将无法确定React占用了X个字节，Lodash占用了Y个字节，依此类推。A / B测试可能是找出此类问题的唯一有效方法。但这仍然比我们用于测量内存的较旧工具要好得多（该工具存在很大缺陷，甚至根本不值得描述）。</p><p>  Limiting disk usage is most important in web application scenarios, where it’s possible to reach browser  quota limits depending on the amount of available storage on the device. Excessive storage usage can come in many forms, such as stuffing too many  large images into the  ServiceWorker cache, but JavaScript can add up too.</p><p>  在网络应用程序场景中，限制磁盘使用量是最重要的，在这种情况下，可能会达到浏览器配额限制，具体取决于设备上的可用存储量。过多的存储使用可能有多种形式，例如将太多大图像填充到ServiceWorker缓存中，但是JavaScript也可以累加。</p><p> You might think that the disk usage of a JavaScript module is a direct correlate of its bundle size (i.e. the cost of caching it), but there are some cases were this isn’t true. For instance, with my own   emoji-picker-element, I make heavy use of  IndexedDB to store the emoji data. This means I have to be cognizant of database-related disk usage, such as storing unnecessary data or creating excessive indexes.</p><p> 您可能会认为JavaScript模块的磁盘使用量与其包大小（即缓存它的成本）有直接关系，但是在某些情况下，这是不正确的。例如，通过我自己的emoji-picker-element，我大量使用IndexedDB来存储emoji数据。这意味着我必须意识到与数据库相关的磁盘使用情况，例如存储不必要的数据或创建过多的索引。</p><p>  The Chrome DevTools has an  “Application” tab which shows the total storage usage for a website. This is pretty good as a first approximation, but I’ve found that this screen can be a little bit inconsistent, and also the data has to be gathered manually. Plus, I’m interested in more than just Chrome, since IndexedDB has vastly different implementations across browsers, so the storage size could vary wildly.</p><p>  Chrome DevTools具有“应用程序”标签，该标签显示了网站的总存储空间使用情况。作为一个大概的近似值，这很好，但是我发现此屏幕可能有点不一致，并且必须手动收集数据。另外，我不仅对Chrome感兴趣，还因为IndexedDB在各种浏览器中的实现方式大不相同，因此存储大小可能会千差万别。</p><p> The solution I landed on is a  small script that launches  Playwright, which is a  Puppeteer-like tool that has the advantage of being able to launch more browsers than just Chrome. Another neat feature is that it can launch browsers with a fresh storage area, so you can launch a browser, write storage to  /tmp, and then measure the IndexedDB usage for each browser.</p><p> 我找到的解决方案是一个启动Playwright的小脚本，该脚本是类似于Puppeteer的工具，具有能够启动更多浏览器的优势，而不仅仅是Chrome。另一个很好的功能是，它可以启动具有新存储区域的浏览器，因此您可以启动浏览器，将存储写入/ tmp，然后测量每个浏览器的IndexedDB使用情况。</p><p> To give you an example, here is what I get for the current version of  emoji-picker-element:</p><p> 举个例子，这是我对当前版本的emoji-picker-element的理解： </p><p>  Of course, you would have to adapt this script if you wanted to measure the storage size of the ServiceWorker cache,  LocalStorage, etc.</p><p>当然，如果要测量ServiceWorker缓存，LocalStorage等的存储大小，则必须调整此脚本。</p><p> Another option, which might work better in a production environment, would be the   StorageManager.estimate() API. However, this is designed more for figuring out if you’re approaching quota limits rather than performance analysis, so I’m not sure how accurate it would be as a disk usage metric. As MDN notes: “The returned values are not exact; between compression, deduplication, and obfuscation for security reasons, they will be imprecise.”</p><p> 可能在生产环境中更好工作的另一个选项是StorageManager.estimate（）API。但是，它的目的更多是为了弄清您是否正在接近配额限制而不是性能分析，因此我不确定作为磁盘使用率指标的准确性如何。正如MDN所说：“返回的值不正确；出于安全原因，压缩，重复数据删除和混淆之间的关系将是不精确的。”</p><p>  Performance is a multi-faceted thing. It would be great if we could reduce it down to a single metric such as bundle size, but if you really want to cover all the bases, there are a lot of different angles to consider.</p><p>  性能是多方面的。如果我们可以将其缩减为单个度量标准（例如捆绑包大小），那将是很好的选择，但是如果您真的想涵盖所有基础，则需要考虑很多不同的角度。</p><p> Sometimes this can feel overwhelming, which is why I think initiatives like the  Core Web Vitals, or a general focus on bundle size, aren’t such a bad thing. If you tell people they need to optimize a dozen different metrics, they may just decide not to optimize any of them.</p><p> 有时候，这可能让人感到不知所措，这就是为什么我认为诸如Core Web Vitals之类的计划或通常专注于捆绑销售规模的计划并不是一件坏事。如果您告诉人们他们需要优化许多不同的指标，那么他们可能会决定不对其进行优化。</p><p> That said, for JavaScript dependencies in particular, I would love if it were easier to see all of these metrics at a glance. Imagine if Bundlephobia had a “Nutrition Facts”-type view, with bundle size as the headline metric (sort of like calories!), and all the other metrics listed below. It wouldn’t have to be precise: the numbers might depend on the browser, the size of the DOM, how the API is used, etc. But you could imagine some basic stats around initial CPU execution time, memory usage, and disk usage that wouldn’t be impossible to measure in an automated way.</p><p> 就是说，特别是对于JavaScript依赖关系，如果一眼就能看到所有这些指标，我将很乐意。想象一下，如果Bundlephobia具有“营养事实”类型的视图，并且将bundle size作为标题度量标准（有点像卡路里！），并且下面列出了所有其他度量标准。不必很精确：数字可能取决于浏览器，DOM的大小，API的使用方式等。但是您可以想象一些有关初始CPU执行时间，内存使用率和磁盘使用率的基本统计信息以自动化的方式衡量并非不可能。</p><p> If such a thing existed, it would be a lot easier to make informed decisions about which JavaScript dependencies to use, whether to lazy-load them, etc. But in the meantime, there are lots of different ways of gathering this data, and I hope this blog post has at least encouraged you to look a little bit beyond the streetlight.</p><p> 如果存在这种情况，那么就可以明智地决定要使用哪些JavaScript依赖项，是否延迟加载它们，等等。但是与此同时，有很多不同的方式来收集这些数据，希望这篇博客文章至少鼓励您将目光移到路灯之外。</p><p> Thanks to  Thomas Steiner and  Jake Archibald for feedback on a draft of this blog post.</p><p> 感谢Thomas Steiner和Jake Archibald对本文的草稿提供了反馈。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://nolanlawson.com/2021/02/23/javascript-performance-beyond-bundle-size/">https://nolanlawson.com/2021/02/23/javascript-performance-beyond-bundle-size/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/性能/">#性能</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/java/">#java</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>