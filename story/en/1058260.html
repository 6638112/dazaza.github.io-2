<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>vulkan视频加速扩展 Vulkan Video Acceleration Extensions</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Vulkan Video Acceleration Extensions<br/>vulkan视频加速扩展 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-14 11:57:44</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/4/3531e4de1153976de9dbe16552de58a4.png"><img src="http://img2.diglog.com/img/2021/4/3531e4de1153976de9dbe16552de58a4.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>In early 2018 the Vulkan Working Group at Khronos started to explore how to seamlessly integrate hardware accelerated video compression and decompression into the Vulkan API. Today, Khronos is releasing a set of  Provisional Vulkan Video acceleration extensions : ‘Vulkan Video’. This blog will give you an overview of Vulkan’s new video processing capabilities and we welcome feedback before the extensions are finalized so that they may provide effective acceleration for your video applications!</p><p>在2018年初，Khronos的vulkan工作组开始探索如何将硬件加速的视频压缩和解压缩整合到Vulkan API中。今天，Khronos正在发布一套临时vulkan视频加速扩展：'vulkan视频'。此博客将概述vulkan的新视频处理功能，并在延长最终确定之前欢迎反馈，以便他们为您的视频应用提供有效的加速！</p><p> Vulkan Video adheres to the Vulkan philosophy of providing flexible, fine-grained control over video processing scheduling, synchronization, and memory utilization to the application. Leveraging the existing Vulkan framework enables efficient, low-latency, low-overhead use of processing resources, including distributing stream processing tasks across multiple CPU cores and video codec hardware—all with application portability across multiple platforms and devices ranging from small embedded devices to high performance servers.</p><p> Vulkan视频遵循Vulkan哲学，提供灵活，细粒度控制对应用程序的视频处理调度，同步和内存利用。利用现有的vulkan框架实现了高效，低延迟，低端设备的处理资源，包括在多个CPU内核和视频编解码器硬件上分发流处理任务 - 所有这些都具有跨多个平台和从小嵌入式设备的设备的应用程序的可移植性性能服务器。</p><p>  To complement the low-level design of Vulkan Video, Khronos plans to add support in the Vulkan SDK with layers for validation and higher-level abstractions that will speed the development of video applications where simple frame-in-frame-out and black-box decoding and encoding is sufficient. This will be complemented by open source Vulkan Video samples for a range of application use cases on Windows and Linux.</p><p>  为了补充vulkan视频的低级设计，khronos计划在vulkan sdk中添加支持，其中包含验证和更高级别的抽象，这将加快视频应用程序的视频应用程序，其中帧内框架和黑盒子解码和编码就足够了。这将由Windows和Linux上的一系列应用程序使用案例进行互补的vulkan视频样本。</p><p> The Provisional Vulkan Video extensions closely integrate hardware accelerated video processing with Vulkan’s existing graphics, compute and display functionality. We invite all developers to provide feedback so the finalized Vulkan Video 1.0 extensions can be finely tuned to provide exciting new capabilities for Vulkan applications everywhere!</p><p> 临时vulkan视频扩展与Vulkan现有的图形，计算和显示功能密切集成了硬件加速视频处理。我们邀请所有开发人员提供反馈，以便最终确定的vulkan视频1.0扩展可以精细调整，以便在任何地方提供令人兴奋的vutkan应用程序的新功能！</p><p>  GPUs typically contain dedicated video decode and encode acceleration engine(s) that are independent from other graphics and compute engines. In fact, some physical devices may support only video decode and/or video encode operations. Consequently Vulkan Video adds video decode and encode queues, the presence of which can be queried by using   VkQueueFlagBits.</p><p>  GPU通常包含专用的视频解码和编码与其他图形和计算引擎无关的加速引擎。实际上，一些物理设备可以仅支持视频解码和/或视频编码操作。因此，Vulkan视频添加了视频解码和编码队列，可以使用VKQueueFlagbits查询。</p><p> Also, the field of video codecs is continuously evolving, enabling ever more efficient video compression and decompression through increasingly advanced and domain-specific video coding tools—resulting in new codecs and codec extensions. Consequently Vulkan Video has been designed with flexible support for a wide variety of existing and future codecs by being divided into universal ‘core’ extensions expected to be relevant to all codecs, and codec specific extensions. Core extensions include video queue functionality that are video codec-independent:</p><p> 此外，视频编解码器领域正在持续发展，通过越来越高级和特定于域的视频编码工具，实现更高效的视频压缩和减压 - 导致新的编解码器和编解码器扩展。因此，除了与所有编解码器相关的通用“核心”扩展，vulkan视频已经设计了对各种现有和未来编解码器的灵活支持，该视频划分为通用的“核心”扩展和编解码器特定扩展。核心扩展包括视频编解码的视频队列功能：</p><p>   This provisional Vulkan Video release also includes three extensions that extend base structures defined by the core video KHR extensions to support H.264-decode, H.264-encode, and H.265-decode:</p><p>   该临时vulkan视频发布还包括三个扩展，其扩展由核心视频KHR扩展定义的基础结构，以支持H.264-Decode，H.264编码和H.265-Decode： </p><p>  These EXT extensions do not define API calls, they simply extend data structures. There is an H.265-encode extension currently in development, and VP9 decode and AV1 decode/encode extensions are expected to follow soon after in a later release.</p><p>这些EXT扩展不会定义API调用，它们只是扩展数据结构。目前正在开发中有一个H.265-edode扩展，并且在稍后的发布后，预计VP9解码和AV1解码/编码扩展将很快跟随。</p><p> As an example, a Vulkan Video implementation that only supports H.264 decoding would only expose support for  VK_KHR_video_queue,  VK_KHR_video_decode_queue, and  VK_EXT_video_decode_h264 extensions, and an application would use all three extensions together to perform H.264 decode operations on that target device.</p><p> 作为示例，只支持H.264解码的vulkan视频实现将仅公开对vk_khr_video_queue，vk_khr_video_decode_queue和vk_ext_video_decode_h264扩展的支持，并且应用程序将所有三个扩展一起使用，以在该目标设备上执行H.264解码操作。</p><p> The standard   vkGetPhysicalDeviceQueueFamilyProperties2 API may be used to determine support for codec extensions, such as H.265 decode, H.264 encode, by chaining   VkVideoQueueFamilyProperties2KHR to retrieve   VkVideoCodecOperationFlagsKHR.</p><p> 标准vKgetPhysicalDeviceQueueFamilyProperties2 API可用于确定对Codec扩展的支持，例如H.265解码，H.264编码，通过链接VkvideoQueueFamilyPropertize2kHR来检索VKVIDEoDecodeCoperationFlagskhr。</p><p>  Video coding experts often analyze video bitstreams to investigate coding artifacts and improve video quality using codec-specific syntax elements in the bitstream using the codec specification that defines behavioral descriptions of syntax and tools. Vulkan Video makes it easy to recognize API fields corresponding to codec syntax elements or codec-defined terms, without bloating the Vulkan specification with descriptions already well documented in the codec standard specifications.</p><p>  视频编码专家经常分析视频比特流，以调查编码伪像，并使用比特流中的编解码器的语法元素使用编解码器规范来改善视频质量，该编解码器规范定义了语法和工具的行为描述。 vulkan视频可以轻松识别与编解码器语法元素或编解码器定义的术语相对应的API字段，而无需在编解码器标准规范中介绍已充分记录的说明具有漂亮的vUlkan规范。</p><p> Codec-specific standard (&#34;Std&#34;) C-headers define structures with explicit and derived codec syntax fields in the naming and style convention of the corresponding codec standard specification. These Std structures are used as fields in Vulkan Video codec EXT extension structures. The provisional Vulkan Video release provides the following codec Std headers:</p><p> 特定于编解码标准（＆＃34; std＆＃34;）C头定义了相应编解码器标准规范的命名和样式约定中的具有显式和派生编解码器语法字段的结构。这些STD结构用作vUlkan视频编解码器EXT扩展结构中的字段。临时vutkan视频发布提供以下编解码器STD标题：</p><p>   Video transcoding is often used to transition video content from an older to a newer codec to benefit from improved compression efficiency. It may also be used to convert content to a codec more appropriate for efficient consumption at the target environment. Figure 3 depicts a basic block diagram for video transcoding.</p><p>   视频代码转换通常用于从较旧的复码到更新的编解码器转换视频内容，从而受益于改进的压缩效率。它还可用于将内容转换为编解码器，更适合于目标环境的有效消耗。图3描绘了用于视频转码的基本框图。</p><p>  The first phase of video transcoding is decoding an input video bitstream (sequence of bytes) to generate the images that make up the video sequence. Decoding individual images in the bitstream often requires referencing one or multiple previously decoded images, which must be retained for this purpose in the  Decoded Picture Buffer (DPB). Note that some implementations may support using the same image resources for output images and DPB images while others may require or prefer decoupling output images from the decode operation from DPB images, for example to use proprietary layouts and store metadata along with DPB images while keeping output images in standard layouts for external consumption. Finally, to arrive at the original video sequence it may be necessary to re-order output images as instructed by the bitstream.</p><p>  视频转码的第一阶段是解码输入视频比特流（字节序列）以生成构成视频序列的图像。在比特流中解码单个图像通常需要引用一个或多个先前解码的图像，这必须在解码的图像缓冲器（DPB）中以此目的被保留。注意，一些实施方式可以支持使用输出图像和DPB图像的相同图像资源，而其他实现可能需要或更喜欢从DPB图像中的解码操作解耦输出图像，例如用于在保持输出的同时使用专有布局并将元数据与DPB图像一起使用和存储元数据用于外部消耗的标准布局中的图像。最后，要到达原始视频序列，可能需要按照比特流指示重新订购输出图像。 </p><p> The second phase of transcoding involves encoding the decoded images with a new codec (or perhaps the same codec with a different set of tools). The encoding process is essentially the reverse of the decoding process: the input is a sequence of images, which may be re-ordered before encoding, and it may be necessary to retain &#34;reconstructed&#34; or decoded versions of the images for reference while encoding the following images. Note that in general, input images are not used for reference in the encoding process to avoid drift when decoding the bitstream at the consumer end since encoding is usually a lossy operation. Transcoding applications pipeline decode and encode operations to reduce the number of decode output / encode input images needed while transcoding.</p><p>代码转换的第二阶段涉及使用新编解码器（或者具有不同组件组的相同编解码器）对解码的图像进行编码。编码过程基本上是解码过程的反向：输入是一系列图像，可以在编码之前重新排序，并且可能需要保留＆＃34;重建＆＃34;或在编码以下图像的同时引用的图像的解码版本。注意，通常，输入图像不用于编码过程中的参考，以避免在解码消费者端的比特流时避免漂移，因为编码通常是有损操作。代码转换应用程序管道解码和编码操作以减少转码时所需的解码输出/编码输入图像的数量。</p><p>   The first step of a transcoding application is to allocate the necessary resources. The basic resources for video decode and encode operations use standard Vulkan objects:</p><p>   代码转换应用程序的第一步是分配必要的资源。视频解码和编码操作的基本资源使用标准vulkan对象：</p><p>  Vulkan Video extends   VkBufferUsage,   VkImageUsage and   VkImageLayout with bits relevant to video decode/encode usage and layouts, that are used by applications to optimally manage video decode and encode resources.</p><p>  Vulkan视频扩展了VKBufferUsage，VkimageUsage和VkimageLayout，与视频解码/编码使用和布局相关的位，应用程序以最佳地管理视频解码和编码资源。</p><p> Video codecs typically define &#34;profiles&#34; that are used to advertise the feature set used by a coded bitstream. Codec-compliant HW decoders often support the full set of profile features so they can process all compliant content. In contrast, hardware vendors may support selected profile features in a hardware encoder, and still generate a compliant bitstream, driven by area and cost considerations while prioritizing key encoding APIs and use cases. The   VkVideoProfileKHR structure defines the target video profile:</p><p> 视频编解码器通常定义＆＃34;配置文件＆＃34;用于宣传编码比特流使用的特征集的广告。编解码符合的HW解码器通常支持全套配置文件功能，以便它们可以处理所有兼容的内容。相比之下，硬件供应商可以支持硬件编码器中的所选配置文件功能，并且仍然生成符合的比特流，由区域驱动和成本考虑，同时优先考虑密钥编码API和用例。 VKVIDEOPOOFILEKHR结构定义目标视频配置文件：</p><p> The YCbCr chroma-subsampling and luma/chroma component bit-depths (e.g. 4:2:0, 8-bit luma/chroma), as video codecs operate on YUV images for coding efficiency</p><p> YCBCR色度分子采样和亮度/色度分量比特深度（例如，4：2：0，8位Luma / Chroma），因为视频编解码器在YUV图像上运行以进行编码效率</p><p> The codec-specific video profile (e.g. H.264 Main profile), via a chained EXT structure specific to the codec-operation in use</p><p> 特定于编解码器的视频配置文件（例如H.264主配置文件），通过Chited EXT结构，特定于使用中的编解码器操作</p><p> Resources intended for video operations may have implementation-specific properties and requirements based on the target video profile, and so applications should specify the target video profile when querying properties, or creating various resources (images, buffers, etc.).</p><p> 用于视频操作的资源可能具有基于目标视频配置文件的特定于实现的属性和需求，因此应用程序应在查询属性时指定目标视频配置文件，或创建各种资源（图像，缓冲区等）。 </p><p> The   VkFormat API call enumerates the supported video images for a given video codec operation and video profile:</p><p>VKFormat API调用枚举给定视频编解码器操作和视频配置文件的支持的视频图像：</p><p>   Once resources are allocated, the transcoding application creates a video session. The   VkVideoSessionKHR video session object provides a context to store persistent state while operating on a particular video stream. Separate instances of  VkVideoSessionKHR may be created to concurrently operate on multiple video streams. The following APIs create, destroy, query memory requirements, and bind memory to video session objects:</p><p>   一旦资源分配，转码应用程序会创建一个视频会话。 VKVIDEOSESSIONKHR视频会话对象提供了一个上下文，可以在特定视频流上运行时存储持久状态。可以创建vkvideosessionkhr的单独实例以在多个视频流上同时运行。以下API创建，销毁，查询内存要求和绑定存储器到视频会话对象：</p><p>  If the application is to support decoding a video bitstream that dynamically changes resolution, to deal with varying network conditions for example, the video session should be created with maximum video stream parameters so that sufficient resources are allocated.</p><p>  如果应用程序是支持解码动态地改变分辨率的视频比特流，以处理变化的网络条件，则应使用最大视频流参数来创建视频会话，从而分配足够的资源。</p><p> An API is provided for the application to query the capabilities of the implementation, including minimum and maximum limits for certain settings:</p><p> 为应用程序提供了一个API来查询实现的功能，包括某些设置的最小值和最大限制：</p><p>   Vulkan Video uses   VkVideoSessionParametersKHR objects, created against a given  VkVideoSessionKHR instance, to store video parameter sets to control stream processing, e.g. to describe settings that apply to one or more pictures within a stream—such as H.264 sequence and picture parameter sets.</p><p>   vulkan视频使用vkvideoSessionParameterskhr对象，针对给定的vkvideosessionkhr实例创建，以将视频参数集存储为控制流处理，例如：描述在流内应用于流中的一个或多个图片的设置 - 例如H.264序列和图片参数集。</p><p> The application may create multiple session parameters objects for a given video session, specifying the maximum number of parameter sets of various kinds that this object is expected to hold. This allows the user to later add more parameter sets to the same object, subject to certain conditions. Alternatively, the user may create another session parameters object with more storage capacity, and inherit existing parameter sets retained from a previously created session parameters object. This avoids re-translation of parameter sets through the Vulkan API and enables re-using their internal representations across objects.</p><p> 应用程序可以为给定视频会话创建多个会话参数对象，指定预期该对象的各种参数集的最大数量。这允许用户稍后将更多参数集添加到同一对象，但在某些条件下。或者，用户可以使用更多存储容量创建另一个会话参数对象，并继承从先前创建的会话参数对象保留的现有参数集。这避免了通过Vulkan API重新翻译参数集，并启用跨对象重新使用其内部表示。</p><p>   Currently, the session parameters object is used to store H.264 SPS and PPS parameter sets, and H.265 VPS, SPS, and PPS parameter sets. For decode operations, the application is expected to parse bitstream segments containing these codec headers to create/update session parameters objects as needed.</p><p>   目前，会话参数对象用于存储H.264 SPS和PPS参数集，以及H.265 VPS，SP和PPS参数集。对于解码操作，预计应用程序将解析包含这些编解码器头部的比特流段，以根据需要创建/更新会话参数对象。 </p><p>  Now the Video session is created, decoding can start by parsing the video bitstream into a sequence of individually decodable bitstream segments, as defined by the video codec. Some of these segments carry codec parameter sets that are applicable to multiple pictures in the sequence, as described earlier. Other bitstream segments carry the coded picture themselves, or coded sub-picture regions (e.g. H.264 slices).</p><p>现在，创建视频会话，通过将视频比特流解析为由视频编解码器所定义的单独解码比特流段的序列来开始解码。如前所述，其中一些段携带适用于多个图片的编解码器参数集。其他比特流段携带编码图像本身或编码的子图像区域（例如H.264切片）。</p><p>  Video decode hardware acceleration is typically needed only for the bitstream segments related to images/pictures or their sub-regions, while segments related to parameter sets are designed for simple CPU-based decoding or parsing. Parameter sets are also designed to efficiently communicate resource requirements for decoding the video bitstream ahead of time, and to determine whether the hardware decoder supports decoding the actual bitstreams or not.</p><p>  视频解码硬件加速通常仅适用于与图像/图片或其子区域相关的比特流段，而与参数集相关的段被设计用于基于CPU的简单解码或解析。参数集还旨在有效地传达用于提前解码视频比特流的资源要求，并确定硬件解码器是否支持解码实际比特流。</p><p> As well as accelerating picture or sub-region decoding, implementations may also utilize various techniques to work around bitstream errors (e.g. caused by corruption during unreliable network transmission). It may also be necessary to store statistics or state related to prior decoding to aid decoding current/future pictures/sub-pictures in the video sequence. Typically, an application will use Vulkan Video for the heavy lifting for picture-level decoding, while handling parsing, resource management and synchronization internally.</p><p> 除了加速图像或子区域解码中，实现还可以利用各种技术来解决比特流误差（例如，由不可靠的网络传输期间腐败引起）。还可能需要存储与先前解码相关的统计数据或状态，以帮助解码视频序列中的当前/未来的图像/子图像。通常，应用程序将使用vulkan视频进行沉重的升降级解码，同时处理解析，资源管理和内部同步。</p><p>  Now, it is finally time to record the video decode operation into a Vulkan command buffer using:</p><p>  现在，最终是时候将视频解码操作记录到vulkan命令缓冲区中：</p><p>  This is the only API call provided in the  VK_KHR_video_decode_queue extension. Command buffers and bitstream data are built for the video device in memory before submission to the GPU.</p><p>  这是vk_khr_video_decode_queue扩展中提供的唯一API调用。在提交给GPU之前，在内存中为视频设备构建命令缓冲区和比特流数据。</p><p> Currently only picture-level decode commands are supported (as specified by the appropriate codec-specific EXT extension structures for decode operations, for example  VkVideoDecodeH264PictureInfoEXT). We are interested to hear of use cases that need to request more fine grained operations!</p><p> 目前仅支持图片级解码命令（由用于解码操作的相应编解码器特定的EXT扩展结构指定，例如vkvideodeCodeh264pictureInfoext）。我们有兴趣听取使用需要要求更精细的颗粒操作的情况！</p><p>  Now we have the decoded images, encoding involves similar detailed tasks to decoding but with considerably more decision points (Figure 5). At the sequence level the application can configure the target bitrate for the generated bitstream. Implementations employ proprietary algorithms to assess picture complexity and budget the bit allocation across pictures and within sub-regions of each picture. Commonly known as &#34;rate control&#34;, this feature also necessitates storing statistics and state that may be utilized while encoding future pictures of the sequence.</p><p>  现在我们有解码的图像，编码涉及类似的详细任务来解码，但是具有更大的决策点（图5）。在序列级别，应用程序可以为生成的比特流配置目标比特率。实现雇用专有算法，以评估图片复杂性和预算跨图像的比特分配以及在每个图片的子区域内。通常称为＆＃34;速率控制＆＃34;，此特征也需要存储统计数据和状态，同时编码序列的未来图片。 </p><p>  As part of the encoding process, decisions must also be made regarding which codec tools to use when encoding each picture or sub-picture region, and which other pictures should be referenced while encoding. Decisions may even be applied at the lowest-level coding units (e.g. 16x16 pixel blocks) for which bitstream syntax may be specified (as defined by the codec). The appropriate parameter sets must be coded in addition to the bitstreams for pictures or sub-picture regions to generate the final elementary video bitstream.</p><p>作为编码过程的一部分，还必须在编码每个图像或子图像区域时使用的编解码器工具以及应该在编码时引用哪些其他图片。甚至可以在最低级编码单元（例如16x16像素块）上应用决定，用于指定比特流语法（如编解码器所定义）。除了用于生成最终基本视频比特流的图像或子图像区域的比特流之外，还必须对相应的参数集进行编码。</p><p> Encoder implementations may vary in the set of codec tools offered, and the level of detailed control exposed to the user. Similarly, user expectations vary significantly for encode; some users prefer black-box encoders that are simply fed images and some high-level settings with all detailed syntax being generated under-the-hood. Some advanced users may desire more control of the low-level encoding process to enable domain-specific optimizations in the application.</p><p> 编码器实现可以在所提供的编解码器工具集中变化，以及暴露给用户的详细控制级别。同样，用户期望对编码有很大差异;有些用户更喜欢黑盒式编码器，这些编码器简单地馈送图像和一些高级设置，具有在引擎盖下生成的所有详细语法。一些高级用户可能需要更多地控制低级编码过程，以在应用程序中启用特定于域的优化。</p><p> Vulkan Video is a result of balancing these requirements, resulting in a low-level API to encourage broad silicon vendor adoption, while relying on tools and layers to hide complexity from applications that prefer a higher-level API. Vulkan Video enables vendor extensions that expose vendor-specific controls which may be standardized if there is cross-vendor support.</p><p> vulkan视频是平衡这些要求的结果，导致低级API来鼓励广泛的Silicon供应商采用，同时依赖于工具和层来隐藏优选更高级别API的应用程序的复杂性。 vulkan视频使供应商扩展揭示了特定于供应商的控件，如果存在交叉供应商支持，则可以标准化。</p><p> Figure 5. also illustrates some of the additional Vulkan Video commands and queries introduced, which are described next.</p><p> 图5.还示出了介绍的一些附加的vUlkan视频命令和查询，其接下来描述。</p><p>  Now we are ready to start the encoding process by recording the video encode operation into a Vulkan command buffer:</p><p>  现在我们准备通过将视频编码操作记录为vulkan命令缓冲区来启动编码过程：</p><p>   Currently only picture-level encode commands are supported (as specified by the appropriate codec-specific EXT extension structures for encode operations, e.g.  VkVideoEncodeH264VclFrameInfoEXT). In the future, the encode command may support encoding of a sub-picture region by itself (e.g. a single slice in a multi-slice frame in H.264).</p><p>   目前仅支持图片级编码命令（由特定于编码的特定于编码的EXT扩展结构指定，用于编码操作，例如，VKVIDEOENCODEH264VCLFRAMEINFoext）。将来，编码命令可以自身支持子图像区域的编码（例如，在H.264中的多切片帧中的单个切片）。</p><p> All picture and reference management decisions are left to the application, which also has direct control over bitstream syntax related to reference management. In addition, the application may optionally request generation of H.264 SPS/PPS bitstream segments by the implementation (see  VkVideoEncodeH264EmitPictureParametersEXT). This provides a path for implementations to generate a complete elementary bitstream if needed.</p><p> 所有图片和参考管理决策都留给了应用程序，该应用程序还直接控制与参考管理相关的比特流语法。此外，应用程序可以选择通过实现来请求生成H.264 SPS / PPS比特流段（参见VKVIDEOENCODEH264EMITPICTUREPARAMENTEREXT）。这提供了一种用于实现如果需要生成完整的基本比特流的路径。 </p><p> Encoder rate control settings are recorded using the following API into a Vulkan command buffer:</p><p>使用以下API记录编码器速率控制设置，以vulkan命令缓冲区：</p><p>  Note that these settings take effect in the execution timeline (i.e. at queue submission). This API also allows resetting the video session to the initial state, for example if the video session will be used to process a new video stream. This generic API hook enables future extensions for other stream-level control operations.</p><p>  请注意，这些设置在执行时间轴中生效（即队列提交）。该API还允许将视频会话重置为初始状态，例如，如果视频会话将用于处理新视频流。此通用API挂钩可实现其他流级控制操作的未来扩展。</p><p>  As a number of decode or encode operations may be recorded in the same command buffer, all relying on the same set of resources and settings, Vulkan Video defines a pair of API calls to mark the scope of video command control parameters during a session:</p><p>  作为许多解码或编码操作可以在相同的命令缓冲区中记录，所有依赖于相同的资源和设置，vulkan视频定义了一对API调用以在会话期间标记视频命令控制参数的范围：</p><p>  vkCmdBeginVideoCodingKHR sets up the command buffer context for video operations on a single video stream. The  VkVideoSessionKHR object is provided at this point, along with the  VkVideoSessionParametersKHR object containing parameter sets for use in all subsequent video decode or encode operations until the end of scope. One or more  vkCmd*Video*KHR are expected after this, specifying the actual decode/encode operation(s) and/or video control operation(s). Standard Vulkan commands for synchronization, layout transition etc. may also be present along with the video commands.  vkCmdEndVideoCodingKHR ends the scope of video operations.</p><p>  vkcmdbeginvideocodingkhr为单个视频流设置用于视频操作的命令缓冲区上下文。此时提供了VKVIDEOSESSIONKHR对象，以及VKVIDEOSESSIONPERAMETERSKHR对象包含参数集，用于所有后续视频解码或编码操作，直到范围结束。在此之后，预期一个或多个VKCMD *视频* KHR，指定实际解码/编码操作和/或视频控制操作。用于同步的标准vUlkan命令，布局转换等也可以与视频命令一起存在。 VKCMDENDVIDEOCODINGKHR结束了视频操作的范围。</p><p> Multiple sets of video commands delimited by the  vkCmdBeginVideoCodingKHR and  vkCmdEndVideoCodingKHRcommands may be recorded into the same command buffer, using either the same or different video session and video session parameters objects for each set. It is also possible to use a video session parameters object with the corresponding video session object in multiple command buffer recording calls—recording into multiple command buffers in parallel.</p><p> 可以使用每个集合的相同或不同的视频会话和视频会话参数对象将vkcmdbeginvideocodkhr和vkcmdendvideocodingkhrcommands界定的多组视频命令录制到相同的命令缓冲区中。还可以在多个命令缓冲区中使用具有相应的视频会话对象的视频会话参数对象并行地记录到多个命令缓冲器中。</p><p>  Vulkan Video adds a new mandatory   VkQueryType to report the location and size of the encoded bitstream in the output buffer (see   VK_QUERY_TYPE_VIDEO_ENCODE_BITSTREAM_BUFFER_RANGE_KHR).</p><p>  vulkan视频添加了一个新的强制vkquerytype，以报告输出缓冲区中的编码比特流的位置和大小（请参阅vk_query_type_video_encode_bitstream_buffer_range_khr）。</p><p> In addition, an optional result status query type is added to determine the completion status of a set of operations enclosed between the  vkCmdBeginQuery and  vkCmdEndQuery commands. This result status may be reported by itself using the   VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR query type, or in conjunction with another query type using   VK_QUERY_RESULT_WITH_STATUS_BIT_KHR. The result status is not specific to video operations, and may be used to report errors during execution of any Vulkan commands that require additional investigation. For video operations, implementations may report error status when decoding syntax errors are encountered, or when the encode-bitstream buffer overflows.</p><p> 此外，添加可选的结果状态查询类型以确定括在vkcmdbeginquery和vkcmdendquery命令之间括起一组操作的完成状态。此结果状态本身可以使用vk_query_type_result_status_only_khr查询类型，或与使用vk_query_result_with_status_bit_khr的另一个查询类型一起报告。结果状态不是特定于视频操作，并且可以用于在执行需要额外调查的任何vulkan命令期间报告错误。对于视频操作，实现可以在遇到解码语法错误时报告错误状态，或者当编码比特流缓冲区溢出时。 </p><p> As video queries are generally consumed by the host, video queues only support host translation of query results (  vkGetQueryPoolResults), and do  not support device translation (  vkCmdCopyQueryPoolResults). Please let us know If device translation is important for your use case!</p><p>随着视频查询通常由主机消耗，视频队列仅支持查询结果（vkgetQueryPoolResults）的主机转换，并且不支持设备转换（vkcmdcopyquerypoolresults）。请告诉我们设备翻译是否对您的用例很重要！</p><p> And this concludes the transcoding example walkthrough! We hope this has given you a taste of how Vulkan Video could enable new capabilities in your own products by integrating low-level video acceleration in sophisticated Vulkan pipelines combining video, graphics, compute and display operations.</p><p> 这总结了代码转换示例演练！我们希望这使您可以享受vulkan视频如何通过在复杂的vulkan管道中集成视频，图形，计算和显示操作中的高级视频加速来实现您自己的产品中的新功能。</p><p>  The release of the Provisional Vulkan Video extensions marks the first public exposure of this significant new Vulkan functionality and is an important milestone to enable industry review and feedback. Please share your thoughts through the  Khronos Vulkan Video GitHub Issue.</p><p>  临时vutkan视频扩展的发布标志着这一重要的新vutkan功能的第一次公开曝光，是能够实现行业审查和反馈的重要里程碑。请通过Khronos Vulkan视频Github问题分享您的想法。</p><p> As with any provisional release, the Vulkan Video extensions may be updated in response to developer feedback. We therefore request that driver vendors not ship production drivers supporting these provisional extensions, and that ISVs not use these provisional extensions in their production applications. To use these provisional extensions, applications must explicitly enable beta extensions as follows:</p><p> 与任何临时版本一样，可以响应于开发人员反馈而更新vulkan视频扩展。因此，我们要求司机供应商不发货支持这些临时扩展的生产驱动程序，并且ISV不会在其生产应用中使用这些临时扩展。要使用这些临时扩展，应用程序必须明确使能Beta扩展如下：</p><p>    NVIDIA has released  beta Vulkan drivers that implement Vulkan Video, and a sample Vulkan Video decoding application  vk_video_decoder to enable developers to prototype and experiment against the current provisional extensions.</p><p>    NVIDIA已发布实现vulkan视频的Beta Vulkan驱动程序，以及一个样本vulkan视频解码应用程序vk_video_decoder，使开发人员能够对当前临时扩展进行原型和实验。</p><p> Vulkan SDK validation layer support will be added for the finalized Vulkan Video 1.0 extensions. For this provisional release, validation layers will only be verified to work with Vulkan Video extensions disabled.</p><p> 将为最终vUlkan视频1.0扩展添加vulkan SDK验证层支持。对于此临时版本，验证层只会验证禁用vulkan视频扩展。</p><p> Khronos will now work to finalize the Vulkan Video 1.0 specifications, SDK and conformance tests, so focus can then shift towards supporting additional codecs and more advanced video features!</p><p> Khronos现在将努力完成vulkan视频1.0规格，SDK和一致性测试，因此焦点可以转向支持额外的编解码器和更高级的视频功能！ </p><p> We look forward to your feedback on Vulkan Video. Thank you for your interest and support to make Vulkan Video effective for your use cases and applications!</p><p>我们期待您对Vulkan视频的反馈。 感谢您的兴趣和支持对您的用例和应用程序有效的vulkan视频！ </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.khronos.org/blog/an-introduction-to-vulkan-video">https://www.khronos.org/blog/an-introduction-to-vulkan-video</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/video/">#video</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>