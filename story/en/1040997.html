<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在Z3Py中为TLA +建模（2020） Modeling TLA+ in Z3Py (2020)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Modeling TLA+ in Z3Py (2020)<br/>在Z3Py中为TLA +建模（2020） </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-21 15:34:07</div><div class="page_narrow text-break page_content"><p>It’s that time of year again where I’m fiddling around with Z3Py. I’m booting it back up because I’m scheduled to do a  tutorial on Z3 on Feb 3. It’s kind of silly because I probably already have too much content, and the tutorial is aimed at newbies, but there are some fun new things that I’ve learned in the last year I can do in Z3. As one example, it’s not so hard to build a pretty reasonable simulacrum of TLA+ in Z3.</p><p>在每年的这个时候，我又开始摆弄Z3Py。我正在启动它，因为我计划于2月3日在Z3上进行教程。这很愚蠢，因为我可能已经有太多的内容，并且该教程针对的是新手，但其中还包含一些有趣的新事物我在去年学到的知识可以在Z3中完成。举一个例子，在Z3中构建一个相当合理的TLA +模拟并不难。</p><p> TLA+ is a modelling/specification language for computational processes. It is particularly useful for modeling concurrency, where our intuitions fail us  http://deadlockempire.github.io/. It’s the mind child of Leslie Lamport, the same guy behind  LaTex and  Paxos. The language doesn’t aim for deep verification of your actual code as is sometimes the goal with tools like Coq, but because of that it is significantly more lightweight and easy to use. The  TLA+ Toolbox is a freely available IDE and checker to TLA+, but I think it is kind of a neat idea to replicate something in the flavor of TLA+ in all too familiar python. By leveraging Z3, we can get a lot of logical mileage and solver power for free.</p><p> TLA +是用于计算过程的建模/规范语言。它对于并发建模特别有用，因为我们的直觉使我们无法通过http://deadlockempire.github.io/进行并发建模。是莱斯利·兰帕特（Lasex and Paxos）背后的同胞莱斯利·兰帕特（Leslie Lamport）的智囊。这种语言的目的不是要对您的实际代码进行深度验证，而这有时并不是Coq之类的工具所追求的目标，而是因为这种语言更加轻巧且易于使用。 TLA +工具箱是TLA +的免费IDE和检查器，但我认为在所有太熟悉的python中复制TLA +风格的东西是一种好主意。利用Z3，我们可以免费获得大量逻辑里程和求解器功能。</p><p> Z3 is an SMT solver. Its input language  smtlib2 is a kind of typed first order logic with special support for things like booleans, integers, reals, bitvectors, and algebraic datatypes. You can ask Z3 if propositions are valid, or if not it can provide a counterexample. It works pretty crazy good, especially if you work around its weaknesses (mostly quantifiers and nasty nonlinear stuff). Z3 has top class performance and its  python bindings are widely regarded as very good.</p><p> Z3是SMT求解器。它的输入语言smtlib2是一种类型化的一阶逻辑，对布尔，整数，实数，位向量和代数数据类型等内容提供特殊支持。您可以询问Z3命题是否有效，或者是否可以提供反例。它的工作原理非常好，尤其是当您克服其缺点（主要是量词和讨厌的非线性内容）时。 Z3具有一流的性能，其python绑定被广泛认为是非常好的。</p><p> The main unusual things TLA brings into play compared to bog standard logics is the primed variables \(x&#39;\), representing the values of variables at the next time step, and some temporal operators like always \(\Box\) and eventually \(\Diamond\).</p><p> 与沼泽标准逻辑相比，TLA发挥的主要非同寻常的作用是素数变量\（x＆＃39; \），表示下一个时间步长的变量值，以及一些时间运算符，例如始终\（\ Box \）和最终\（\ Diamond \）。</p><p>   But I’ve chosen to mark the prime variables using a special uninterpreted function, which we strip out later.</p><p>   但是，我选择使用特殊的未解释函数标记质数变量，我们稍后将对其进行介绍。</p><p> def  nxt ( x ):  # next is a special function for generators in python, so we shouldn&#39;t use that name  assert  is_const ( x )  assert  f . decl (). kind ()  ==  Z3_OP_UNINTERPRETED :  s  =  x . sort ()  return  Function ( &#34;nxt&#34; ,  s ,  s )( x )</p><p> def nxt（x）：＃next是python中生成器的特殊功能，因此我们不应该使用该名称assert is_const（x）assert f。 decl（）。 kind（）== Z3_OP_UNINTERPRETED：s = x。 sort（）返回函数（＆＃34; nxt＆＃34;，s，s）（x）</p><p> One breakage here as compared to with TLA+ is the use of types. TLA+ curiously insists on a lack of intrinsic types and argues against them as a foundational feature. Types are instead propositions that are proved in the system. This just is really not convenient for using with Z3, so from the get-go I’m going to take liberties.</p><p> 与TLA +相比，这里的一个破绽是类型的使用。 TLA +奇怪地坚持缺乏内在类型，并反对将其作为基本特征。类型是在系统中证明的命题。这样做真的不方便与Z3一起使用，因此一开始我要自由自在。 </p><p> We can implement an  always operator via a fairly simple procedure, we just roll out the execution of any formula for  n time steps. This is the trick of bounded model checking. This rollout can be achieved by using the Z3  substitute function, a surprisingly useful little fellow.</p><p>我们可以通过一个相当简单的过程来实现always操作符，我们只需在n个时间步上展开任何公式的执行即可。这是有界模型检查的技巧。可以通过使用Z3替代功能（一个非常有用的小家伙）来实现此部署。</p><p> # collects up all the variable from a formula# https://stackoverflow.com/questions/14080398/z3py-how-to-get-the-list-of-variables-from-a-formula def  get_vars ( f ):  r  =  set ()  def  collect ( f ):  if  is_const ( f ):  if  f . decl (). kind ()  ==  Z3_OP_UNINTERPRETED :  r . add ( f )  else :  for  c  in  f . children ():  collect ( c )  collect ( f )  return  r #https://theory.stanford.edu/~nikolaj/programmingz3.html#sec-bounded-model-checking# rolls out the transition relation for n steps# it replaces x with x_i and prime(x) with x_(i+1) def  always ( p , n = 20 ):  orig_vs  =  get_vars ( p )  nextvs  =  orig_vs  t  =  True  for  i  in  range ( 1 , n ):  vs  =  nextvs  nextvs  =  [  Const (  f&#34; { str ( v ) } _ { i } &#34; ,  v . sort ())  for  v  in  orig_vs  ]  p1  =  substitute ( p ,  [  ( nxt ( v ),  nextv )  for  v ,  nextv  in  zip ( orig_vs , nextvs )  ])  p2  =  substitute ( p1 ,  [  ( orig_v ,  v )  for  orig_v ,  v  in  zip ( orig_vs , vs )  ])  t  =  And ( t , p2 )  return  t</p><p> ＃从公式中收集所有变量＃https://stackoverflow.com/questions/14080398/z3py-how-to-get-the-list-of-variables-from-a-form def get_vars（f）：r = set（）def collect（f）：如果is_const（f）：如果f。 decl（）。 kind（）== Z3_OP_UNINTERPRETED：r。加（f）else：对于f中的c。孩子（）：收集（c）收集（f）返回r #https：//theory.stanford.edu/~nikolaj/programmingz3.html#sec-bounded-model-checking#推出n个步骤的过渡关系＃它始终将x替换为x_i，并且将prime（x）替换为x_（i + 1）def（p，n = 20）：orig_vs = get_vars（p）nextvs = orig_vs t =对于范围（1，n）中的i为真：vs = nextvs nextvs = [const（f＆＃34; {str（v）} _ {i}＆＃34;，v。or（sort（））for orig_vs中的v] p1 =替换（p，[（（nxt（v）），nextv ）for v，zip中的nextv（orig_vs，nextvs）]）p2 =替代（p1，[（orig_v，v）替代orig_v，zip中的v（orig_vs，vs）]）t =和（t，p2）返回t</p><p> Here for example is the specification of a clock from the  Specifying Systems book. The clock starts with an hour between 0 and 12, and at each time step increases unless it’s wrapped around 12.</p><p> 例如，这里是“指定系统”书中的时钟规范。时钟从0到12之间的一个小时开始，并且在每个时间步长都增加，除非环绕12。</p><p> hr  =  Int ( &#34;hr&#34; ) HCini  =  And ( 1  &lt;=  hr ,  hr  &lt;=  12 ) HCnxt  =  nxt ( hr )  ==  If ( hr  !=  12 ,  hr  +  1 ,  1 ) HC  =  And ( HCini ,  always ( HCnxt ))  prove ( Implies ( HC ,  always ( HCini )))  # prove clock always stays between 0 and 12 (for 20 times steps)</p><p> hr =整数（＆＃34; hr＆＃34;）HCini =和（1 <== hr，hr <= 12）HCnxt = nxt（hr）==如果（hr！= 12，hr +1,1） HC =并且（HCini，始终（HCnxt））证明（隐含（HC，始终（HCini）））＃证明时钟始终保持在0到12之间（20步）</p><p> You do have to be careful with using always. Arbitrarily nesting it’s usage may give unexpected results. Lamport makes an argument that specs very rarely do or should make sophisticated use of the temporal operators. Maybe this is good enough or maybe there is a way to patch this up.</p><p> 您一定要谨慎使用Always。任意嵌套它的用法可能会产生意想不到的结果。 Lamport提出这样一个论点，即规范很少执行或应该充分利用时间运算符。也许这已经足够好了，或者也许有一种方法可以对此进行修补。</p><p>  def  elem ( x , S ):  return  Or ([ x  ==  s  for  s  in  S ]) def  unchanged ( * args ):  return  And ([ prime ( x )  ==  x  for  x  in  args ]) def  eventually ( p ,  n = 20 ):  return  Not ( always ( Not ( p ), n = n )) def  stutter ( p ,  vars = None ):  if  vars  ==  None :  vars  =  get_vars ( p )  return  Or ( p ,  unchanged ( * vars )) def  enabled ( A ):  vs  =  get_vars ( A )  nxtvs  =  [  FreshConst (  v . sort (),  prefix = str ( v )  )  for  v  in  vs ]  p1  =  substitute ( A ,  [  ( nxt ( v ),  nextv )  for  v ,  nextv  in  zip ( vs , nxtvs )  ])  return  Exists ( nxtvs ,  p1 ) # backports useful logical operator notation for z3 that it does not have by default BoolRef . __and__  =  lambda  self ,  rhs :  And ( self , rhs ) BoolRef . __or__  =  lambda  self ,  rhs :  Or ( self , rhs ) BoolRef . __xor__  =  lambda  self ,  rhs :  Xor ( self , rhs ) BoolRef . __invert__  =  lambda  self :  Not ( self ) BoolRef . __rshift__  =  lambda  self ,  rhs :  Implies ( self , rhs )</p><p>  def elem（x，S）：返回或（[x == s表示S中的s]）def不变（* args）：返回And（[素数（x）== x表示args中的x]）def最终（p ，n = 20）：返回Not（始终（不是（p（p），n = n））def断断续续（p，vars = None）：if vars == None：vars = get_vars（p）返回Or（p，不变（ * vars））def启用（A）：vs = get_vars（A）nxtvs = [vs中的v的FreshConst（v。sort（），前缀= str（v））] p1 =替代（A，[（nxt（v ），v的nextv，zip中的nextv（vs，nxtvs）]）return Exists（nxtvs，p1）＃向后移植z3的有用逻辑运算符，默认情况下没有BoolRef。 __and__ = lambda self，rhs：和（self，rhs）BoolRef。 __or__ = lambda self，rhs：或（self，rhs）BoolRef。 __xor__ = lambda self，rhs：Xor（self，rhs）BoolRef。 __invert__ = lambda self：不是（self）BoolRef。 __rshift__ = lambda self，rhs：隐含（self，rhs）</p><p>  small ,  big  =  Ints ( &#34;small big&#34; ) TypeOk  =  And (  elem ( small ,  range ( 4 )),  elem ( big ,  range ( 6 )) ) Init  =  And (  big  ==  0 ,  small  ==  0 ) FillSmall  =  And ( prime ( small )  ==  3 ,  unchanged ( big )) FillBig  =  And ( prime ( big )  ==  5 ,  unchanged ( small )) Goal  =  big  !=  4 SmallToBig  =  If ( big  +  small  &lt;=  5 ,  And (  nxt ( big )  ==  big  +  small ,  nxt ( small )  ==  0  )  ,  And ( nxt ( small )  ==  small  -  ( 5  -  big ),  nxt ( big )  ==  5 )  ) BigToSmall  =  If (  big  +  small  &lt;=  3 ,  And (  nxt ( small )  ==  big  +  small ,  nxt ( big )  ==  0 ),  And (  nxt ( small )  ==  3 ,  nxt ( big )  ==  big  -  ( 3  -  small )  )  ) EmptyBig  =  And ( nxt ( big )  ==  0 ,  unchanged ( small ))  EmptySmall  =  And ( nxt ( small )  ==  0 ,  unchanged ( big ))  Next  =  Or ( FillSmall ,  FillBig ,  EmptySmall ,  EmptyBig ,  SmallToBig ,  BigToSmall ) Spec  =  Init  &amp;  always ( Next ,  n = 8 ) prove (  Implies ( Spec  ,  always ( Goal ,  n  =  8 )))</p><p>  small，big = Ints（＆＃34; small big＆＃34;）TypeOk = And（elem（small，range（4）），elem（big，range（6）））Init = And（big（= 0，small） == 0）FillSmall =和（素数（小）== 3，不变（大））FillBig =和（素数（大）== 5，不变（小））目标=大！= 4 SmallToBig = If（大+小＆lt; = 5，和（nxt（大）==大+小，nxt（小）== 0），和（nxt（小）==小-（5-大），nxt（大）== 5 ））BigToSmall =如果（大+小＆lt; = 3，并且（nxt（小）==大+小，nxt（大）== 0），And（nxt（小）== 3，nxt（大）= = big-（3-small）））EmptyBig = And（nxt（big）== 0，不变（small））EmptySmall = And（nxt（small）== 0，不变（big））Next =或（FillSmall， FillBig，EmptySmall，EmptyBig，SmallToBig，BigToSmall）Spec = Init＆amp;总是（下一个，n = 8）证明（隐含（规格，总是（目标，n = 8））） </p><p> Z3 does in fact return a counter model that fills the buckets up as desired.</p><p>实际上，Z3确实会返回一个计数器模型，该模型可以按需填充水桶。</p><p> TLA+ has a tendency to use functions/records which are not so obvious how to encode. There are different ways of going about this. One aspect of playing around with Z3py is that it makes extremely clear the existence of the logic language and a metalanguage. The logic is Z3 expressions, but the metalanguage is python and they are obviously very different. But there is often a choice of whether to encode things in the logic vs the metalanguage. It is usually better I think to encode as much in python as possible if you can get away with it. Z3 likes piles of simple constraints more than it likes complicated quantifiers and things.</p><p> TLA +倾向于使用不太明显的编码功能/记录。有不同的解决方法。使用Z3py的一个方面是，它使逻辑语言和元语言的存在变得非常清晰。逻辑是Z3表达式，但是metaanguage是python，它们显然有很大不同。但是，通常可以选择是否在逻辑与元语言之间对事物进行编码。通常我认为最好是在python中尽可能多地编码，如果您可以避免的话。 Z3喜欢一堆简单的约束，而不喜欢复杂的量词和事物。</p><p> For example, we can want to encode an Enum type in python or in Z3.</p><p> 例如，我们可能想在python或Z3中编码一个Enum类型。</p><p> from  enum  import  Enum ,  auto #python enum class  RMState ( Enum ):  WORKING  =  auto ()  PREPARED  =  auto ()  COMMITTED  =  auto ()  ABORTED  =  auto () # z3 enum RMState  =  Datatype ( &#34;RMState&#34; ) RMState . declare ( &#34;working&#34; ) RMState . declare ( &#34;prepared&#34; ) RMState . declare ( &#34;committed&#34; ) RMState . declare ( &#34;aborted&#34; ) RMState  =  RMState . create ()</p><p> 从枚举import Enum，auto #python枚举类RMState（Enum）：WORKING = auto（）PREPARED = auto（）COMMITTED = auto（）ABORTED = auto（）＃z3枚举RMState =数据类型（＆＃34; RMState＆＃34; ）RMState。声明（＆＃34; working＆＃34;）RMState。声明（＆＃34; prepared＆＃34;）RMState。声明（＆＃34; committed＆＃34;）RMState。声明（＆＃34; aborted＆＃34;）RMState = RMState。创造 （）</p><p>  #python record of z3 values val  =  Int ( &#34;val&#34; ) rdy ,  ack  =  Bools ( &#34;rdy ack&#34; ) chan  =  { val  :  val ,  rdy  :  rdy ,  ack  :  ack } # Z3 record of Z3 values Chan  =  Datatype ( &#34;Chan&#34; ) ChanCon  =  Chan . declare ( &#34;constr&#34; ,  ( &#34;val&#34; ,  IntSort ())  ,  ( &#34;rdy&#34; ,  BoolSort ()),  ( &#34;ack&#34; ,  BoolSort ())  ) Chan  =  Chan . create () record  =  Chan . constr ( val , rdy , ack ) chan  =  Const ( &#34;chan&#34; ,  Chan )</p><p>  ＃3的z3值的python记录val = Int（＆＃34; val＆＃34;）rdy，ack =布尔（（#rdy ack＆＃34;））chan = {val：val，rdy：rdy，ack：ack} Z3值的＃Z3记录Chan =数据类型（＆＃34; Chan＆＃34;）ChanCon = Chan。声明（＆＃34; constr＆＃34;，（＆＃34; val＆＃34;，IntSort（）），（＆＃34; rdy＆＃34;，BoolSort（）），（＆＃34; ack＆＃34; ，BoolSort（）））Chan = Chan。 create（）record = Chan。 constr（val，rdy，ack）chan = const（＆＃34; chan＆＃34;，Chan）</p><p>  # python square. Works of Z3 values too def  square ( x ):  return  x * x # Internalized Z3 square function square  =  Function ( &#34;square&#34; ,  IntSort (), IntSort ()) x  =  Int ( &#34;x&#34; ) square_axiom  =  ForAll ([ x ],  square ( x )  ==  x  *  x )</p><p>  ＃蟒蛇广场。 Z3值的工作也太平方（x）：return x * x＃内部化的Z3平方函数square = Function（＆＃34; square＆＃34;，IntSort（），IntSort（））x = Int（＆＃34; x＆ ＃34;）square_axiom = ForAll（[x]，square（x）== x * x）</p><p>   Very ad hoc. The use of special autogenerated names is a great way to inadvertently smash things together</p><p>   非常特别。使用特殊的自动生成名称是一种无意间将事物粉碎在一起的好方法 </p><p>      TLA has a lot of thought gone into it. Making changes to it in an afternoon of thought is probably not to be trusted</p><p>TLA有很多想法。在一个下午的思考中进行更改可能不值得信赖</p><p>  python is lingua franca of computing. It is comforting compared to TLA+, even if Z3py might be discomfiting.</p><p>  python是通用语言。与TLA +相比，它令人感到安慰，即使Z3py可能会出现不适。</p><p>  Having to download the toolbox and figure out how to use it is always going to be a slight speedbump. There is a TLA+ vscode extension now though. That might help</p><p>  必须下载工具箱并弄清楚如何使用它总是会有一点点麻烦。现在有TLA + vscode扩展。那可能有帮助</p><p> Using Python ast parsing  https://greentreesnakes.readthedocs.io/en/latest/index.html, we could probably use regular simple python syntax as a PlusCal like DSL and compile it into the above Z3-TLA+ hybrid.</p><p> 使用Python ast解析https://greentreesnakes.readthedocs.io/en/latest/index.html，我们可以使用常规的简单python语法作为PlusCal（如DSL），并将其编译为上述Z3-TLA +混合体。</p><p> I’m not sure if the CHOOSE operator of TLA+ will be easy to implement. It kind of seems like it requires nested solves? Can it be encoded using</p><p> 我不确定TLA +的CHOOSE运算符是否易于实现。似乎需要嵌套求解？可以使用编码吗</p><p> I don’t particularly understand the TLA+ module system yet and I’m not so sure how to emulate it. Python modules might be one way, or perhaps classes.</p><p> 我还不太了解TLA +模块系统，也不确定如何模拟它。 Python模块可能是一种方式，也可能是类。</p><p> Although I tried to copy exactly, perhaps one shouldn’t spec in precisely the style of standard TLA+.</p><p> 尽管我尝试精确复制，但也许不应该严格按照标准TLA +的样式进行规范。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.philipzucker.com/Modelling_TLA_in_z3py/">https://www.philipzucker.com/Modelling_TLA_in_z3py/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/2020/">#2020</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tla/">#tla</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/z3/">#z3</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>