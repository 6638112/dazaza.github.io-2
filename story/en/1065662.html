<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>代码观察：Clojure的破坏性 Code Observation: Clojure's Destructuring</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Code Observation: Clojure's Destructuring<br/>代码观察：Clojure的破坏性 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-14 21:36:22</div><div class="page_narrow text-break page_content"><p>Clojure&#39;s destructuring helps us establish bindings to items in Clojure collections in a concise, intuitive way if we already understand how to use  Clojure&#39;s data structures and core functions that work with them.</p><p>如果我们已经了解如何使用与它们一起使用的数据结构和核心函数，有助于我们在简洁，直观的方式中帮助我们为Clojure Collection中的物品中的物品建立绑定。</p><p> Here,  concise means that destructuring employs fewer expressions than would be required using only Clojure&#39;s core functions for retrieving parts of data structures.</p><p> 在这里，简明扼要意味着破坏性的表达式比仅使用Clojure＆＃39; S核心功能来检索数据结构的部分的核心函数。</p><p> Here,  intuitive means that Clojure&#39;s implementation and our own intuition are aligned. If they are not now, they should be by the experiment&#39;s end.</p><p> 在这里，直观意味着clojure＆＃39; s的实施和我们自己的直觉是对齐的。如果他们现在不是，他们应该是通过实验＆＃39; s结束。</p><p>  System: Linux 5.11.0-18-generic #19-Ubuntu SMP Fri May 7 14:22:03 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux</p><p>  系统：Linux 5.11.0-18-generic＃19-ubuntu smp fri 5月7日14:22:03 UTC 2021 x86_64 x86_64 x86_64 gnu / linux</p><p> The forms below have been evaluated at Clojure&#39;s REPL. Lines printed to STDOUT are prefixed with  ; (out).</p><p> 下面的表格已在Clojure＆＃39; s repl中进行了评估。打印到STDOUT的线是前缀的; （出去）。</p><p> Evaluation results are collapsed by default. You&#39;re encouraged to run the examples at your own REPL or mentally determine the outcomes before peeking.</p><p> 默认情况下，评估结果崩溃。你和他们鼓励在你自己的求职中运行这些例子，或者在精神上决定偷看之前的结果。</p><p>  We will explore how the  syntax of Clojure&#39;s destructuring allows us to replace invocations of core Clojure functions. First, we will consider the depth of destructuring support specific to sequential and associative data structures. As we progress, we&#39;ll note what is common between those categories, as well as what other Clojure features have related syntax. Finally, we&#39;ll review the breadth of binding contexts in which destructuring is supported.</p><p>  我们将探讨Clojure的语法和＃39; S破坏性的语法允许我们替换核心Clojure函数的调用。首先，我们将考虑特定于顺序和关联数据结构的特定破坏性支持的深度。当我们的进步时，我们＆＃39; ll说明这些类别之间的常见，以及其他clojure特征具有相关的语法。最后，我们＆＃39; ll回顾了支持破坏性的绑定背景的宽度。 </p><p>  Sequential data structures maintain an ordering of their items. Destructuring them, therefore, allows us to retrieve items in a specified order.</p><p>顺序数据结构维持其项目的排序。因此，破坏它们允许我们以指定的顺序检索项目。</p><p>  (def coll (map (comp char (partial + 65)) (range 26)));;=&gt; #&#39;user/collcoll;;=&gt; (\A \B \C \D \E \F \G \H \I \J \K \L \M \N \O \P \Q \R \S \T \U \V \W \X \Y \Z);; By using a seq, rather than a concrete list or vector,;; we demonstrate which functions do or do not require;; a particular concrete collection.(type coll);;=&gt; clojure.lang.LazySeq</p><p>  （DEF COLL（MAP（COMP CHAR（Partial + 65））（范围26）））; =＆gt; ＃＆＃39;用户/ collcoll ;; =＆gt; （\ a \ b \ c \ d \ e \ f \ g \ h \ i \ j \ k \ l \ m \ n \ o \ p \ q \ r \ s \ t \ u \ v \ w \ x \ y \ z）;;通过使用SEQ，而不是具体列表或向量，;;我们证明了哪些功能或不需要;特定的具体收集。（COLL）;; =＆gt; clojure.lang.lazyseq.</p><p>  The following functions and macros in Clojure&#39;s core API allow you to pull sequential data structures apart:</p><p>  以下函数和宏在Clojure＆＃39; s核心API中允许您将顺序数据结构分开：</p><p> A Clojure set, when invoked, returns the value supplied if it&#39;s contained in the set, else  nil</p><p> 调用时，Clojure集返回所提供的值＆＃39; s中包含的值，否则否则</p><p> Sequential destructuring gives us a way to pull values out of a sequence without having to use these directly, though destructuring does not support all of the behaviors of all of these functions.</p><p> 顺序破坏使我们提供了一种方法来将值拉出序列，而无需直接使用这些方法，但破坏性不支持所有这些功能的所有行为。</p><p>  ;; Basic operations:(first coll) ; \A(second coll) ; \B(last coll) ; \Z(rand-nth coll) ; \K;; In absence of cadadadr and friends,;; a few built-in compositions of the above:(ffirst [coll coll]) ; \A(ffirst [(reverse coll) coll]) ; \Z(fnext coll) ; \B;; Efficient retrieval based on;; concrete persistent data structures:(try (peek coll) (catch Exception e (.getMessage e)));;=&gt; &#34;class clojure.lang.LazySeq cannot be cast to class clojure.lang.IPersistentStack...&#34;(peek (apply list coll)) ; \A(peek (into () coll)) ; \Z(peek (vec coll)) ; \Z(nth (vec coll) 2) ; \C(nth (apply list coll) 2) ; \C(nth (into () coll) 2) ; \X;; Sets as functions of their members:(#{\A} \A) ; \A(#{\A} \B) ; nil(some #{\A} coll) ; \A;; Utility macro for conditional binding of `(first coll)`:(when-first [letter coll] letter);;=&gt; \A(when-first [letter [false]] letter);;=&gt; false(when-first [letter ()] letter);;=&gt; nil</p><p>  ;;基本操作:(第一Coll）; \ a（第二coll）; \ b（最后加尔）; \ z（兰德 - 第n Coll）; \ k ;;在没有康多拉德和朋友的情况下，;;少数内置的上述组合物:( ffirst [Coll Coll]）; \ a（ffirst [（反向Coll）Coll]）; \ z（fnext coll）; \ b ;;基于;;具体持久性数据结构:(尝试（偷看Coll）（捕获异常e（.getmessage e）））; =＆gt; ＆＃34; claslajure.lang.lazyseq不能投下课程clojure.lang.ipersistentstack ...＆＃34;（偷看（申请Coll））; \ a（peek（进入（）coll））; \ z（PEEK（VEC COLL））; \ z（第n（Vec Coll）2）; \ c（第n（申请Coll）2）; \ c（nth（进入（）coll）2）; \X;;设置为其成员的函数：（＃{\ A} \ a）; \ a（＃{\ a} \ b）; nil（一些＃{\ a} coll）; \一种;;用于条件绑定的实用程序宏（First Coll）`:(当第一[字母Coll]字母）;; =＆gt; \ a（第一个[字母[false]字母）;; =＆gt; false（第一个[字母（）]字母）;; =＆gt;零</p><p> If we consider that literal vectors are used by  defn and  let for ordered bindings, it should not surprise us that the syntax for destructuring sequential data structures also employs literal vectors.</p><p> 如果我们认为文字向量被污秽使用并让订购绑定使用，请不要让我们惊喜，用于破坏顺序数据结构的语法也采用了文字向量。 </p><p>             The left-hand side of each binding—which is normally just a Clojure symbol—is treated as sequential destructuring when a literal vector is used. The  [?],  [_ ?], and  [_ _ ?] forms bind  ? to the value of  (nth coll 0),  (nth coll 1), and  (nth coll 2), respectively.</p><p>每个结合的左侧 - 通常只是Clojure符号 - 当使用文字向量时被视为连续破坏性。 [？]，[_？]和[__？]表单绑定？ （第n Colle 0），（第n Colle 1）和（第n Colle 2）的值分别值。</p><p>  (let [[__0 __1 __2 __3 __4 __5 __6 __7 __8 __9 _10 _11 _12 _13 _14 _15 _16 _17 _18 _19 _20 _21 _22 _23 _24 ?] coll] ?)</p><p>  （让[__0 __1 __2 __3 __4 __5 __6 __7 __8 __10 _11 _12 _13 _11 _15 _16 _111 _19 _20 _21 _22 _23 _24？] coll]吗？）？）</p><p>         Important Observation: Destructuring binds  nil rather than throwing exceptions when it can&#39;t find what we&#39;re asking for.</p><p>         重要观察：破坏性绑定零，而不是在＆＃39时扔掉异常。去找我们＆＃39;重申。</p><p> Before progressing to more advanced examples, let&#39;s macroexpand our  let to understand what Clojure functions are used:</p><p> 在进展到更高级示例之前，让＆＃39; s宏eppand我们的允许了解使用了什么Clojure函数：</p><p>    (let* [vec__17860 coll ?1 (clojure.core/nth vec__17860 0 nil) ?2 (clojure.core/nth vec__17860 1 nil)] [?1 ?2])</p><p>    （Let * [vec__17860 coll？1（clojure.core / nth vec_t_17860 0 nil）？2（clojure.core / nth vec_t_17860 1 nil）] [？1？2]）</p><p> So Clojure&#39;s core  nth function powers sequential destructuring. Whereas  nth supplied with only a  coll and  index will throw an exception when that index is out of bounds, if a third  not-found value is passed, then  nth will return that instead:</p><p> 所以Clojure＆＃39; S核心Nth函数为连续破坏性提供动力。当NOTH提供COLL和索引时，当该索引超出界限时，如果传递了第三个未找到的值，则NTH将抛出异常，则NTH将返回它：</p><p> (try (nth &#34;HAL&#34; 3) (catch Exception e (.getMessage e)));;=&gt; &#34;String index out of range: 3&#34;(nth &#34;HAL&#34; 3 ::not-found);;=&gt; :user/not-found</p><p> （尝试（nth＆＃34; hal＆＃34; 3）（捕获异常e（.getmessage e）））; =＆gt; ＆＃34;字符串索引超出范围：3＆＃34;（nth＆＃34; hal＆＃34; 3 ::未找到）;; =＆gt; ：用户/未找到 </p><p> We can further deduce that since destructuring leverages  nth, any data structure that  nth accepts can be destructured in the same way. In the examples that follow, remember that  into uses  conj to build new collections, so lists and vectors made with  into will have opposite orderings.</p><p>我们可以进一步推断出来，由于破坏性利用第n，NTH接受的任何数据结构都可以以同样的方式破坏。在下面的示例中，请记住，以用来建立新的收藏，因此列出并与其制作的标志有相反的排序。</p><p> (let [[?] (reduce str coll)] ?) ; \A(let [[?] (into [] coll)] ?) ; \A(let [[?] (into () coll)] ?) ; \Z(let [[?] (into-array coll)] ?) ; \A(let [[_k v] (first {:A \A})] v) ; \A(let [[?] (into (clojure.lang.PersistentQueue/EMPTY) coll)] ?) ; \A(let [[?] (java.util.ArrayList. coll)] ?) ; \A(let [[?] nil] ?) ; nil</p><p> （让[[？]（减少str coll）]？）; \ a（让[[？]（进入[] coll）]？）; \ a（让[[？]（进入（）coll）]？）; \ z（让[[？]（进入阵列Coll）]？）; \ a（让[[_k v]（first {：a \ a}）] v）; \ a（让[[？]（进入（clojure.lang.persistentqueue coll）]？）; \ a（让[[？]（java.util.arraylist。coll）]？）; \ a（让[[？] nil]？）;零</p><p> Remember that Clojure&#39;s  sets are not sequential data structures and cannot be used with  nth or sequential destructuring.</p><p> 请记住，Clojure＆＃39; S组不是顺序数据结构，不能与第n个或连续破坏性一起使用。</p><p> Expand the section below to see the salient aspects of the implementation of  nth which reveal the kinds of values it supports.</p><p> 展开下面的部分，以便查看第n的突出方面，揭示了它支持的价值的种类。</p><p> // From src/jvm/clojure/lang/RT.javastatic public Object nth(Object coll, int n){	if(coll instanceof Indexed)		return ((Indexed) coll).nth(n);	return nthFrom(Util.ret1(coll, coll = null), n);}static Object nthFrom(Object coll, int n){	if(coll == null)		return null;	else if(coll instanceof CharSequence)		return Character.valueOf(((CharSequence) coll).charAt(n));	else if(coll.getClass().isArray())		return Reflector.prepRet(coll.getClass().getComponentType(),Array.get(coll, n));	else if(coll instanceof RandomAccess)		return ((List) coll).get(n);	else if(coll instanceof Matcher)		return ((Matcher) coll).group(n);	else if(coll instanceof Map.Entry) {		Map.Entry e = (Map.Entry) coll;		if(n == 0)			return e.getKey();		else if(n == 1)			return e.getValue();		throw new IndexOutOfBoundsException();	}	else if(coll instanceof Sequential) {		ISeq seq = RT.seq(coll);		coll = null;		for(int i = 0; i &lt;= n &amp;&amp; seq != null; ++i, seq = seq.next()) {			if(i == n)				return seq.first();		}		throw new IndexOutOfBoundsException();	}	else		throw new UnsupportedOperationException(				&#34;nth not supported on this type: &#34; + coll.getClass().getSimpleName());}</p><p> //从SRC / JVM / Clojure / Lang / RT.JavaStatic Public Object第n（Object Coll，Int N）{if（Coll Instansialof索引）返回（（索引）coll）.Nth（n）;返回nthfrom（util.ret1（coll，coll = null），n）;静态对象nthfrom（对象coll，int n）{if（coll == null）返回null;否则if（coll suiscessof char sequence）返回character.valueof（（（charsequence）coll）.charat（n））;否则if（coll.getClass（）。Isarray（））返回反射器.prepret（coll.getClass（）。getComponentType（），Array.get（Coll，N））;否则if（coll instanceofOccess）返回（（列表）coll）.get（n）;否则if（coll instanceof匹配器）返回（（匹配器）coll）.group（n）;否则if（coll instanceof map.entry）{map.entry e =（map.entry）coll; if（n == 0）返回e.getkey（）;否则if（n == 1）返回e.getvalue（）;抛出new indexoutofboundsexception（）; }如果（Coll instansialof Sequential）{ISEQ SEQ = RT.Seq（Coll）; coll = null; for（int i = 0; i＆lt; = n＆amp; seq！= null; ++ i，seq = seq.next（））{if（i == n）return seq.first（）; }抛出新的indexoutofboundsexception（）; }否则抛出新的UnsupportedOperationException（＆＃34; nth不支持此类型：＆＃34; + coll.getClass（）。获取ismplename（））;}</p><p>  Now that we understand how to create bindings for individual items, let&#39;s progress to extracting sub-sequences. The following functions and macros in Clojure&#39;s core API allow you to extract one or more sub-sequences from a sequential data structure:</p><p>  现在我们了解如何为单个项目创建绑定，让＆＃39;■提取子序列的进度。 Clojure＆＃39中的以下函数和宏允许您从顺序数据结构中提取一个或多个子序列：</p><p>  We&#39;ll see that destructuring can take the place of some of these core functions, too. If you need a refresher on these forms, expand the section below.</p><p>  我们＆＃39; ll看到破坏性也可以取代其中一些核心功能。如果您需要在这些形式上进行复习，请展开以下部分。 </p><p> ;; Basic operations:(take 3 coll) ; (\A \B \C)(drop 23 coll) ; (\X \Y \Z)(count (take 1000000 coll)) ; 26(take 3 (next coll)) ; (\B \C \D)(take 3 (rest coll)) ; (\B \C \D)(take-last 3 coll) ; (\X \Y \Z)(take-last 3 (butlast coll)) ; (\W \X \Y)(drop-last 23 coll) ; (\A \B \C)(second (split-at 23 coll)) ; (\X \Y \Z)(subs (reduce str coll) 13 15) ; &#34;NO&#34;(subvec (vec coll) 23) ; [\X \Y \Z];; In absence of cadadadr and friends,;; a few built-in compositions of the above:(take 3 (nfirst [coll coll])) ; (\B \C \D)(take 3 (nnext coll)) ; (\C \D \E)(nthnext coll 23) ; (\X \Y \Z)(nthrest coll 23) ; (\X \Y \Z);; Efficient retrieval based on;; concrete persistent data structures:(try (pop coll) (catch Exception e (.getMessage e)));;=&gt; &#34;class clojure.lang.LazySeq cannot be cast to class clojure.lang.IPersistentStack...&#34;(take-last 3 (pop (vec coll))) ; (\W \X \Y)(take 3 (pop (into () coll))) ; (\Y \X \W)(take 3 (pop (apply list coll))) ; (\B \C \D)(take 3 (pop (into (clojure.lang.PersistentQueue/EMPTY) coll))) ; (\B \C \D);; Based on predicate functions:(drop-while #(&lt; (int %) 88) coll) ; (\X \Y \Z)(second (split-with #(&lt; (int %) 88) coll)) ; (\X \Y \Z)(take-while #(&lt; (int %) 68) coll) ; (\A \B \C);; Interesting extras:(take-nth 8 coll) ; (\A \I \Q \Y)(random-sample 0.1 coll); Seven executions:; (\K \M \X); (); (\Q \T \Z); (\E \F \G \O); (\B \F \G \H \W \X); (\H \Q \S \W \Y); (\K \W \Y)</p><p>;;基本操作:(拿3 Coll）; （\ a \ b \ c）（下降23 coll）; （\ x \ y \ z）（计数（拿1000000 coll））; 26（花3（下一个Coll））; （\ b \ c \ d）（取3（休息））; （\ b \ c \ d）（持续3 coll）; （\ x \ y \ z）（take-last 3（butlast coll））; （\ w \ x \ y）（下拉 - 最后23 coll）; （\ a \ b \ c）（第二个（分裂23 coll））; （\ x \ y \ z）（潜艇（减少str coll）13 15）; ＆＃34;没有＆＃34;（Subvec（Vec Coll）23）; [\ x \ y \ z] ;;在没有康多拉德和朋友的情况下，;;一些上述内置组合物:(服用3（Nfirst [Coll Coll]））; （\ b \ c \ d）（取3（nnext coll））; （\ c \ d \ e）（nthnext coll 23）; （\ x \ y \ z）（硝酸盐财政23）; （\ x \ y \ z）;基于;;具体持久性数据结构:(尝试（弹出coll）（捕获异常e（.getmessage e）））; =＆gt; ＆＃34; clasljure.lang.lazyseq不能投下到课堂clojure.lang.ipersistentstack ...＆＃34;（take-last 3（pop（vec coll）））; （\ w \ x \ y）（需要3（pop（进入（）coll）））; （\ y \ x \ w）（拿3（pop（申请coll）））; （\ b \ c \ d）（拿3（pop（进入（clojure.lang.persistentqueue coll））））; （\ b \ c \ d）;基于谓词函数:(下降＃（＆lt;（int％）88）coll）; （\ x \ y \ z）（第二个（分裂＃（＆lt;（int％）88）coll））; （\ x \ y \ z）（上行时间＃（＆lt;（int％）68）coll）; （\ a \ b \ c）;;有趣的额外额外:( Take-N 4 Coll）; （\ a \ i \ q \ y）（随机样品0.1 coll）;七个执行： （\ k \ m \ x）; （）; （\ q \ t \ z）; （\ e \ f \ g \ o）; （\ b \ f \ g \ h \ w \ x）; （\ h \ q \ w \ y）; （\ k \ w \ y）</p><p> Remembering that  defn supports a variable number of arguments if we insert a  &amp; followed by a symbol that gets bound to a list of the extra arguments passed to our function, it should not surprise us that the same syntax is used to bind a variable number of final items when destructuring:</p><p> 如果我们插入A＆amp，则记住defn支持可变数量的参数;接着是符号，它绑定到传递给我们函数的额外参数的列表中，它不应该让我们感到惊讶，同样的语法用于在破坏性时绑定变量数量的最终项目：</p><p>    ; (\B \C \D \E \F \G \H \I \J \K \L \M \N \O \P \Q \R \S \T \U \V \W \X \Y \Z)</p><p>    ; （\ b \ c \ d \ e \ f \ g \ h \ i \ j \ k \ l \ m \ n \ o \ p \ q \ r \ s \ t \ u \ v \ w \ x \ y \ Z）</p><p>    ; (\C \D \E \F \G \H \I \J \K \L \M \N \O \P \Q \R \S \T \U \V \W \X \Y \Z)</p><p>    ; （\ c \ d \ e \ f \ g \ h \ i \ j \ k \ l \ m \ n \ o \ p \ q \ r \ s \ t \ u \ v \ w \ x \ y \ z）</p><p> As with varargs support in  defn, we cannot attempt to add any additional positional bindings after the  &amp; and its symbol. The following does not compile because macroexpansion fails:</p><p> 与DEFN中的VARARGS支持一样，我们不能在＆amp之后尝试添加任何额外的位置绑定;及其符号。以下内容不编译，因为宏展开失败了：</p><p> (try (macroexpand &#39;(let [[_ &amp; ?rest ?another] coll] ?another)) (catch Throwable t (.getMessage (.getCause t))));;=&gt; &#34;Call to clojure.core/let did not conform to spec.&#34;</p><p> （尝试（宏expand＆＃39;（让[[_＆amp;休息？另一个] coll]？另一个））（捕获throwable t（.getmessage（.getvause t）））; =＆gt; ＆＃34;呼叫clojure.core /让我们没有符合规范。＆＃34;</p><p> Let&#39;s take a look at a successful macroexpansion to see how  &amp; usage translates to Clojure functions:</p><p> 让＆＃39;看看一个成功的宏观展开，看看如何＆amp;用法转换为Clojure函数： </p><p>    (let* [vec__17698 coll seq__17699 (clojure.core/seq vec__17698) first__17700 (clojure.core/first seq__17699) seq__17699 (clojure.core/next seq__17699) _1 first__17700 first__17700 (clojure.core/first seq__17699) seq__17699 (clojure.core/next seq__17699) _2 first__17700 ?rest seq__17699] ?rest)</p><p>（Let * [vec__17698 coll seq__17699（clojure.core / seq vec__17698）first__17700（clojure.core / first seq__17699）seq__17699（clojure.core / next seq__17699）_1 first__17700 first__17700（clojure.core / first seq__17699）seq__17699（clojure.core /下一个SEQ__17699）_2 first__17700？休息SEQ__17699]？休息）</p><p> Based on the number of single-item retrievals at the beginning of our destructuring expression, a corresponding number of calls to  first and  next are used to establish the positional and final  ?rest bindings.</p><p> 基于我们的破坏表达式的单项检索的数量，对相应的呼叫数量和下一个用于建立位置和最终的？休息绑定。</p><p> In our examples so far we have used an already-bound  coll, but for extra concision we can bind a new collection and destructure parts of it in one destructuring expression. For this feature, destructuring shares syntax with  require, which expects the keyword  :as followed by an alias. Here is an example that employs all three aspects we&#39;ve observed:</p><p> 在我们的例子中，到目前为止，我们使用了一个已经绑定的Coll，但是为了额外的亲密，我们可以在一个破坏性表达式中绑定它的新收藏和破坏部分。对于此功能，破坏性份额与expers的股票语法，它期望关键字：后跟别名。这是一个雇用我们所有三个方面的示例，我们观察到的所有三个方面：</p><p> (let [[?1 ?2 &amp; ?rest :as alphabet] (map (comp char (partial + 65)) (range 26))] [?1 ?2 (count ?rest) (count alphabet)])</p><p> （让[[1吗？2＆amp;休息：作为字母]（MAP（Comp Char（Partial + 65））（范围26））] [？1？2（计数？休息）（count字母表）]）</p><p>    And as a final test that we understand how this works, let&#39;s look at the macroexpansion of this last example:</p><p>    作为我们理解这项工作的最终测试，让＆＃39;查看最后一个示例的宏展开：</p><p> (macroexpand &#39;(let [[?1 ?2 &amp; ?rest :as alphabet] (map (comp char (partial + 65)) (range 26))] [?2 ?1 (count ?rest) (count alphabet)]))</p><p> （宏eplexpand＆＃39;（让[？1？2＆amp;休息：作为字母]（MAP（Pargial + 65））（范围26））] [？2？1（计数？休息）（数字母表）]））））</p><p>   (let* [vec__17703 (map (comp char (partial + 65)) (range 26)) seq__17704 (clojure.core/seq vec__17703) first__17705 (clojure.core/first seq__17704) seq__17704 (clojure.core/next seq__17704) ?1 first__17705 first__17705 (clojure.core/first seq__17704) seq__17704 (clojure.core/next seq__17704) ?2 first__17705 ?rest seq__17704 alphabet vec__17703] [?2 ?1 (count ?rest) (count alphabet)])</p><p>   （设* [vec__17703（map（pargial + 65））（范围26））seq__17704（clojure.core / seq vec_17703）first__17705（clojure.core / first seq__17704）seq__17704（clojure.core / next seq__17704）？1 first__17705 first__17705（clojure.core / first seq__17704）seq__17704（clojure.core / next seq__17704）？2 first__17705？rest seq__17705字母vec__17703] [吗？2？1（计数字母）（count字母）]） </p><p>   If we can destructure a flat sequence, can we apply the same technique to a nested one? Note that we wrap  coll in a vector in this example:</p><p>如果我们可以破坏平面序列，我们可以将与嵌套的技术相同吗？请注意，在此示例中，我们将Coll在向量中进行COLL：</p><p>      (let [ [ [_ _ ?] ] [coll] ];; ^ ^ ^;; | | |__Destructure `coll`, taking the 3rd item, which is `\C`;; | |;; | |__Destructure `[coll]`, taking the 1st item which is `coll`;; |;; |__The outer [ ... ] for all `let` bindings ?)</p><p>      （让[[__？] [coll]] ;; ^ ^ ^ ;; | | | | | | | | | | __Destucture`Coll`，采取第3项，这是“\ C`; | | ;; | | | | | | | | | | | | | | | | | | | | | | __Desturecure` [coll]`，拍摄的第一个项目是`coll`; | ;; | __所有`let`绑定的外部[...]？）</p><p>       (let [[[_ &amp; ?rest-1 :as alpha1] [_ _ _ _ &amp; ?rest-2 :as alpha2]] [coll coll]] [?rest-1 ?rest-2 (count alpha1) (count alpha2)])</p><p>       （允许[[_＆amp; rest-1：作为alpha1] [_ _ _＆amp; rest-2：作为alpha2]​​] [coll coll]] [？rest-1？rest-2（count alpha1） （count alpha2）]）</p><p>   [(\B \C \D \E \F \G \H \I \J \K \L \M \N \O \P \Q \R \S \T \U \V \W \X \Y \Z) (\E \F \G \H \I \J \K \L \M \N \O \P \Q \R \S \T \U \V \W \X \Y \Z) 26 26]</p><p>   [（\ b \ c \ d \ e \ f \ g \ h \ i \ j \ k \ l \ m \ n \ o \ p \ q \ r \ s \ t \ u \ v \ w \ x \ y \ z）（\ e \ f \ g \ h \ i \ j \ k \ l \ m \ n \ o \ p \ q \ r \ s \ t \ u \ v \ w \ x \ y \ z）26 26]</p><p>       (let* [vec__16915 coll _ (clojure.core/nth vec__16915 0 nil) _ (clojure.core/nth vec__16915 1 nil) ? (clojure.core/nth vec__16915 2 nil)] ?)</p><p>       （Let * [vec__16915 coll _（clojure.core / nth vec_t_16915 0 nil）_（clojure.core / nth vec_t_16915 1 nil）？（clojure.core / nth vec_t_16915 2 nil）]？）</p><p> Note the multiple bindings of  _. Except for select functions that return lazy sequences, Clojure as a language is eagerly evaluated. Binding to the underscore symbol does not have any special behavior that avoids evaluation of the next form; it&#39;s just a widespread convention that informs the human reader to ignore the binding. Each binding in the above macroexpanded code will be evaluated, so keep this in mind if you are destructuring lazy sequences that might trigger side effects.</p><p> 注意_的多个绑定。除了选择返回延迟序列的功能外，急切地评估Clojure作为一种语言。绑定到下划线符号没有任何特殊行为，可避免评估下一个表格;它只是一个广泛的公约，通知人类读者忽视绑定。在上面的宏展开代码中的每个绑定将被评估，因此如果您正在破坏可能触发副作用的懒惰序列，请记住这一点。</p><p>     ; (out) 1; (out) 2; (out) 3; (out) 4; (out) 5; (out) 6; (out) 7; (out) 8; (out) 9; (out) 10; (out) 11; (out) 12; (out) 13; (out) 14; (out) 15; (out) 16; (out) 17; (out) 18; (out) 19; (out) 20; (out) 21; (out) 22; (out) 23; (out) 24; (out) 25; (out) 26; (out) 27; (out) 28; (out) 29; (out) 30; (out) 31; (out) 323</p><p>     ; （出）1; （出）2; （出）3; （出）4; （出）5; （出）6; （出）7; （出）8; （出）9; （出）10; （出）11; （出）12; （出）13; （出）14; （出）15; （出）16; （出）17; （出）18; （出）19; （出）20; （出）21; （出）22; （出）23; （出）24; （出）25; （出）26; （出）27; （出）28; （出）29; （出）30; （出）31; （出）323 </p><p> If we are retrieving the third item from the lazy seq provided by  (range 1 100), why were the first 32 items of our lazy sequence evaluated? Because Clojure&#39;s lazy collections are  chunked for performance reasons, and that chunk size is 32:</p><p>如果我们从（范围1 100）提供的懒人SEQ中检索第三项，为什么我们的懒惰序列的前32项是评估的？因为Clojure＆＃39; s懒惰的集合是为了性能原因而被束缚，块大小为32：</p><p>  We can implement completely lazy sequences (each item realized individually) by combining  lazy-seq with  cons as follows:</p><p>  我们可以通过将Lazy-SEQ与CIM组合如下所示，实现完全惰性的序列（单独实现的每个项目）：</p><p> (defn fully-lazy-range-with-side-effect [n] (lazy-seq (cons (do (println n) n) (fully-lazy-rangewith-side-effect (inc n)))))(let [[_ _ ?] (fully-lazy-range-with-side-effect 1)] ?)</p><p> （Defn完全延迟范围 - 侧面效果[n]（Lazy-SEQ（CAN（DO（PRINTLN N）N）（完全延迟范围副作用（INC N）））））（让[[_ _？]（完全懒惰范围 - 副作用1）]？）</p><p>    As a general principle, it is perilous to combine side effects with lazy collections. Not only does destructuring not shield you from those concerns, but because it is presented as end-user syntax and therefore obscures the exact evaluation, it&#39;s important to remember that every binding in a destructuring expression is evaluated.</p><p>    作为一般原则，它是将副作用与懒人收藏界相结合。不仅破坏性不仅屏蔽了你的担忧，而且因为它被呈现为最终用户语法，因此掩盖了确切的评估，它很重要，因为重视破坏性表达中的每一个绑定都很重要。</p><p>  Clojure&#39;s associative data structures provide efficient means to insert and retrieve key-value pairs. Destructuring them, therefore, also focuses on specifying keys whose values we want out of the collection.</p><p>  Clojure＆＃39; S关联数据结构提供了有效的方法来插入和检索键值对。因此，破坏它们也专注于指定所需值的键。</p><p>  ;; Note the different key types.(def card {:card/suit :spade :card/rank :queen :id 42 &#39;special? false &#34;code&#34; &#34;QS&#34;	 [:game :hearts] :tactic/avoid})</p><p>  ;;注意不同的关键类型游戏：心]：策略/避免}）</p><p> Although a Clojure map supports arbitrary key types, destructuring provides special support for keys that are keywords, strings, or symbols.</p><p> 虽然Clojure地图支持任意关键类型，但是破坏性为关键字，字符串或符号的键提供特殊支持。 </p><p>             If you have a map with a mixture of different key types like our chaotic  card example, you can specify  :keys,  :syms, and  :strs in a single destructuring expression.</p><p>如果您有一个类似于我们的混沌卡示例的不同关键类型的混合的地图，则可以指定：键，：syms和：strs在单一的破坏性表达式中。</p><p> In addition to the simple  :id entry, our  card also has namespace-qualified keyword keys. We have two techniques we can apply to such keywords:</p><p> 除了简单：ID条目外，我们的卡还具有命名空间合格的关键字键。我们有两种技术，我们可以应用于这样的关键词：</p><p>          There are different ergonomic considerations for both approaches. Some people like to keep the namespace and name of keywords side-by-side as in the first example for easier textual search; others value the DRYer approach shown in the second example.</p><p>          两种方法都有不同的人体工程学考虑因素。有些人喜欢并排保留关键字的命名空间和关键字的名称，如在更容易的文本搜索的第一个示例中;其他值在第二个例子中显示干燥机方法。</p><p> I had been working with Clojure for over 10 years before discovering that you can use either symbols  or keywords with  :keys destructuring. Note the  :id in this example:</p><p> 在发现您可以使用以下符号或关键字之前，我一直在康复10年超过10年，其中：键解析。注意：ID在此示例中：</p><p> ;; Personal annotation: This works, but please don&#39;t do this.(let [{:keys [:id]} card] id);;=&gt; 42</p><p> ;;个人注释：这是有效的，但请不要这样做。（让[{：键[：ID]}卡] ID）; =＆gt; 42.</p><p> As far as I am aware, symbols universally represent bindings in all other Clojure contexts but this one corner of destructuring. Using  keywords for bindings adds unnecessary mental overhead for those reading code, who naturally expect to find symbols in binding contexts. Thankfully, this same loop-hole does not work with  :strs.</p><p> 据我所知，符号普遍代表所有其他Clojure语境中的绑定，而是破坏性的一个角落。使用关键字对于绑定为那些读取代码添加了不必要的精神开销，他自然期望在绑定上下文中找到符号。谢天谢地，同样的环孔不适用于：strs。</p><p> In situations where a key name is problematic (e.g., the name is confusing in the context in which it is destructured) or when a key is not a keyword, string, or symbol, then we have access to another form of associative destructuring:</p><p> 在关键名称存在的情况下（例如，该名称在其被破坏的上下文中困惑）或当密钥不是关键字，字符串或符号时，我们可以访问另一种形式的关联破坏性： </p><p>     This formulation can prove confusing at first, but it&#39;s closely related to the syntax of sequential destructuring we explored first. For sequential destructuring, we were able to rely on implicit &#34;keys&#34; of the positions 0, 1, 2, etc. in the sequence. For maps, we have to be explicit about the key whose value we want to bind to a symbol, in this case  &#34;code&#34;.</p><p>这种配方首先可以证明令人困惑，但它与我们首先探索的顺序破坏性言论密切相关。为了顺序破坏性，我们能够依靠隐式＆＃34;钥匙＆＃34;序列中的位置0,1,2等。对于地图，我们必须明确关于我们想要绑定到符号的键的关键，在这种情况下，在这种情况下;代码＆＃34;</p><p>            (let [{:card/keys [suit rank] :as card} {:card/suit :spade :card/rank :queen :id 42 &#39;special? false &#34;code&#34; &#34;QS&#34; [:game :hearts] :tactic/avoid}] [suit rank (count card)])</p><p>            （让[{：卡/钥匙[套装排名]：担任卡} {：卡/西装：Spade：Card / Rank：女王：ID 42＆＃39;特殊？假＆＃34;代码＆＃34;＆＃34;＆＃34 ; QS＆＃34; [：游戏：心]：Tactic /避免}] [诉讼等级（数卡）]）</p><p>    As with sequential destructuring, if we attempt to extract a value at a key that is not present in an associative data structure, our binding will be  nil rather than throwing an exception:</p><p>    与顺序破坏性一样，如果我们尝试在关联数据结构中不存在的密钥处提取值，我们的绑定将是nil，而不是抛出异常：</p><p>     Associative destructuring takes this  nil support one step further by allowing us to define default values other than  nil by supplying an  :or entry in our destructuring expression:</p><p>     关联破坏性通过允许我们通过提供：或进入我们的破坏性表达式来允许我们定义除NIL以外的默认值来进一步支持这一步：</p><p>     The  :or can provide defaults to all symbols bound within the destructuring expression, not just those specified with  :keys:</p><p>     介绍：或可以为破坏性表达式内绑定的所有符号提供默认值，而不仅仅是指定的符号：键：键：</p><p> (let [{:keys [card/suit card/rank card/wild?] another :absent-field :or {suit :heart wild? false another &#34;default&#34;}} card] [suit rank wild? another])</p><p> （让[【：钥匙[卡/套装/排名卡/野外吗？]另一个：缺席场：或{西装：心脏狂野？假另一个＆＃34;默认和＃34;}}卡]其他]）</p><p>    Note that  :or is about supplying defaults for  bindings. If you don&#39;t bind it within the destructuring expression,  :or doesn&#39;t know what to do with it:</p><p>    请注意：或者是关于提供绑定的默认值。如果你不在破坏性表达中绑定它，或者不知道如何处理它： </p><p> (try (eval &#39;(let [{:keys [id] :or {suit :heart}} card] [id suit])) (catch Exception e (.getMessage (.getCause e))));;=&gt; &#34;Unable to resolve symbol: suit in this context&#34;</p><p>（尝试（eval＆＃39;（let [{：keys [id]：或{siate：heart}}卡）[id suit]））（捕获异常e（.getmessage（.getvause（.getvause e））））; =＆gt; ＆＃34;无法解决符号：在此上下文中适用于此环境＆＃34;</p><p>  We can use destructuring to dive as deeply into associative data structures as we did with sequential ones. We&#39;ll use the following  card+ definition in this section:</p><p>  我们可以使用序贯数据结构使用损坏来潜入联想数据结构。我们＆＃39; ll在本节中使用以下卡+定义：</p><p> (def card+ {:suit {:id :spade :color :black} :rank {:id :queen :value {:hearts ##-Inf :blackjack 10}} :games [:hearts :blackjack :poker]})</p><p> （def卡+ {：suit {：id：spade：color：black}：排名{：ID：女王：value {：hearts ##  -  inf：blackjack 10}}：游戏[：hearts：blackjack：扑克]}）</p><p> Since  :keys,  :strs, and  :syms expect literal keywords, strings, and symbols, we&#39;ll have to use the other syntax for associative destructuring if we want to create bindings of nested values:</p><p> key：keys，：strs，和：syms期望文字关键字，字符串和符号，我们＆＃39;如果我们想创建嵌套值的绑定，我们必须使用其他语法进行关联破坏性：</p><p>     Here we used  {symbol :a-key} for the outer binding and  :keys for the inner binding. If we wanted to go deeper:</p><p>     在这里，我们使用了外部绑定的{符号：a-key}：内部绑定的键。如果我们深入了解：</p><p>      (let [{ { {:keys [blackjack]} :value} :rank} card+];; ^ ^ ^;; | | |__Grab the value of the `:blackjack` key, equivalent to `(get-in card+ [:rank :value :blackjack])`;; | |;; | |__Grab the value of the `:value` key, equivalent to `(get-in card+ [:rank :value])`;; |;; |__Grab the value of the `:rank` key in `card+` blackjack)</p><p>      （{{{{{{lexy [blackjack]}：value}：rank}卡+]; ^ ^ ^ ;; | | | | __grab的“：Blackjack`键，相当于`（夹住卡+ [ ：秩：value：blackjack]）`;; | | ;; | | |; __grab的“：value`键，相当于`（夹住卡+ [：排名：值]）`;; | ;; | ;; | ;; | ;; | ;; |; __GRAB在“卡”+“Blackjack中的”：等级“密钥的价值）</p><p> Any combination of destructuring at any level is supported, including a combination of associative and sequential destructuring wherever appropriate data structures are found:</p><p> 支持任何级别的破坏性组合，包括联合和顺序破坏性的组合，无论是否找到适当的数据结构： </p><p> (let [[{id-1 :id :keys [foo] :or {foo &#34;bar&#34;} {suit :id} :suit} {id-2 :id [_ _ third-game] :games} :as cards] [(assoc card+ :id 1) (assoc card+ :id 2)]] [id-1 id-2 foo suit third-game (count cards)])</p><p>（允许[{id-1：id：keys [foo]：或{foo＆＃34; bar＆＃34;} {suit：id}：suit} {id-2：ID [_ _ _ _第三游戏]：游戏}：AS卡] [（ASSACAD CARD +：ID 1）（ASSIC卡+：ID 2）]] [ID-1 ID-2 Foo套装第三游戏（计数卡）]）</p><p>    Let&#39;s consider the macroexpansion of this non-trivial example to see what destructuring is buying us:</p><p>    让＆＃39;考虑这个非琐碎榜样的宏观展开，看看是什么样的破坏性：</p><p> (macroexpand &#39;(let [[{id-1 :id :keys [foo] :or {foo &#34;bar&#34;} {suit :id} :suit} {id-2 :id [_ _ third-game] :games} :as cards] [(assoc card+ :id 1) (assoc card+ :id 2)]] [id-1 id-2 foo suit third-game (count cards)]))</p><p> （宏alpand＆＃39;（let [[{id-1：id：keys [foo]：或{foo＆＃34; bar＆＃34;} {suit：id}：suit} {id-2：id [_ _第三游戏]：游戏}：作为卡片] [（ASSAC卡+：ID 1）（ASSAC卡+：ID 2）]] [ID-1 ID-2 Foo套装第三种游戏（计数卡）]））</p><p>   (let* [vec__18794 [(assoc card+ :id 1) (assoc card+ :id 2)] map__18797 (clojure.core/nth vec__18794 0 nil) map__18797 (if (clojure.core/seq? map__18797) (clojure.lang.PersistentHashMap/create (clojure.core/seq map__18797)) map__18797) id-1 (clojure.core/get map__18797 :id) map__18798 (clojure.core/get map__18797 :suit) map__18798 (if (clojure.core/seq? map__18798) (clojure.lang.PersistentHashMap/create (clojure.core/seq map__18798)) map__18798) suit (clojure.core/get map__18798 :id) foo (clojure.core/get map__18797 :foo &#34;bar&#34;) map__18799 (clojure.core/nth vec__18794 1 nil) map__18799 (if (clojure.core/seq? map__18799) (clojure.lang.PersistentHashMap/create (clojure.core/seq map__18799)) map__18799) id-2 (clojure.core/get map__18799 :id) vec__18800 (clojure.core/get map__18799 :games) _ (clojure.core/nth vec__18800 0 nil) _ (clojure.core/nth vec__18800 1 nil) third-game (clojure.core/nth vec__18800 2 nil) cards vec__18794] [id-1 id-2 foo suit third-game (count cards)])</p><p>   （设* [vec__18794 [（assocack +：id 1）（关卡+：id 2）] map__18797（clojure.core / nth vec_t18794 0 nil）map__18797（如果（clojure.core / seq？map__18797）（clojure.lang.persistenthashmap / create（clojure.core / seq map__18797））map__18797）id-1（clojure.core / get map__18797：id）map__18798（clojure.core / get map__18797：suit）map__18798（如果（clojure.core / seq？map__18798）（if（clojure.core / seq）（ clojure.lang.persistenthashmap / create（clojure.core / seq map__18798））Map__18798）Suit（clojure.core / get map__18798：ID）foo（clojure.core / get map__18797：foo＆＃34; bar＆＃34;）map__18799（ clojure.core / nth vec_t18794 1 nil）map__18799（如果（clojure.core / seq？map__18799）（clojure.lang.persistenthashmap / create（clojure.core / seq map__18799））id-2（clojure.core / get map__18799 ：ID）vec__18800（clojure.core / get map__18799：游戏）_（clojure.core / nth vec_t_18800 0 nil）_（clojure.core / nth vec_t_18800 1 nil）第三游戏（clojure.core / nth vec__18800 2 nil）卡vec__18794] [ID-1 ID-2 Foo Suit第三游戏（计数卡）]）</p><p> Even casting aside the gensymed names, there is a clearer syntactic relationship between the shape of our data and our bin</p><p> 甚至抛开了语假名称，我们的数据形状与我们的垃圾箱之间存在更清晰的句法关系</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://danielgregoire.dev/posts/2021-06-13-code-observation-clojure-destructuring/">https://danielgregoire.dev/posts/2021-06-13-code-observation-clojure-destructuring/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/观察/">#观察</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/coll/">#coll</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>