<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>使用Haskell以本机速度编程R</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">使用Haskell以本机速度编程R</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-04 01:10:25</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/022ae1f163e3837faf7572f4d1b4761b.png"><img src="http://img2.diglog.com/img/2020/11/022ae1f163e3837faf7572f4d1b4761b.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Most good data stories start with a interesting question. If theaverage request latency went down by a further 100ms, by how muchcould we expect user engagement to increase? How can we detectevidence of corruption of government officials given a list of allbids nationwide for the building of new roads and repair of existingones? Can we identify a new pandemic in the making given a timeline ofcommon search terms? Often though, we know we have the data, but wedon’t even know what questions the data might help answer, or how thestory will unfold. From the data scientist who scratched an itch on anidle afternoon, to a low latency, high availability, real-timeanalysis deployed on hundreds of machines, the story typicallyinvolves lots of rewrites, meanderings and building out of a lot ofcode and utilities to improve the precision, speed or scale of theanalysis.</p><p>大多数好的数据故事都是从一个有趣的问题开始的。如果平均请求延迟再降低100毫秒，我们可以预期用户参与度会增加多少呢？给出一份全国范围内新建和修复现有道路的所有投标清单，我们如何才能发现政府官员腐败的证据？给出一个常见搜索词的时间表，我们能否确定一场新的大流行正在酝酿之中？然而，我们通常知道我们有数据，但我们甚至不知道这些数据可能有助于回答什么问题，或者故事将如何展开。从在空闲的下午挠痒痒的数据科学家，到部署在数百台机器上的低延迟、高可用性的实时分析，故事通常涉及大量重写、曲折和构建大量代码和实用程序，以提高分析的精度、速度或规模。</p><p> R provides a great interactive environment for poking at the dataset du jour and find what answers might be lurking in there. It providesa wealth of readily available libraries for banging out an initialstory to tell. But R is a special purpose scripting language. Itsstrength in supporting throwaway “do what I mean” programming to testand iterate on hypotheses quickly becomes a hindrance when a model isto be built out into an industrial scale, performant and maintainableproduct or service. By then, a more general purpose languageencouraging structured, modular programming, providing strong staticguarantees of correctness and that compiles down to native code formaximum speed becomes more appropriate. Haskell is such a language.</p><p>R提供了一个很好的交互环境，用于查看当前的数据集，并找出可能潜藏在其中的答案。它提供了丰富的现成的库，可以用来拼凑出一个可以讲述的初始故事。但是R是一种特殊用途的脚本语言。它在支持一次性“按我的意思做”编程以验证假设的迭代方面的优势，当一个模型要被建立成工业规模、高性能和可维护的产品或服务时，很快就会成为一个障碍。到那时，更通用的语言(鼓励结构化、模块化编程，提供强大的正确性静态保证，并编译成本机代码以获得最大速度)变得更加合适。哈斯克尔就是这样一种语言。</p><p> Mind you, Haskell makes for a great language to support rapiditeration, “in the small” exploratory programming too, but it as ofyet lacks the plethora of high quality libraries from machine learningto visualization that R provides, and perhaps also some syntacticfacilities to play it fast and loose. Today we’re proud to announcethe first public release of the HaskellR project, which includesa library and two interactive environments for seamlessly programmingin  both R and Haskell in the same source file, or indeed at the sameprompt.</p><p>请注意，Haskell是一种支持快速迭代的伟大语言，“在小的”探索性编程中也是如此，但到目前为止，它还缺乏R提供的从机器学习到可视化的过多高质量库，也许还缺少一些语法工具来快速和松散地发挥作用。今天，我们很自豪地宣布HaskellR项目的第一个公开版本，它包括一个库和两个交互环境，可以在同一源文件中或在同一提示符下无缝地对R和Haskell进行编程。</p><p> At the heart of the project lies  inline-r (whose design laterinspired inline-c - theyshare a coauthor), which exports a few quasiquoters for expressingcalls to R functions and indeed arbitrary R code in R’s syntax. Theprinciples behind the design of  inline-r are,</p><p>该项目的核心是inline-r(其设计后来启发了inline-c-他们共享一个合著者)，它导出一些准引号来表达对R函数的调用，甚至是R语法中的任意R代码。内联R设计背后的原则是，</p><p> use R libraries the way R intends them to be used: using R’s syntaxand calling conventions;</p><p>按照R预期的方式使用R库：使用R的语法和调用约定；</p><p> keep the overhead of crossing language boundaries as low as possibleto encourage fine grained interleaving of code in both languages;</p><p>尽可能降低跨越语言边界的开销，以鼓励两种语言的代码细粒度交错；</p><p>   let the user stoop as low or jump as high as (s)he likes in theabstraction stack: everything is under the user’s control control incase (s)he needs it.</p><p>让用户在抽象堆栈中弯下腰或跳到他喜欢的高度：一切都在用户的控制之下，以防他需要它。</p><p> We’ll touch upon each of the above points in more detail below and infuture posts. But first, let’s get a taste of this stuff. You may wantto consider the below setup as your go-to interactive shell if youhaven’t already: it reuses existing projects and works much like GHCi,in an isolated sandbox if you like, except that you have inlinegraphics and formulas out-of-the-box, as Shae Erisson first pioneeredin the Haskell world with  ghcliveand Manuel Chakravarty realized more recently on OS X with Haskell for Mac.</p><p>我们将在下面和以后的帖子中更详细地讨论以上每一点。但首先，让我们先来品尝一下这些东西。如果还没有的话，你可以考虑将下面的设置作为你的首选交互shell：它重用了现有的项目，工作方式很像GHCi，如果你愿意，在一个孤立的沙盒里，除了你有开箱即用的内嵌图形和公式，就像Shae Erisson最先在Haskell世界中用ghclive和Manuel Chakravarty最近在OSX上用Haskell for Mac实现的那样，你可以考虑使用下面的设置作为你的首选交互shell：它重用了现有的项目，工作方式很像GHCi，如果你愿意的话，就像你有开箱即用的内嵌图形和公式一样。</p><p>   a bare bones REPL, called H. This is a thin wrapper around GHCiinitializing it with all the right extensions and imports to hit theroad running;</p><p>一个名为H的基本REPL。这是一个围绕GHCi的薄包装器，使用所有正确的扩展和导入来初始化它，以命中加载运行；</p><p> an all singing, all dancing interactive notebook, powered by Jupyter (formerly IPython) and AndrewGibiansky’s fantastic IHaskell kernel.</p><p>这是一款全唱全跳的互动笔记本，由Jupyter(以前的IPython)和AndrewGibiansky的奇妙的IHaskell内核提供支持。</p><p> In this post, we’ll talk mostly about the latter. Thanks to stack, getting startedwith  HaskellR is pretty straightforward, and more importantly,comparatively reliable. We put together a Docker container to getyou started hassle-free. It includes  Jupyter and  IHaskellpreinstalled. To build  HaskellR inside it:</p><p>在这篇文章中，我们将主要讨论后者。多亏了堆栈，开始使用HaskellR非常简单，更重要的是，相对可靠。我们组装了一个码头集装箱，让您轻松上手。它包括预装的Jupyter和IHaskell.。要在其中构建HaskellR，请执行以下操作：</p><p>       With  IHaskell, you can keep your notes and formulas together withyour code in one place, called a notebook. With  HaskellR’s pluginfor  IHaskell, you can use widely acclaimed and very popularR visualization packages such as  ggplot2 forembedding plots in your notebook. Working in notebooks (aka playgrounds)is convenient: they are self contained units that is easy to sharewith colleagues, via email or on the web, and you can edit earlierdefinitions while keeping the later ones in sync.</p><p>使用IHaskell，您可以将笔记、公式和代码保存在一个称为笔记本的地方。使用HaskellR的IHaskell插件，您可以在笔记本中使用广受好评且非常受欢迎的R可视化包，如ggplot2前置绘图。在笔记本电脑(又名操场)中工作很方便：它们是独立的单元，很容易通过电子邮件或网络与同事共享，您可以编辑早期的定义，同时保持后面的定义同步。</p><p> Here’s a simple example of using R’s data analysis facilities on datagenerated in Haskell. Say you have a cluster of noisy data. We’ll usethe  random package to generate a sample set:</p><p>下面是一个使用R的数据分析工具处理在Haskell中生成的数据的简单示例。假设您有一群噪音很大的数据。我们将使用随机包来生成样例集：</p><p> import Control.Monad  import System.Random.MWC  as MWC  import System.Random.MWC.Distributions main  =  do  gen  &lt;-  MWC.create  xs  &lt;-  replicateM  500  $  normal  10  3  gen  ys  &lt;-  replicateM  500  $  normal  10  3  gen  ...</p><p>导入Control.Monad导入系统.Random.MWC作为MWC导入系统.Random.MWC.Distributions main=do gen&lt；-MWC.create Xs&lt；-replicateM 500$Normal 103 Gen ys&lt；-replicateM 500$Normal 103 Gen...。</p><p> We can now plot the list of x-ordinates against the list ofy-ordinates using R’s standard library  plot() function:</p><p>现在，我们可以使用R的标准库Plot()函数根据y坐标列表绘制x坐标列表：</p><p>   Better yet: say we want some kind of visualization of the densityestimation of these points. We can use R’s 2D kernel densityestimation function, available out-of-the-box:</p><p>更好的是：假设我们想要这些点的密度估计的某种可视化。我们可以使用R的2D核密度估计函数，开箱即用：</p><p>   Notice how in the above, some code appears delineated inquasiquotation blocks. This is a syntactic facility to tell theHaskell compiler that any code inside the block should be understoodto be in R’s syntax, not Haskell’s syntax as is normally the caseoutside of these blocks. We implemented a mechanism to get an embeddedinstance of the R interpreter to parse that code for us, so that wedon’t have to grok R’s full surface syntax ourselves.</p><p>请注意，在上面的代码中，一些代码显示为查询引号块。这是一个语法工具，用来告诉Haskell编译器，块内的任何代码都应该理解为使用R的语法，而不是像通常在这些块之外那样使用Haskell的语法。我们实现了一种机制，让R解释器的嵌入式实例为我们解析代码，这样我们就不必自己摸索R的完整表面语法。</p><p> By convention,  _hs suffixed variables don’t refer to bindings in theR environment, but rather to bindings in the Haskell environment. Intechnical terms, these variables are actually antiquotations(we use convention over extra syntax so that we can reuse R’s stockparser as-is and not implement our own). Antiquotation is thefundamental mechanism for communicating data between R and Haskell. Incommon cases, we can do so with no marshalling at all, so you cancross the language boundaries repeatedly in a tight loop with impunityif you like.</p><p>按照惯例，_hs后缀变量并不引用环境中的绑定，而是引用Haskell环境中的绑定。在技术术语中，这些变量实际上是反引号(我们使用约定而不是额外的语法，这样我们就可以按原样重用R的股票解析器，而不是实现我们自己的)。反引用是R和Haskell之间进行数据通信的基本机制。在常见情况下，我们可以完全不用编组就可以做到这一点，所以如果您愿意，您可以在紧凑的循环中重复取消语言边界。</p><p>  The core idea behind  HaskellR is that language interop should bezero-cost, or close to. There should be no reason why you wouldhesitate to dip into a little bit of R to get the job done, overreimplementing the same thing in Haskell because you’re worried aboutperformance or the cost of sending large volumes of data to someremote R interpreter instance. We believe that making foreign callspractically as fast as native calls is the key to making theexperience programming with both  CRANand  Hackage package functions at thesame time seamless.</p><p>HaskellR背后的核心思想是语言互操作应该是零成本的，或者接近零成本。您应该没有理由犹豫使用一点R来完成这项工作，在Haskell中过度实现相同的事情，因为您担心将大量数据发送到Smer Remote R解释器实例的性能或成本。我们相信，让外来调用和本地调用一样快，是让同时使用CRAN和黑客包功能的体验编程无缝进行的关键。</p><p> To this end, we decided to embed the R interpreter instance, that isto say link together in the same binary the C code of theR interpreter with the Haskell code of Haskell programs. In this way,we can communicate with the R interpreter in the same process addressspace. Many R functions are actually written in C, for speed, andcompile down to native code. Some of these primitives can be calledfrom Haskell as cheaply as any other foreign function call.</p><p>为此，我们决定嵌入R解释器实例，也就是说将解释器的C代码与Haskell程序的Haskell代码链接在同一个二进制中。这样，我们就可以在相同的进程地址空间中与R解释器进行通信。为了提高速度，许多R函数实际上都是用C语言编写的，并编译成本机代码。其中一些原语可以从Haskell调用，其成本与任何其他外部函数调用的成本一样低。</p><p> But that’s not the end of the performance story. A typically vexingissue in cross-language programming is that the one language insistson one representation of the data, while the other language wants itsown representation. Therefore, data typically has to be marshalledfrom one representation to another constantly. In  HaskellR, wesolved that problem in the following way: just use R’s representationthroughout. It’s the form that R functions expect, so they can getstraight to computing on that data when called. The trouble is, R’sdata representation is foreign to Haskell, so you lose Haskell’sextremely powerful language facilities that work with any nativealgebraic datatype, such as pattern matching. Or do you?…</p><p>但这并不是表演故事的结束。跨语言编程中一个典型的令人烦恼的问题是，一种语言坚持数据的一种表示形式，而另一种语言则想要它自己的表示形式。因此，数据通常必须不断地从一种表示形式编组到另一种表示形式。在HaskellR中，我们通过以下方式解决了这个问题：从头到尾都使用R的表示。这是R函数期望的形式，因此它们在被调用时可以直接对该数据进行计算。问题是，R的数据表示对于Haskell来说是陌生的，因此您失去了Haskell强大的语言工具，这些工具可以处理任何本机代数数据类型，比如模式匹配。或者你有吗？…。</p><p> The trick to get the best of both worlds, zero marshalling but alsopattern matching, is to define so-called view functions that provideyou with a native view as an algebraic datatype of the foreign data.Here’s a toy and contrived example, where we define the factorialfunction in Haskell but over R integers:</p><p>两全其美(零编组和模式匹配)的诀窍是定义所谓的视图函数，该函数为您提供作为外来数据的代数数据类型的本机视图。下面是一个精心设计的玩具示例，其中我们在Haskell中定义阶乘函数，但定义在R个整数之上：</p><p> fact  ::  SEXP  s &#39; R.Int  -&gt;  R  s  ( SEXP  s &#39; R.Int ) fact  ( hexp  -&gt;  Int  [ 0 ] )  =  R.cast  sing  &lt;$&gt;  [ r | 1L  | ] fact  n @ ( hexp  -&gt;  Int  _ )  =  R.cast  sing  &lt;$&gt;  [ r |  n_hs  *  fact_hs ( n_hs  - 1L )  | ]</p><p>FACT：：SEXP s&#39；R.Int-&gt；R s(SEXP s&#39；R.Int)Fact(Hexp-&gt；Int[0])=R.cast sing&lt；$&gt；[r|1L|]Fact n@(Hexp-&gt；Int_)=R.cast sing&lt；$&gt；[r|n_hs*act_hs(n_hs-1L)|]。</p><p> hexp is a view function, mapping native R data (everything isa  SEXP internally in R) to a Haskell-native GADT. Thanks to the typeannotations (more on that in future posts), we know statically thatthe R data can only be some kind of integer vector, so we patternmatch on that, check whether it’s the singleton zero vector or not,and recurse.</p><p>Hexp是一个视图函数，它将原生R数据(所有内容在R内部都是SEXP)映射到Haskell原生GADT。多亏了类型注释(在以后的帖子中会有更多)，我们静态地知道R数据只能是某种整数向量，所以我们对此进行模式匹配，检查它是否是单例零向量，然后递归。</p><p> Aren’t we now back to marshalling? Yes and no! We carefully engineeredthese view functions to be non-recursive. Non-recursive functions canbe inlined. So that when you use a view function only to pattern matchon the result immediately afterwards, as is the case above,  GHC issmart enough to recognize that the view function is constructinga datatype value only to destructure it later, so it simplifies theallocation away! Yes this is marshalling of sorts, but it’smarshalling for free: there is no trace of it at runtime.</p><p>我们现在不是回到编组了吗？是也不是！我们将这些视图函数精心设计为非递归的。非递归函数可以内联。因此，当您只使用视图函数在紧接着之后的结果上进行模式匹配时，就像上面的情况一样，GHC足够聪明，能够识别视图函数正在构造的数据类型值只是为了稍后对其进行变形，所以它简化了分配！是的，这是某种编组，但它是免费的智能编组：在运行时没有任何痕迹。</p><p> There’s plenty more to talk about regarding the design of HaskellR, but this post is already getting long, so we’ll keepa few topics for next time.</p><p>关于HaskellR的设计还有很多要讨论的内容，但这篇文章已经很长了，所以我们将保留一些主题留到下一次。</p><p>  In the meantime, there’s plenty more to work on, so feel free to jumpin and contribute to the project. In the end what  HaskellRprovides is a way to write Haskell programs piecing togetherR primitives at native speed rather than doing so via semi-structuredR scripts. But we haven’t entirely removed the overhead of callingthese R primitives just yet. The next steps:</p><p>同时，还有更多的工作要做，所以请随时参与并为该项目做出贡献。最后，HaskellR提供的是一种以原生速度编写Haskell程序将R原语拼凑在一起的方法，而不是通过半结构化R脚本。但是我们还没有完全消除调用这些R原语的开销。接下来的步骤：</p><p> direct access to primitives written in C without incurring atruntime the cost of a lookup due to R’s dynamic binding. Currently,this involves poking a bit deeper into the internals of R than isentirely reasonable, but we’re working to make this easier in futureversions of R.</p><p>直接访问用C编写的原语，而不会因为R的动态绑定而在运行时招致查找成本。目前，这涉及到比完全合理的更深入地研究R的内部，但我们正在努力在R的未来恢复中使这一点变得更容易。</p><p> Better Windows support: currently Windows support is highlyexperimental, and the installation instructions need to be sortedout. Any help appreciated.</p><p>更好的Windows支持：目前对Windows的支持主要是试验性的，安装说明还需要整理。如有任何帮助，我将不胜感激。</p><p> Alexander Vershilov has contributed a newimplementation of quasiquoters that should significantly speed upcompile times for large quasiquotations.</p><p>Alexander Vershilov贡献了一个新的准引号实现，它应该会大大加快大型准引号的加速编译时间。</p><p> If you’re interested in this line of work and want to keep abreast ofany significant updates, do sign up to the  HaskellR mailing list.</p><p>如果您对这项工作感兴趣，并想了解任何重要的更新，请务必注册HaskellR邮件列表。</p><p> Special thanks to Dave Balaban for his help and support, and to theearly users of HaskellR and previous incarnations.</p><p>特别感谢Dave Balaban的帮助和支持，以及HaskellR和以前版本的早期用户。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.tweag.io/blog/2015-09-08-programming-r-at-native-speed-in-haskell/">https://www.tweag.io/blog/2015-09-08-programming-r-at-native-speed-in-haskell/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/haskell/">#haskell</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/native/">#native</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1032935.html"><img src="http://img2.diglog.com/img/2020/11/thumb_c72a4bdf84c77ccc3eff0558d5edc17a.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032935.html">大流行将如何影响软件编程工作？</a></div><span class="my_story_list_date">2020-11-3 15:9</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032918.html"><img src="http://img2.diglog.com/img/2020/11/thumb_0cc89c062fa51d7ddb60a4c7ab23abb9.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032918.html">信号量(编程)</a></div><span class="my_story_list_date">2020-11-3 13:55</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032711.html"><img src="http://img2.diglog.com/img/2020/11/thumb_5e2df8cc5948ef745d260d73d8ee4226.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032711.html">计算机编程课程应该把重点放在项目上而不是“逻辑谜题”上吗？</a></div><span class="my_story_list_date">2020-11-2 10:44</span></div><div class="col-sm"><div><a target="_blank" href="/story/1032551.html"><img src="http://img2.diglog.com/img/2020/11/thumb_0a8f1c493ac8e56198471312bf491773.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1032551.html">关于编程的文章我想了很多</a></div><span class="my_story_list_date">2020-11-1 6:11</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>