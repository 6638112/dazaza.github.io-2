<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>为什么证明助手使用从属类型理论而不是集合理论？Why do proof assistants use dependent type theory instead of set theory?</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Why do proof assistants use dependent type theory instead of set theory?<br/>为什么证明助手使用从属类型理论而不是集合理论？</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-21 23:15:58</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/3cf11483891a9fc23a4c96f0bf5dd58c.png"><img src="http://img2.diglog.com/img/2020/11/3cf11483891a9fc23a4c96f0bf5dd58c.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>$\begingroup$  In his talk,  The Future of Mathematics,  Dr. Kevin Buzzard states that  Lean is the only existing proof assistant suitable for formalizing  all of math. In the Q&amp;A part of the talk (at  1:00:00) he justifies this as follows:</p><p>\\ begingroup $在演讲中，凯文·巴扎德（Kevin Buzzard）博士指出，精益是唯一适用于形式化所有数学的现有证明助手。在演讲的“问答环节”（1:00:00）中，他提出以下理由：</p><p>  My question is about the first of these: Why is automation very difficult with set theory (compared to dependent type theory)?</p><p>  我的问题是关于第一个问题的：为什么集合论（与从属类型论相比）很难实现自动化？</p><p>      $\endgroup$</p><p>      $ \ endgroup $</p><p>  $\begingroup$  It&#39;s also tempting to ask about accuracy of the sentence that it&#39;s the only existing such proof assistant which suggests that other proof assistants such as  Coq are not &#34;suitable for formalizing all of math&#34;.  $\endgroup$–  YCor</p><p>  $ \ begingroup $也很想问一句句子的准确性，它是现有的唯一这样的证明助手，它表明其他证明助手（例如Coq）“不适合将所有数学形式化”。 $ \ endgroup $ – YCor</p><p>  $\begingroup$  I hope Buzzard joins the discussion. But one thing I found strange is this mention of &#34;chaps&#34; around Voevodsky who haven&#39;t done anything with Coq except formalize rings and modules. Did I hear that correctly? It sounded really misleading. Clearly there are extensive libraries of math formalized by Coq; for example, the formalization of the odd order theorem (finite groups of odd order are solvable) by Gonthier et al. was one such tour de force, although not necessarily one developed by the &#34;Voevodsky chaps&#34;.  $\endgroup$–  Todd Trimble ♦</p><p>  $ \ begingroup $我希望Buzzard参与讨论。但是我发现奇怪的是，这一次提到了Voevodsky周围的“小伙子”，除了对环和模块进行形式化之外，他们对Coq并没有做任何事情。我没听错吗？听起来确实令人误解。显然，有很多由Coq正规化的数学库；例如，Gonthier等人将奇数定理形式化（可解决奇数有限组）。是一种这样的巡回演出，尽管不一定是“ Voevodsky小伙子”开发的。 $ \ endgroup $ – Todd Trimble♦</p><p>  $\begingroup$  @TimothyChow Thanks; I listened again and you&#39;re right. Still, I&#39;m not sure how to take this assertion of &#34;doing nothing&#34;.  $\endgroup$–  Todd Trimble ♦</p><p>$ \ begingroup $ @TimothyChow谢谢；我再次听了，你是对的。不过，我不确定如何接受“无所作为”的主张。 $ \ endgroup $ – Todd Trimble♦</p><p>  $\begingroup$  Let me state, once again, that I thoroughly regret bad-mouthing Coq in a talk which I had no idea would go &#34;viral&#34; to the extent that it has.  $\endgroup$–  Kevin Buzzard</p><p>  $ \ begingroup $让我再说一次，我对Coq口臭的事感到非常遗憾，我不知道会不会对Coq造成严重影响。 $ \ endgroup $ –凯文·巴扎德</p><p>  $\begingroup$  Yes, this summarises it well! I have given 20+ talks on this stuff now, and some get recorded, but somehow this one talk went crazy and I completely inadvertantly upset a bunch of Coq users. I do have strong opinions about what is good and bad about the Coq ecosystem but I do a poor job of summarising them in the talk. I have posted far more well-thought-out comments elsewhere (e.g. on the Coq Zulip) but nothing gets the traction of this talk.  $\endgroup$–  Kevin Buzzard</p><p>  $ \ begingroup $是的，这很好地概括了它！现在，我已经就此问题进行了20多次演讲，并且有一些录音被记录在案，但是不知何故，这一演讲变得疯狂了，我完全无意间使一堆Coq用户不安。对于Coq生态系统的优缺点，我确实有很强的看法，但是在演讲中总结它们时我做得很糟糕。我在其他地方（例如在Coq Zulip上）发表了更多经过深思熟虑的评论，但没有任何内容可以吸引此演讲。 $ \ endgroup $ –凯文·巴扎德</p><p>  $\begingroup$  I apologize for writing a lengthy answer, but I get the feeling the discussion about foundations for formalized mathematics are often hindered by lack of information.</p><p>  $ \ begingroup $我写了一个冗长的答案表示歉意，但是我感到关于形式化数学基础的讨论通常由于缺乏信息而受阻。</p><p> I have used proof assistants for a while now, and also worked on their design and implementation. While I will be quick to tell jokes about set theory, I am bitterly aware of the shortcomings of type theory, very likely more so than the typical set theorist. (Ha, ha, &#34;typical set theorist&#34;!) If anyone can show me how to improve proof assistants with set theory, I will be absolutely deligthed! But it is not enough to just have good ideas – you need to test them in practice on large projects, as many phenomena related to formalized mathematics only appear once we reach a certain level of complexity.</p><p> 我已经使用了一段时间的证明助手，并且还进行了他们的设计和实现。尽管我会很快讲一些关于集合论的笑话，但我非常痛苦地意识到类型论的缺点，很可能比典型的集合论者更是如此。 （哈，哈，“典型的集合论者”！）如果有人可以向我展示如何用集合论来改进证明助手，那么我绝对会感到无所适从！但是仅仅拥有一个好的想法是不够的–您需要在大型项目中进行实践测试，因为与形式化数学相关的许多现象只有在达到一定程度的复杂性后才会出现。</p><p>  The architecture of modern proof assistants is the result of several decades of experimentation, development and practical experience. A proof assistant incorporates not one, but several formal systems.</p><p>现代证明助手的体系结构是数十年实验，开发和实践经验的结果。证明助手不包含一个，而是包含多个正式系统。</p><p> The central component of a proof assistant is the  kernel, which validates every inference step and makes sure that proofs are correct. It does so by implementing a formal system  $F$ (the  foundation) which is expressive enough to allow formalization of a large amount of mathematics, but also simple enough to allow an efficient and correct implementation.</p><p> 证明助手的核心组件是内核，它可验证每个推理步骤并确保证明正确。它是通过实现一个正式的系统$ F $（基础）来实现的，该系统的表现力足以允许大量数学的形式化，但又足够简单以允许高效且正确的实现。</p><p> The foundational system implemented in the kernel is too rudimentary to be directly usable for sophisticated mathematics. Instead, the user writes their input in a more expressive formal language  $V$ (the  vernacular) that is designed to be practical and useful. Typically  $V$ is quite complex so that it can accommodate various notational conventions and other accepted forms of mathematical expression. A second component of the proof assistant, the  elaborator, translates  $V$ to  $F$ and passes the translations to the kernel for verification.</p><p> 内核中实现的基础系统太基本，无法直接用于复杂的数学。取而代之的是，用户使用一种更具表现力的形式化语言$ V $（白话）来编写他们的输入，这种语言被设计成实用且有用的。通常$ V $非常复杂，因此可以容纳各种符号约定和其他可接受的数学表达形式。证明助手的第二个组成部分，细化器，将$ V $转换为$ F $，并将转换结果传递给内核进行验证。</p><p> A proof assistant may incorporate a third formal language  $M$ (the  meta-language), which is used to implement proof search, decision procedures, and other automation techniques. Because the purpose of  $M$ is to implement algorithms, it typically resembles a programming language. The distinction between  $M$ and  $V$ may not be very sharp, and sometimes they are combined into a single formalism. From mathematical point of view,  $M$ is less interesting that  $F$ and  $V$, so we shall ignore it.</p><p> 证明助手可以合并第三种正式语言$ M $（元语言），该语言用于实现证明搜索，决策程序和其他自动化技术。因为$ M $的目的是实现算法，所以它通常类似于编程语言。 $ M $和$ V $之间的区别可能不是很明显，有时它们被合并为一个形式主义。从数学角度来看，$ M $比$ F $和$ V $有趣，因此我们将忽略它。</p><p>  The correctness of the entire system depends on the correctness of the kernel. A bug in the kernel allows invalid proofs to be accepted, whereas a bug in any other component is just an annoyance. Therefore, the foundation  $F$ should be simple so that we can implement it reliably. It should not be so exotic that logicians cannot tell how it relates to the accepted foundations of mathematics. Computers are fast, so it does not matter (too much) if the translation from  $V$ to  $F$ creates verbose statements. Also,  $F$ need not be directly usable by humans.</p><p>  整个系统的正确性取决于内核的正确性。内核中的错误允许接受无效的证明，而任何其他组件中的错误仅是一个烦人。因此，基础$ F $应该很简单，以便我们可以可靠地实现它。它不应太过奇特，以至于逻辑学家无法说出它与公认的数学基础之间的关系。计算机速度很快，因此从$ V $到$ F $的转换是否产生冗长的语句并不重要（太多）。同样，$ F $不必直接由人类使用。</p><p> A suitable variant of set theory or type theory fits these criteria. Indeed Mizar is based on set theory, while HOL, Lean, Coq, and Agda use type theory in the kernel. Since both set theory and type theory are mathematically very well understood, and more or less equally expressive, the choice will hinge on technical criteria, such as availability and efficiency of proof-checking algorithms.</p><p>集合论或类型论的合适变体符合这些标准。实际上，Mizar是基于集合论的，而HOL，Lean，Coq和Agda则在内核中使用类型论。由于集合论和类型论在数学上都非常了解，并且或多或少地具有同等的表现力，因此选择将取决于技术标准，例如证明检查算法的可用性和效率。</p><p>   For the vernacular to be useful, it has to reflect mathematical practice as much as possible. It should allow expression of mathematical ideas and concepts directly in familiar terms, and without unnecessary formalistic hassle. On the other hand,  $V$ should be a formal language so that the elaborator can translate it to the foundation  $F$.</p><p>   为了使本地语言有用，它必须尽可能地反映数学实践。它应该允许以熟悉的术语直接表达数学思想和概念，而没有不必要的形式主义麻烦。另一方面，$ V $应该是一种正式的语言，以便制作者可以将其翻译为基础$ F $。</p><p> To learn more about what makes  $V$ good, we need to carefully observe how mathematicians  actually write mathematics. They produce  complex webs of definitions, theorems, and constructions, therefore  $V$ should support  management of large collections of formalized mathematics. In this regards we can learn a great deal by looking at how programmers organize software. For instance, saying that a body of mathematics is &#34;just a series of definitions, theorems and proofs&#34; is a naive idealization that works in certain contexts, but certainly not in practical formalization of mathematics.</p><p> 要了解有关使$ V $变得更好的原因的更多信息，我们需要仔细观察数学家如何实际编写数学。它们产生定义，定理和构造的复杂网络，因此$ V $应该支持对大量正规数学的管理。在这方面，通过查看程序员如何组织软件，我们可以学到很多东西。例如，说一个数学主体是“只是一系列定义，定理和证明”，这是一种幼稚的理想化，它在某些情况下有效，但在数学的实际形式化中肯定不是。</p><p> Mathematicians omit a great deal of information in their writings, and are quite willing to sacrifice formal correctness for succinctness. The reader is expected to fill in the missing details, and to rectify the imprecisions. The proof assistant is expected to do the same. To illustrate this point, consider the following snippet of mathematical text:</p><p> 数学家在他们的著作中省略了大量信息，并且非常愿意为了简洁而牺牲形式上的正确性。希望读者填写缺少的细节，并纠正不正确之处。证明助手将执行相同的操作。为了说明这一点，请考虑以下数学文本片段：</p><p> Let  $U$ and  $V$ be vector spaces and  $f : U \to V$ a linear map. Then  $f(2 \cdot x + y) = 2 \cdot f(x) + f(y)$ for all  $x$ and  $y$.</p><p> 假设$ U $和$ V $为向量空间，$ f：U \至V $为线性映射。那么对于所有$ x $和$ y $，$ f（2 \ cdot x + y）= 2 \ cdot f（x）+ f（y）$。</p><p> Did you understand it? Of course. But you might be quite surprised to learn how much guesswork and correction your brain carried out:</p><p>你听懂了吗当然。但是，您可能会惊讶地发现大脑进行了多少猜测和纠正：</p><p> The field of scalars is not specified, but this does not prevent you from understanding the text. You simply assumed that there is some underlying field of scalars  $K$. You might find out more about  $K$ in subsequent text. ( $K$ is an  existential variable.)</p><p> 标量字段未指定，但这不会阻止您理解文本。您仅假设存在标量$ K $的一些基础字段。您可能会在随后的文本中找到有关$ K $的更多信息。 （$ K $是一个存在变量。）</p><p> Strictly speaking &#34; $f : U \to V$&#34; does not make sense because  $U$ and  $V$ are not sets, but structures  $U = (|U|, 0_U, {+}_U, {-}_U, {\cdot}_U)$ and  $V = (|V|, 0_V, {+}_V, {-}_V, {\cdot}_V)$. Of course, you correctly surmised that  $f$ is a map between the  carriers, i.e.,  $f : |U| \to |V|$. (You inserted an  implicit coercion from a vector space to its carrier.)</p><p> 严格来说“ $ f：U \ to V $”没有意义，因为$ U $和$ V $没有设置，而是结构$ U =（| U |，0_U，{+} _ U，{-} _ U， {\ cdot} _U）$和$ V =（| V |，0_V，{+} _ V，{-} _ V，{\ cdot} _V）$。当然，您正确地推测$ f $是运营商之间的映射，即$ f：| U |。 \至| V | $。 （您从向量空间向其载体插入了隐式强制。）</p><p> What do  $x$ and  $y$ range over? For  $f(x)$ and  $f(y)$ to make sense, it must be the case that  $x \in |U|$ and  $y \in |U|$. (You  inferred the domain of  $x$ and  $y$.)</p><p> $ x $和$ y $的范围是多少？为了使$ f（x）$和$ f（y）$有意义，必须是$ x \ in | U | $和$ y \ in | U | $。 （您推断出$ x $和$ y $的域。）</p><p> In the equation,  $+$ on the left-hand side means  $+_{U}$, and  $+$ on the right-hand side  ${+}_V$, and similarly for scalar multiplication. (You reconstructed the  implicit arguments of  $+$.)</p><p> 在等式中，左侧的$ + $表示$ + _ {U} $，右侧的$ + $是$ {+} _ V $，对于标量乘法也类似。 （您重构了$ + $的隐式参数。）</p><p> The symbol  $2$ is a natural number, as every child knows, but clearly it is meant to denote the scalar  $1_K +_K 1_K$. (You again inserted an  implicit coercion from  $\mathbb{N}$ to  $K$ that maps  $n$ to the  $n$-fold sum of  $1_K$&#39;s.)</p><p>每个孩子都知道，符号$ 2 $是一个自然数，但显然它的意思是表示标量$ 1_K + _K 1_K $。 （您再次从$ \ mathbb {N} $插入到$ K $的隐式强制，将$ n $映射为$ 1 $ K $的$ n $倍数。）</p><p> The vernacular  $V$ must support these techniques, and many more, so that they can be implemented in the elaborator. It cannot be anything as simple as ZFC with first-order logic and definitional extensions, or bare Martin-Löf type theory. You may consider the development of  $V$ to be outside of scope of mathematics and logic, but then do not complain when computer scientist fashion it after their technology.</p><p> 本地的$ V $必须支持这些技术，以及更多其他技术，以便可以在详细说明中实现它们。它不能像具有一阶逻辑和定义扩展的ZFC或单纯的Martin-Löf类型理论那样简单。您可能会认为$ V $的开发超出了数学和逻辑的范围，但是当计算机科学家按照他们的技术塑造它时，不要抱怨。</p><p> I have never seen any serious proposals for a vernacular based on set theory. Or to put it another way, as soon as we start expanding and transforming set theory to fit the requirements for  $V$, we end up with something that looks a lot like type theory. (You may entertain yourself by thinking how set theory could be used to detect that  $f : U \to V$ above does not make sense unless we insert coercions – for if everthying is a set then so are  $U$ and  $V$, in which case  $f : U \to V$  does make sense.)</p><p> 我从未见过针对基于集合论的本地语言的任何严肃建议。或者换句话说，一旦我们开始扩展和转换集合论以适应$ V $的要求，我们最终得到的东西看起来很像类型论。 （您可以考虑如何用集合论来检测$ f：U \ to V $才有意义，除非我们插入强制–因为如果一切都是集合，那么$ U $和$ V $也是如此。 ，在这种情况下，$ f：U \ to V $确实有意义。）</p><p>  An important aspect of suitability of foundation is its ability to detect mistakes. Of course, its purpose is to prevent logical errors, but there is more to mistakes than just violation of logic. There are formally meaningful statements which, with very high probability, are mistakes. Consider the following snippet, and read it carefully:</p><p>  基础适用性的一个重要方面是其发现错误的能力。当然，它的目的是防止逻辑错误，但是错误不仅限于违反逻辑。有形式上有意义的陈述，很可能是错误。请考虑以下代码片段，并仔细阅读：</p><p> Definition: A set  $X$ is  jaberwocky when for every  $x \in X$ there exists a bryllyg  $U \subseteq X$ and an uffish  $K \subseteq X$ such that  $x \in U$ and  $U \in K$.</p><p> 定义：当每个$ x \ in X $中存在一个bryllyg $ U \ subseteq X $和一个乏味的$ K \ subseteq X $使得$ x \ in U $和$ U \ in时，集合$ X $是jaberwocky K $。</p><p> Even if you have never read Lewis Carroll&#39;s works, you should wonder about &#34; $U \in K$&#34;. It looks like &#34; $U \subseteq K$&#34; would make more sense, since  $U$ and  $K$ are both subsets of  $X$. Nevertheless, a proof assistant whose foundation  $F$ is based on ZFC will accept the above definition as valid, even though it is very unlikely that the human intended it.</p><p>即使您从未阅读过Lewis Carroll的作品，您也应该对“ $ U \ in K $”感到好奇。看起来“ $ U \ subseteq K $”更有意义，因为$ U $和$ K $都是$ X $的子集。尽管如此，其基础$ F $基于ZFC的证明助手将接受上述定义为有效，即使人类不太可能使用它。</p><p> A proof assistant based on type theory would reject the definition by stating that &#34; $U \in K$&#34; is a type error.</p><p> 基于类型理论的证明助手会通过声明“ $ U \ in K $”是类型错误来拒绝该定义。</p><p> So suppose we use a set-theoretic foundation  $F$ that accepts any syntactic formula as valid. In such a system writing &#34; $U \in K$&#34; is meaningful and therefore the above definition will be accepted by the kernel. If we want the proof assistant to actually  assist the human, it has to contain an additional mechanism that will flag &#34; $U \in K$&#34; as suspect, despite the kernel being happy with it. But what is this additional mechanism, if not just a second kernel based on type theory?</p><p> 因此，假设我们使用集合理论基础$ F $，该基础接受任何语法公式均有效。在这样的系统中，写“ $ U \ in K $”是有意义的，因此内核将接受上述定义。如果我们希望证明助手真正地帮助人类，它就必须包含一个附加机制，即使内核对此感到满意，该机制仍会将“ $ U \ in K $”标记为可疑对象。但是，如果不仅仅是基于类型理论的第二个内核，那么这种额外的机制又是什么呢？</p><p> I am not saying that it is impossible to design a proof assistant based on set theory. After all,  Mizar, the most venerable of them all, is designed precisely in this way – set theory with a layer of type-theoretic mechanisms on top. But I cannot help to wonder: why bother with the set-theoretic kernel that requires a type-theoric fence to insulate the user from the unintended permissiveness of set theory?</p><p> 我并不是说不可能基于集合论来设计证明助手。毕竟，所有这些中最受尊敬的Mizar都是以这种方式精确设计的-集合论在顶部具有类型理论机制的层。但是我不禁要问：为什么要烦恼需要集合类型理论的围栏的集合论内核，以使用户免受集合论的意料之外的限制？</p><p>    $\endgroup$</p><p>    $ \ endgroup $</p><p>  $\begingroup$  Very informative answer! But I don&#39;t understand the remark that &#34;a proof assistant whose foundation $F$ is based on ZFC will accept the above definition as valid.&#34; Whether it gets accepted depends on the vernacular rather than the foundation, doesn&#39;t it? What&#39;s to stop someone from building a vernacular that is similar to type theory on top of a set-theoretic foundation? That seems to be the natural thing to do if we want to be able to calibrate logical strength in terms of set-theoretic axioms but want the advantages of type theory in the human interface.  $\endgroup$–  Timothy Chow</p><p>$ \ begingroup $非常有用的答案！但是我不明白“基于ZFC的基础$ F $的证明助手将接受上述定义为有效的说法”。它是否被接受取决于白话而不是基础，不是吗？是什么阻止某人在集合论基础上构建类似于类型理论的白话语言？如果我们希望能够根据集合论公理来校准逻辑强度，但又希望在人机界面中使用类型论的优势，那似乎是很自然的事情。 $ \ endgroup $ –蒂莫西·周</p><p>  $\begingroup$  Andrej, thanks a lot for this great answer! (Super minor nitpick: let&#39;s see whether the meta-language $M$ is not important for mathematicians. It might turn out that it is important that mathematicians/users can easily write short amounts of meta code that codify proof methods specific to a certain subfield of maths. Example: in my recent project with Rob Lewis formalising the ring of Witt vectors, we wrote tactics (meta code) for so-called &#34;ghost calculations&#34; — a common method specific to Witt vectors. This allowed us to then write 2-line proofs of many identities, mimicking the informal.)  $\endgroup$–  jmc</p><p>  $ \ begingroup $ Andrej，非常感谢您的出色回答！ （超级未成年人nitpick：让我们看看元语言$ M $对数学家来说是否不重要。事实证明，重要的是，数学家/用户可以轻松地编写少量的元代码来整理特定于子字段的证明方法例如：在我最近与Rob Lewis进行Witt向量环的形式化的项目中，我们为所谓的“重影计算”（即Witt向量的通用方法）编写了战术（元代码），这使我们得以写出2许多身份的在线证明，模仿非正式证明。）$ \ endgroup $ – jmc</p><p>  $\begingroup$  @TimothyChow Metamath in particular was designed with this use case in mind; the tool reports what axioms any particular theorem depends on, and there are a lot of redundant axioms specifically so that you can prove a theorem with the minimum axiomatic strength for which it holds; since the entire library is written that way you can both find out if a given proof is in ZF-replacement, and also a nontrivial fraction of theorems are in fact in that subset.  $\endgroup$–  Mario Carneiro</p><p>  $ \ begingroup $ @TimothyChow Metamath在设计时就考虑了这种用例；该工具报告任何特定定理所依赖的公理，并且有许多专门的冗余公理，以便您可以用其所具有的最小公理强度来证明一个定理；由于整个库都是以这种方式编写的，因此您既可以找出给定的证明是否在ZF替换中，也可以在该子集中找到不平凡的定理。 $ \ endgroup $ – Mario Carneiro</p><p>  $\begingroup$  This is a really fantastic answer, MathOverflow at its best. Two questions/objections, though: (1) &#34;A bug in the kernel allows invalid proofs to be accepted, whereas a bug in any other component is just an annoyance&#34;: what about a bug in the elaborator? Couldn&#39;t that be catastrophic too? (2) I see no implicit coercion in &#34;let $U$ and $V$ be vector spaces and $f: U \to V$ a linear map&#34;. As a category theorist, I take you at your word. $f$ is a linear map between vector spaces, and that&#39;s that. It&#39;s an arrow in $\mathbf{Vect}$. Sets simply aren&#39;t mentioned here... right?  $\endgroup$–  Tom Leinster</p><p>  $ \ begingroup $这是一个非常了不起的答案，MathOverflow处于最佳状态。但是，有两个问题/异议：（1）“内核中的错误允许接受无效的证明，而其他任何组件中的错误仅是一个烦人”：细化器中的错误如何处理？那不是灾难性的吗？ （2）在“让$ U $和$ V $为向量空间，而$ f：U \ to V $为线性映射”中，我看不到任何隐式强制。作为分类理论家，我相信你的话。 $ f $是向量空间之间的线性映射，仅此而已。这是$ \ mathbf {Vect} $中的箭头。简而言之，这里没有提及集吧？ $ \ endgroup $ –汤姆·伦斯特</p><p>  $\begingroup$  @TomLeinster However, under that interpretation (which I would also favor), you then have to implicitly coerce your linear map to a set-function in order to write $f(x)$. (-:  $\endgroup$–  Mike Shulman</p><p>  $ \ begingroup $ @TomLeinster但是，在这种解释下（我也希望这样做），然后您必须隐式将线性映射强制转换为集合函数，以便编写$ f（x）$。 （-：$ \ endgroup $ –́ Mike Shulman</p><p>   $\begingroup$  I personally believe that the work Kevin Buzzard is doing is excellent; at the same time, he has strong opinions about proof assistants that are not universally shared, so you should take those opinions with a grain of salt.</p><p>$ \ begingroup $我个人认为Kevin Buzzard所做的工作非常出色；同时，他对尚未普遍使用的证明助手有很强的见解，因此您应该一丁点儿接受这些见解。</p><p> In 2018, John Harrison gave a talk entitled,  Let&#39;s make set theory great again!. IMO, the slides to Harrison&#39;s talk provide a more balanced discussion of the pros and cons of using set theory than Buzzard does.</p><p> 在2018年，约翰·哈里森（John Harrison）进行了题为``让集合理论再次变得伟大！''的演讲。 IMO，Harrison演讲的幻灯片比Buzzard更加平衡地讨论了使用集合论的利弊。</p><p> Regarding Lean, a couple of years ago, Tom Hales provided a  review of the Lean theorem prover that spells out the pros and cons as he saw them at the time. Some of what he said may no longer be true today, but one thing that is true is that even Lean enthusiasts agree that there are flaws that they promise will be fixed in Lean Version 4 (which unfortunately is going to be incompatible with Lean 3, or so I hear).</p><p> 关于精益，几年前，汤姆·海尔斯（Tom Hales）对精益定理证明者进行了回顾，阐明了当时所见的利弊。他所说的某些内容在今天可能已不再适用，但事实是，即使精益爱好者也同意，他们承诺将在精益版本4中修复一些缺陷（不幸的是，该缺陷将与精益3不兼容，或我听到）。</p><p>    $\endgroup$</p><p>    $ \ endgroup $</p><p>  $\begingroup$  John Harrison&#39;s slides are a fine collection of suggestions, but there is a long way from having good ideas about theorem provers to implementing them and trying them out. Has Harisson worked on the ideas?  $\endgroup$–  Andrej Bauer</p><p>  $ \ begingroup $ John Harrison的幻灯片是一组很好的建议，但是从对定理证明者有好的想法到实施并尝试它们还有很长的路要走。哈里森是否已经研究过这些想法？ $ \ endgroup $ –安德烈·鲍尔（Andrej Bauer）</p><p>      $\begingroup$  I never insisted that one way is uniformly better than the other. In any case, I explained my position more carefully in a separate answer.  $\endgroup$–  Andrej Bauer</p><p>$ \ begingroup $我从未坚持过一种方法总比另一种方法更好。无论如何，我都会在一个单独的答案中更仔细地解释我的立场。 $ \ endgroup $ –安德烈·鲍尔（Andrej Bauer）</p><p>  $\begingroup$  When I am doing counting, I like my natural numbers to start at 0 (because some sets are empty). When I am doing primes and factoring, I like them to start at 1 (otherwise I have to continually have to write &#34;if n isn&#39;t zero then...&#34;). My feelings about sets and types are the same -- different foundational systems make different things easier/nicer.  $\endgroup$–  Kevin Buzzard</p><p>  $ \ begingroup $进行计数时，我喜欢自然数从0开始（因为某些集合为空）。当我做质数和因式分解时，我喜欢它们从1开始（否则，我必须不断写“如果n不为零，则...”）。我对集合和类型的感觉是相同的-不同的基础系统使不同的事情变得更容易/更简单。 $ \ endgroup $ –凯文·巴扎德</p><p>   $\begingroup$  I still find it very surprising that this random talk I gave attracts so much attention, especially as not everything I said was very well thought out. I am more than happy to engage with people in discussions about what I said and whether or not some things I said were ill-informed.</p><p>   $ \ begingroup $我仍然感到非常惊讶，我所进行的这种随机交谈吸引了如此多的关注，特别是因为并非我所说的一切都经过深思熟虑。我非常乐意与人们进行讨论，讨论我所说的话以及我所说的某些话是否不了解情况。</p><p> But onto my answer to your question: whilst I am not an expert in proof assistants in general (I have become knowledgeable at precisely  one proof assistant and have limited experience with others), it is my empirical observation that high-level tactics like Lean&#39;s  ring tactic, which will  prove results like  $(x+2y)^3=x^3+6x^2y+12xy^2+8y^3$ immediately -- and there are similar tactics in Coq and Isabelle/HOL, two more type theory systems -- do not seem to exist in the two main set theory formal proof systems, namely Metamath and Mizar. I don&#39;t really know why, but those are the facts. Note that the proof of this from the axioms of a ring is extremely long and uncomfortable, because you need to apply associativity and commutativity of addition and multiplication many times -- things mathematicians do almost without thinking.</p><p> 但是，在我对您的问题的回答上：尽管我一般不是专家证明专家（我已经成为一名专家的知识渊博，并且对其他人的经验有限），但是根据我的经验观察，像精益钻戒这样的高级策略策略，它将立即证明$（x + 2y）^ 3 = x ^ 3 + 6x ^ 2y + 12xy ^ 2 + 8y ^ 3 $这样的结果-在Coq和Isabelle / HOL中也有类似的策略，另外两种类型理论系统-似乎不存在于两个主要的集合理论形式证明系统中，即Metamath和Mizar。我真的不知道为什么，但是这些都是事实。请注意，从环的公理来证明这一点非常长且令人不舒服，因为您需要多次应用加法和乘法的关联性和可交换性-数学家所做的事情几乎没有考虑。</p><p>    $\endgroup$</p><p>    $ \ endgroup $</p><p>  $\begingroup$  So echoing a comment that Andrej made -- as well as asking &#34;what can be done in theory?&#34;, in this game an equally important question is &#34;what can be done in practice?&#34; Mario Carneiro is an expert in both Metamath and Lean, and he wrote Lean&#39;s ring tactic in just a few days as far as I could see, but Metamath still has no ring tactic.  $\endgroup$–  Kevin Buzzard</p><p>$ \ begingroup $因此，在回应游戏中，安德烈（Andrej）提出了一个评论-并问“理论上可以做什么？”，在这个游戏中，一个同样重要的问题是“实践中可以做什么？” Mario Carneiro是Metamath和Lean的专家，据我所知，他在短短几天内就写下了Lean的铃声策略，但Metamath仍然没有铃声策略。 $ \ endgroup $ –凯文·巴扎德</p><p>  $\begingroup$  Part of the reason I didn&#39;t write ring for Metamath is because there weren&#39;t that many examples that came up that couldn&#39;t be done manually with a better proof; in metamath a tactic that creates ugly proofs is a much harder sell because every single line of the proof is laid bare for everyone to read. The numeric evaluator (aka  norm_num in lean)  was written in metamath and contains the same techniques as a ring tactic would have.  $\endgroup$–  Mario Carneiro</p><p>  $ \ begingroup $我没有为Metamath写戒指的部分原因是因为没有太多的例子无法用更好的证据手动完成。在元数学中，创建丑陋证明的策略很难出售，因为证明的每一行都暴露给所有人阅读。数字评估器（又名lean的norm_num）是用metamath编写的，并且包含与环战术相同的技术。 $ \ endgroup $ – Mario Carneiro</p><p>  $\begingroup$  ... The current proof assistant I am working in, Metamath Zero, is based on peano arithmetic, not even set theory, and a ring tactic would be similarly easy to write as in lean. This has more to do with the framework around the language rather than the formal system (in Andrej&#39;s terminology: $M$ matters for writing automation, not $F$), and the problem with Metamath is that $M$ is in no way encoded in the &#34;deliverables&#34;, so every author must discover it for themselves.  $\endgroup$–  Mario Carneiro</p><p>  $ \ begingroup $ ...我正在使用的当前证明助手Metamath Zero是基于peano算术，甚至没有集合论，并且环法与lean一样容易编写。这更多地与语言框架有关，而不是与形式系统有关（用Andrej的话说：$ M $对于编写自动化来说很重要，而不是$ F $），而Metamath的问题在于$ M $根本没有编码在“可交付成果”中，因此每个作者都必须亲自发现它。 $ \ endgroup $ – Mario Carneiro</p><p>   $\begingroup$  I&#39;ll answer just the automation question since the other answers gave nice broad overview, but didn&#39;t seem focus on that narrow question. My own direct automation experience is wrt to ACL2, Lean and SMT-based solvers.</p><p>   $ \ begingroup $我将只回答自动化问题，因为其他答案给出了很好的概括，但似乎没有集中在这个狭窄的问题上。我自己的直接自动化经验是使用ACL2，精益和基于SMT的求解器。</p><p> Strictly speaking, I don&#39;t know if there&#39;s any foundational argument for why set theory would be better or worse than the type theory-based approach in Lean.</p><p> 严格来讲，我不知道为什么精益理论中的集合论比基于类型论的方法好还是坏，有什么基础论点。</p><p> The strengths that Lean have from my perspective are: an expressive explicit type system, a relatively simple core language for representing terms, and a attention to how terms are represented for efficient manipulation.</p><p>从我的角度来看，Lean的优势在于：表达力强的显式类型系统，用于表示术语的相对简单的核心语言，以及对术语如何有效操纵表示的关注。</p><p> With regards to typed core logics, most automation in theorem provers is tailored to specific common theories that are widely used in mathematics. When writing such automation, it is important to know the types and operations involved. For example, in writing a decision procedure for linear arithmetic in an untyped language, one needs to carefully check that any transformations still make sense even if the expressions do not denote numbers. By having a typed and typechecked expression language, one gets from the theorem prover itself and does not have to pay the additional runtime and complexity costs.</p><p> 关于类型化的核心逻辑，定理证明中的大多数自动化都是针对数学中广泛使用的特定通用理论量身定制的。在编写这种自动化程序时，重要的是要知道所涉及的类型和操作。例如，在用无类型语言编写线性算术的决策程序时，即使表达式不表示数字，也需要仔细检查是否所有转换仍然有意义。通过使用经过类型验证和类型检查的表达式语言，可以从定理证明者本身获得知识，而不必支付额外的运行时和复杂性成本。</p><p> A second strength of Lean is ensuring that the core language is simple, but expressive so that one can represent proofs compactly. When using automation such as SMT solvers, the &#34;proof terms&#34; generated as evidence can be very large and the core proof language needs to be designed to compactly represent proofs while still be amenably to efficient checking. I&#39;m not sure if Lean has an advantage to Coq or other solvers here per se but it is a factor in Lean&#39;s design.</p><p> 精益的第二个优势是确保核心语言既简单又具有表达力，因此可以紧凑地表示证明。当使用诸如SMT求解器之类的自动化工具时，作为证据生成的“证明条款”可能非常庞大，并且需要设计核心证明语言以紧凑地表示证明，同时仍然要进行有效的检查。我不确定Lean本身是否对Coq或其他求解器有优势，但这是否是Lean设计的一个因素。</p><p> A third strength of Lean is that the language for writi</p><p> 精益的第三项优势是写作的语言</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://mathoverflow.net/questions/376839/what-makes-dependent-type-theory-more-suitable-than-set-theory-for-proof-assista">https://mathoverflow.net/questions/376839/what-makes-dependent-type-theory-more-suitable-than-set-theory-for-proof-assista</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/助手/">#助手</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/证明/">#证明</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>