<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在Haskell实现LLVM Micro C编译器 Implementing a LLVM Micro C compiler in Haskell</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Implementing a LLVM Micro C compiler in Haskell<br/>在Haskell实现LLVM Micro C编译器 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-05 00:56:47</div><div class="page_narrow text-break page_content"><p>In this series, we will explore how to write a compiler for a small subset of C to LLVM in Haskell. Our language, Micro C, is basically a small subset of real C. We&#39;ll have basic numeric types, a real  bool type, pointers, and structs. At the end of the series, we&#39;ll have a beautiful executable,  mcc (Micro C Compiler), that takes  one  .mc source file and produces an executable.</p><p>在本系列中，我们将探讨如何在Haskell中为LLVM的小型C子集编写编译器。我们的语言Micro C，基本上是真实C的小子集。我们有基本的数字类型，真正的BOOL类型，指针和结构。在系列末尾，我们＆＃39; LL有一个漂亮的可执行文件，MCC（Micro C编译器），它需要一个.mc源文件并生成可执行文件。</p><p>  Stephen Diehl&#39;s translation of the  kaleidescope tutorial provides an excellent introduction to building a simple language using Haskell and LLVM. However, it uses an older version of LLVM than is currently available. In particular, it was written before the  IRBuilder module was added to the Haskell bindings and required users to write a lot of plumbing themselves which is now handled by the library. Also, although kaleidescope is a fine teaching language for compiler construction, our version of C, stripped down though it is, is still meatier, and will allow us to dive a little deeper into LLVM features. Moreover, basically everyone already knows C  1, and being able to compare our compiler&#39;s output to clang&#39;s is an excellent debugging resource.</p><p>  Kaleidescope教程的斯蒂芬Diehl＆＃39的翻译提供了使用Haskell和LLVM构建简单语言的出色介绍。但是，它使用的是LLVM的旧版本而不是目前可用的。特别是，在将Irbuilder模块添加到Haskell绑定和所需用户时写入很多管道本身，它写得在图书馆处理了很多管道。此外，虽然Kaleidescope是一个用于编译器建设的精细教学语言，但我们的版本，虽然它是仍然是肉类，但允许我们深入了解LLVM功能。此外，基本上每个人都知道C 1，并且能够将我们的编译器和＃39; S输出进行比较到Clang＆＃39; s是一个很好的调试资源。</p><p>  This tutorial assumes some familiarity with Haskell. To learn the language, consult the resources mentioned in  this superb Stackoverflow answer. For reference, the Haskell used in this project falls somewhere in what that answer would deem the early intermediate category, as there are a lot of Monad transformers, but no fancy GADTs, TypeFamilies, recursion schemes, or any of the other billion extensions that GHC has to offer. While all of these advanced language features could actually be quite helpful in writing a compiler, I&#39;ve left them out of mcc in order to attempt to be more beginner friendly.</p><p>  本教程假设熟悉Haskell。要学习语言，请参阅此Superb StackOverflow答案中提到的资源。供参考，在这个项目中使用的Haskell在答案中占据了早期中级类别的答案，因为有很多Monad变形金刚，但没有花哨的加剧，衣服，递归方案或任何其他GHC的延伸必须提供。虽然所有这些高级语言特征实际上都可以在编写编译器中非常有用，但我将他们留出了MCC，以便尝试更初学者友好。</p><p>   The full Haskell source of the compiler lives at  https://github.com/jmorag/mcc.git. Getting the LLVM toolchain set up is rather involved, so in lieu of providing you with build instructions, my recommendation is to just use  nix. At the root of the repo, there is a  shell.nix file that you can use to drop into a shell with the necessary Haskell libraries,  cabal, and  clang. If running  nix-shell --pure --run &#39;cabal new-clean; cabal new-test&#39; runs smoothly, then everything should be set up correctly. If not, please open an issue.</p><p>   Compiler的完整Haskell源在https://github.com/jmorag/mcc.git上生存。获取LLVM Toolchain设置是相当涉及的，所以代替为您提供构建指令，我的推荐就是使用NIX。在repo的根目录中，有一个shell.nix文件，您可以用来删除包含必要的Haskell库，Cabal和Clang的shell。如果运行nix-shell --pure --run＆＃39; Cabal New-Clean; Cabal New-Test＆＃39;顺利运行​​，然后应该正确设置所有内容。如果没有，请打开一个问题。</p><p> Haskell tooling is constantly in flux. When I started writing Micro C, I used vim and  ale, but switched to emacs and  intero halfway through, both with stack. As of April 2020, I&#39;ve replaced intero with  dante and switched back to plain cabal, as it plays better with nix. I&#39;ve been meaning to look into  ghcide but dante works well enough for me and I haven&#39;t found the time or motivation to switch. In the case that these tools don&#39;t work or take too long to setup,  ghcid is a great fallback.</p><p> Haskell Tooling经常在助焊剂中。当我开始编写Micro C时，我使用Vim和Ale，但是通过堆栈切换到Emacs和Into Onlo。截至2020年4月，我与丁迪更换了互联网，并转回普通的Cabal，因为它与NIX更好地播放。我一直是看待GHCIDE，但Dante对我来说足够好，而且我没有找到打开的时间或动机＆＃39。在这些工具Don＆＃39; T工作或花费太多的情况下，GHCID是一个伟大的回力。</p><p>  Following  this excellent blog post by Alexis King, we&#39;ll specify our project information in a  package.yaml  2. The first few lines just specify project name and author</p><p>  遵循这篇优秀的博客文章，由Alexis King，我们在包中指定了我们的项目信息.YAML 2.前几行仅指定项目名称和作者</p><p>  We will also increase GHC&#39;s warning levels to catch more potential problems. Some of these can be annoying, but they solve many more headaches than they cause.</p><p>  我们还将增加GHC＆＃39; S警告水平以捕获更多的潜在问题。其中一些可能是令人讨厌的，但他们解决了比他们的更多头痛。 </p><p>   dependencies: - base &gt;=  4.7  &amp;&amp; &lt;  5 - mtl - array - containers - text - string-conversions - directory - process - unix - filepath - bytestring - prettyprinter - pretty-simple - llvm-hs-pure &gt;=  9  &amp;&amp; &lt;  10 - llvm-hs-pretty &gt;=  0.9  &amp;&amp; &lt;  1 - megaparsec - parser-combinators library:  source-dirs: src executable:  main: Main.hs  source-dirs: app  dependencies: - optparse-applicative - mcc tests:  testall:  main: Testall.hs  source-dirs: tests  dependencies: - tasty - tasty-golden - tasty-hunit - mcc</p><p>依赖性： - 基础＆gt; = 4.7＆amp;＆amp; ＆lt; 5  -  MTL  - 阵列 - 容器 - 文本 - 字符串转换 - 目录 - 进程 -  UNIX  -  FilePath  -  Bytestring  -  PrettyPrinter  - 漂亮简单 -  LLVM-HS-Pure＆Gt; = 9＆amp;＆amp;＆amp;＆amp; ＆lt; 10  -  llvm-hs-pretty＆gt; = 0.9＆amp;＆amp; ＆lt; 1  -  Megaparsec  -  Parser-Combinators库：source-dirs：src可执行文件：main：main.hs source-dirs：应用程序依赖项： -  OptParse应用 -  MCC测试：TestAll：Main：TestAll.HS源码：测试依赖性： - 美味 - 鲜美 - 金色 - 鲜美猎 -  MCC</p><p>   OverloadedStrings is a necessary evil to deal with Haskell&#39;s infamous string problem and  LambdaCase is a tiny syntactic extension that lets us get away with making up fewer variable names, thereby solving a  hard problem in Computer Science.</p><p>   过载机是处理Haskell＆＃39; S臭张弦问题和Lambdacase的必要罪恶是一种微小的句法延伸，让我们逃脱，弥补了更少的变量名称，从而解决了计算机科学的艰难问题。</p><p>  A compiler&#39;s job is to take one or more source files, parse them into an Abstract Syntax Tree (AST), check them for semantic errors, and if they have none, lower them to an Intermediate Representation (IR), optimize said IR, and produce an executable for the target CPU.</p><p>  编译器＆＃39; s作业是拍摄一个或多个源文件，将它们解析为抽象语法树（AST），检查它们是否进行语义错误，如果它们没有，则将其降低到中间表示（IR），优化所述IR，并为目标CPU生成可执行文件。</p><p> Different languages treat these steps differently. Lisp&#39;s syntax resembles an AST so closely that parsing is almost a no-op, whereas C has infix operators and block statements that make the transformation from a sequence of bytes to an AST nontrivial. Many dynamic languages perform almost no semantic analysis whatsoever before runtime, whereas on the other side of the spectrum, dependently typed languages perform such intricate analyses that they can prove that their programs will terminate. Our C dialect falls somewhere in the middle; we will reject programs at compile time that assign a  float to an  int type variable, but we will make no effort to do any type inference or termination checking. We will also not concern ourselves with target specific code generation, leaving that to LLVM. The basic architecture will be something like:</p><p> 不同的语言以不同的方式对待这些步骤。 Lisp＆＃39; s语法如此紧密地仔细地，解析几乎是一个no-op，而c有infix运算符和块语句，使从一系列字节序列变换到AST非活动。许多动态语言在运行时执行几乎没有语义分析，而在频谱的另一边，依赖性类型的语言执行如此复杂的分析，以便他们可以证明他们的程序将终止。我们的C方言落在中间的某个地方;我们将在编译时间拒绝程序，该程序将浮点浮到int类型变量，但我们将不努力执行任何类型的推断或终止检查。我们也不关心目标特定代码生成，将此留给LLVM。基本架构将是如下：</p><p>  Now that we&#39;ve laid out the preliminaries, we can actually start coding in  part 1!</p><p>  现在我们＆＃39;我们奠定了预先的，我们实际上可以在第1部分开始编码！</p><p> 1 and if you don&#39;t but want to work with LLVM, you should really really learn it, as LLVM is designed first and foremost as an intermediate representation for C and C++</p><p> 1，如果你不愿意使用LLVM，你应该真的真的学习它，因为LLVM首先设计为C和C ++的中间代表</p><p> 2 The native cabal format recently got support for common stanzas, eliminating much of the need to use hpack. Also, FPComplete  now recommends committing the generated cabal files, so in the future it might be a good idea to write an mcc.cabal by hand instead.</p><p> 2最近的本机Cabal格式得到了普通斯坦斯的支持，消除了大部分需要使用HP​​ACK的需求。此外，FPComplete现在建议提交生成的Cabal文件，因此在未来，它可能是一个好主意用手编写MCC.Cabal。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.josephmorag.com/posts/mcc0/">https://blog.josephmorag.com/posts/mcc0/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/实现/">#实现</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/llvm/">#llvm</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>