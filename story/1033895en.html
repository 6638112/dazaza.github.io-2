<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>解决问题的技巧</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">解决问题的技巧</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-09 02:00:02</div><div class="page_narrow text-break page_content"><p>The first category includes things like learning language syntax, constructs, and patterns. I would summarize it as the ability to connect and utilize the myriad, &#34;tools of the trade&#34; -- languages, frameworks, APIs, libraries -- to create software. There&#39;s usually tutorials for these things.</p><p>第一类包括学习语言语法、结构和模式等内容。我将其概括为能够连接和利用行业中的无数工具--语言、框架、API、库--来创建软件。通常有关于这些事情的教程。</p><p> The second category includes things that are a little bit harder to put your finger on, but can probably be best described as problem solving. It&#39;s the ability to analyze, troubleshoot, debug, or solve a problem. It&#39;s the ability to reason with abstract ideas and turn them into code.</p><p>第二类包括一些比较难理解的东西，但最好的描述可能是解决问题的方法。它是分析、故障排除、调试或解决问题的能力。它是一种用抽象的想法进行推理并将其转化为代码的能力。</p><p> There is for sure some overlap between these two categories, but this is how I like to think about it.</p><p>这两个类别之间肯定有一些重叠，但我喜欢这样想。</p><p> It&#39;s hard to be specific about what it takes to be good at problem solving. I believe that&#39;s because we all have a slightly different perception of the world around us. Everyone learns differently. There must, however, be at least some techniques that I might learn from you, and vice versa.</p><p>很难具体说明怎样才能擅长解决问题。我相信这是因为我们对周围世界的看法略有不同。每个人都学到了不同的东西。然而，至少有一些技巧可以让我向你学习，反之亦然。</p><p> Problems like the one I am about to share can be great tools for learning about problem solving. This one&#39;s from Project Euler. My intention is not to simply spoil the answer. I want to share my process of figuring it out, with the hope of being able to pinpoint some specific strategies that can be used to solve all kinds of problems.</p><p>像我将要分享的这样的问题可以成为学习解决问题的很好的工具。这是来自Project Euler的。我的意图不是简单地破坏答案。我想分享我弄清楚这个问题的过程，希望能够找出一些可以用来解决各种问题的具体策略。</p><p>  You can find the original problem statement  here. It&#39;s short, so take a moment to read through.</p><p>您可以在这里找到原始的问题陈述。它很短，所以花点时间通读一下。</p><p>  The challenge is to determine what the shortest possible secret number is. Here&#39;s an excerpt from the keylogger file.</p><p>挑战在于确定最短的可能密码是什么。以下是键盘记录程序文件的摘录。</p><p>   I began by sitting down with pencil and paper to write some numbers from the list. Writing helps me begin to think about the problem.</p><p>我开始用铅笔和纸坐下来，从清单上写下一些数字。写作帮助我开始思考这个问题。</p><p> I thought about what these numbers in the list could tell me about the secret number. Maybe I could find a way to at least figure out its length. There are about fifty numbers in the list, so maybe that number is somehow correlated to the secret number.</p><p>我想着清单上的这些数字能告诉我关于这个秘密号码的什么信息。或许我能找到一种方法至少算出它的长度。列表中大约有50个数字，所以这个数字可能与秘密数字有某种关联。</p><p> These were a few of the questions going through my head. If the answers seem super obvious to you, then congratulations, you might be smarter than me. What&#39;s most important during the first steps is that you ask questions.</p><p>这些都是我脑海中浮现的几个问题。如果你觉得答案非常明显，那么恭喜你，你可能比我聪明。在第一步中，最重要的是你要问问题。</p><p> I realized pretty quickly that no, the length of the list I was given didn&#39;t tell me much, but you&#39;ve got to start somewhere. Next, my thoughts turned to the fact that each number was three digits long.</p><p>我很快意识到不是的，我得到的名单长度并不能告诉我太多，但你总得从某个地方开始吧。接下来，我的想法转向这样一个事实：每个数字都有三位数长。</p><p> What if I was given a list of two-digit numbers, or even a list of just one-digit numbers? What could that tell me about the length of the secret number? Is there something special about three-digit numbers in particular? These were valuable questions to ask, because it helped me to simplify the problem.</p><p>如果给我一份两位数的数字列表，或者甚至只给我一位数字的列表，会怎么样？关于密码的长度，这能告诉我些什么呢？三位数有什么特别之处吗？这些都是有价值的问题，因为它帮助我简化了问题。</p><p> I made a list of one-digit numbers and tried to think about how I might be able to solve the same problem with that instead.</p><p>我列了一张一位数的单子，试着想一想，我如何才能用它来解决同样的问题。</p><p>  Given a list like this as clues, I could say for certain that the secret number has at least a 6,2,1, and 0, but I also loose essential information about the problem: The order that the numbers appear in. A list of one-digit numbers is too ambiguous. The secret number could be  6210,  2601, or any other combination, and I would have no way of knowing which one is correct.</p><p>给出一个这样的列表作为线索，我可以肯定地说，这个秘密数字至少有6、2、1和0，但我也泄露了关于这个问题的基本信息：数字出现的顺序。一位数字的列表太含糊了。密码可能是6210、2601或任何其他组合，我无法知道哪一个是正确的。</p><p> A list of two-digit numbers might be nice. It&#39;s less to think about, yet is still able to convey the needed information. From this point forward, I decided to think about the list as two-digit numbers, rather than three-digit numbers.</p><p>一份两位数的数字列表可能会更好。它不需要考虑太多，但仍然能够传达所需的信息。从现在开始，我决定把这个列表看作两位数的数字，而不是三位数的数字。</p><p>  At this point, I still wasn&#39;t sure how to solve the problem on paper, so I decided to try and work backwards. I wrote down a random number and then picked a few pairs of digits from it to try and reconstruct my own version of the problem. I decided to go through each number in the list and write down the digits as if they were being inserted into some kind of array.</p><p>在这一点上，我仍然不确定如何在纸上解决这个问题，所以我决定试着倒着做。我写下了一个随机数字，然后从其中挑选了几对数字，试图重建我自己版本的问题。我决定仔细检查列表中的每个数字，并将数字写下来，就像它们被插入到某种数组中一样。</p><p>  I realized an approach like this would not be very practical because it still leaves room for ambiguity.</p><p>我意识到这样的方法不太实际，因为它仍然留下了模棱两可的空间。</p><p> In the example above, its clear that 5 is before 2, but if I continue to add the digits from the next number, I can&#39;t tell if the 1 should come before or after the 5. It&#39;s the same problem for the 8: I know it should come before the 2, but the data says nothing about if it should be before or after the 1, or the 5.</p><p>在上面的例子中，很明显5在2之前，但如果我继续添加下一个数字中的数字，我不知道1应该在5之前还是之后。8也是同样的问题：我知道它应该在2之前，但数据没有说明它应该在1之前还是在5之后。</p><p> Even if I had another data point to disambiguate the clues --  51, for example -- sure, it would tell me that the 1 is in the correct spot between 5 and 2, but I already get the feeling that trying to write code to account for switching numbers around in an array is not going to be practical, and that there is probably an easier way.</p><p>即使我有另一个数据点来消除线索的歧义--例如51--当然，它会告诉我1位于5和2之间的正确位置，但我已经感觉到，试图编写代码来解释数组中的数字切换是不现实的，而且可能有更简单的方法。</p><p> Writing it out this way helped me realize that the help of some sort of data structure would be useful for solving this problem.</p><p>这样写出来让我意识到，某种数据结构的帮助将有助于解决这个问题。</p><p> So now the question is,  what kind of data structure could help model this problem? To help with this decision, I thought about what data is actually provided in the problem. Using the example above, the list of numbers reads as:</p><p>所以现在的问题是，什么样的数据结构可以帮助建模这个问题？为了帮助做出这个决定，我考虑了问题中实际提供了哪些数据。使用上面的示例，数字列表如下所示：</p><p>  Each number in the list provides helpful clues, but the problem is that it&#39;s difficult to keep track of how each clue ultimately fits together. I tried to think of some kind of data structure that would be able to represent each clue individually, but also as a whole.</p><p>列表中的每个数字都提供了有用的线索，但问题是很难跟踪每条线索最终是如何组合在一起的。我试着想出一种数据结构，既可以单独表示每条线索，也可以作为一个整体来表示。</p><p> A directed graph seems to be a pretty natural fit to represent this information. Each node could be a digit, and the edges between nodes could represent the relationship between them.</p><p>有向图似乎很自然地适合表示这种信息。每个节点可以是一个数字，节点之间的边可以表示它们之间的关系。</p><p>  I felt good about using a graph to solve the problem, but there were still some questions that I had to figure out.</p><p>我对用图表来解决这个问题感觉不错，但仍然有一些问题需要我去弄清楚。</p><p> How would I know when the graph has enough information to to be able to get the secret number? In other words, how can I know when my answer is conclusive?</p><p>我怎样才能知道图表何时有足够的信息来获得秘密数字呢？换句话说，我怎么知道我的答案是确凿的呢？</p><p>  What if a secret number had more than one of the same digit? Would that ruin my approach?</p><p>如果一个秘密号码有多个相同数字怎么办？这会毁了我的方法吗？</p><p>  To help answer this question I used the same technique of creating a simplified version of the problem and working backwards. Pretend now that 157 is the secret number. How many edges between the nodes would it take to definitively say that 1 comes before both 5 and 7, and 5 comes before 7? The answer is three edges for this particular graph.</p><p>为了帮助回答这个问题，我使用了同样的技术，即创建问题的简化版本并向后处理。现在假设157是密码。节点之间需要多少条边才能确定1在5和7之前，5在7之前？答案是这个特殊图形的三条边。</p><p>  In this example, the order is known when number of edges are equal to the number of nodes.  Is it that simple? Can we know what the secret number is if the number of edges are equal to the number of nodes?</p><p>在本例中，当边的数量等于节点的数量时，顺序是已知的。就这么简单吗？如果边数等于节点数，我们能知道秘密数是多少吗？</p><p> In this example, yes, but it doesn&#39;t hold true for the general case. By creating more examples, I start to find a relationship between the number of nodes, and the number of edges. Have a look at what four and five-digit secret numbers look like as a graph:</p><p>在本例中，答案是肯定的，但它并不适用于一般情况。通过创建更多的例子，我开始发现节点数和边数之间的关系。看看四位数和五位数的秘密数字在图表中是什么样子：</p><p>   After drawing a few of these, I could begin to see a pattern emerge. As the number of nodes increase, the number of edges increase like,  1, 3, 6, 10, 15, 21, 28, ...</p><p>在画了几张之后，我可以开始看到一种模式出现了。随着节点数量的增加，边的数量也会增加，如1、3、6、10、15、21、28……。</p><p> It can be helpful to look for patterns, because it means that there&#39;s an equation which can be used to represent some aspect of the problem. Here the pattern showed me what condition to use in order to know when my answer could be considered conclusive. This is the equation that represents that pattern, where n is the number of nodes in the graph.</p><p>寻找模式会很有帮助，因为这意味着有一个方程式可以用来表示问题的某些方面。这里的模式告诉我，为了知道什么时候我的答案可以被认为是确凿的，应该使用什么条件。这是表示该模式的等式，其中n是图中的节点数。</p><p>   A hand-drawn graph helps to visualize the approach of solving this problem, but I knew that I would also need to keep in mind how the graph could be represented with code. Specifically, how to programmatically traverse the graph to produce a result.</p><p>手绘图形有助于可视化解决此问题的方法，但我知道我还需要记住如何用代码表示图形。具体地说，就是如何以编程方式遍历图形以生成结果。</p><p> After staring at the examples for a bit longer, I realized an obvious and helpful property about the graph.</p><p>在盯着这些例子看了一段时间之后，我意识到这个图有一个明显且有用的属性。</p><p> The nodes with the most outward edges come before those with less outward edges. Additionally, the number of edges for each node differ by exactly one. This means that the first digit of the secret number should have the most outward edges, while the last digit would not have any outward edges.</p><p>具有最向外边缘的节点位于向外边缘较少的节点之前。此外，每个节点的边数正好相差一个。这意味着密码的第一个数字应该具有最向外的边缘，而最后一个数字将不会有任何向外的边缘。</p><p> This property made logical sense to me, and was something that could be easily translated into code.</p><p>这个属性对我来说是合乎逻辑的，而且可以很容易地转换成代码。</p><p>  A secret number with more than one of the same digit could cause problems with my approach. This was something that worried me as I was working, because it was not clear how to know which two nodes to put the edge between. For example, take a look at 1030 as the secret number, and imagine the digits given in the following order:</p><p>有多个相同数字的密码可能会导致我的方法出现问题。这是我在工作时担心的事情，因为不清楚如何知道应该将边放在哪两个节点之间。例如，看一下1030作为密码，想象一下按以下顺序给出的数字：</p><p>  There are multiple ways to draw the graph because there are two 0&#39;s. There should still be only one &#34;correct&#34; way. Creating a correct graph might depend on the order in which the digits are given. I might need to think of some way to backtrack and re-connect nodes in order to end up with the correct graph.</p><p>绘制图表有多种方法，因为有两种方法。仍然应该只有一种正确的方法。创建正确的图表可能取决于给出数字的顺序。我可能需要想出一些方法来回溯和重新连接节点，以便最终得到正确的图形。</p><p> The correct and incorrect graphs can be compared to understand how exactly they differ. The incorrect graph has a circular dependency: 3 comes before both the orange and blue 0&#39;s, but then the blue 0 comes before 3, which is contradictory.</p><p>可以比较正确和不正确的图表，以了解它们到底有多大不同。错误的图形有循环依赖关系：3位于橙色和蓝色0之前，但蓝色0位于3之前，这是相互矛盾的。</p><p> Another difference is that the correct version is the only one that satisfies the property mentioned above, where the number of each node&#39;s edges differ by exactly one. This property should always be true for any secret number modeled with the graph.</p><p>另一个不同之处在于，正确的版本是唯一满足上述属性的版本，其中每个节点的边数正好相差一个。对于使用图形建模的任何秘密数字，此属性应始终为真。</p><p>  At this point, I decided to put the question of duplicate digits on hold. It looked like this would break the approach that I had planned to use. I think its possible to figure out, but it was unclear if this use case needed to be supported at all.</p><p>在这一点上，我决定搁置重复数字的问题。看起来这会打破我原本计划使用的方法。我认为有可能弄清楚，但还不清楚这个用例是否需要支持。</p><p> My plan was now to turn my ideas into code to see if it would produce the correct answer.</p><p>我现在的计划是将我的想法转化为代码，看看它是否会产生正确的答案。</p><p>  This part went by pretty quickly because I had formed a good understanding of the problem, as well as an approach for how to solve it. I picked Python for no particular reason, other than I thought it would be fun to use a language that I hadn&#39;t used in a while.</p><p>这一部分很快就过去了，因为我已经对这个问题有了很好的理解，以及如何解决它的方法。我选择了Python并没有什么特别的原因，只是我觉得用一种我有一段时间没用过的语言会很有趣。</p><p> I&#39;m not going explain the code in too much detail, but I want to express the thought process I had while writing it.</p><p>我不打算详细解释代码，但我想表达一下我在编写代码时的思考过程。</p><p> My idea was to loop over each number in the list to build up the graph. Up until now, the graph had only been represented visually on paper with circles and arrows. The task is now to represent the graph using code.</p><p>我的想法是循环列表中的每个数字来构建图表。到目前为止，图形只在纸上用圆圈和箭头直观地表示出来。现在的任务是使用代码表示图形。</p><p> There&#39;s at least a couple ways to implement a graph. What I came up with was closest to what&#39;s traditionally known as an  adjacency matrix, but with some changes.</p><p>至少有几种方法可以实现图表。我想出的方法最接近传统上所说的邻接矩阵，但有一些变化。</p><p> keylogs = [ 319, 680, 180, 690, # ...]adj_matrix = {}for digits in keylogs: a, b, c = str(digits) adj_matrix[(a,b)] = 1 adj_matrix[(a,c)] = 1 adj_matrix[(b,c)] = 1</p><p>密钥日志=[319,680,180,690，#...]密钥日志中的位数：a，b，c=str(位数)adj_Matrix[(a，b)]=1 adj_Matrix[(a，c)]=1 adj_Matrix[(b，c)]=1。</p><p> Here the graph is represented by a Python dict. Each key in the dict is a tuple of digits from the current number in the list. The values are hard-coded with 1s to indicate that there is an edge between the two digits in the tuple.</p><p>在这里，该图由一个Python字典表示。字典中的每个键都是列表中当前号码的数字元组。这些值是用1硬编码的，表示元组中的两个数字之间有一条边。</p><p> The values are less important, so long as there&#39;s a key with the two digits to signify an edge. In other words, the edge is indicated by the existance of an entry in the dict.</p><p>值不那么重要，只要有两个数字表示边缘的关键字就行。换句话说，边缘由词典中词条的存在来表示。</p><p> Notice how the  actual problem provides a list of three-digit numbers. Using two-digit numbers was a simplification that I had made to help me think about the problem initially. Three-digit numbers do not fundamentally change the problem, it just provides more data per number. Now instead of only knowing that digit  a comes before digit  b, I also know that digit  a comes before  c, and  b before  c.</p><p>请注意实际问题是如何提供三位数的列表的。使用两位数的数字是我最初为了帮助我思考这个问题而做的一个简化。三位数的数字并不能从根本上改变问题，它只是为每个数字提供了更多的数据。现在我不只知道数字a在数字b之前，我还知道数字a在c之前，b在c之前。</p><p> The next step is to add a check to see if the graph contains enough information to reveal the secret number. As I had already discovered, the condition can be modeled using the following formula:</p><p>下一步是添加检查，以查看图表是否包含足够的信息来揭示秘密数字。正如我已经发现的，可以使用以下公式对条件进行建模：</p><p> for digits in keylogs: # ... n_nodes = len(set( [digit for edge in adj_matrix.keys() for digit in edge])) n_edges = sum(adj_matrix.values()) is_conclusive = n_nodes &gt; 3 and ( n_nodes * (n_nodes - 1)) / 2 == n_edges # ...</p><p>对于键盘日志中的数字：#...。N_nodes=len(set([adj_matrix.key()中的边的位数，用于边中的位数]))n_edges=sum(adj_matrix.values())is_conducsive=n_node&gt；3 and(n_node*(n_node-1))/2==n_edges#...。</p><p> I found that adding  n_nodes &gt; 3 was necessary, otherwise the program would stop after the very first iteration.</p><p>我发现添加nNodes&gt；3是必要的，否则程序会在第一次迭代后停止。</p><p> Side note: I found that  n * (n - 1)) / 2 == e + 1 also produces the correct answer, and in fewer iterations. However, I believe it could leave room for ambiguity in some cases, depending on the order that the numbers are given, so I decided not include it as part of the solution I ended up with.</p><p>附注：我发现n*(n-1)/2==e+1也会产生正确的答案，而且迭代次数更少。然而，我认为它在某些情况下可能会留下模棱两可的空间，这取决于给出数字的顺序，所以我决定不把它作为我最终得到的解决方案的一部分。</p><p> Once the condition is met, the graph can be traversed to produce the correct answer.</p><p>一旦满足条件，就可以遍历图表以生成正确答案。</p><p> # ...if is_conclusive: nodes = [edge[0] for edge in adj_matrix] counts_by_node = reduce(count_digits, nodes, {}) front_digits = sorted(counts_by_node, key=counts_by_node.get, reverse=True) [last_digit] = list(set( [edge[1] for edge in adj_matrix]).difference(nodes)) result = int(&#39;&#39;.join(front_digits) + last_digit) return result</p><p>#...if is_conducsive：Nodes=[Edge[0]for edge in adj_Matrix]Counts_by_node=Reduced(count_digits，node，{})front_digits=排序(Counts_by_node，key=Counts_by_node.get，Reverse=True)[last_digit]=list(set([edge[1]for edge in adj_Matrix]).Difference(Nodes))Result=int(&#39；&#39；.Join(front_digits。</p><p> Using my weird/unique representation of a graph, the nodes with the most outgoing edges can be found by creating a list of only the first element in each tuple. The resulting list will have one or more of each digit from the secret number, and it will be counted and sorted. Here&#39;s some print statements to help illustrate what&#39;s happening:</p><p>使用我奇怪/独特的图形表示法，只需创建一个包含每个元组中第一个元素的列表，就可以找到出边最多的节点。得到的列表将包含来自密码的每个数字的一个或多个，并将对其进行计数和排序。以下是一些打印语句，以帮助说明正在发生的情况：</p><p> print(nodes)# [&#39;3&#39;, &#39;3&#39;, &#39;1&#39;, &#39;6&#39;, &#39;6&#39;, &#39;8&#39;, &#39;1&#39;, &#39;1&#39;, &#39;6&#39;, &#39;9&#39;, &#39;1&#39;, &#39;2&#39;, &#39;6&#39;, &#39;2&#39;, &#39;7&#39;, &#39;7&#39;, &#39;8&#39;, &#39;3&#39;, &#39;3&#39;, &#39;7&#39;, &#39;7&#39;, &#39;1&#39;, &#39;7&#39;, &#39;7&#39;, &#39;2&#39;, &#39;7&#39;, &#39;3&#39;, &#39;3&#39;]print(counts_by_nodes)# {&#39;3&#39;: 6, &#39;1&#39;: 5, &#39;6&#39;: 4, &#39;8&#39;: 2, &#39;9&#39;: 1, &#39;2&#39;: 3, &#39;7&#39;: 7}print(front_digits)# [&#39;7&#39;, &#39;3&#39;, &#39;1&#39;, &#39;6&#39;, &#39;2&#39;, &#39;8&#39;, &#39;9&#39;]</p><p>打印(节点)#[&#39；3&#39；，&#39；3&#39；，&#39；1&#39；，&#39；6&#39；，&#39；8&#39；，&#39；1&#39；，&#39；1&#39；，&#39；6&#39；，&#39；1&#39；，&#39；1&#39；，&#39；1&#39；，&#39；1&#39；，&#39；1&#39；，&#39；1&#39；，&#39；2&#39；，&#39；6&#39；，&#39；7&#39；，&#39；7&#39；，&#39；8&#39；，&#39；3&#39；，&#39；7&#39；，&#39；7&#39；，&#39；1&#39；，&#39；7&#39；，&#39；7&#39；，&#39；2&#39；，&#39；3&#39；，&#39；3&#39；]打印(Counts_By_Nodes)#{&#39；3&#39；：6，&#39；1&#39；：5，&#39；6&#39；：4，&#39；8&#39；：2，&#39；9&#39；：1，&#39；2&#39；：3，&#39；7&#39；：7}打印(正面数字)#[&#39；7&#39；，&#39；3&#39；，&#39；1&#39；，&#39；6&#39；，&#39；2&#39；，&#39；8&#39；，&#39；9&#39；]。</p><p> The final step before the result is to get the very last digit of the secret number. It&#39;s not included in the  front_digits list, because the last digit in the secret number has 0 outward edges. It should be the only number that remains in the graph, but not in the list of  nodes -- 0 in this case.</p><p>结果出来之前的最后一步是得到密码的最后一位。它不包括在front_digits列表中，因为密码中的最后一个数字没有向外的边缘。它应该是图表中保留的唯一数字，但不是节点列表中的数字--在本例中为0。</p><p> And so the secret number is  73162890. Luckily I did not have to worry about duplicate digits to solve this particular problem, so I am glad that I didn&#39;t end up spending time on that for nothing.</p><p>所以密码是73162890。幸运的是，我不必担心重复的数字来解决这个特殊的问题，所以我很高兴我没有在这个问题上白白浪费时间。</p><p> I&#39;m going to stop here, but the next step would be to look for ways to improve my answer. Now that I have a baseline, I can improve all sorts of things about the program such as its runtime, memory usage, the readability of the code, or work on refactoring to handle special cases (like duplicate digits.)</p><p>我的回答到此为止，但下一步将是寻找改进我的答案的方法。现在我有了一个基线，我可以改进程序的所有方面，比如它的运行时、内存使用情况、代码的可读性，或者进行重构以处理特殊情况(如重复数字)。</p><p>  I think that problem solving is quite personal. There&#39;s never going to be a laundry list of steps for everyone to follow. Our minds are unique, as is the way that we see and solve problems, and that&#39;s awesome!</p><p>我认为解决问题是非常个人化的。永远不会有一份供每个人遵循的繁琐步骤清单。我们的头脑是独一无二的，我们看待和解决问题的方式也是独一无二的，这真是太棒了！</p><p> There&#39;s obviously not just one way to solve the example here, but I hope that I have demonstrated at least a few of the techniques that I find useful.</p><p>很明显，这里不只有一种方法可以解决这个例子，但我希望我已经演示了一些我认为有用的技术。</p><p> Start by asking questions and making observations about the problem. Sometimes this step feels like I&#39;m just spinning my wheels, or stating the obvious, but I find that it gives my mind the traction needed to get started.</p><p>从提出问题和对问题进行观察开始。有时候，这一步感觉就像我只是在转动轮子，或者在陈述显而易见的事情，但我发现它给了我开始工作所需的牵引力。</p><p> Try to make the problem smaller, and solve those ones instead. Look for ways to simplify the information given. This helps me reason about the problem easier, and it can reveal different aspects that I may not have considered otherwise.</p><p>试着把问题缩小，然后解决那些问题。寻找简化所给信息的方法。这可以帮助我更容易地理解这个问题，它可以揭示出我可能没有考虑过的不同方面。</p><p>  Realize that your ideas will probably be wrong more often than they are right. Don&#39;t get discouraged about it. Failed attempts can provide a lot of valuable insight to the problem.</p><p>认识到你的想法很可能是错误的，而不是正确的。不要为此灰心丧气。失败的尝试可以为问题提供很多有价值的见解。</p><p>   Visualize ideas by writing them down. Pencil and paper is a medium that helps me think clearly.</p><p>把想法写下来，把它们形象化。铅笔和纸是一种帮助我清晰思考的媒介。</p><p> Try not to jump straight into the code, sometimes it&#39;s OK, but it can also be distracting. I strive to first form a reasonable conceptual model of my approach before implementing it in code. There are times where I do the opposite though.</p><p>尽量不要直接跳到代码中去，有时这是可以的，但也可能会让人分心。在代码中实现我的方法之前，我努力首先形成一个合理的概念模型。不过，有些时候我会做相反的事情。</p><p> Think about edge cases, but don&#39;t try to tackle everything at once. It helps to just make a note, and then revisit if necessary.</p><p>想想边缘情况，但不要试图一下子解决所有问题。只要做个笔记，然后在必要的时候再去看看会很有帮助。</p><p> It almost goes without saying, but practice/experience makes a big difference. For example, if I had never even heard of a graph data structure, I would not have thought to apply it to this problem. So, make practice and learning part of your daily workflow as much as possible.</p><p>这几乎是不言而喻的，但实践/经验会产生很大的不同。例如，如果我从来没有听说过图形数据结构，我就不会想到将其应用于这个问题。所以，尽可能让练习和学习成为你日常工作流程的一部分。</p><p> While we can definitely learn from each other, we should also formulate our own techniques to reason about the problems that we&#39;re given. This was a fun exercise for me -- to solve a problem, but also to analyze what my own version of problem solving involves. Try it out for yourself and see what you can learn.</p><p>虽然我们绝对可以相互学习，但我们也应该制定自己的技巧来推理我们面临的问题。这对我来说是一次有趣的练习--不仅是为了解决问题，也是为了分析我自己版本的解决问题所涉及的内容。自己试一试，看看你能学到什么。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://denvaar.github.io/articles/problem_solving_example.html">https://denvaar.github.io/articles/problem_solving_example.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/解决问题/">#解决问题</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/solving/">#solving</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>