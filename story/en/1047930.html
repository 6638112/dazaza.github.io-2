<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>PC版《侠盗猎车手》反向工程为原始源代码 PC versions of Grand Theft Auto reverse-engineered to raw source code</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">PC versions of Grand Theft Auto reverse-engineered to raw source code<br/>PC版《侠盗猎车手》反向工程为原始源代码 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-17 19:19:02</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/2/c888d8264accfa9688123988f0224d3c.png"><img src="http://img2.diglog.com/img/2021/2/c888d8264accfa9688123988f0224d3c.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>A group of dedicated coders has  generated complete reverse-engineered raw source code for the PC versions of  Grand Theft Auto III and  Vice City, which comprises hundreds of thousands of lines of C++ code, in a years-long process.</p><p>一组专门的编码人员在长达数年的过程中为侠盗猎车手III和Vice City的PC版本生成了完整的逆向工程原始代码，其中包括成千上万行C ++代码。</p><p> We&#39;ve  discussed in the past how video game fan coders use reverse-engineering techniques to deconstruct the packaged executable files distributed by a game&#39;s original developers. This painstaking, function-by-function process creates raw programming code that can generate exactly the same binary file when compiled.</p><p> 过去，我们已经讨论了视频游戏迷编码器如何使用逆向工程技术来解构由游戏原始开发人员分发的打包可执行文件。这个艰苦的，逐个函数的过程创建了原始的编程代码，在编译时可以生成完全相同的二进制文件。</p><p> With that code in hand, coders can examine what makes the game tick and make improvements and changes at a much more granular level than with traditional modding. In the case of  Grand Theft Auto, those improvements include bug fixes, reduced load times, improved rendering, widescreen monitor support, and a free-floating camera system, to name a few examples. The source code can also be used to generate ports of the game to new platforms like  Linux,  Switch, and  PlayStation Vita (though these recompiled versions all require the copyrighted art and music files extracted from the original game).</p><p> 有了这些代码，编码人员可以检查是什么使游戏停滞不前，并在比传统改装更细粒度的层次上进行改进和更改。仅举几个例子，就侠盗猎车手而言，这些改进包括错误修复，减少了加载时间，改进了渲染，宽屏监视器支持以及自由浮动的摄像头系统。源代码还可用于生成游戏移植到Linux，Switch和PlayStation Vita等新平台的端口（尽管这些重新编译的版本都需要从原始游戏中提取受版权保护的艺术品和音乐文件）。</p><p> Github contributor &#34;aap&#34; wrote that the project started in early 2018 &#34;initially as a way to test reversed collision and physics code inside the game&#34; by reverse-engineering specific DLLs. By 2019, the project grew to incorporate other contributors, who were able to generate a working executable by April of 2020. The team built off that code to generate a source version of  Vice City that was ready by December 2020, aap wrote.</p><p> Github贡献者＆＃34; aap＆＃34;写道，该项目始于2018年初，最初是为了测试游戏内反向碰撞和物理代码的一种方式。通过对特定的DLL进行反向工程。到2019年，该项目的合并人员也有所增加，他们能够在2020年4月之前生成可运行的可执行文件。aap写道，该团队利用该代码生成了Vice版本的源代码，该版本将于2020年12月准备就绪。</p><p> In addition to working on a similar decompilation for  Grand Theft Auto: Liberty City Stories, the source code team has also expressed interest in generating PS2 and Xbox ports of the PC version of the game, as well as additional bug fixes.</p><p> 除了为《侠盗猎车手：自由城故事》进行类似的反编译外，源代码团队还表示有兴趣生成PC版游戏的PS2和Xbox端口，以及其他错误修复程序。</p><p>  I&#39;ve dwelved in a lot of retro DOS/Windows 9x era game digging/dissassembly, mostly for fun, and I must say, the older the games are, the harder they are to reverse engineer. It mostly comes from the all the quirks and optimisations the developers had to employ to get the most performance out the machines at the time. Custom compression algorythm, precompiled assets, bit packing... there&#39;s a lot of technique that were very common at the time and that are now gone. And the way assets are used too. At the time, most stuff were bitmaps with palettes, effects were hard coded or series of sprites applied at run time. Now everything is shaders and 3d models.</p><p>  我曾经参加过很多复古的DOS / Windows 9x时代的游戏挖掘/分解工作，主要是出于娱乐目的，我必须说，游戏越老，它们对反向工程的难度就越大。它主要来自开发人员必须采用的所有怪癖和优化措施，以使当时的机器获得最佳性能。自定义压缩算法，预编译资产，位打包...有很多技术在当时非常普遍，现在已经不复存在。以及资产的使用方式。当时，大多数东西是带有调色板的位图，特效经过硬编码或在运行时应用一系列精灵。现在，一切都是着色器和3D模型。</p><p>  There used to be a really cool program called &#34;Sourcerer&#34; that would decompile any dos program into asm This gave you a lot of insight into what went on in the game/program  A couple of years later there was a windows version &amp; a really nice book that showed you how to optimize windows code using asm.  At that point all you had was the c sdk with the CreateWindow/CreateWindowEx api calls with the WinMain entry point  Some of the above really needs to be required teaching, as you really get a feel for what makes piece of code work.  Another excellent source is Jon Stokes book &#34;Inside The Machine&#34;   https://www.amazon.com/Inside-Machine-I ... 183&amp;sr=8-1  Once you go deep down the rabbit hole, then you have &#34;Linkers &amp; Loaders by John Levine&#34;</p><p>  曾经有一个很酷的程序，叫做＆＃34; Sourcerer＆＃34;。可以将任何dos程序反编译为asm。这使您对游戏/程序中发生的事情有很多了解。几年后，出现了Windows版本＆amp;一本非常不错的书，向您展示了如何使用asm优化Windows代码。到那时，您所拥有的只是带有WinWindow入口点的带有CreateWindow / CreateWindowEx api调用的c sdk，因为您确实了解使代码片段起作用的原因，因此上述某些内容确实需要进行教学。另一个出色的资料来源是乔恩·斯托克斯（Jon Stokes）的书《机器里面》（Inside The Machine）。 https://www.amazon.com/Inside-Machine-I ... 183＆amp; sr = 8-1一旦深入兔子的洞，便有＆＃34; Linkers＆amp;约翰·莱文（John Levine）的装载机 </p><p>  One thing I&#39;ve always wondered about when I hear about decompiling is since I assume that you end up with generated variable names which are largely meaningless strings of text, has anyone ever attempted to write decompilers that attempt to assign useful variable names? I&#39;m not expecting highly decriptive camelcase names, but do decompilers at least attempt to indicate the type?</p><p>我一直想知道何时听到反编译的一件事是，因为我假设您最终生成的变量名在很大程度上是毫无意义的文本字符串，有人曾经尝试编写反编译程序来尝试分配有用的变量名吗？我不期望使用具有高度描述性的驼峰名称，但是反编译器至少会尝试指出类型吗？</p><p> Yes, they are absolutely able to determine type. CPUs have instructions that specify the types of operands. For example, the ADD instruction specifies addition of integer operands, while the ADDSS and ADDSD instructions specify addition of single-precision and double-precision operands. Additional work is required when dealing with type-casting and value promotion, but this is actually very easy.  The real difficulties in writing a reverse compiler comes from two sources: compiler optimizations and hand-written assembly.  Compiler optimizations change the source code on the fly, so what&#39;s compiled may not be what was written in the source code. The end result, however, is the same. For example, changing multiplication and division by two into left and right shifts, and multiplication by 9 into the LEA opcode (which can make you think the input is a memory address, although LEA can also be used as a faster way of performing certain multiplications). Compiler optimizations aren&#39;t always complicated, so they can be reverse engineered with a bit of work.  Hand-written assembly is where all bets are off. Obviously, it was much more common to find hand-written assembly in older programs. C and C++ compilers weren&#39;t as efficient as they are now, and programs were smaller. However, high-level languages have the benefit of generating code based on a fixed set of patterns and are therefore known as &#34;structured languages&#34;. Once you know the patterns you can reverse them. But, hand-written assembly is rarely based on a pattern, so a reverse compiler may have to employ a variety of tricks to determine what&#39;s going on in the code.  Worse, high-level languages like C and C++ allow for the use of the GOTO statement. Entire papers have been written on why this statement should never be used, including Edgar Djikstra&#39;s famous &#34;GOTO Considered Harmful&#34;. Use of this statement lead to a large number of bugs in programs, and it makes reverse compiling practically impossible due to the lack of structure. GOTO is implemented as an unconditional jump, and it can jump anywhere inside a function. Consider the loop control structure:   1) logical comparison 2) conditional jump 3) code 4) unconditional jump back to 1)  The reverse compiler can easily determine that 1-4 is a loop. And if there&#39;s an unconditional jump inside the loop, then the direction tells the reverse compiler what that means: a jump past 4) is a BREAK statement, a jump to 4) is a CONTINUE statement. That&#39;s the benefit of structure. Now, imagine the problems that arise when a GOTO statement jumps from  outside of the loop in to 3)...  Full disclosure: I&#39;m writing a reverse compiler for a C-like language that compiles to a simple x86-like byte-code. I thank my lucky stars the developers did not include support for GOTO.</p><p> 是的，他们绝对有能力确定类型。 CPU具有指定操作数类型的指令。例如，ADD指令指定整数操作数的相加，而ADDSS和ADDSD指令指定单精度和双精度操作数的相加。处理类型转换和价值提升时需要进行其他工作，但这实际上非常容易。编写反向编译器的真正困难来自两个方面：编译器优化和手写汇编。编译器优化会动态更改源代码，因此编译的内容可能不是源代码中编写的内容。但是，最终结果是相同的。例如，将乘法和除法更改为左右两次，然后将9乘以更改为LEA操作码（尽管LEA也可以用作执行某些乘法的较快方法，但您可以认为输入是一个内存地址。 ）。编译器优化并不总是很复杂，因此可以通过一些工作对其进行逆向工程。手写大会是所有下注的地方。显然，在较旧的程序中找到手写汇编更为普遍。 C和C ++编译器的效率不如现在，并且程序更小。但是，高级语言的好处是可以基于一组固定的模式生成代码，因此被称为“结构化语言”。一旦知道了模式，就可以将其反转。但是，手写汇编很少基于模式，因此反向编译器可能必须采用各种技巧来确定代码中正在发生的事情。更糟糕的是，诸如C和C ++的高级语言允许使用GOTO语句。关于为什么不应该使用此声明的所有论文，包括埃德加·吉克斯特拉（Edgar Djikstra）著名的“ GOTO被认为有害”，已被撰写。使用此语句会导致程序中出现大量错误，并且由于缺乏结构，实际上使反向编译成为不可能。 GOTO被实现为无条件跳转，它可以在函数内部的任何位置跳转。考虑循环控制结构：1）逻辑比较2）有条件跳转3）代码4）无条件跳转回1）反向编译器可以轻松确定1-4是循环。并且如果循环内无条件跳转，则该方向告诉反向编译器这意味着什么：跳过4）是BREAK语句，跳转到4）是CONTINUE语句。那就是结构的好处。现在，想象一下当GOTO语句从循环外跳入3时出现的问题。...完全公开：我正在为类似C的语言编写一个反向编译器，该编译器可以编译为简单的x86类似语言字节码。感谢我的幸运星，开发人员不包括对GOTO的支持。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://arstechnica.com/gaming/2021/02/coders-reverse-engineer-grand-theft-autos-raw-pc-source-code/">https://arstechnica.com/gaming/2021/02/coders-reverse-engineer-grand-theft-autos-raw-pc-source-code/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/代码/">#代码</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/反向/">#反向</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/versions/">#versions</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/游戏/">#游戏</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>