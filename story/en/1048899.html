<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>咖喱霍华德是一个骗局 Curry-Howard Is a Scam</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Curry-Howard Is a Scam<br/>咖喱霍华德是一个骗局 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-02-24 21:36:15</div><div class="page_narrow text-break page_content"><p>The Curry-Howard correspondencehas been talked about a lot recently, not only in Haskell circles, but alsoamong CiC-based proof assistant practitioners (Coq, Lean, etc.).In a nutshell, it makes a deep parallel between &#34;programs&#34; (terms of some flavorof lambda calculus, typically), and &#34;proofs&#34; (these programs are a proof of their type,or more precisely they are witnesses that their types are inhabited).The most basic example is  id x = x which, in Haskell, would be a proof of$ \forall a. a \rightarrow a $, a trivial theorem of propositional logic.</p><p>近年来，不仅在Haskell圈子中，而且在基于CiC的证明助理从业者（Coq，Lean等）中都广泛讨论了Curry-Howard的对应关系。简而言之，它使＆＃34; programs＆ ＃34; （通常是某种类型的lambda演算的术语）和＆＃34; proofs＆＃34; （这些程序是它们类型的证明，或者更确切地说，它们是它们类型被居住的见证）。最基本的示例是id x = x，在Haskell中，这将是$ \ forall a的证明。 \ rightarrow a $，命题逻辑的平凡定理。</p><p> That&#39;s all good and well, but my point here is that  in practice, the equivalence isnot as interesting as it first looks.</p><p> 一切都很好，但是我的意思是，在实践中，对等并不像它最初看起来那样有趣。</p><p>   A real program (i.e. one that is written to be executed and do something useful)is not really a proof of anything interesting.Pedantically, a haskell program has type  IO (), which is not really a validproposition. But even beyond that, if we look just below the surface of  main,nothing has that interesting a type:</p><p>   真正的程序（即被编写为要执行并执行有用操作的程序）实际上并不是任何有趣的证明，而就学上而言，haskell程序的类型为IO（），这实际上不是有效的主张。但是即使如此，如果我们只是在main的表面下方看，也没有什么有趣的类型：</p><p> A classic Haskell program that is used by people is  pandoc.Most of what it does could be described as  Doc Markdown -&gt; Doc Html (ora similar pair of document formats). So you have a &#34;proof&#34; that these two treescan be somehow mapped onto one another. No mathematician will fawn over that.</p><p> 人们使用的经典的Haskell程序是pandoc。它所做的大部分工作都可以描述为Doc Markdown->。 Doc Html（或类似的一对文档格式）。所以您有一个“证明”这两棵树可以以某种方式相互映射。没有数学家会为此讨好。</p><p> Servers written in Haskell, like webservers, would have the type  request -&gt; IO response(or something close to that, maybe  request -&gt; M response for some custom monad  M)if you look inside the server loop. Again that&#39;s not really mathematically interesting.</p><p> 用Haskell编写的服务器（如Web服务器）的类型为request-＆gt;如果您在服务器循环内部查看，则IO响应（或接近响应的响应，也许会请求-> M响应某些自定义monad M）。同样，这在数学上并不是很有趣。</p><p> It&#39;s only if you look in combinator libraries (like Parsec, say) that types get more generic,and start looking more like formulas. Things like  flip : (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; care as generic as it gets… and are proofs of super trivial propositional logic theorems.In fact you can&#39;t even state much in Haskell, any real mathematical statement will at leastrequire first-order logic (which corresponds to dependent types — no mainstreamlanguage features these beyond, er, C++). Idris could  possiblyhave some interesting proofs that are also real programs… if it were designed tobe a proof assistant and not a beefed-up programming language.</p><p> 只有在查看组合器库（例如Parsec）时，类型才变得更通用，并开始看起来更像公式。像翻转这样的东西：（a-> b-> c）-＆gt; b-＆gt; -＆gt;尽可能多地关心……并证明了超微不足道的命题逻辑定理。事实上，您甚至无法在Haskell中陈述太多，任何真实的数学陈述至少都需要一阶逻辑（对应于从属类型，否）主流语言还提供了这些功能，例如er，C ++）。如果Idris被设计为证明助手，而不是功能强大的编程语言，则它可能会有一些有趣的证明，它们也是真实的程序。</p><p> If anyone has a useful program that is also actually a proof of something nontrivial, I&#39;d be happy to be proven wrong.</p><p> 如果有人使用的实用程序实际上也证明了某些琐碎的事情，我很乐意被证明是错误的。 </p><p>  What is the program corresponding to a proof of&#34;there exists an infinite number of primes&#34;?If I run this program, what input does it takes, and what do I get as anoutput?</p><p>对应于＆＃34的证据的程序是什么;存在无限数量的素数＆＃34;？如果我运行这个程序，它需要什么输入，以及我作为Anoutput达到什么？</p><p> I don&#39;t have a direct answer to that question. If you develop this proof in Coq,using a  Prop typed statement, I don&#39;t even think it could be extracted to OCamland compiled.</p><p> 我没有直接回答这个问题。如果您在COQ中开发此证明，请使用PROP类型语句，我甚至认为它可以提取到ocamland编译。</p><p> For most of mathematics, I have no idea what the &#34;programs&#34; corresponding to proofsfound in textbooks would look like, nor what they would compute. There arevery complicated lambda terms for these proofs, but what they compute isunclear.</p><p> 对于大多数数学，我不知道＆＃34;程序＆＃34;对应于教科书中的验证看起来像是他们会计算的。这些证据的虚拟性λ术语，但它们计算了胰岛素。</p><p>  A domain where CH  does make sense to me, is algorithms (written in a functionalstyle) that are used as  existential witnesses of some property.For example, the Euclid GCD algorithm is, in a very real sense, a proof thattwo natural numbers have a GCD. You can write some Coq or Lean code thatcomputes the GCD of two numbers and proves that it&#39;s indeed their greatest divisor.</p><p>  一个域，Ch确实对我有意义，是用作某些属性的存在证人的算法（用函数）。例如，EuclID GCD算法在非常真实的意义上，证明Thatwo Natural Numbers有一个GCD。您可以编写一些COQ或精益代码，即拖累两个数字的GCD，并证明它确实是他们最大的除法。</p><p> That said, I don&#39;t know of any large program written this way. It&#39;s a labor intensiveway of writing programs, even compared to alternatives like  why3where you can cleanly separate the code and the specification, and ask automatic proversto do as much proving as possible for you.</p><p> 那说，我不知道以这种方式写入的任何大型程序。它＆＃39;甚至与whewhive的替代方案的劳动意义，甚至与why3的替代方案相比，您可以清洁代码和规范，并要求自动proversto对您尽可能多地证明。</p><p>  Let&#39;s look at  Compcert, famously one of the largestprograms written in Coq.I suppose the main type is  compile : C_program -&gt; Option Asm_programor something like that (I&#39;m no expert on Compcert so I could be very wrong).However, as far as I know, it&#39;s not written in a purely dependent style: proofs areseparated from the &#34;real code&#34; part of the development. This meanswe don&#39;t get $\forall x: \text{C_program} \rightarrow Option \set{y : \text{ASM_program} | R(x,y) }$where $R(x,y)$ would mean that $x$ and $y$ have the same semantics; rather youhave  C_program -&gt; ASM_program and proofs on the side that the function preservesits input&#39;s semantic.</p><p>  让＆＃39;看看CoMcert，着名的是在Coq.i中写的最大值之一假设主要类型是编译：C_program  - ＆gt;选项ASM_PRAGGOR这样的东西（我＆＃39; m没有专家在COMPCERT上，所以我可能是非常错误的）。但是，据我所知，它＆＃39;没有用纯粹的依赖风格写作：从＆＃aresperation aresperated 34;实际代码＆＃34;部分发展。这意味着易于＆＃39; t得到$ \ forall x：\ text {c_procraph} \ lightarrow选项\ set {y：\ text {asm_procum} | r（x，y）} $ where $ r（x，y）$意味着$ x $和$ y $具有相同的语义;相反，你是c_program  - ＆gt; asm_prick和侧面上的证明，函数保存输入＆＃39; s语义。</p><p>   The title was click-baity, of course 🙂. But I do think that CH is over-hyped,because the correspondence is  only mostly interesting abstractly; in practice thingsare either a (interesting) program, or a (interesting) proof, but not bothat the same time.</p><p>   当然，标题是点击八分之一。但我确实认为CH过度炒作，因为信件只是抽象地兴趣;在实践中，符合（有趣）的程序，或（有趣的）证明，但同时不是两个人。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blag.cedeela.fr/curry-howard-scam/">https://blag.cedeela.fr/curry-howard-scam/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/咖喱/">#咖喱</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/howard/">#howard</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/证明/">#证明</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>