<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>OOP的重复死亡 The Repeated Deaths of OOP</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Repeated Deaths of OOP<br/>OOP的重复死亡 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-06-06 18:05:48</div><div class="page_narrow text-break page_content"><p>Since its inception in the late sixties, Object Oriented Programminghas pervaded our industry. Current mainstream programming languagesall support OOP —except maybe C, and it is no longer that mainstream.Most programmers I have met in person tend to divide the world thus:</p><p>自从六十年代晚期成立以来，面向对象的编程哈斯普及我们的行业。当前主流编程语言支持OOP -Except也许C，并且它不再是那个主流。最多的是我亲自遇到的主要程序员往往会划分世界：</p><p>   On the other hand, despite having gone through serious mutations, OOPis still strongly criticised by knowledgeable people (including yours truly). Worse, the game industry seems to bemoving  away from it. Video games are simulations, a core niche ofOOP. That&#39;s what  Simula was named after. If it&#39;s not thebest tool for even  that job…</p><p>   另一方面，尽管经历了严重的突变，但Oopis仍然受到知识渊博的人（包括你真正）的强烈批评。更糟糕的是，游戏行业似乎击败了它。视频游戏是仿真，一个核心利基ofoop。那个＆＃39; s什么是以后的命名。如果它＆＃39;甚至那份工作的工具也是......</p><p>  Oh. Right. I&#39;m saying &#34;OOP&#34; all over the place, and I don&#39;t evenknow  what it means. Thankfully, Deborah J. Armstrong madea survey of how people use the term ( The Quarks of Object OrientedDevelopment), and came up with 8 fundamental building blocks.</p><p>  哦。正确的。我＆＃39; m＆＃34; OOP＆＃34;到处，我不知道它意味着什么。谢天谢地，Deborah J. Armstrong Madea调查人们如何使用这个词（Orienteddevelopment的夸克），并提出了8个基本构建块。</p><p>  Abstraction Representing reality in a simplified form byremoving certain distinctions so that we can see the commonalities.</p><p>  以简化形式的讨论表达现实的抽象，以便我们可以看到常见。</p><p>  Encapsulation Data and behaviour are defined within an object andseparated from everything else, protecting the internalrepresentation of the object.</p><p>  封装数据和行为在对象中定义了来自其他一切的对象，保护对象的内部陈述。</p><p> Inheritance Allows the attributes and methods of one class to bebased on another existing class.</p><p> 继承允许将一个类的属性和方法粘在另一个现有类上。</p><p> Object An individual, identifiable item, either real orabstract, which contains information about itself and thedescriptions of its manipulations.</p><p> 对象一个个人，可识别的项目，真正的orabstract，其中包含有关其操作的自身和对齐的信息。 </p><p>    Now I understand why nobody agrees on what OO means: few objectoriented languages support all of the above, and the other languagesall support  some of the above. Consider:</p><p>现在我理解为什么没有人同意OO的意思：很少有非对象语言支持上述所有语言，而另一个语言支持上述一些语言。考虑：</p><p> Java don&#39;t really support messages. You can call methods of course,but those are just as synchronous as ordinary function calls.</p><p> Java Don＆＃39; t真正支持消息。您可以调用课程的方法，但那些与普通函数调用一样同步。</p><p>   Encapsulation is supported by a wide range of programming languages,OO or not. Abstraction is even more ubiquitous.</p><p>   通过各种编程语言，OO或不支持封装。抽象甚至更无处不在。</p><p> Looking at the big picture, I can see that object orientation is not aparadigm, but a set of mechanics we can cherry pick. Yet we continueto treat it as if it were a unified concept.</p><p> 看着大局，我可以看到对象方向不是Aparadigm，而是一套机械师我们可以樱桃挑选。然而，我们继续将它视为统一的概念。</p><p> I think this is why &#34;OOP&#34; survived this long. Without a definitedefinition everyone can agree on, its meaning keeps mutating beyondrecognition as we change our programming practices.</p><p> 我认为这就是为什么＆＃34; OOP＆＃34;幸存下来。如果没有肯定的成就，每个人都可以达成一致，它的意思是因为我们改变了我们的编程实践时，它的意义不断变化。</p><p>  (Note: the following &#34;deaths&#34; are only in  rough chronological order,and often describe a slow decline in popularity, not a brutal cessationof activity. Think of COBOL. The language is long dead, yet stillmaintained  to this day.)</p><p>  （注意：以下＆＃34;死亡＆＃34;只是以粗糙的时间顺序排列，并且通常描述普及的缓慢下降，而不是野蛮的活动。想到COBOL。这门语言是长期的死亡，但今年的语言仍然是剧本。）</p><p>   Actually I made up the term &#34;object-oriented&#34;, and I can tell you Idid not have C++ in mind.</p><p>   实际上我组成了这个词和＃34;面向对象的＆＃34 ;,我可以告诉你IDID没有C ++。 </p><p>  For a time, &#34;Object Oriented&#34; mostly meant Smalltalk. We speak ofSimula as the first object oriented language, but Alan Kay inventedthe term, and Smalltalk, though inspired by Simula, was quitedifferent. It had some Lisp roots, and  everything was an object,including classes and messages.</p><p>一段时间，＆＃34;面向对象＆＃34;大多是幻灯行。我们将鸟瞰为第一个面向对象的语言，但艾伦凯发明了这个术语，而Smalltalk虽然受到Simula的启发，但被要求。它有一些LISP根，一切都是一个物体，包括类和消息。</p><p> Then C++ effectively ported Simula in a C environment. In theprocess, it emphasised short term efficiency, and stopped many things(primitive types, classes, methods…) from being objects. Classes weremostly abstract data types with inheritance and polymorphism. Manyobjects were directly manipulable from the outside, through eitherpublic data members, or getters and setters.</p><p> 然后C ++在C环境中有效地移植了Simula。在Process中，它强调了短期效率，并阻止了许多事情（原始类型，类，方法......）是对象。课程Weremostly摘要数据类型具有继承和多态性。许多Objects通过Offullic数据成员或Getters和Setters直接可操纵。</p><p> Then Java came. It was presented as an &#34;easier C++&#34;. Same syntax,similar abstractions, garbage collection… At that point Smalltalk washardly used any more, and &#34;OOP&#34; basically meant Java and C++.</p><p> 然后java来了。它被呈现为＆＃34;更容易C ++＆＃34;同样的语法，类似的抽象，垃圾收集......在那点SmallTalk Warkardly使用了更多，＆＃34; OOP＆＃34;基本上意味着Java和C ++。</p><p>   When I was first taught OOP, around 2004, Java was already anestablished language. Despite having been published 10 years before Iwas taught Java, the  Design Patterns book had yet to take holdof the teachers. The older ones seemed to be stuck in the inheritancehierarchy mindset. I had my share of animals, shapes, and everydaypossessions. The vision I got out of it was simple:</p><p>   当我第一次教授OOP时，大约2004年，Java已经成为了一种语言。尽管在iwas教授Java之前已经发表了10年，但设计模式书尚未接受老师。较旧的似乎被困在遗产中的心态。我有我的动物，形状和每天的份额。我出来的愿景很简单：</p><p>  There wasn&#39;t much time for subtlety back then. We had a language tolearn, a project to complete, and of course the rest of thecurriculum. One teacher stood out however:</p><p>  那时＆＃39;那时是微妙的时间。我们有一种语言TOLEARN，一个项目完成，当然还有其余的。一位老师突然出现：</p><p>  Wait a minute. Inheritance is OOP&#39;s  flagship. And we should stopusing it?  Fragile base class? Okay, you win. Inheritance isEvil, and the other teacher is Stupid —no time for subtlety, remember?The argument was compelling, though.</p><p>  等一下。遗产是OOP＆＃39; s旗舰。我们应该彻底阻止它吗？脆弱的基础？好的，你赢了。继承Isevil，另一种老师是愚蠢的 - 没有时间的微妙，记住？争论很引人注目。</p><p> The change was drastic. Before, we had big inheritance hierarchies,classes that model mostly real-world entities, and a separation ofconcerns that looked like &#34;the Dog class is responsible for everythingthat happens to dogs&#34;. Now we favour composition, and separate the concerns, not just the entities. The  Model View Controllerpattern, despite being older than Java, is a good example: itseparates display from interaction of even a single entity: we don&#39;tjust have a dog. We have a model of the dog, an image of the dog, aclickable area of the dog…</p><p> 变化是剧烈的。之前，我们有大型继承层次结构，课程大多是现实世界的实体，以及看起来像＆＃34的围绕的分离;狗课是负责狗＆＃34;现在我们有利于构成，并将关注的关注分开，而不仅仅是实体。模型视图控制器托特恩，尽管比Java大，但是一个很好的例子：从甚至单一实体的互动中显示出来的差异：我们不会有一只狗。我们有一个狗的型号，狗的形象，狗的可行区域...... </p><p> This was the second death. The coffin soon followed, nailed by Java&#39;s generics: suddenlywe hardly needed  Object any more.</p><p>这是第二个死亡。棺材很快，被java＆＃39;泛型：突然们几乎不需要对象。</p><p>  Even with its second death, &#34;OOP&#34; still mostly meant Java and C++.(And C#.) The practices changed a lot; the languages, not so much.</p><p>  即使是第二个死亡，＆＃34; OOP＆＃34;仍然主要是java和c ++。（和c＃。）实践变化了很多;语言，不是那么多。</p><p> Meanwhile, scripting languages were on the rise. Python, Ruby,JavaScript… None are statically typed, and JavaScript doesn&#39;t evenhave classes. &#34;OOP&#34; just got a lot more inclusive. And the code andpractices you would find in those languages were quite different too.</p><p> 同时，脚本语言正在上升。 Python，Ruby，JavaScript ......没有静态键入，并且JavaScript并在＆＃39; t即使是课程。 ＆＃34; OOP＆＃34;刚得更多包容性。你将在那些语言中找到的代码和普通也完全不同。</p><p> Test Driven Development for instance, was invented  (Update: maybe rediscovered)by users of these dynamic languages. Most probably to compensate theweaknesses of dynamic type systems, by the way: without the host ofproofs a static type system gives you for free, the need to check yourassumptions is  dire. Tests can provide those checks.</p><p> 例如，通过这些动态语言的用户发明了（更新：Moder：Modented）的更新。最重要的是通过方式补偿动态型系统的跳柄，顺便说一下：如果没有静止的静态类型系统，无需免费提供，需要检查yousassuptions是可怕的。测试可以提供这些检查。</p><p> Now &#34;OOP&#34; is too diluted to mean anything any more. Being &#34;objectoriented&#34; tells me so little about a language that I might as well notbother.</p><p> 现在＆＃34; OOP＆＃34;太稀释了，意味着什么。作为＃34; Objoreriented＆＃34;这么少地告诉我关于我可能也是臭味的语言。</p><p>   As meaningless as it has become, &#34;OOP&#34; is still around. The practiceshave changed beyond recognition, but the name somehow survived.</p><p>   它已经变得毫无意义，＆＃34; OOP＆＃34;还在周围。实践吸引力超越了识别，但以某种方式幸存下来。</p><p>  There are several reasons for this. Bjarne Stroustrup himself says C++ is not object oriented. Lambdas are  everywhere,including in C++ and Java. Parallelism calls for a better way tomanage state, which OOP doesn&#39;t currently provide. Some core nichesof OOP (GUI, simulation), are starting to get attractive alternativesolutions. And again, the game industry is slowly moving away fromOOP.</p><p>  有几个原因。 Bjarne Stroustrup自己说C ++不是面向对象的。 Lambdas无处不在，包括C ++和Java。并行呼吁更好的方式划线状态，哪个OOP当前提供。一些核心oop（GUI，仿真），正在开始获得有吸引力的替代品。而且，游戏行业正在慢慢走开。 </p><p>  Two fancy words for a simple concept. A lambda is just the literaldescription of a function —the same way 42 is the literal descriptionof a number. With them, you are no longer required to name everysingle function. A closure is an implementation strategy. Basicallyan object that contains a piece of code and a piece of data.Together, lambdas and closures can make functions &#34;first class&#34;: theycan be passed around and manipulated just like integers.</p><p>一个简单的概念的两个花梢词。 Lambda只是一个函数的界面， - 相同的方式42是一个数字的字面描述。与他们一起，您不再需要命名everysingle函数。关闭是一种实现策略。基本上包含一段代码和一块数据的对象.TOWETHER，lambdas和封闭物可以使功能＆＃34;第一类＆＃34 ;: accan通过整数来传递和操纵。</p><p> At a fundamental level, closures and objects are  very close.Yet from a popular perspective, first class functions are not OO atall: they come from functional programming. Yet they managed toinvade every single mainstream OOP language.</p><p> 在基本级别，关闭和对象非常接近。从流行的角度来看，一流的功能不是oo atall：他们来自功能编程。然而，他们管理每一个主流oop语言。</p><p> This is a severe blow to OOP. If the closure/object duality didn&#39;tprevent closures from invading even  Java, we can be sure influentialpeople are acknowledging that OOP is not always appropriate. Forreal. It&#39;s easy to pay lip service to the &#34;best tool for the job&#34;,yet decide that OOP is the best tool for whatever we are doing. Thistime, they went further.</p><p> 这是对OOP的严重打击。如果关闭/对象二元性并没有DIDN＆＃39; Tprevent关闭甚至Java甚至java，我们可以确保有影响的人承认OOP并不总是合适的。真的。它易于支付给＆＃34的唇部服务;作业的最佳工具和＃34;但是决定OOP是我们正在做的任何事情的最佳工具。镜子，他们进一步走了。</p><p> This may not be enough to kill &#34;OOP&#34;, though. Lambdas and closurescould be co-opted, spoken of as if they were object oriented allalong. I&#39;ve seen it happen with  parametric polymorphism.Suddenly it got a  new name, and even became an importantcharacteristic of OOP, depending on who you asked.</p><p> 这可能不足以杀死＆＃34; oop＆＃34;但是。 λ和封堵功能可以联合选择，好像他们是面向对象的allalong。我看到它用参数多态性发生了。很多，它得到了一个新的名字，甚至成为OOP的重要特征，具体取决于你问道。</p><p>  Typical OOP programs are also imperative programs. Much mutablestate, though it tends to be hidden under the encapsulation carpet.In a multithreaded context this quickly becomes a nightmare. Now yourobject could be interrupted at  any time, and asked to run concurrentwrites on itself. Hence the importance of thread safety, the propermanagement of locks…</p><p>  典型的OOP程序也是必要的程序。虽然它倾向于隐藏在封装地毯下。在多线程上的背景下，这迅速成为噩梦。现在，您的Object可以随时中断，并要求在自己身上运行ConcurrentWrites。因此，线程安全的重要性，锁的Propermanagement ......</p><p> There is an easier way: don&#39;t mutate state. Always construct newstuff, never throw away anything. Then let your smart pointers oryour garbage collector take care of unreachable references.</p><p> 有一种更简单的方法：Don＆＃39; t突变状态。始终构建换下，永远不要扔掉任何东西。然后让您的智能指针oryour垃圾收集器照顾不可达的参考。</p><p> That gets rid of most of our concurrency related problems. Sure, youdo need side effects at some point, but they can always be isolated tosmall portions of your program.</p><p> 这消除了我们的大部分并发性相关问题。当然，您需要在某些时候需要副作用，但它们总是可以隔离孤立的TOSMALL部分程序。 </p><p> On the other hand, forbidding mutable state and other such sideeffects without changing anything else is  crippling. You need awhole new bag of tricks.  Persistent data structures, so youdon&#39;t have to copy the state of your entire application for everylittle update. Standard  higher order functions such as  map, fold, and  filter, so you have an alternative to most of your  forand  while loops without resorting to the  recursive nuclearoption.  Algebraic data types, so you can have functions thatfail without resorting to the harder to tame exceptions. Monads, so you can chain such computations without having towrite annoying chains of  if-else expressions…</p><p>另一方面，禁止变形状态和其他这样的Sideefefects而不改变其他任何东西是瘫痪。你需要一个新的一袋技巧。持久性数据结构，所以youdon＆＃39; t必须复制整个应用程序的状态，以便每次更新。标准高阶函数，如地图，折叠和过滤器，因此您对大多数伪装的替代方案有替代，而循环则不借入递归核选择。代数数据类型，因此您可以在不诉诸驯化异常的情况下，具有comail的功能。 Monads，所以你可以链接这样的计算，而不是在else的表达式的烦人的链条......</p><p> You can see where this is going: without mutable state, the pulltowards functional programming is hard to resist. It will take time,but I think OOP cannot survive this. Not even  actor models willhelp. While actors are very similar to objects, they don&#39;t brandthemselves as such. OOP may live on, but &#34;OOP&#34; will die.</p><p> 您可以看到这将在哪里：没有变形状态，PullTowards功能编程很难抵抗。它需要时间，但我认为OOP无法生存。甚至甚至actor模型都会闪耀。虽然演员与对象非常相似，但他们不像自己那样。 OOP可能会活下去，但＆＃34; OOP＆＃34;会死。</p><p>  Up until now, we could have said that OOP wasn&#39;t so bad. Sure, itgained new features, and faced new obstacles, but that doesn&#39;tinvalidate the core idea. To do that, you would need to beat OOP atits own game. Guess what, entity systems are doing just that. Theyenjoy mainstream awareness in the game industry, and I expect theywill eventually invade GUI programming in some form.</p><p>  到目前为止，我们可以说OOP并不是那么糟糕。当然，曝光的新功能，面临新的障碍，但这并不是那么n; tonvalidate核心的想法。要做到这一点，你需要击败自己的游戏。猜猜，实体系统正在做什么。他们在游戏行业的主流意识，我希望他们最终以某种形式侵入GUI编程。</p><p> Being so utterly outclassed wouldn&#39;t just mean the conditions havechanged. It would mark OOP as a  mistake. Maybe not one we couldhave avoided: we had to try. But a mistake nonetheless.</p><p> 如此完全被遗弃的问题＆＃39; t只是意味着条件。它会将OOP标记为错误。也许不是我们可以避免的人：我们不得不尝试。但仍然是一个错误。</p><p> Back when inheritance hierarchies were all the rage, most games weredesigned around a big taxonomy of game objects. Like this:</p><p> 返回当继承层次都是愤怒时，大多数游戏都在游戏对象的大分类上徘徊。像这样：</p><p> Object / \ Small, incomplete, / \ and totally made up Static \ inheritance hierarchy /\ Moving / \ |\ / Loot | \Clutter | Enemy platform</p><p> 对象/ \ small，不完整，/ \完全组成静态\继承层次结构/ \移动/ \ | \ / loot | \ clutter |.敌人平台</p><p> The main problem with this design is its inflexibility. What aboutloot that moves? Invisible enemies? And so on. We could of coursemodify the hierarchy as we tinker with the design of the game, but thechanges involved are heavy. Games can&#39;t have that: deadlines aretight, yet we need experiments and backtracking to make them better.</p><p> 这种设计的主要问题是它的不灵活性。怎么样的移动？看不见的敌人？等等。我们可以通过对游戏设计的修补程序来调整层次结构，但涉及的TheChanges很重。游戏可以＆＃39; t有：截止日期aretight，但我们需要实验并回溯以使它们更好。 </p><p> We need something more flexible. One solution is to treat gameobjects as the accumulation of  components. That way, you can easilyhave static loot and dynamic loot. They are both  rendered and pickable, but only one of them is  animated.</p><p>我们需要更灵活的东西。一个解决方案是将GameObjects视为组件的累积。这样，您可以轻松静态战利品和动态战利品。它们都是渲染和可赢的，但其中只有一个动画。</p><p> The question is, how do you add those components together? Onesolution is to use  mixins. This gives us some flexibility back,but we can go even further. See, mixins still tie the data of thecomponent to the code that processes it. But when you think of it,some data, like the position of an object, can be useful for severalsystems (rendering, collision detection, AI…).</p><p> 问题是，如何将这些组件添加在一起？ OneLyolatult是使用Mixins。这给了我们一些灵活性，但我们可以进一步走。请参阅，Mixins仍将Checonent的数据绑定到处理它的代码。但是当您想到它时，一些数据，如对象的位置，对Severalsystems（渲染，碰撞检测，AI ...）有用。</p><p> The obvious solution is to separate code and data. Let the componentsbe mere blobs of data, and have separate processors map over them.This gives you a database-like system: your game data is basically agiant table, with a column per type of component, and a row per gameobject. The processors then query the relevant columns.</p><p> 显而易见的解决方案是分离代码和数据。让组件仅仅是数据，并具有单独的处理器映射到它们上。这为您提供了一种类似的数据库 - 类似的系统：您的游戏数据基本上是agiant表，每种类型组件的列，以及每个GameObject的一行。然后处理器查询相关列。</p><p> This separation of data and code has a number of advantages. Forinstance, it makes it easy to separate performance sensitiveprocessors from the rest. That lets you write much of your game logicin a scripting language, and treat it as ordinary data —like texturesand meshes. Your game is now easier to modify before you release it,and easier to mod  after.</p><p> 这种数据和代码的分离具有许多优点。 Forinstance，它可以轻松地将性能敏感的性能从其余部分分开。这让您可以写下您的大部分游戏逻辑脚本语言，并将其视为普通数据 - 纯纹理和网格。在释放它之前，您的游戏现在更容易修改，更容易换后。</p><p> Enough with the  ECS advocacy however. My point is, thisarchitecture cannot be mistaken for an OOP flavour. It separates codeand data, and  doesn&#39;t mesh well with objects. Its growingpopularity can only mean OOP is being driven out of one of its twocore niches. If OOP is not the best tool for the jobs it was designed for, is it the best tool for anything at all?</p><p> 然而，足够了ECS倡导。我的观点是，这个architecture不能被误认为是oop味道。它将Codeand数据分开，并与对象很好地＆＃39;它的成长性只能意味着oop正在被驱逐出其两种双胞不平的巨头。如果OOP不是它设计的作业的最佳工具，那么它是最适合任何东西的最佳工具吗？</p><p> You may think OOP can still be saved by Graphical User Interfaces, butI wouldn&#39;t count on it: entity systems can be adapted to that context,and there are other  promising solutions.</p><p> 您可以认为OOP仍然可以通过图形用户界面来保存，但是＆＃39; t指望它：实体系统可以适应该上下文，还有其他有希望的解决方案。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://loup-vaillant.fr/articles/deaths-of-oop">https://loup-vaillant.fr/articles/deaths-of-oop</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/oop/">#oop</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/deaths/">#deaths</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>