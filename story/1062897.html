<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>parsix：解析不验证 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">parsix：解析不验证 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-16 00:42:47</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/945d6789e2d9643f2da320e8f0a62c11.png"><img src="http://img2.diglog.com/img/2021/5/945d6789e2d9643f2da320e8f0a62c11.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>为确保输入的高级解析为右侧，满足业务逻辑所需的所有约束。</p><p> 它受到亚历克西斯国王的工作的强烈启发;解析，Don＆＃39; t验证＆＃34;我们建议您读它即使您不熟悉Haskell。</p><p>  任何非琐碎程序始终需要验证外部输入。在Kotlin Ecosystem IT＆＃39; s往往是将Stream化为对象的混合，然后验证它满足更复杂的业务约束。至上的时间将以形式执行验证，如：</p><p>  所有这些都共享一个关键漏洞：无法保证我们的程序实际运行此验证。</p><p>   我们知道，在商业级店面恐帆必须收到一封电子邮件，但是我们的编译器是不知道的，事实上我们可以删除assertemail，它会愉快地编译成功。</p><p>  而不是只是验证，而是应该将输入解析为一个形状，使得编译器意识到我们想要做的内容。在Parsix中，前一个例子将成为：</p><p> 导入parsix.core.parse@jvminlineValue类电子邮件（val电子邮件：string）val parseemail：parse＆lt;字符串，电子邮件＆gt;有趣的StoreMailendPoint（InP：String）{何时（val解析= ParseeMail（InP））{是OK  - ＆gt; storemail（parsed.value）是parseerror  - ＆gt; todo（＆＃34;处理失败＆＃34;）}}有趣的店铺（电子邮件：电子邮件）{todo（＆＃34;将其存储在某个地方＆＃34;）} </p><p>我们更改了店铺邮件以要求电子邮件作为其参数，因此我们无法直接传递原始输入，但更重要的是，此功能不必进行任何进一步的检查以确保其输入有效，这尤为重要在大的codebase中。如果我们尝试删除Parse逻辑，编译将失败。通过对我们的电子邮件使用价值类，我们得到最好的两个世界：使用字符串运行时更具安全性和相同的性能。</p><p> 通过可见性修饰符，我们可以确保必须始终通过解析构建电子邮件，以便编译器将强制我们做正确的事情。</p><p> 请注意，如果我们想在解析后访问电子邮件，我们被迫评估并明确处理故障情况。</p><p> 这可能看起来像更多的代码，但它很容易摘要鉴于大多数程序将有一个出口点的错误。例如，如果我们在Web服务器上工作，代码可能如下所示：</p><p> 有趣＆lt; T＆gt;把手（解析：解析：paintedcase：（t） - ＆gt;响应）：响应=当（解析）{是OK  - ＆gt; HappyCase（Parsed.Value）是ParseFailure  - ＆gt; parsefailuretoreSponse（已解析）}</p><p>   这只是一个简单的抽象，具体取决于您的代码库，您可以通过例如在路由定义级别处理解析输入来更好地使其更好。</p><p> 鉴于我们正在使用简单的数据类型，抽象和组合的可能性非常高。 </p><p>做正确的事情：作为图书馆作者，我们努力使做法易于遵循，促进将编译器视为一个宝贵的朋友的文化而不是敌人。</p><p> 可兼容：人们只能一次处理一定数量的信息，越越好。为什么为什么将问题分解为更小，可消化的解决方案，然后将所有这些都放在一起以有效地解决主要问题。</p><p> 可扩展：我们希望我们的用户能够扩展我们的图书馆并以适应他们的问题的方式弯曲，而不是相反的方式。</p><p> 简单：开发人员应该能够通过函数跳跃并阅读我们的代码来了解整体实现。</p><p> 显式：我们更愿意制作代码明确，只隐藏什么是有意义的;如果有助于避免错误，我们并不害怕更详细的代码。</p><p>  Parsix专注于构图和扩展，因此使用新的解析器即将直接地实现以下功能：</p><p>    解析是一个密封的类，它模拟了我们的解析结果，并且只能有两个形状： </p><p>如果您熟悉功能编程，则此类型是专用类型的结果（也称为）。</p><p>  鉴于每个企业域都与彼此不同，Parsix仅提供低级解析器和组合器，使其易于实现更复杂的Parsers。</p><p> 让＆＃39;我们说我们有年龄概念，我们希望确保在特定的流动中只有成年人（年龄＆gt; = 18）可以进入它：</p><p> 导入parsix.core.terminalError导入parsix.core.parsed数据类年龄（val值：uint）数据类成人（val值：uint）数据类Notsultoror（Val Inp：年龄）：IncerionError有趣的Parseadultage（InP：年龄）：解析＆lt ;成人成人＆gt; = if（inp.value＆gt; = 18）OK（成人（Inp.Value））否则NotAdulterror（Inp）</p><p> 实现新的解析功能非常简单和直截了当，＆＃39;＆＃39;这也表明您可以解析任何类型的数据，不必是一个原始类型。</p><p> 值得一提的是，错误是Parsix中的第一类公民：每个解析器都应该返回特定的ParseRor类型并以允许我们为客户创建非常内信息的错误消息的方式捕获整体上下文。好的部分是它＆＃39;＆＃39;图书馆用户，它将决定哪个是最终格式。</p><p>  我们有一个特定的解析器，能够解析任何枚举，只要它实现了Parsableenum接口。 </p><p>enum类attrtype（覆盖val键：字符串）：parsableenum {inttype（＆＃34; int＆＃34;），strype（＆＃34; str＆＃34; str＆＃34;），} val parseattributeType：parse＆lt;字符串，attrtype＆gt; =治疗蛋白＆lt; attrtype＆gt;（）</p><p>  有些可能建议使用enum.name而不是必须从特定界面扩展，但是，良好的做法是不将外部API绑定为enum.name .Name。显式提供密钥使代码重命名 - 安全：您可以在不无意中打破API合同的情况下自由更改枚举。</p><p>  让＆＃39; s在我们的域中说，我们需要使用名称，它必须是一个字符串，它的长度在3到255个字符之间：</p><p> 导入parsix.core.parsed import parsix.core.ok import parsix.core.parseerror导入parsix.core.terminalError导入parsix.core.parsebetween / **使其在解析之后使用此值使用此值* / @ jvminlinevalue类名称（val原始：字符串）/ **模型我们的新错误以获得更好的错误消息* / data class nameError（Val Inp：String，override val错误：parseError）：CompositeError / **制作一个新的解析，将根据业务解析长度的新解析逻辑* / val parselength：parse＆lt; int，int＆gt; = Parsebeen（3,255）有趣寄生命令（INP：String）：解析＆lt;名称＆gt; =何时（解析= Parsthength（Inp.length））{是OK  - ＆gt;好的（名称（inp））是parseerror  - ＆gt; NameError（Inp，解析）}</p><p>  导入parsix.core.focusedParse val arseName：parse＆lt;字符串，名称＆gt; = FocusedParse（//我们想要约束字符串长度焦点= {inp  - ＆gt; inp.length}，// parse length parse = parsebetween（3,255），//成功值mapok = :: name，//包更好的错误消息错误maperr = :: nameError）</p><p> 使用此组合器的好处是指导库用户朝向正确的路径，并确保我们增强输入和错误。</p><p>  解析单个值是可以的，但我们通常需要构建需要多个元素的类型。例如： </p><p>数据类用户（val名称：名称，val年龄：年龄）数据类名称（val值：字符串）数据类年龄（Val值：uint）</p><p> 假设我们将从CSV摄取数据，并且每行将是Map＆lt; String，String＆gt;喜欢：</p><p>   导入parsix.core.carry import parsix.core.parsemap导入parsix.core.parseinto导入parsix.core.parsestring导入parsix.core.parseuint导入parsix.core.greedy.required val parseuser：parsemap＆lt;用户＆gt; = ParseInto（:: user.Carry（））.required（＆＃34;名称＆＃34; :: parsestring.map（:: name）.required（＆＃34;年龄＆＃34; :: parseuint.map（:: Age））</p><p> 要注意的一个重要事情是:: user.carry（）：它将拆查用户构造函数到多个函数，每个函数都接收单个参数。移走一个参数并完全键入，编译器将抱怨如果类型抱怨不匹配;通过为每个参数具有特定类型，我们还确保我们无法交换线路。</p><p>  val parseuser：parsemap＆lt;用户＆gt; = ParseInto（:: User.Carry（））。重量（＆＃34;年龄＆＃34; :: parseuint.map（:: Age））//＆lt;  - 预期类型名称，有年龄。重点（＆ ＃34;姓名＆＃34 ;, :: parsestring.map（:: name））</p><p> 请注意，我们已经包含一个用于ParseUsuser的显式类型，例如目的，编译器将推断出没有问题的类型。</p><p>  与上一部分相同的例子，但这一次我们将RAW输入的DERISIALIED DERSIALIZEDIALIACIEDING </p><p>如前所述，解析器类型是多余的，所有类型必须匹配，否则将有一个编译器错误。</p><p>  使用ParseInto时，我们可以在每个步骤出错。有些应用程序想收集所有这些，而其他应用则愿意立即停止。</p><p> 出于这个原因，我们提供了两组不同的扩展函数，您可以在Parsix.Core.Greeey和Parsix.core.Lazy中找到它们。</p><p> 贪婪的版本没有前缀，并将贪婪地收集错误，在失败后不会停止，而是尝试尽可能多的错误。如果我们有多个失败，结果将是manyErrors。</p><p> 懒惰的版本以懒惰为前缀，并在失败后立即关闭短路执行。当我们需要快速反馈或跳过特别昂贵的操作时，它们更有效，应该是优选的。</p><p> 懒惰和贪婪的版本都可以共同努力，但你必须小心ParseInto如何执行解析器：他们从最后一开始就运行。</p><p>   c将首先运行并执行下一个解析器，即使解析失败，但是＆＃39; s罚款，因为b也很快 </p><p>B将始终运行，但是因为这是懒惰的，如果发生故障，它将立即停止。 这很好，因为我们的下一个解析很慢  A是最后一个解析运行，它并不重要，如果它＆＃39;贪婪或懒惰  因此，如果所有解析器发生故障，我们只会收集C和B的错误。  密封类属性数据类IntAttribute（val值：int）：attribute（）数据类strattribute（val值：字符串）：attribute（）  为IntAttribute和Strattribute创建解析器应该简单，但我们如何为属性制作解析器？  通常，我们将从我们的输入中有某种类型，以指定哪些变体当前数据是指的：  val attrint = mapof（＆＃34;类型＆＃34;＆＃34; int＆＃34;＆＃34; val＆＃34;＆＃34; 10＆＃34;）valtrtr = mapof（ ＆＃34;类型＆＃34;＆＃34; str＆＃34 ;,＆＃34; val＆＃34;＆＃34; ten＆＃34;） </p><p>我们应该部分评估我们的输入并根据类型值，再次解析输入。</p><p> 这是一个常见的模式，我们有ementhen（即：评估，然后继续......）运算符：</p><p> val parseattribute：parsemap＆lt;属性＆gt; = parsekey（＆＃34;类型＆＃34;，parsetype）.evalthen {何时（它）{attrtype。 inttype  - ＆gt; parsekey（＆＃34; val＆＃34;，parseintattr）attrtype。 strype  - ＆gt; Parsekey（＆＃34; val＆＃34;，parsestrattr）}}</p><p> Parsekey是一个低级运算符，创建一个Parse，它在输入映射中查找给定的键并解析.Eventhen的结果必须是另一个Parse，该解析器接收与初始解析相同的输入，因此它将是一个地图。结果是正常解析，可以像往常一样使用：</p><p>  通过首先将类型转换为AttrType并使用何时使用，编译器将抱怨，以防我们添加新类型但Don＆＃39; t更新此代码。始终使用枚举和密封类时使用，使您的代码易于维护。</p><p> 请注意，Evalthen可以与任何解析器一起使用，它不必是枚举，并且Lambda代码可以像您需要的那样复杂。</p><p>  我们重视可编译性，因此一切都可以撰写，包括我们的解析，我们有一个方便的扩展功能。 </p><p>假设我们需要解析SomeNum，但是我们的初始输入是任何。在这种情况下，我们可以＆＃39; t只使用parseenum，因为它需要一个字符串作为输入。值得庆幸的事我们已经有一种方法来解析任何字符串，Parsestring。让＆＃39;粘在一起：</p><p>  这是非常自然的，应该清楚它所做的事情：解析输入，如果成功，将结果转发到下一个解析。</p><p> 此操作员是一个infix，所以如果您愿意，我们可以删除一些括号：</p><p>  撰写更小的，更简单的解析器是我们首选的风格，它将增加代码可重用性并制作整体码库清洁剂。</p><p>   此库及其扩展返回的所有错误必须是信息性的，并捕获创建顶部缺口错误消息所需的所有上下文。</p><p> 我们很清楚，商业域彼此完全不同，即我们为什么我们决定为错误提供可扩展的层次结构，同时仍将其限制为良好的开发体验。</p><p> 解析错误的底部类型是ParseError，它是密封接口，可以具有3个形状： </p><p>ImperionError是一个打开的界面，它模拟具有所需的所有信息的错误，从而从中生成错误消息，例如ResearError</p><p> CompositeError是一个打开的界面，它模拟了一种缠绕其他错误并给予更多结构的错误，如PropError。</p><p> ManyErrors是模拟错误集合的最终类，可用于贪婪解析器。</p><p>  开箱即用我们只提供一个错误处理程序，能够将Parsix.core中的所有错误翻译成适合显示到英语客户的消息列表。</p><p> 但是错误是可扩展的，我们鼓励图书馆用户创建特定于其业务域的新错误。此为什么用户必须提供两个扩展函数来获取错误处理程序。在最简单的形式中，我们可以为未知错误提供默认值：</p><p> 导入parsix.core.makestringErrorHandler val MyHandler = MakestringErrorHandler（{＆＃34;未知错误，出现问题，＃34;}，{＆＃34;未知＆＃34;}，）</p><p> 第一个Lamba将收到我们Weren和＃39;能够解析并应返回合适的错误消息。第二个lambda将收到一个rocositeError，即我们Weren＆＃39;它能解析并应该返回一个合适的消息用作前缀，然后我们将递归地解析包裹的错误并构建如下消息，如：＆＃34; $前缀：$留言＆＃34; </p><p>导入parsix.core.requirederror导入parsix.core.terminalError导入parsix.core.compositeError数据类MyterminalError：IncermentError数据类MyCompositeError（覆盖val错误：ParseError）：ComposeErrorMyHandler（MyterMinalError（））== Listof（＆＃34;未知错误 ，出现问题＆＃34;）MyHandler（MyCompositeError（ResearError））== Listof（＆＃34;未知：所需值＆＃34;） </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/parsix/parsix">https://github.com/parsix/parsix</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/parsix/">#parsix</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/parse/">#parse</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/解析/">#解析</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>