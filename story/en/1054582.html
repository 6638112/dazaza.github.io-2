<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>从MD5构造海绵功能 Constructing a sponge function from MD5</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Constructing a sponge function from MD5<br/>从MD5构造海绵功能 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-26 21:42:49</div><div class="page_narrow text-break page_content"><p>While doing some research, I came across the term “Sponge function”. After playing around with them and implementing one inside  my kernel, I decided to write this blog post about how to write a simplified version. To keep low-level cryptographic code to a minimum, we will be relying on the hash function  MD5. Buckle in, this is going to be a long one.</p><p>在进行一些研究时，我遇到了“海绵函数”一词。在与他们一起玩并在我的内核内实施一个，我决定写这个博客文章有关如何编写简化版本。要将低级加密代码保持为最小，我们将依靠哈希函数MD5。扣上，这将是很长的一个。</p><p>  This article will start from the simple concept of an MD5 hash, and incrementally build on it until we implement a lot of common functionality that seems like black boxes. Every step should be small enough to be digested individually, while still contributing to the overall understanding of the topic. If anything is unclear, feel free to discuss it in the comments. The post is designed so that you can pause and play around with the concepts yourself any time you want, or speed through it if that is what you prefer.</p><p>  本文将从MD5哈希的简单概念开始，并逐步构建它，直到我们实施大量常用功能，似乎是黑匣子。每一步都应该足够小，以便单独消化，同时仍然有助于对主题的整体理解。如果有任何清楚，请随时在评论中讨论。该帖子被设计成使您可以随时随地暂停和播放概念，如果这是您喜欢的话，才能通过它速度。</p><p>  Since we are going to base our project on the MD5 hash function, let’s set aside a small section to go through what it is. We will treat MD5 as a black box and ignore any complicated details for the sake of brevity.</p><p>  由于我们将在MD5哈希函数上基于项目，因此让我们留出一小部分来经历它是什么。我们将把MD5视为一个黑匣子，为简洁起见，忽略任何复杂的细节。</p><p>    MD5 is a cryptographic hash function that maps an arbitrary amount of data into 16 bytes (or 128 bits). In its heyday, MD5 was the go-to choice for hashing passwords, checking files for corruption, and tagging data against tampering. Those days are long gone. It has been considered broken for some time, and it is not recommended using it for anything security-related. But it is well-known and has been implemented for practically any computing device ever created. Luckily for us, Python comes bundled with a collection of hash functions in the  hashlib module. Let’s quickly see how it works.</p><p>    MD5是加密散列函数，可将任意数量的数据映射到16个字节（或128位）。在鼎盛时期，MD5是散列密码，检查损坏文件的可选择，并将数据标记为篡改。那些日子已经一去不回。它被认为已被破坏了一段时间了，并不建议使用它的任何安全相关的东西。但它是众所周知的，并且已经为几乎所有创建的计算设备实施了。幸运的是，Python捆绑了Hashlib模块中的哈希函数集合。让我们快点看它是如何工作的。</p><p>        As we can see, inputs of different lengths map to fixed-size outputs, and small changes in the input lead to completely different output values. Basically what we would expect from a hash function. In this article, we will be (ab)using the MD5 hash function to create a sponge function. But before we can do that, we need to know a sponge function is.</p><p>        正如我们所看到的，不同长度映射的输入到固定尺寸输出，并且输入的小变化导致完全不同的输出值。基本上我们期望哈希函数。在本文中，我们将使用MD5哈希函数来创建海绵函数。但在我们能做到之前，我们需要知道海绵函数。</p><p>    A  sponge function is a cryptographic function that can “absorb” any number of bits and “squeeze” any number of bits, like a sponge. This is different from what we observed about MD5; while MD5 will only produce fixed-size outputs of 16 bytes, a sponge function can output 1 byte, 26 bytes, 5000 bytes or any number that you like. This sounds fun and could be useful for a lot of different tasks, so let’s do some unholy programming and turn MD5 into a sponge function.</p><p>    海绵函数是一个加密功能，可以“吸收”任何数量的位和“挤压”任何数量的位，就像海绵。这与我们观察到的大约MD5不同;虽然MD5只产生16个字节的固定尺寸输出，但海绵函数可以输出1字节，26个字节，5000个字节或您喜欢的任何号码。这听起来有趣，可能对许多不同的任务有用，因此让我们做一些不明的编程并将MD5变成海绵函数。</p><p>  Sponge functions are fascinating. You can use a sponge function as a  hash function,  random number generator,  Message Authentication Code or for  data encryption. It would be apt to describe one as a cryptographic Swiss army knife.</p><p>  海绵功能令人着迷。您可以使用海绵功能作为哈希函数，随机数生成器，消息认证码或数据加密。将一个是一个加密瑞士军刀。 </p><p>    In order to create a sponge function, we need an internal state (which is just a buffer), and function to  pseudorandomly transform one state into another. We will take advantage of the two properties of the MD5 hash, our state buffer will be the 16 bytes of MD5 output and our transform function will be MD5 itself.</p><p>为了创建海绵函数，我们需要一个内部状态（只是缓冲区），并函数伪装成将一个状态转换为另一个状态。我们将利用MD5哈希的两个属性，我们的状态缓冲区将是MD5输出的16个字节，我们的变换功能将是MD5本身。</p><p>  Sponge functions keep most of their internal state hidden. Both the bits absorbed and the bits squeezed only touch a small portion of it, so the output never reveals the full state of the function.</p><p>  海绵函数隐藏的大部分内部状态。吸收的位和位挤压只有触摸它的一小部分，所以输出永远不会透露功能的完整状态。</p><p>  The first step is to initialize the state, either to zero or to a sensible default value.</p><p>  第一步是初始化状态，无论是零还是明智的默认值。</p><p>  This process  absorbs all the input data into the state. After we have absorbed our input, we can  squeeze out as many output bytes as we want by following a very similar process. For each byte that we want to produce:</p><p>  此过程将所有输入数据吸收到状态。我们吸收了我们的输入后，我们可以在遵循非常相似的过程时挤出尽可能多的输出字节。对于我们想要生产的每个字节：</p><p>    Warning! You probably don’t want to use this for anything too sensitive. This is a proof-of-concept implementation using the broken MD5 function as a base. At least pick something better like  ChaCha20 or  SHA-512. In general, we want a large state and a transform function that mixes the state really well.</p><p>    警告！您可能不想为任何太敏感使用此功能。这是一个使用破损的MD5函数作为基础的概念验证实现。至少选择更好的东西，如Chacha20或SHA-512。一般来说，我们想要一个大状态和变换功能，可以很好地混合状态。</p><p>    Now that we have briefly gone over the theory, let’s get to the implementation. We will take this step by step and implement each operation we mentioned above. Our first step is the transform function.</p><p>    现在我们已经简要走过了这个理论，让我们来实现。我们将逐步逐步并实现我们上面提到的每个操作。我们的第一步是转换功能。</p><p>    According to the theory we outlined above, we need a transform function that will take our state and pseudorandomly map it to another state. In our case, the MD5 hash function will be doing the heavy lifting for us. And by heavy lifting I mean MD5 will be doing pretty much the whole job.</p><p>    根据我们上面概述的理论，我们需要一个转变函数，将我们的州和伪安地多组将其映射到另一个州。在我们的案例中，MD5哈希函数将为我们做繁重的举重。通过沉重的举重，我的意思是MD5将做几乎整个工作。 </p><p>  We can transform the current state by passing it through the MD5 function. Here’s a small demonstration.</p><p>我们可以通过通过MD5功能转换当前状态。这是一个小型示范。</p><p>          Looks like everything is working. Let’s encapsulate this in a method of the Sponge class. Every time we  absorb or  squeeze a byte, we will mix the state using this method.</p><p>          看起来一切都在工作。让我们在海绵类的方法中封装这一点。每次吸收或挤压字节时，我们都会使用此方法将状态混合。</p><p>      As we mentioned before, the state needs to be initialized before we start absorbing and squeezing any bits. Since we are using MD5, we want our state to be 16 bytes. Fortunately, MD5 makes sure that no matter the value we provide, the state will end up being 16 bytes. So we can pick any value, including an empty string. Let’s go with that option.</p><p>      如前所述，在开始吸收和挤压任何比特之前，需要初始化状态。由于我们使用MD5，我们希望我们的状态为16个字节。幸运的是，MD5确保无论我们提供的价值，州最终将成为16个字节。所以我们可以选择任何值，包括空字符串。让我们选择这个选项。</p><p>    Let’s see if everything is working. After creating a Sponge instance, we should be greeted with the MD5 of the empty string,  d41d8cd98f00b204e9800998ecf8427e.</p><p>    让我们看看一切是否正常工作。创建海绵实例后，我们应该与空字符串的MD5打招呼，D41D8CD98F00B204E9800998ECF8427E。</p><p>        Using the logic from the theory section, we can write the code for absorbing a single byte easily. We will replace the first byte of the state with  input XOR first byte, and then transform the state.</p><p>        使用理论部分的逻辑，我们可以轻松地编写用于吸收单个字节的代码。我们将用输入XOR第一个字节替换状态的第一个字节，然后转换状态。</p><p>    We can quickly test that this results in different states after we absorb different data. Let’s try to absorb  [1,2] and  [2,1] and observe the difference in the states.</p><p>    我们可以在我们吸收不同数据后快速测试这导致不同状态。让我们试图吸收[1,2]和[2,1]并观察各州的差异。</p><p>            Generalizing this to buffers of arbitrary sizes is trivial. Just iterate over a buffer and absorb the bytes one-by-one. This is a useful abstraction because in real code we will commonly work with buffers instead of individual bytes.</p><p>            将其概括为自动尺寸的缓冲是微不足道的。只是迭代缓冲区并一对一吸收字节。这是一个有用的抽象，因为在实际代码中，我们通常会与缓冲区而不是单个字节一起工作。 </p><p>    Here’s a quick sanity check: Our state should be different from the empty state after absorbing bytes. Let’s quickly verify this before moving on.</p><p>这是一个快速的理智检查：我们的州应在吸收字节后与空状态不同。让我们在继续之前快速验证这一点。</p><p>        Since we don’t need to do any input-mixing, our  squeeze logic will be simpler than our  absorb logic. Following the theory part, we will output the first byte and transform the state again in order to produce one byte.</p><p>        由于我们不需要做任何输入混合，因此我们的挤压逻辑比我们的吸收逻辑更简单。在理论部分之后，我们将输出第一个字节并再次转换状态以产生一个字节。</p><p>            Going from extracting single bytes to exctracting buffers is not too difficult. We can use a  list comprehension to write this in a concise way.</p><p>            从提取单个字节到exctracting缓冲区并不太难。我们可以使用列表理解以简明的方式写入这一点。</p><p>        It might seem like a very small amount of code, but this is all we need. It might be useful to add some convenience funtions later, but for 99% of the use cases these methods will be sufficient. Now we can start playing around with our sponge function.</p><p>        它似乎是一个非常少量的代码，但这就是我们所需要的。在以后添加一些便利功能可能很有用，但对于99％的用例，这些方法就足够了。现在我们可以开始使用我们的海绵功能。</p><p>    In the beginning, we mentioned that sponge functions have a wide range of cryptographic use cases. In this section I will implement them in simple ways to provide some examples on how useful sponge functions can be.</p><p>    在开始，我们提到海绵函数具有广泛的加密用例。在本节中，我将以简单的方式实现它们，以提供一些示例，就如何有用的海绵函数。</p><p>    Hashing is the easiest thing to implement with a sponge function. In fact, we already saw a demonstration of this when testing the  squeeze function above. To clarify; we can produce a hash by absorbing all the input and squeezing a fixed number of bytes.</p><p>    哈希是用海绵函数实现的最简单的事情。实际上，当测试上面的挤压功能时，我们已经看到了这一点。澄清;我们可以通过吸收所有输入并挤压固定数量的字节来生成哈希。</p><p>          This seems to fit our criteria of a hash function; inputs of different sizes map to fixed-size outputs, and small changes in the output result in completely different hashes. You can substitute  10 with any other length in order to change the output size of your hash. In general, longer hashes are less likely to have collisions but take up more space. You can play around and pick the sweet spot for your use case.</p><p>          这似乎符合我们的哈希功能标准;将不同大小的映射输入到固定尺寸输出，以及输出的小变化导致完全不同的哈希值。您可以用任何其他长度替换10，以更改哈希的输出大小。一般来说，较长的哈希不太可能具有碰撞，但占用更多空间。您可以播放并为您的用例选择甜蜜点。 </p><p>    Random number generation is also something that can be done with sponge functions. The basic idea is to absorb the  RNG seed and then squeeze out bytes for as many random numbers as you need. In the following example, I am using a fixed seed in order to generate 10 unsigned 16-bit integers.</p><p>随机数生成也是可以使用海绵功能完成的。基本思想是吸收rng种子，然后按照您的需要挤出与多个随机数的字节。在以下示例中，我使用固定的种子来生成10个无符号16位整数。</p><p>  In [19]: import  struct s  =  Sponge () s . absorb ( b &#34;Seeding the RNG&#34; ) def  rng ():  buf  =  s . squeeze ( 2 )  return  struct . unpack ( &#39;H&#39; ,  buf )[ 0 ] [ rng ()  for  _  in  range ( 10 )]</p><p>  在[19]中：导入struct s = sponge（）s。吸收（B＆＃34;播种RNG＆＃34;）def rng（）：buf = s。挤压（2）返回结构。打开包装（＆＃39; h＆＃39;，buf）[0] [rng（）在范围内（10）]</p><p>    If we use the same seed, we will always get the same output. This might sound counterintuitive for the goal of generating “random” numbers, but it is commonly required to be able to replicate random results. If this is not something you need, you can seed from an actually random source or something that changes regularly like the current time. This depends on what qualities you expect from your random numbers. Below is a demonstration of how to read a random seed from  /dev/urandom.</p><p>    如果我们使用相同的种子，我们将始终获得相同的输出。这可能会对生成“随机”数字的目标来说，但通常需要能够复制随机结果。如果这不是您需要的，您可以从实际随机源或定期更改的内容中种子。这取决于您对随机数所期望的质量。以下是如何从/ dev / urandom读取随机种子的演示。</p><p>      Idea! You can absorb values while generating them as well, this allows you to periodically reseed your RNG using external sources.</p><p>      主意！您也可以在生成它们的同时吸收值，这允许您使用外部来源定期重新定位您的RNG。</p><p>    We can use a sponge function in order to produce a mechanism that can produce and verify signatures using a secret key. This is a very common technique, especially in mobile and web applications where it is used to store the session on the client without letting them tamper with it. If you want to read more about this use-case, check out  JSON Web Tokens.</p><p>    我们可以使用海绵函数来生成可以使用秘密密钥生成和验证签名的机制。这是一种非常常见的技术，尤其是在移动和Web应用程序中，它用于将会话存储在客户端上而不让他们篡改它。如果您想了解有关此用例的更多信息，请查看JSON Web令牌。</p><p>  In order to produce a signature; we will  absorb the data, and the secret key. After this, we can  squeeze any number of bits that can be used as the signature.</p><p>  为了产生签名;我们将吸收数据和秘密密钥。在此之后，我们可以挤压任何可以用作签名的位数。</p><p>  In [21]: def  sign ( data ,  key ):  s  =  Sponge ()  s . absorb ( data )  s . absorb ( key )  return  s . squeeze ( 5 ) data  =  b &#34;Hello world!&#34; key  =  b &#34;password123&#34; signature  =  sign ( data ,  key ) signature . hex ()</p><p>  在[21]中：DEF标志（数据，键）：s = sponge（）s。吸收（数据）s。吸收（键）返回s。挤压（5）数据= B＆＃34;你好世界！＆＃34;键= B＆＃34; Password123＆＃34;签名=符号（数据，键）签名。十六进制（） </p><p>    Verification of a signature can be done by generating the signature yourself and comparing the signature you received with the signature you generated. If they match up, the data and the signature have not been tampered with.</p><p>可以通过生成自己生成签名并进行比较您生成的签名来进行签名来完成签名的验证。如果它们匹配，则数据和签名尚未被篡改。</p><p>      As expected, the signature can be verified successfully. Let’s try to modify the data a little and switch two characters around.</p><p>      正如预期的那样，可以成功验证签名。让我们尝试修改数据的数据，并在周围切换两个字符。</p><p>      Similarly, we can have the correct data and tamper with the signature instead. The verification fails, showing that both the signature and the data are protected against corruption and tampering.</p><p>      同样，我们可以使用签名的正确数据和篡改。验证失败，显示签名和数据都受到保护免受损坏和篡改。</p><p>        A stream cipher allows us to encrypt and decrypt a stream of bytes using a single secret key. This can be used to make sure only you, or anyone you entrust with the secret key can decrypt the data.</p><p>        流密码允许我们使用单个密钥加密和解密字节流。这可用于仅确保您，或者您委托密钥的任何人都可以解密数据。</p><p>  In [25]: def  stream_cipher ( data ,  key ):  s  =  Sponge ()  s . absorb ( key )  output  =  bytearray ( data )  for  i  in  range ( len ( data )):  key  =  s . squeeze_byte ()  output [ i ]  ^=  key  return  output data  =  b &#34;Hello, world!&#34; encrypted  =  stream_cipher ( data ,  b &#34;password123&#34; ) encrypted . hex ()</p><p>  在[25]中：def stream_cipher（数据，键）：s = sponge（）s。吸收（键）输出= I在范围内的（数据）（LEN（数据））：key = s。 squeeze_byte（）输出[i] ^ =键返回输出数据= B＆＃34;您好，世界！＆＃34;加密= Stream_Cipher（数据，B＆＃34; password123＆＃34;）加密。十六进制（）</p><p>    Decoding a stream cipher is very simple, in fact it takes no code at all. Simply encrypting the already encrypted value with the correct key will end up decrypt your data. Let’s try to decode our data with the correct and incorrect passwords.</p><p>    解码流密码非常简单，实际上它根本没有代码。只需使用正确的键加密已有加密的值将结束解密您的数据。让我们尝试用正确且不正确的密码解码我们的数据。</p><p>        Idea! You can combine the Message Authentication Code and the Stream Cipher in order make a chunk of data that is encrypted and resitant against tampering. This is called  Authenticated encryption commonly done in real protocols. Try to implement the AE and AEAD variants.</p><p>        主意！您可以将消息认证码和流密码组合顺序，使得加密的数据块和攻击篡改。这被称为经过验证的加密，通常以实际协议完成。尝试实现AE和AEAD变体。 </p><p>  Warning! It is recommended to also include an IV / nonce with your key in order to make sure the same plaintext encrypts to different ciphertexts.</p><p>警告！建议还包含一个带有钥匙的IV / nonce，以确保相同的明文加密到不同的密文。</p><p>    You might have noticed that a lot of services these days ask you for one-time tokens when trying to authenticate. These tokens are usually displayed as 6 digits and expire in ~30 seconds. Using a sponge function, we can implement our own version pretty easily. Here’s how these one-time tokens work.</p><p>    你可能已经注意到这几天有很多服务在尝试验证时要求您进行一次性令牌。这些令牌通常显示为6位数，并在〜30秒内过期。使用海绵函数，我们可以轻松实现自己的版本。这是这些一次性令牌的工作原理。</p><p>  The client absorbs the current time and the secret key in order to produce a token, and sends it to the server.</p><p>  客户端吸收当前时间和密钥以生成令牌，并将其发送到服务器。</p><p>  The server independently produces a token using the same key and following the same rules.</p><p>  服务器独立地使用相同的键和遵循相同规则生成令牌。</p><p>  In [27]: import  time key  =  b &#34;Secret key 123&#34; def  get_otp ( key ,  period = 10 ):  t  =  time . time ()  value  =  int ( t  /  period )  time_left  =  period  -  ( t  %  period )  s  =  Sponge ()  s . absorb ( key )  s . absorb ( str ( value ). encode ( &#39;ascii&#39; ))  otp  =  [ s . squeeze ( 1 ). hex ()  for  _  in  range ( 3 )]  otp  =  &#39; &#39; . join ( otp )  return  otp ,  int ( time_left ) otp ,  time_left  =  get_otp ( key ) f &#34;OTP is &#39; { otp } &#39;.&#34; f &#34;Valid for  { time_left }  more seconds.&#34;</p><p>  [27]：导入时间键= B＆＃34;秘密密钥123＆＃34; def get_otp（key，su段= 10）：t =时间。时间（）值= int（t /si段）time_left =句点 - （t％时段）s = sponge（）s。吸收（键）s。吸收（str（值）。编码（＆＃39; ascii＆＃39;））OTP = [s。挤压（1）。 _在范围（3）] OTP =＆＃39中的十六进制（）; ＆＃39; 。加入（OTP）返回OTP，int（time_left）otp，time_left = get_otp（key）f＆＃34; OTP是＆＃39; {OTP}＆＃39;。＆＃34; F＆＃34;适用于{time_left}更多秒。＆＃34;</p><p>      If the code is still valid, meaning that time_left is still not zero, the OTP will be considered  valid.</p><p>      如果代码仍然有效，这意味着time_left仍然不为零，则OTP将被视为有效。</p><p>            Idea! It is recommended to also accept codes that should have been generated before or after the current time in order to account for clock skew. After all, the current time is the input that determines what the code will be, so authentication won’t be possible if the clocks don’t match up.</p><p>            主意！建议也接受当前时间之前或之后的代码，以便考虑时钟偏斜。毕竟，当前时间是输入确定代码是什么，因此如果时钟不匹配，则无法进行身份验证。 </p><p>    Stream ciphers that use cryptographic hashes have a risk of running into cycles. This is when calling the transform function on the state will eventually go back to a previous one. In order to mitigate this, we can use a block cipher instead.</p><p>使用加密散列的流密码有跑进循环的风险。这是在调用州上的变换功能时，最终将返回前一个。为了缓解此操作，我们可以使用块密码。</p><p>  The difference of a block cipher is; instead of constructing the sponge once and squeezing bytes from it for the whole stream, we instead absorb a counter into the sponge along with the key and nonce in order to generate a fixed block of bytes. This is where we get the name “block cipher”.</p><p>  块密码的差异是;而不是从它挤压海绵到整个流，而是将反击与钥匙和随机块一起吸收到海绵中，以便产生固定的字节块。这是我们获得名称“块密码”的地方。</p><p>  In [30]: BLOCKSIZE  =  10 def  get_block ( key ,  counter ):  s  =  Sponge ()  s . absorb ( key )  s . absorb ( str ( counter ). encode ( &#34;ascii&#34; ))  return  bytearray ( s . squeeze ( BLOCKSIZE )) def  block_encrypt ( data ,  key ):  size  =  len ( data )  result  =  b &#34;&#34;  counter  =  0  while  data :  # Chop off BLOCKSIZE bytes from the data  data_block  =  data [: BLOCKSIZE ]  data  =  data [ BLOCKSIZE :]  # Generate a block cipher block  block  =  get_block ( key ,  counter )  for  i ,  byte  in  enumerate ( data_block ):  block [ i ]  ^=  byte  result  +=  block  counter  +=  1  return  result [: size ] data  =  b &#34;Hello, world! Don&#39;t forget to stay hydrated.&#34; encrypted  =  block_encrypt ( data ,  b &#34;test&#34; ) encrypted . hex ()</p><p>  在[30]中：blocksize = 10 def get_block（key，counter）：s = sponge（）s。吸收（键）s。吸收（柜台）。编码（＆＃34; ascii＆＃34;））返回bytearray（s。挤压（blocksize））def block_encrypt（数据，键）：size = len（数据）结果= b＆＃34; ＆＃34;计数器= 0虽然数据：#echech关闭off offata data_block = data [：blocksize] data = data [blocksize：]＃生成块密码块= i，emumerate中的byte（ket_block（key，count）（data_block ）：块[i] ^ =字节结果+ =块计数器+ = 1返回结果[：size] data = b＆＃34;您好，世界！不要忘记保持水分。＆＃34;加密= block_encrypt（数据，B＆＃34;测试＆＃34;）加密。十六进制（）</p><p>    As we did with the stream cipher, let’s try to decrypt our data with correct and incorrect keys.</p><p>    正如我们对流密码所做的那样，让我们​​尝试用正确且不正确的键解密我们的数据。</p><p>          If you made it this far, thank you for reading my article. I’d appreciate any emails or comments. You now have an understanding of how to implement some commonly used cryptographic technologies from scratch, please let me know what projects you end up doing with sponge functions.</p><p>          如果你这么做，请感谢您阅读我的文章。我很感激任何电子邮件或评论。您现在有一个了解如何从头开始实施一些常用的加密技术，请让我知道你最终有什么项目用海绵函数。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.gkbrk.com/2021/03/md5-sponge/">https://www.gkbrk.com/2021/03/md5-sponge/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/构造/">#构造</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/sponge/">#sponge</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/数据/">#数据</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>