<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>博士后——不要这样做Postgres – Don't Do This</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Postgres – Don't Do This<br/>博士后——不要这样做</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-13 20:52:27</div><div class="page_narrow text-break page_content"><p>SQL_ASCII means &#34;no conversions&#34; for the purpose of all encoding conversion functions. That is to say, the original bytes are simply treated as being in the new encoding, subject to validity checks, without any regard for what they mean. Unless extreme care is taken, an  SQL_ASCII database will usually end up storing a mixture of many different encodings with no way to recover the original characters reliably.</p><p>SQL_ASCII表示&#34；没有转换&#34；用于所有编码转换函数。也就是说，原始字节被简单地视为处于新编码中，接受有效性检查，而不考虑它们的含义。除非格外小心，否则SQL_ASCII数据库通常会混合存储许多不同的编码，无法可靠地恢复原始字符。</p><p>  If your input data is already in a hopeless mixture of unlabelled encodings, such as IRC channel logs or non-MIME-compliant emails, then SQL_ASCII might be useful as a last resort—but consider using  bytea first instead, or whether you could autodetect UTF8 and assume non-UTF8 data is in some specific encoding such as WIN1252.</p><p>如果您的输入数据已经处于未标记的编码（例如IRC信道日志或非MIME兼容电子邮件）的无希望混合中，那么SqLYASCII可能是有用的，但考虑首先使用ByTeA，或者是否可以自动检测UTF8，并假设非UTF8数据在某些特定的编码中，例如Win 1252。</p><p>     Using the --password or -W flags will tell  psql to prompt you for a password, before trying to connect to the server - so you&#39;ll be prompted for a password even if the server doesn&#39;t require one.</p><p>在尝试连接到服务器之前，使用--password或-W标志将告诉psql提示您输入密码，因此您&#39；即使服务器没有&#39；我不需要。</p><p> It&#39;s never required, as if the server does require a password psql will prompt you for one, and it can be very confusing when setting up permissions. If you&#39;re connecting with -W to a server configured to allow you access via  peer authentication you may think that it&#39;s requiring a password when it really isn&#39;t. And if the user you&#39;re logging in as doesn&#39;t have a password set or you enter the wrong password at the prompt you&#39;ll still be logged in and think you have the right password - but you won&#39;t be able to log in from other clients (that connect via localhost) or when logged in as other users.</p><p>它&#39；s从来都不是必需的，好像服务器确实需要密码，psql会提示您输入密码，在设置权限时可能会非常混乱。如果你&#39；将-W重新连接到一个配置为允许您通过对等身份验证访问的服务器，您可能会认为它&#39；当密码真的不存在时，它需要密码&#39；t、 如果用户你&#39；以不&#39的身份重新登录；没有设置密码，或者在提示您时输入了错误的密码&#39；我仍然会登录并认为你有正确的密码，但你赢了&#39；无法从其他客户端（通过本地主机连接）或以其他用户身份登录。</p><p>  Never, pretty much. It will save a round trip to the server but that&#39;s about it.</p><p>几乎从来没有。这将节省到服务器的往返时间，但是&#39；关于这件事。</p><p>     Rules are incredibly powerful, but they don&#39;t do what they look like they do. They look like they&#39;re some conditional logic, but they actually rewrite a query to modify it or add additional queries to it.</p><p>规则非常强大，但它们没有&#39；不要做他们看起来像做的事。他们看起来像&#39；我们有一些条件逻辑，但他们实际上重写了一个查询来修改它或向它添加额外的查询。</p><p>    Never. While the rewriter is an implementation detail of VIEWs, there is no reason to pry up this cover plate directly.</p><p>从不虽然重写器是视图的一个实现细节，但没有理由直接撬起这个盖板。</p><p>     Table inheritance was a part of a fad wherein the database was closely coupled to object-oriented code. It turned out that coupling things that closely didn&#39;t actually produce the desired results.</p><p>表继承是fad的一部分，在fad中，数据库与面向对象代码紧密耦合。事实证明，把紧密联系在一起的事情&#39；实际上并不能产生预期的结果。</p><p>  Never …almost. Now that table partitioning is done natively, that common use case for table inheritance has been replaced by a native feature that handles tuple routing, etc., without bespoke code.</p><p>从来没有……几乎没有。既然表分区是本机完成的，那么表继承的常见用例已经被一个本机特性所取代，该特性可以处理元组路由等，而无需定制代码。</p><p> One of the very few exceptions would be  temporal_tables extension if you are in a pinch and want to use that for row versioning in place of a lacking SQL 2011 support. Table inheritance will provide a small shortcut instead of using  UNION ALL to get both historical as well as current rows.Even then you ought to be wary of  caveats while working with parent table.</p><p>如果需要时态_表扩展，并且希望用它来代替缺乏SQL 2011支持的行版本控制，那么极少数例外情况之一就是时态_表扩展。表继承将提供一个小的快捷方式，而不是使用UNION ALL来获取历史行和当前行。即便如此，在使用父表时，也应该警惕警告。</p><p>   Don&#39;t use  NOT IN, or any combination of  NOT and  IN such as  NOT (x IN (select…)).</p><p>唐&#39；t使用NOT IN，或NOT和IN的任何组合，例如NOT（x IN（选择…）。</p><p> (If you think you wanted  NOT IN (select …) then you should rewrite to use  NOT EXISTS instead.)</p><p>（如果你认为你不想加入（选择…），那么你应该重写为使用NOT EXISTS。）</p><p>     select * from foo where col not in (select x from bar); -- returns 0 rows if any value of bar.x is null</p><p>从列不在的foo中选择*（从条中选择x）；——如果bar的任何值为0，则返回0行。x是空的</p><p> This happens because  col IN (1,null) returns  TRUE if col=1, and  NULL otherwise (i.e. it can never return  FALSE). Since  NOT (TRUE) is  FALSE, but  NOT (NULL) is still  NULL, there is no way that  NOT (col IN (1,null)) (which is the same thing as  col NOT IN (1,null)) can return  TRUE under any circumstances.</p><p>这是因为如果col=1，col IN（1，null）返回TRUE，否则返回null（即它永远不会返回FALSE）。由于NOT（TRUE）为FALSE，但NOT（NULL）仍然为NULL，因此NOT（col IN（1，NULL））在任何情况下都不可能返回TRUE（这与col NOT IN（1，NULL）相同）。</p><p> 2. Because of point 1 above,  NOT IN (SELECT ...) does not optimize very well. In particular, the planner can&#39;t transform it into an anti-join, and so it becomes either a hashed Subplan or a plain Subplan. The hashed subplan is fast, but the planner only allows that plan for small result sets; the plain subplan is  horrifically slow (in fact O(N²)). This means that the performance can look good in small-scale tests but then slow down by 5 or more orders of magnitude once a size threshold is crossed; you  do not want this to happen.</p><p>2.由于上述第1点，不在（选择…）没有很好地优化。特别是，规划者可以&#39；t将其转换为反连接，因此它要么成为散列子平面，要么成为普通子平面。散列子计划速度很快，但规划器只允许对小的结果集使用该计划；简单的子平面非常慢（实际上是O（N²））。这意味着性能在小规模测试中看起来不错，但一旦超过尺寸阈值，性能就会降低5个或更多数量级；你不想发生这种事。</p><p>  NOT IN ( list,of,values,...) is mostly safe  unless you might have a null in the list (via a parameter or otherwise). So it&#39;s sometimes natural and even advisable to use it when excluding specific constant values from a query result.</p><p>不在（列表、列表、值等）通常是安全的，除非列表中可能有空值（通过参数或其他方式）。所以它&#39；当从查询结果中排除特定的常量值时，有时使用它是自然的，甚至是明智的。</p><p>     PostgreSQL folds all names - of tables, columns, functions and everything else - to lower case unless they&#39;re &#34;double quoted&#34;.</p><p>PostgreSQL将表、列、函数和其他所有名称折叠为小写，除非它们&#39；re&#34；双引号&#34；。</p><p> So  create table Foo() will create a table called  foo, while  create table &#34;Bar&#34;() will create a table called  Bar.</p><p>所以create table Foo（）将创建一个名为Foo的表，而create table&#34；酒吧&#34；（）将创建一个名为Bar的表。</p><p> These select commands will work:  select * from Foo,  select * from foo,  select * from &#34;Bar&#34;.</p><p>这些select命令将起作用：select*from Foo，select*from Foo，select*from&#34；酒吧&#34；。</p><p> These will fail with &#34;no such table&#34;:  select * from &#34;Foo&#34;,  select * from Bar,  select * from bar.</p><p>这些将以&#34失败；没有这样的桌子&#34；：从&#34中选择*；Foo&#34；，从栏中选择*，从栏中选择*。</p><p> This means that if you use uppercase characters in your table or column names you have to either  always double quote them or  never double quote them. That&#39;s annoying enough by hand, but when you start using other tools to access the database, some of which always quote all names and some don&#39;t, it gets very confusing.</p><p>这意味着，如果在表或列名中使用大写字符，则必须始终对其进行双引号，或永远不要对其进行双引号。那&#39；手工操作已经够烦人的了，但是当你开始使用其他工具访问数据库时，有些工具总是引用所有的名字，有些则不&#39；t、 这让人很困惑。</p><p> Stick to using a-z, 0-9 and underscore for names and you never have to worry about quoting them.</p><p>坚持使用a-z、0-9和下划线作为名称，你永远不必担心引用它们。</p><p>  If it&#39;s important that &#34;pretty&#34; names are displaying in report output then you might want to use them. But you can also use column aliases to use lower case names in a table and still get pretty names in the output of a query:  select character_name as &#34;Character Name&#34; from foo.</p><p>如果是&#39；重要的是&#34；漂亮&#34；名称显示在报告输出中，然后您可能想要使用它们。但是，您也可以使用列别名在表中使用小写名称，并且在查询的输出中仍然可以获得漂亮的名称：选择character_name as&#34；字符名&#34；来自福。</p><p>    BETWEEN uses a closed-interval comparison: the values of both ends of the specified range are included in the result.</p><p>使用闭合区间比较：结果中包括指定范围两端的值。</p><p>   This will include results where the timestamp is  exactly 2018-06-08 00:00:00.000000, but not timestamps later in that same day. So the query might seem to work, but as soon as you get an entry exactly on midnight, you&#39;ll end up double-counting it.</p><p>这将包括时间戳正好为2018-06-08 00:00:00.000000的结果，但不包括当天晚些时候的时间戳。因此，这个查询似乎是可行的，但一旦你在午夜得到一个条目，你&#39；我最终会重复计算。</p><p>    BETWEEN is safe for discrete quantities like integers or dates, as long as you remember that both ends of the range are included in the result. But it&#39;s a bad habit to get into.</p><p>对于整数或日期等离散量，只要记住结果中包含范围的两端，中间值是安全的。但它&#39；这是一个坏习惯。</p><p>    Don&#39;t use the  timestamp type to store timestamps, use  timestamptz (also known as  timestamp with time zone) instead.</p><p>唐&#39；t使用timestamp类型来存储时间戳，而使用timestamp tz（也称为带时区的时间戳）。</p><p>  timestamptz records a single moment in time. Despite what the name says it doesn&#39;t store a timestamp, just a point in time described as the number of microseconds since January 1st, 2000 in UTC. You can insert values in any timezone and it&#39;ll store the point in time that value describes. By default it will display times in your current timezone, but you can use  at time zone to display it in other time zones.</p><p>timestamptz记录了时间上的一个瞬间。不管名字怎么说，它都没有&#39；t存储一个时间戳，只是一个时间点，用UTC表示，自2000年1月1日以来的微秒数。您可以在任何时区中插入值，它&#39；我们将存储值描述的时间点。默认情况下，它将显示当前时区中的时间，但您可以使用at time zone在其他时区中显示时间。</p><p> Because it stores a point in time it will do the right thing with arithmetic involving timestamps entered in different timezones - including between timestamps from the same location on different sides of a daylight savings time change.</p><p>因为它存储的是一个时间点，所以它将在涉及在不同时区输入的时间戳的算法上做正确的事情——包括夏时制时间变化不同侧面上相同位置的时间戳之间的时间戳。</p><p> timestamp (also known as  timestamp without time zone) doesn&#39;t do any of that, it just stores a date and time you give it. You can think of it being a picture of a calendar and a clock rather than a point in time. Without additional information - the timezone - you don&#39;t know what time it records. Because of that, arithmetic between timestamps from different locations or between timestamps from summer and winter may give the wrong answer.</p><p>时间戳（也称为无时区时间戳）不&#39；它不会做任何事情，只会存储你给出的日期和时间。你可以把它想象成日历和时钟的画面，而不是时间点。如果没有额外的信息——时区——你不会&#39；我不知道它记录了什么时间。因此，不同位置的时间戳之间或夏季和冬季的时间戳之间的算术可能给出错误的答案。</p><p> So if what you want to store is a point in time, rather than a picture of a clock, use timestamptz.</p><p>因此，如果你想存储的是一个时间点，而不是一个时钟的图片，请使用timestamptz。</p><p>   If you&#39;re dealing with timestamps in an abstract way, or just saving and retrieving them from an app, where you aren&#39;t going to be doing arithmetic with them then timestamp might be suitable.</p><p>如果你&#39；以抽象的方式重新处理时间戳，或者只是从应用程序中保存和检索时间戳，而你不在&#39；我不打算用它们做算术运算，那么时间戳可能是合适的。</p><p>   Storing UTC values in a  timestamp without time zone column is, unfortunately, a practice commonly inherited from other databases that lack usable timezone support.</p><p>不幸的是，在没有时区列的时间戳中存储UTC值通常是从缺乏可用时区支持的其他数据库继承的做法。</p><p>   Because there is no way for the database to know that UTC is the intended timezone for the column values.</p><p>因为数据库无法知道UTC是列值的预期时区。</p><p> This complicates many otherwise useful time calculations. For example, &#34;last midnight in the timezone given by u.timezone&#34; becomes this:</p><p>这使得许多其他有用的时间计算变得复杂。例如&#34；在u.timezone#34给出的时区中的最后一个午夜；变成这样：</p><p>   date_trunc(&#39;day&#39;, x.datecol AT TIME ZONE &#39;UTC&#39; AT TIME ZONE u.timezone) AT TIME ZONE u.timezone AT TIME ZONE &#39;UTC&#39;</p><p>date#trunc（&#39；day&#39；，x.datecol在时区和#39；UTC和#39；在时区和#39；在时区和#39；UTC和#39；</p><p>        The type time with time zone is defined by the SQL standard, but the definition exhibits properties which lead to questionable usefulness. In most cases, a combination of date, time, timestamp without time zone, and timestamp with time zone should provide a complete range of date/time functionality required by any application.</p><p>带时区的time类型是由SQL标准定义的，但该定义显示出的属性导致其有用性受到质疑。在大多数情况下，日期、时间、不带时区的时间戳和带时区的时间戳的组合应提供任何应用程序所需的完整的日期/时间功能。</p><p>             Don&#39;t use a precision specification, especially not 0, for timestamp columns or casts to timestamp.</p><p>唐&#39；对于时间戳列或时间戳强制转换，不要使用精度规格，尤其不要使用0。</p><p>   Because it rounds off the fractional part rather than truncating it as everyone would expect. This can cause unexpected issues; consider that when you store  now() into such a column, you might be storing a value half a second in the future.</p><p>因为它舍入了小数部分，而不是像大家所期望的那样截断它。这可能会导致意想不到的问题；当您将NOW（）存储到这样的列中时，您可能会在将来存储一个半秒的值。</p><p>        Any string you insert into a  char(n) field will be padded with spaces to the declared width. That&#39;s probably not what you actually want.</p><p>插入到char（n）字段中的任何字符串都将用空格填充到声明的宽度。那&#39；这可能不是你真正想要的。</p><p>  Values of type character are physically padded with spaces to the specified width n, and are stored and displayed that way. However, trailing spaces are treated as semantically insignificant and disregarded when comparing two values of type character. In collations where whitespace is significant, this behavior can produce unexpected results; for example  SELECT &#39;a &#39;::CHAR(2) collate &#34;C&#34; &lt; E&#39;a\n&#39;::CHAR(2) returns true, even though C locale would consider a space to be greater than a newline. Trailing spaces are removed when converting a character value to one of the other string types. Note that trailing spaces are semantically significant in character varying and text values, and when using pattern matching, that is LIKE and regular expressions.</p><p>字符类型的值在物理上用空格填充到指定的宽度n，并以这种方式存储和显示。然而，在比较字符类型的两个值时，尾随空格在语义上是不重要的，并且被忽略。在空白比较重要的排序中，这种行为可能会产生意想不到的结果；例如选择&#39；a&#39；：：字符（2）校对和#34；C&#34&书信电报；E&#39；a\n&#39；：：Car（2）返回true，即使C语言环境会考虑一个空间大于一个换行符。将字符值转换为其他字符串类型时，会删除尾随空格。请注意，尾随空格在字符变化和文本值中具有重要的语义意义，在使用模式匹配时，尾随空格与正则表达式类似。</p><p>  The space-padding does waste space, but doesn&#39;t make operations on it any faster; in fact the reverse, thanks to the need to strip spaces in many contexts.</p><p>空间填充确实会浪费空间，但不会&#39；不要让它的运行速度更快；事实上，情况正好相反，因为在许多情况下需要剥离空间。</p><p> It&#39;s important to note that from a storage point of view  char(n)  is not a fixed-width type. The actual number of bytes varies since characters may take more than one byte, and the stored values are therefore treated as variable-length anyway (even though the space padding is included in the storage).</p><p>它&#39；需要注意的是，从存储角度来看，char（n）不是固定宽度的类型。实际字节数会有所不同，因为字符可能会占用多个字节，因此存储的值无论如何都会被视为可变长度（即使存储中包含空格填充）。</p><p>  When you&#39;re porting very, very old software that uses fixed width fields. Or when you read the snippet from the manual above and think &#34;yes, that makes perfect sense and is a good match for my requirements&#34; rather than gibbering and running away.</p><p>当你&#39；重新移植使用固定宽度字段的非常非常旧的软件。或者当你读到上面手册中的片段并思考&#34；是的，这很合理，很符合我的要求#34；而不是胡言乱语和逃跑。</p><p>   Sometimes people respond to &#34;don&#39;t use  char(n)&#34; with &#34;but my values must always be exactly N characters long&#34; (e.g. country codes, hashes, or identifiers from some other system).  It is still a bad idea to use  char(n) even in these cases.</p><p>有时人们对&#34；唐&#39；t使用char（n）和#34；与&#34；但我的值必须始终精确到N个字符长#34；（例如，国家代码、哈希或来自其他系统的标识符）。即使在这些情况下，使用char（n）仍然是一个坏主意。</p><p> Use  text, or a domain over text, with  CHECK(length(VALUE)=3) or  CHECK(VALUE ~ &#39;^[[:alpha:]]{3}$&#39;) or similar.</p><p>使用文本或文本上的域，带有CHECK（长度（值）=3）或CHECK（值&#39；^[：alpha:][3}$&#39；）或者类似的。</p><p>  Because  char(n) doesn&#39;t reject values that are too short, it just silently pads them with spaces. So there&#39;s no actual benefit over using  text with a constraint that checks for the exact length. As a bonus, such a check can also verify that the value is in the correct format.</p><p>因为char（n）不&#39；不要拒绝太短的值，它只是默默地用空格填充它们。因此&#39；It’使用带有约束的文本来检查确切的长度没有实际的好处。作为奖励，这样的检查还可以验证值的格式是否正确。</p><p> Remember,  there is no performance benefit whatsoever to using  char(n) over  varchar(n). In fact the reverse is true. One particular problem that comes up is that if you try and compare a  char(n) field against a parameter where the driver has explicitly specified a type of  text or  varchar, you may be unexpectedly unable to use an index for the comparison. This can be hard to debug since it doesn&#39;t show up on manual queries.</p><p>记住，使用char（n）而不是varchar（n）对性能没有任何好处。事实恰恰相反。出现的一个特殊问题是，如果尝试将char（n）字段与驱动程序显式指定了文本或varchar类型的参数进行比较，可能会意外地无法使用索引进行比较。这可能很难调试，因为它没有&#39；手动查询时不会出现。</p><p>     Don&#39;t use the type  varchar(n) by default. Consider  varchar (without the length limit) or  text instead.</p><p>唐&#39；默认情况下，不要使用varchar（n）类型。考虑VARCHAR（没有长度限制）或文本替代。</p><p>  varchar(n) is a variable width text field that will throw an error if you try and insert a string longer than n characters (not bytes) into it.</p><p>varchar（n）是一个可变宽度的文本字段，如果尝试在其中插入长度超过n个字符（而不是字节）的字符串，则会引发错误。</p><p> varchar (without the  (n)) or  text are similar, but without the length limit. If you insert the same string into the three field types they will take up exactly the same amount of space, and you won&#39;t be able to measure any difference in performance.</p><p>varchar（不带（n））或text类似，但没有长度限制。如果在三个字段类型中插入相同的字符串，它们将占用完全相同的空间量，您将赢得&#39；我无法衡量绩效上的任何差异。</p><p> If what you really need is a text field with an length limit then varchar(n) is great, but if you pick an arbitrary length and choose varchar(20) for a surname field you&#39;re risking production errors in the future when Hubert Blaine Wolfe­schlegel­stein­hausen­berger­dorff signs up for your service.</p><p>如果你真正需要的是一个有长度限制的文本字段，那么varchar（n）就很好了，但是如果你选择任意长度并选择varchar（20）作为姓氏字段，你就&#39；Hubert Blaine Wolfe-schlegel-stein-hausen-berger-dorff为您的服务注册时，您将面临生产错误的风险。</p><p> Some databases don&#39;t have a type that can hold arbitrary long text, or if they do it&#39;s not as convenient or efficient or well-supported as varchar(n). Users from those databases will often use something like  varchar(255) when what they really want is  text.</p><p>有些数据库没有&#39；我没有一个可以容纳任意长文本的类型，或者如果他们这样做了&#39；它不像varchar（n）那样方便、高效或得到很好的支持。当这些数据库的用户真正想要的是文本时，他们通常会使用varchar（255）之类的东西。</p><p> If you need to constrain the value in a field you probably need something more specific than a maximum length - maybe a minimum length too, or a limited set of characters - and a  check constraint can do all of those things as well as a maximum string length.</p><p>如果需要约束字段中的值，则可能需要比最大长度（也可能是最小长度，或有限的字符集）更具体的内容，而检查约束可以与最大字符串长度一起完成所有这些任务。</p><p>  When you want to, really. If what you want is a text field that will throw an error if you insert too long a string into it, and you don&#39;t want to use an explicit check constraint then varchar(n) is a perfectly good type. Just don&#39;t use it automatically without thinking about it.</p><p>当你想的时候，真的。如果你想要的是一个文本字段，如果你在其中插入太长的字符串，它会抛出一个错误，而你没有&#39；我不想使用显式检查约束，那么varchar（n）是一个非常好的类型。只是不要&#39；不要不假思索地自动使用它。</p><p> Also, the varchar type is in the SQL standard, unlike the text type, so it might be the best choice for writing super-portable applications.</p><p>此外，与文本类型不同，varchar类型在SQL标准中，因此它可能是编写超级可移植应用程序的最佳选择。</p><p>    The  money data type isn&#39;t actually very good for storing monetary values. Numeric, or (rarely) integer may be better.</p><p>货币数据类型为&#39；实际上，它不太适合储存货币价值。数字或（很少）整数可能更好。</p><p>   It&#39;s a fixed-point type, implemented as a machine int, so arithmetic with it is fast. But it doesn&#39;t handle fractions of a cent (or equivalents in other currencies), it&#39;s rounding behaviour is probably not what you want.</p><p>它&#39；它是一种定点类型，以机器int的形式实现，因此使用它的算法很快。但它没有&#39；t处理零碎的一美分（或其他货币的等值），它&#39；s的舍入行为可能不是你想要的。</p><p> It doesn&#39;t store a currency with the value, rather assuming that all money columns contain the currency specified by the database&#39;s  lc_monetary locale setting. If you change the lc_monetary setting for any reason, all money columns will contain the wrong value. That means that if you insert &#39;$10.00&#39; while lc_monetary is set to &#39;en_US.UTF-8&#39; the value you retrieve may be &#39;10,00 Lei&#39; or &#39;¥1,000&#39; if lc_monetary is changed.</p><p>它没有&#39；t使用值存储货币，而不是假设所有货币列都包含数据库指定的货币&#39；s lc_货币区域设置。如果出于任何原因更改lc_货币设置，所有货币列将包含错误的值。这意味着如果你插入&#39$10.00&#39; 而lc#U货币设置为&#39；恩!。UTF-8和#39；您检索到的值可能是&#39；10,00列伊和#39；或&#39；¥1,000&#39; 如果信用证金额发生变化。</p><p> Storing a value as a numeric, possibly with the currency being used in an adjacent column, might be better.</p><p>将值存储为数字（可能在相邻列中使用货币）可能更好。</p><p>  If you&#39;re only working in a single currency, aren&#39;t dealing with fractional cents and are only doing addition and subtraction then money might be the right thing.</p><p>如果你&#39；我们只使用单一货币，不是吗；t处理分数美分，只做加法和减法，那么钱可能是正确的选择。</p><p>     The serial types have some  weird behaviors that make schema, dependency, and permission management unnecessarily cumbersome.</p><p>序列类型有一些奇怪的行为，使得模式、依赖关系和权限管理变得不必要的麻烦。</p><p>  More generally, if you somehow use the same sequence for multiple tables, although in those cases an explicit declaration might be preferable over the serial types.</p><p>更一般地说，如果对多个表使用相同的序列，尽管在这些情况下，显式声明可能比串行类型更可取。</p><p>    Don&#39;t use  trust authentication over any TCP/IP method (e.g. host, hostssl) in any production environment.</p><p>唐&#39；不要在任何生产环境中通过任何TCP/IP方法（例如主机、主机SSL）使用信任身份验证。</p><p>   which allows anyone on the Internet to authenticate as any PostgreSQL user in your cluster, including the PostgreSQL superuser.</p><p>它允许Internet上的任何人作为集群中的任何PostgreSQL用户进行身份验证，包括PostgreSQL超级用户。</p><p> There is a  list of authentication methods you can choose that are better for establishing a remote connection to PostgreSQL. It is fairly easy to set up a  password based authentication method, the recommendation being  scram-sha-256 that is available in PostgreSQL 10 and above.</p><p>您可以选择一系列身份验证方法，这些方法更适合于建立到PostgreSQL的远程连接。设置基于密码的身份验证方法相当容易，建议使用PostgreSQL 10及更高版本中提供的scram-sha-256。</p><p>   trust authentication is only suitable for TCP/IP connections if you trust every user on every machine that is allowed to connect to the server by the  pg_hba.conf lines that specify  trust. It is seldom reasonable to use trust for any TCP/IP connections other than those from localhost (127.0.0.1).</p><p>信任身份验证仅适用于TCP/IP连接，前提是您信任pg_hba允许连接到服务器的每台计算机上的每个用户。指定信任的conf行。除了来自本地主机（127.0.0.1）的TCP/IP连接之外，对任何TCP/IP连接使用信任都是不合理的。</p><p> With  trust authentication, any user can claim to be any other user and PostgreSQL will trust that assertion. This means that someone can claim to be the  postgres superuser account and PostgreSQL will accept that claim and allow them to log in.</p><p>通过信任认证，任何用户都可以声称自己是任何其他用户，PostgreSQL将信任该断言。这意味着有人可以声称自己是postgres超级用户帐户，PostgreSQL将接受该声明并允许他们登录。</p><p> To take this a step further, it is also not a good idea to allow  trust authentication to be used on  local UNIX socket connections in a production environment, as anyone with access to the instance running PostgreSQL could log in as any user.</p><p>更进一步说，允许在生产环境中的本地UNIX套接字连接上使用信任身份验证也不是一个好主意，因为任何有权访问运行PostgreSQL的实例的人都可以作为任何用户登录。</p><p>   The longer answer is there are a few scenarios where  trust authentication may be appropriate:</p><p>较长的答案是，有几种情况下，信任验证可能是合适的：</p><p> Running tests against a PostgreSQL server as part of a CI/CD job that is on a trusted network</p><p>作为可信网络上CI/CD作业的一部分，对PostgreSQL server运行测试</p><p> but you should see if any of the alternative methods work better for you. For example, on UNIX-based systems, you can connect to your local development environment using  peer authentication.</p><p>但你应该看看是否有其他方法更适合你。例如，在基于UNIX的系统上，可以使用对等身份验证连接到本地开发环境。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/博士后/">#博士后</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/postgres/">#postgres</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>