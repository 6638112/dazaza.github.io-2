<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>视觉上探索数据库 Exploring Databases Visually</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Exploring Databases Visually<br/>视觉上探索数据库 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-04-05 07:59:04</div><div class="page_narrow text-break page_content"><p>One way to look at a database&#39;s structure is as a graph of foreign key relationships among tables. Two styles of visual representation predominate: models or entity-relationship diagrams ( ERDs) created as part of requirements negotiation and design, and descriptive diagrams of an extant database. The former are drawn by hand on a whiteboard or in diagramming software; the latter are often generated by database management tools with some manual cleanup and organization. Both styles usually take the complete database as their object, and whether descriptive or prescriptive, their role in the software development process is as reference material, or documentation.</p><p>一种查看数据库的一种方法和＃39; S结构是表中的外键关系图。两种类型的视觉表示占主导地位：作为需求协商和设计的一部分创建的模型或实体关系图（ERDS），以及扩展数据库的描述性图。前者是用手动绘制的白板或图中的软件;后者通常由数据库管理工具生成，具有一些手动清理和组织。这两种样式通常将完整的数据库作为它们的对象，以及是否描述或规定，它们在软件开发过程中的角色是参考材料或文档。</p><p> Documentation isn&#39;t disposable. Even though these diagrams are out of date practically as soon as they&#39;re saved off, they take effort to make, or at least to make legible -- automated tools are only so good at layout, especially as table and relationship counts grow. That effort isn&#39;t lightly discarded, and anyway a diagram that&#39;s still  mostly accurate remains a useful reference.</p><p> 文档ISN＆＃39; t一次性。尽管这些图表已经超出了一旦被保存了，但他们正在努力制造，或者至少制作易读 - 自动化工具只是如此擅长布局，尤其是表和关系的增长。这种努力尚未丢弃，无论如何仍然大多数准确的图仍然是一个有用的参考。</p><p> Documentation isn&#39;t disposable. But documentation isn&#39;t the only tool we have for orienting ourselves in a system: we can also explore, view the system in parts and from different angles, follow individual paths through the model from concept to concept. Exploration depends on adopting a partial, mobile perspective from the inside of the model, with rapid feedback and enough context to navigate but not so much as to be overwhelmed. The view from a single point is more or less important depending on the point itself, but in order to facilitate exploration that view has to be generated and discarded on demand. Look, move, look, move.</p><p> 文档ISN＆＃39; t一次性。但文档ISN＆＃39; T唯一用于在系统中定向自己的工具：我们还可以探索，从零件和不同角度查看系统，从概念到概念的模型跟随单个路径。探索取决于采用模型内部的部分，移动角度，快速反馈和足够的上下文来导航，但不是不堪重负。根据点本身，单点的视图或多或少重要，但为了促进探索，必须根据需求生成和丢弃。看，移动，看，移动。</p><p>   It&#39;s generated by  this  fks zsh function which queries Postgres&#39; catalog of foreign keys using a  recursive common table expression to identify and visualize everything connected in a straight line to the target. The query output is passed to the  Graphviz suite&#39;s  dot with a template, rendered to png, and the png displayed with   wezterm imgcat. No files are created or harmed at any point in the process.</p><p>   它由此FKS ZSH函数生成的＆＃39;查询Postgres＆＃39;使用递归公共表表达式对外键的目录来识别和可视化直线连接到目标的所有内容。查询输出通过呈现为PNG的模板传递给GraphViz套件＆＃39; s点，并使用Wezterm Imgcat显示的PNG。在此过程中的任何点都没有创建或损害任何文件。</p><p> Why only a straight line, though? The graph above has obvious gaps:  film_actor implies an  actor, and  film_category its own table on the other side of the junction.  inventory probably wants a  store, and  rental and the payment tables aren&#39;t much use without a  customer. The view from  rental is markedly different, with half a dozen tables that weren&#39;t visible at all from  film:</p><p> 虽然为什么只有一条直线？上面的图表具有明显的空白：Film_Actor暗示了一个演员，并在交界处的另一侧拍摄了自己的表。库存可能想要商店，租赁和支付桌子＆＃39; T无需客户。来自租赁的视图是显着的，有一半的表＆＃39;在电影中可见半个表：</p><p>  This graph is familiar in part: there&#39;s  rental itself, the payment tables,  inventory,  film -- the last shorn of the junctions to the still-missing  actor and  category tables. Those have passed around a metaphorical corner, since in order to get from  rental to  film_actor you must travel first  up foreign keys into  film (via  rental.inventory_id and  inventory.film_id), then  down by way of  film_actor.film_id.  language, meanwhile, is &#34;upwards&#34; of  film and therefore remains visible from  rental.</p><p>  此图表部分是熟悉的：租赁本身，支付表，库存，电影 - 结束对仍然缺少的演员和类别表的最后一层。那些已经传递了一个隐喻的角落，因为为了从租赁到Film_Actor来到Film_actor，你必须先将外部键进入电影（通过rental.inventory_id和库存.film_id），然后通过film_actor.film_id下来。与此同时，语言，是＆＃34;向上和＃34;薄膜，因此从租金中仍然可见。</p><p> The reason  fks restricts its search to straight lines from the target table is to keep context narrow. You can get a fuller picture of the table structure by navigating and viewing the graph from multiple perspectives; what  fks shows is the set of tables which can affect the target, or which will be affected by changes in the target. If you delete a  store or a  film, rentals from that store or of that film are invalidated (and, unless the intermediary foreign keys are set to cascade, the delete fails). But deleting a  film_actor has nothing to do with  rental, and vice versa.</p><p> 原因FKS将其从目标表中的直线限制为直线，是保持上下文缩小。您可以通过从多个透视图导航和查看图表来获得表结构的更全面的照片;什么FKS显示的是一组可以影响目标的表，或者将受到目标变化的影响。如果您删除商店或电影，则租用该商店或该电影的租赁失效（以及除非中间键设置为Cascade，删除失败）。但删除电影_actor与租赁无关，反之亦然。 </p><p> There&#39;s an actual, serious problem with unrestricted traversal, too. If you recurse through  all relationships, you wind up mapping entire subgraphs, or clusters of related tables. And clusters grow quickly. Stuart Kauffman has a great illustration of the principle in his book  At Home in the Universe: The Search for the Laws of Self-Organization and Complexity.</p><p>在没有限制遍历的实际情况下存在实际严重的问题。如果您通过所有关系重复，您会映射整个子图或相关表的集群。和集群快速增长。 Stuart Kauffman在宇宙中的家中的书中有一个很好的说明：寻找自组织和复杂性的法律。</p><p> Imagine 10,000 buttons scattered on a hardwood floor. Randomly choose two buttons and connect them with a thread. Now put this pair down and randomly choose two more buttons, pick them up, and connect them with a thread. As you continue to do this, at first you will almost certainly pick up buttons that you have not picked up before. After a while, however, you are more likely to pick at random a pair of buttons and find that you have already chosen one of the pair. So when you tie a thread between the two newly chosen buttons, you will find three buttons tied together. In short, as you continue to choose random pairs of buttons to connect with a thread, after a while the buttons start becoming interconnected into larger clusters.</p><p> 想象一下，10,000个按钮散落在硬木地板上。随机选择两个按钮并用线程将它们连接。现在将这对放下并随机选择更多按钮，选择它们，并用线程将它们连接。当你继续这样做时，起初你几乎肯定会拿起你之前没有拾取的按钮。但是，一段时间后，您更有可能在随机挑选一对按钮，并发现您已经选择了其中一个对。因此，当您在两个新选择的按钮之间绑定一个线程时，您将找到三个按钮绑在一起。简而言之，随着您继续选择随机对按钮与线程连接，在一段时间之后，按钮开始变为互连到更大的群集。</p><p> When the ratio of threads to buttons, or relationships to tables, passes 0.5, there&#39;s a phase transition. Enough clusters exist that the next thread or relationship will likely connect one cluster to another, and the next, and the next. A supercluster emerges, nearly the size of the entire relationship graph. We can see what the relationship:table ratio looks like in a database by querying the system catalogs:</p><p> 当线程与按钮的比率或与表格的关系，通过0.5，有0.5个，相位过渡。存在足够的群集，下一个线程或关系可能将一个群集连接到另一个群集，然后是下一个群集。超级集团出现，几乎是整个关系图的大小。我们可以通过查询系统目录来查看数据库中的关系：表比在数据库中查看：</p><p> WITH tbls AS (  SELECT  count(*)  AS  num  FROM information_schema.tables  WHERE table_schema  NOT  IN ( &#39;pg_catalog&#39;,  &#39;information_schema&#39;)), fks  AS (  SELECT  count(*)  AS  num  FROM pg_constraint  WHERE contype =  &#39;f&#39;) SELECT fks.num  AS f, tbls.num  AS t, fks.num:: decimal / tbls.num  AS r FROM tbls  CROSS  JOIN fks;</p><p> 使用tbls（选择count（*）为from Information_schema.Tables，其中table_schema不在（＆＃39; pg_catalog＆＃39;＆＃39; secorify_schema＆＃39;）），FKS（选择count（*）为num从pg_constraint，contype =＆＃39; f＆＃39;）选择fks.num作为f，tbls.num作为t，fks.num :: decimal / tbls.num作为tbrs交叉加入fks;</p><p> The lowest ratio I have in a real working database is 0.56, and it&#39;s a small one, with f=14 and t=25. Others range from 0.61 (f=78, t=126) all the way up to 1.96 (f=2171, t=1107 thanks to a heavily partitioned table with multiple foreign keys); pagila itself is in the middle at 1.08 (f=27, t=25). I don&#39;t have enough data to back this up, but I think it&#39;s reasonable to expect that the number of relationships tends to increase faster than the number of tables. Without restrictions on traversal, you might as well draw a regular  ERD: superclusters are inevitable.</p><p> 我在真实工作数据库中的最低比率为0.56，并且它＆＃39; s一个小的，f = 14和t = 25。其他方式范围为0.61（f = 78，t = 126），均可达到1.96（f = 2171，t = 1107，因为具有多个外键的重分隔表）; Pagila本身位于中间1.08（f = 27，t = 25）。我没有足够的数据来返回这一点，但我认为它是合理的，希望关系的数量往往比表的数量更快地增加。没有对遍历的限制，您可以绘制常规ERD：超级全民家是不可避免的。</p><p> fks will draw a regular  ERD if passed only the database name, but like I said earlier, automated tools are only so good at layout (and in a terminal of limited width, even a smallish database is liable to produce an illegibly zoomed-out model). With no way to add universal render hints, Graphviz does a lot better with the smaller, more restricted graphs from local perspectives inside the database -- and so do humans. Reading a full-scale data model is hard! Tens or hundreds of nodes have to be sorted by relevance to the problem at hand; nodes and relationships which matter have to be mapped, the irrelevant actively ignored, others tagged with a mental question mark. Often a given problem involves more relevant entities than the human mind can track unaided.  fks doesn&#39;t resolve the issue completely, but making a database spatial and navigating that space visually goes some way to meet our limitations and those of our tools.</p><p> FKS将绘制一个常规的ERD，如果只传递数据库名称，但就像我之前说过的那样，自动化工具只在布局时才如此擅长（并且在宽度有限的终端，甚至一个Smallish数据库易于产生一个令人无法缩小的缩放模型）。没有办法添加通用渲染提示，GraphViz从数据库内的本地透视图较小，更有限制的图表进行了更好的较多 - 而且人类也是如此。阅读全尺寸数据模型很难！不得不通过与手中的问题的相关性来排序数十或数百个节点;不带映射的节点和关系，无关紧要地忽略了，其他标记有心理问号。通常，给定的问题涉及比人类思维能够履行更多相关的实体。 FKS并不完全解决问题，但是制作数据库空间和导航该空间视觉上的某种方式来满足我们的局限性和我们的工具。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://di.nmfay.com/exploring-databases-visually">https://di.nmfay.com/exploring-databases-visually</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/数据库/">#数据库</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/database/">#database</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/探索/">#探索</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/databases/">#databases</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>