<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>本体，图形和海龟Ontology, Graphs and Turtles</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Ontology, Graphs and Turtles<br/>本体，图形和海龟</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-28 04:12:05</div><div class="page_narrow text-break page_content"><p>Let’s go deeper into the concept and apply some technology to create an actual graph structure and eventually play with it.</p><p>让我们深入了解该概念，并应用一些技术来创建实际的图形结构，并最终使用它。</p><p> At the end of this article, we well have parsed a triplestore in turtle format and created a graph structure in Go (based on  gonum’s interface)</p><p> 在本文的最后，我们已经很好地解析了乌龟格式的Triplestore并在Go中创建了一个图结构（基于gonum的界面）</p><p>  As explained in the last post, our knowledge database is a triple store. As a matter of example, I will rely on the ontology exposed by  schema.org.</p><p>  如上一篇文章所述，我们的知识数据库是一个三重存储。作为示例，我将依靠schema.org公开的本体。</p><p> Schema.org is a collaborative, community activity with a mission to create, maintain, and promote schemas for structured data on the Internet, on web pages, in email messages, and beyond. Founded by Google, Microsoft, Yahoo and Yandex, Schema.org vocabularies are developed by an open community process […].You can grab the complete ontology with this command:</p><p> Schema.org是一项协作性社区活动，其任务是创建，维护和促进Internet，网页，电子邮件以及其他内容中的结构化数据架构。由Google，Microsoft，Yahoo和Yandex创建的Schema.org词汇表是由开放的社区流程开发的[…]。您可以使用以下命令获取完整的本体：</p><p>     To parse the store, I am using the package   gon3 from  Andrei Sambra. Even though there is no license attached, Andrei allowed me to use it and to modify it for non-profit code.</p><p>     为了解析商店，我使用了Andrei Sambra的gon3软件包。即使没有附加许可证，安德烈（Andrei）仍然允许我使用它并针对非营利代码对其进行修改。</p><p>  The entry point of the package is a  Parser structure. Its purpose is to read a byte stream ( io.Reader) and turn it into a functional structure called  Graph. The  Graph structure within the package is not representing all the edges. Still, it consists of an array of Triples (aka rdf graph):</p><p>  包的入口点是解析器结构。其目的是读取字节流（io.Reader）并将其转换为称为Graph的功能结构。包中的Graph结构并不代表所有边缘。它仍然由一个三元组数组（又称为rdf图）组成：</p><p> // An RDF graph is a set of RDF triples  type  Graph  struct  {	 triples  [] * Triple	 uri  * IRI }</p><p> // RDF图是一组RDF三元组类型Graph struct {Triples [] * Triple uri * IRI}</p><p> A  Triple is a structure holding three  Term. One is the subject, one is a predicate, and the last one is the object.</p><p>三元组是包含三个项的结构。一个是主语，一个是谓语，最后一个是宾语。</p><p>  In the previous article, we saw that a term in RDF can be expressed in different types. As of today, the way to represent generic types in Go is to use interfaces. Therefore, a  Term has an  interface based definition:</p><p>  在上一篇文章中，我们看到RDF中的术语可以用不同的类型表示。到目前为止，在Go中表示通用类型的方法是使用接口。因此，术语具有基于接口的定义：</p><p>     If we glue all the concepts together we have the possibility to create a basic structure:</p><p>     如果我们将所有概念粘合在一起，就有可能创建一个基本结构：</p><p> import  &#34;github.com/owulveryck/gon3&#34;  // Other imports omited for brevity  func  main ()  {  baseURI  :=  &#34;https://example.org/foo&#34;  parser  :=  gon3 . NewParser ( baseURI )  gr ,  _  :=  parser . Parse ( os . Stdin )  // Error handling is omited for brevity   fmt . Printf ( &#34;graph contains %v triples&#34; ,  len ( gr . Triples ())) }</p><p> import“ github.com/owulveryck/gon3” //为简洁起见，其他导入省略了func main（）{baseURI：=“ https://example.org/foo”解析器：= gon3。 NewParser（baseURI）gr，_：=解析器。 Parse（os.Stdin）//为简洁起见，省略了错误处理。 Printf（“图形包含％v个三元组”，len（gr。三元组（）））}</p><p>   We can check that roughly the number of triple matches what’s expected by counting the rdf separators from the file:</p><p>   我们可以通过计算文件中的rdf分隔符来检查三元组的数量是否与预期的大致匹配：</p><p>  The numbers are not identical but alike (the grep command does not evaluate the literal and some punctuation may be wrongly counted)</p><p>  这些数字不是相同的，而是相似的（grep命令不评估文字，并且某些标点符号可能被错误地计算）</p><p>   We have an “RDF” graph in memory; sadly, this structure is not a directed graph. I mean that it is not  de facto possible to navigate from nodes to nodes or to identify the edges.</p><p>   我们在内存中有一个“ RDF”图；可悲的是，这种结构不是有向图。我的意思是，实际上不可能从一个节点导航到另一个节点或识别边缘。</p><p> To create a graph, the best option in Go is to rely on the abstraction created by   gonum</p><p>要创建图，Go中最好的选择是依靠gonum创建的抽象</p><p> In Gonum a graph is an interface that manages two objects fulfilling the  Node and  Edge such as:</p><p> 在Gonum中，图形是一个接口，用于管理实现Node和Edge的两个对象，例如：</p><p> type  Graph  interface  {  Node ( id  int64 )  Node  Nodes ()  Nodes  From ( id  int64 )  Nodes  HasEdgeBetween ( xid ,  yid  int64 )  bool  Edge ( uid ,  vid  int64 )  Edge }</p><p> 类型图形接口{节点（id（int64）节点节点（）来自（id int64的节点）节点HasEdgeBetween（xid，yid int64）bool Edge（uid，vid int64）Edge}</p><p>    Once the graph objects are fulfilling those interfaces, it becomes possible to use all the graph algorithms that have been implemented by the gonum team.Please go to this link if you wish to learn more about the capabilities:  pkg.go.dev/gonum.org/v1/gonum/graph#section-directories</p><p>    一旦图形对象满足了这些接口，就可以使用gonum团队已实现的所有图形算法。如果您想了解有关功能的更多信息，请转到此链接：pkg.go.dev/gonum。 org / v1 / gonum / graph＃section-directories</p><p>  We will create a top-level structure that will act as a receiver for our graph. For the graph itself, we rely on the   simple.DirectedGraph implementation provided by the gonum’s project.</p><p>  我们将创建一个顶层结构，它将作为图形的接收者。对于图本身，我们依赖于gonum项目提供的simple.DirectedGraph实现。</p><p>   Then we will create a function to create and fill our graph from our rdfGraph.</p><p>   然后，我们将创建一个函数来从rdfGraph创建并填充图形。</p><p> func  NewGraph ( rdfGraph  * gon3 . Graph )  * Graph  { 	 g  :=  simple . NewDirectedGraph ()  // ... fill the graph   return  &amp; Graph {  DirectedGraph :  g ,  } }</p><p> func NewGraph（rdfGraph * gon3.Graph）* Graph {g：=简单。 NewDirectedGraph（）// ...填满图表return＆Graph {DirectedGraph：g，}}</p><p>  Remember that the rdf graph contains an array of triples. Each triple is a term.</p><p>请记住，rdf图包含一个三元组数组。每个三元组都是一个学期。</p><p>     This indicates a choice I’ve made: I want to produce a graph where its node corresponds to a subject declared  inside the triplestore.Therefore, in the example,  object2 is not a node because it is not defined as a subject to a sentence. It is relatively easy to change this behavior and reference other nodes, but let’s keep that apart.</p><p>     这表明我已经做出了选择：我想生成一个图形，其节点与在Triplestore内部声明的主题相对应。因此，在示例中，object2不是节点，因为它没有被定义为句子的主题。更改此行为并引用其他节点相对容易，但是让我们分开。</p><p>     Adding a method  ID() that returns an int64 makes it compatible with gonum’s Node interface.Therefore it is possible to add it to a simple graph. So far, this codes compiles (but is useless):</p><p>     添加返回int64的方法ID（）使其与gonum的Node接口兼容，因此可以将其添加到简单图形中。到目前为止，此代码可以编译（但没有用）：</p><p>   Using the same principle, we create an Edge structure that holds two nodes  From and  To as well as a term that defines the edge.</p><p>   使用相同的原理，我们创建一个Edge结构，该结构包含两个节点From和To以及一个定义边的术语。</p><p>      The first thing we’ll do is to create a tree of terms. We do that thanks to a hash map.The key is a subject, and the value is another map. The map value’s key is a predicate and the value is an array of objects (remember that a predicate can point to several objects)</p><p>      我们要做的第一件事是创建术语树。我们通过一个哈希映射来做到这一点，键是一个主题，值是另一个映射。地图值的键是一个谓词，并且值是一个对象数组（请记住，谓词可以指向多个对象）</p><p>  But before parsing the rdf graph to fill the tree, we have to address a little gotcha. a  Term is an interface. Therefore it is a pointer. Therefore in the rdf graph, if we consider two  Terms  t1 and  t2 such as:</p><p>  但是在解析rdf图以填充树之前，我们必须解决一些难题。术语是一个接口。因此，它是一个指针。因此，在rdf图中，如果我们考虑两个条件t1和t2，例如：</p><p>     Then we iter over the triples from our rdf graph to fille the tree and the dictionary.</p><p>     然后，我们遍历rdf图的三元组以填充树和字典。</p><p>  Note: for convenience, we will also set the dictionary as an attribute to our graph for later. The structure becomes:</p><p>注意：为方便起见，我们还将字典设置为图形的属性，以备后用。结构变为：</p><p>  We can now range over the tree, and create all the nodes in the graph for each subject:</p><p>  现在，我们可以遍历树，并为每个主题在图中创建所有节点：</p><p> for  s ,  po  :=  range  tree  {  n  :=  &amp; Node {  id :  g . NewNode (). ID (),  Subject :  s ,  PredicateObject :  po ,  }  g . AddNode ( n )  reference [ s ]  =  n }</p><p> 对于s，po：=范围树{n：=＆节点{id：g。 NewNode（）。 ID（），主题：s，PredicateObject：po，} g。 AddNode（n）引用[s] = n}</p><p> Note: once again, for convenience, we track the nodes in a hash map. This reference map has the subject as a key and the node as a value (its type is  map[rdf.Term]*Node).</p><p> 注意：为方便起见，我们再次跟踪哈希图中的节点。此参考地图的主题为键，节点为值（其类型为map [rdf.Term] * Node）。</p><p>  for  s ,  po  :=  range  tree  {  me  :=  reference [ s ]  for  predicate ,  objects  :=  range  po  {  for  _ ,  object  :=  range  objects  {  if  me  ==  to  {  // self edge   continue  }  to  :=  reference [ object ]  e  :=  Edge {  F :  me ,  T :  to ,  Term :  predicate ,  }  g . SetEdge ( e )  }  } }</p><p>  对于s，po：=范围树{me：=参考[s]对于谓词，对象：= range po {对于_，object：=范围对象{如果me ==到{//自边缘继续}到：=参考[object] e：= Edge {F：me，T：to，Term：predicate，} g。 SetEdge（e）}}}</p><p>   Now that we have the graph builder ok, we can test it with the data from schema.org we downloaded earlier.</p><p>   现在我们有了图构建器，可以使用我们先前下载的schema.org中的数据进行测试。</p><p> Let’s write a simple program that creates the graph and do a simple query. For example, we may want to get all the nodes directly linked to the  PostalAddress in schema.org.</p><p> 让我们编写一个简单的程序来创建图形并进行简单的查询。例如，我们可能想让所有节点直接链接到schema.org中的PostalAddress。</p><p> baseURI  :=  &#34;https://example.org/foo&#34; parser  :=  rdf . NewParser ( baseURI ) gr ,  err  :=  parser . Parse ( os . Stdin ) if  err  !=  nil  {  log . Fatal ( err ) } g  :=  graph . NewGraph ( gr ) postalAddress  :=  g . Dict [ &#34;http://schema.org/PostalAddress&#34; ] node  :=  g . Reference [ postalAddress ] it  :=  g . To ( node . ID ()) for  it . Next ()  {  n  :=  it . Node ().( * graph . Node )  // need inference here because gonum&#39;s simple graph returns a type graph.Node which is an interface   fmt . Printf ( &#34;%v -&gt; %v\n&#34; ,  node . Subject ,  n . Subject ) }</p><p>baseURI：=“ https://example.org/foo”解析器：= rdf。 NewParser（baseURI）gr，错误：=解析器。如果err！= nil {log。致命（err）} g：=图。 NewGraph（gr）postalAddress：= g。 Dict [“ http://schema.org/PostalAddress”]节点：= g。参考[postalAddress]它：= g。到（节点ID（））。 Next（）{n：=它。 Node（）。（* graph。Node）//在这里需要推论，因为gonum的简单图返回一个graph.Node类型，它是一个接口f​​mt。 Printf（“％v->％v \ n”，节点。主题，n。主题）}</p><p>  ❯ cat schemaorg-current-http.ttl| go run main.go&lt;http://schema.org/PostalAddress&gt; -&gt; &lt;http://schema.org/deliveryAddress&gt;&lt;http://schema.org/PostalAddress&gt; -&gt; &lt;http://schema.org/postalCode&gt;&lt;http://schema.org/PostalAddress&gt; -&gt; &lt;http://schema.org/servicePostalAddress&gt;&lt;http://schema.org/PostalAddress&gt; -&gt; &lt;http://schema.org/originAddress&gt;&lt;http://schema.org/PostalAddress&gt; -&gt; &lt;http://schema.org/addressCountry&gt;&lt;http://schema.org/PostalAddress&gt; -&gt; &lt;http://schema.org/location&gt;&lt;http://schema.org/PostalAddress&gt; -&gt; &lt;http://schema.org/billingAddress&gt;&lt;http://schema.org/PostalAddress&gt; -&gt; &lt;http://schema.org/addressLocality&gt;&lt;http://schema.org/PostalAddress&gt; -&gt; &lt;http://schema.org/postOfficeBoxNumber&gt;&lt;http://schema.org/PostalAddress&gt; -&gt; &lt;http://schema.org/streetAddress&gt;&lt;http://schema.org/PostalAddress&gt; -&gt; &lt;http://schema.org/address&gt;&lt;http://schema.org/PostalAddress&gt; -&gt; &lt;http://schema.org/addressRegion&gt;&lt;http://schema.org/PostalAddress&gt; -&gt; &lt;http://schema.org/gameLocation&gt;&lt;http://schema.org/PostalAddress&gt; -&gt; &lt;http://schema.org/itemLocation&gt;</p><p>  ❯cat schemaorg-current-http.ttl |去运行main.go ->  ->  ->  ->  ->  ->  ->  ->  ->  ->  ->  ->  ->  -> </p><p> If we check on schema.org’s website ( https://schema.org/PostalAddress), we find those elements but in two different tables:</p><p> 如果我们查看schema.org的网站（https://schema.org/PostalAddress），则会在两个不同的表中找到这些元素：</p><p>   Remember, we are dealing with ontology; therefore, the link has a meaning. And this meaning has been set as an attribute of the edge. If we tweak the code to display the edge like this:</p><p>   请记住，我们正在处理本体。因此，链接具有含义。并且已经将该含义设置为边缘的属性。如果我们调整代码以显示边缘，如下所示：</p><p> for  it . Next ()  {  n  :=  it . Node ().( * graph . Node )  // need inference here because gonum&#39;s simple graph returns a type graph.Node which is an interface   e  :=  g . Edge ( n . ID (),  node . ID ()).( graph . Edge )  fmt . Printf ( &#34;%v -%v-&gt; %v\n&#34; ,  node . Subject ,  e . Term ,  n . Subject ) }</p><p> 为了它 。 Next（）{n：=它。 Node（）。（* graph。Node）//在这里需要推论，因为gonum的简单图返回一个graph.Node类型，它是一个接口e：= g。 Edge（n.ID（），节点ID（））。（graph.Edge）fmt。 Printf（“％v-％v->％v \ n”，节点。主题，e。Term，n。主题）}</p><p>  &lt;http://schema.org/PostalAddress&gt; -&lt;http://schema.org/domainIncludes&gt;-&gt; &lt;http://schema.org/addressRegion&gt;&lt;http://schema.org/PostalAddress&gt; -&lt;http://schema.org/rangeIncludes&gt;-&gt; &lt;http://schema.org/billingAddress&gt;&lt;http://schema.org/PostalAddress&gt; -&lt;http://schema.org/rangeIncludes&gt;-&gt; &lt;http://schema.org/servicePostalAddress&gt;&lt;http://schema.org/PostalAddress&gt; -&lt;http://schema.org/domainIncludes&gt;-&gt; &lt;http://schema.org/streetAddress&gt;&lt;http://schema.org/PostalAddress&gt; -&lt;http://schema.org/domainIncludes&gt;-&gt; &lt;http://schema.org/addressCountry&gt;&lt;http://schema.org/PostalAddress&gt; -&lt;http://schema.org/domainIncludes&gt;-&gt; &lt;http://schema.org/postOfficeBoxNumber&gt;&lt;http://schema.org/PostalAddress&gt; -&lt;http://schema.org/domainIncludes&gt;-&gt; &lt;http://schema.org/addressLocality&gt;&lt;http://schema.org/PostalAddress&gt; -&lt;http://schema.org/rangeIncludes&gt;-&gt; &lt;http://schema.org/location&gt;&lt;http://schema.org/PostalAddress&gt; -&lt;http://schema.org/rangeIncludes&gt;-&gt; &lt;http://schema.org/itemLocation&gt;&lt;http://schema.org/PostalAddress&gt; -&lt;http://schema.org/rangeIncludes&gt;-&gt; &lt;http://schema.org/deliveryAddress&gt;&lt;http://schema.org/PostalAddress&gt; -&lt;http://schema.org/rangeIncludes&gt;-&gt; &lt;http://schema.org/address&gt;&lt;http://schema.org/PostalAddress&gt; -&lt;http://schema.org/domainIncludes&gt;-&gt; &lt;http://schema.org/postalCode&gt;&lt;http://schema.org/PostalAddress&gt; -&lt;http://schema.org/rangeIncludes&gt;-&gt; &lt;http://schema.org/gameLocation&gt;&lt;http://schema.org/PostalAddress&gt; -&lt;http://schema.org/rangeIncludes&gt;-&gt; &lt;http://schema.org/originAddress&gt;</p><p>  -->  -->  -->  -->  -->  -->  -->  -->  - ->  -->  -->  -->  -->  - -> </p><p>  We’ve built a graph structure in memory quickly. What’s important is not the structure by itself. The important is the perspectives it opens.So far, we have worked on schemas, but the semantics applies to the data itself. On top of that, the graph we have generated is reasonably generic. Therefore, the same principle could be used to store our knowledge graph within a persistent database such as dgraph or maybe neo4j.</p><p>  我们已经在内存中快速建立了图形结构。重要的不是结构本身。重要的是它打开的视角。到目前为止，我们已经研究了模式，但是语义适用于数据本身。最重要的是，我们生成的图是相当通用的。因此，可以使用相同的原理将我们的知识图存储在诸如dgraph或neo4j之类的持久数据库中。</p><p> In the next article, we will work with the graph and set up a template engine to create generic documentation of our knowledge graph using  go template.</p><p>在下一篇文章中，我们将使用图并设置模板引擎，以使用go模板创建知识图的通用文档。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://blog.owulveryck.info/2020/11/17/ontology-graphs-and-turtles-part-ii.html">https://blog.owulveryck.info/2020/11/17/ontology-graphs-and-turtles-part-ii.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/图形/">#图形</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/graphs/">#graphs</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/org/">#org</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>