<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Go中服务的非阻塞并行性 </title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Go中服务的非阻塞并行性 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-01-19 16:16:11</div><div class="page_narrow text-break page_content"><p>Go具有许多有用的内置功能，可用于安全，并发和并行代码。不管这些功能多么实用，它们都无法为您编写程序。与许多语言一样，最重要的知识不是语言的特征，而是众所周知的模式，这些模式将这些特征组合成可以解决经常发生的问题的解决方案。我刚开始将Go用作日常的基本语言，最近遇到了一种有用的模式，我认为值得分享。有人告诉我，在Palantir，这种方式称为发痒器图案。</p><p>   您可以选择限制服务中的并行度，即一次处理多少个请求。</p><p>  我们将永远拥有服务循环，等待信号重新考虑队列的内容，</p><p> 让我们看一下代码并更详细地讨论这些步骤。我们从类型开始：</p><p> //虚拟请求-通常是一些Protobuf / Thrift结构类型Request int type Service结构{mu sync。互斥体队列*列表。列出sema chan int loopSignal chan结构{}}</p><p> 我们将使用一个通道来表示一个有限的信号量。尽管您也可以使用sync.Semaphore，但在Go中这是非常习惯的做法。我们对所需解决方案的明确要求之一是，调用者在发出请求时绝不能阻塞。我们将始终首先使请求入队，而处理却要异步完成，这一事实可以满足这一要求。请注意，我的解决方案不会提供检索请求响应的方法。</p><p> func（s * Service）EnqueueRequest（请求请求）错误{s。亩Lock（）延迟s。亩解锁（）。排队。 PushBack（请求）日志。 Printf（＆＃34;将请求添加到长度为％d \ n＆＃34;，s。queue。Len（））的队列中。 tickleLoop（）返回nil} </p><p>我们为队列获取了一个互斥锁，因为我们将有多个goroutine并发访问它。我们排队请求，然后通知循环。最后一部分进行了解释。现在我们有了添加请求的方法，我们可以处理代码来处理请求。由于这是一项服务，因此我们将使其永远循环，以等待新工作完成。这也是循环信号起作用的地方：</p><p> func（s * Service）循环（ctx上下文。Context）{日志。为{select {case＆lt;-s}的Println（＆＃34;正在启动服务循环＆＃34;）。 loopSignal：s。 tryDequeue（）case＆lt;-ctx。完成（）：日志。 Printf（＆＃34;取消循环上下文＆＃34;）返回}}}</p><p> 我们的循环方法将具有服务循环，直到在我们传入的上下文中实现Done（）通道为止。这将使我们在程序结束时或发生错误的情况下正常关闭服务。更重要的是，我们等待loopSignal告诉我们重新考虑队列。该信号在以下两种情况之一中发送：</p><p>  您可以说服自己，这是我们服务周期中仅有的两个必须考虑排队的事件。如果服务的队列为空，则使新请求入队将通知服务查看该新请求。如果请求已入队，但由于达到了我们配置的并行度的限制而无法立即处理，则唯一会改变的时间是请求完成处理后，即信号量由一个令牌补充。</p><p> 现在让我们看一下tryDequeue，它在循环“发痒”时调用。其不确定的命名源于以下事实：调用tryDequeue时，我们：</p><p> 根本不知道队列中是否有任何请求，因为该信号可能是由于完成了对上一个飞行中请求的处理，</p><p>  如果队列中有请求，不知道我们是否有足够的资源。 </p><p>func（s * Service）tryDequeue（）{s。亩Lock（）延迟s。亩如果s解锁（）。排队。 Len（）== 0 {return} select {case s。 sema＆lt;-1：请求：= s。出队（）log。 Printf（＆＃34;出队请求％v \ n＆＃34;，request）进入s。处理（请求）默认值：log。 Printf（＆＃34;接收到循环信号，但已达到请求限制＆＃34;）}} func（s * Service）出队（）Request {element：= s。排队。前（）s。排队。删除（元素）返回元素。价值。 （请求）}</p><p> 我们通过测试队列的长度来检查不确定性的第一种情况。如果我们知道我们有工作要做，我们需要检查信号量是否具有足够的插槽以允许处理请求。因为信号量信号量将是一个缓冲通道，所以我们知道，如果信号量中没有剩余的插槽，则发送新令牌（整数1）将阻止该信号量，或者在这种情况下触发默认情况。如果我们达到了并行性的极限，我们只需处理该请求，直到重新标记该循环。出队功能是一个小助手，它可以处理从队列中弹出元素的烦人事务，由于Go缺乏泛型，因此涉及类型转换。</p><p> 如果一个请求通过了tryDequeue函数的严格测试并被选中进行处理，我们将在处理方法中处理它：</p><p> func（s * Service）流程（请求Request）{延迟s。补充（）日志。 Printf（＆＃34;处理请求％v \ n＆＃34;，request）//模拟工作＆lt;-time。之后（时间。持续时间（rand。Intn（500））*时间。毫秒）}函数（s *服务）补充（）{＆lt;-s。信号日志。 Printf（＆＃34;补充信号量，现在％d /％d个插槽正在使用中\ n＆＃34 ;、 len（s.sema），cap（s.sema））s。 tickleLoop（）}</p><p> 真正有趣的是补充功能。此功能有两个职责。首先，它在信号量中释放了一个插槽，以便可以处理新的请求。其次，它会打勾循环，告知您是时候重新考虑请求队列，以防万一有其他先完成的请求被阻止的请求。如果您还记得的话，这是必须重新考虑请求队列的两种情况中的第二种。</p><p> 让我们也揭开tickleLoop函数的神秘面纱。它只是使非阻塞发送到loopSignal通道：</p><p>   func NewService（ctx上下文。Context，requestLimit int）*服务{service：=＆amp;服务{队列：清单。 New（），sema：make（chan int，requestLimit），loopSignal：make（chan struct {}，1），} go service。循环（ctx）返回服务} </p><p>Warning: Can only detect less than 5000 characters</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="http://www.goldsborough.me/go/2020/12/06/12-24-24-non-blocking_parallelism_for_services_in_go/">http://www.goldsborough.me/go/2020/12/06/12-24-24-non-blocking_parallelism_for_services_in_go/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/服务/">#服务</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/请求/">#请求</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1044808.html"><img src="http://img2.diglog.com/img/2021/1/thumb_af861bfb20f1eb7c8c089ef1b8eabbad.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1044808.html">为什么服务网格应逐渐消失 </a></div><span class="my_story_list_date">2021-1-18 7:51</span></div><div class="col-sm"><div><a target="_blank" href="/story/1044361.html"><img src="http://img2.diglog.com/img/2021/1/thumb_71e1ee009c05bdbd93878d27eec979ea.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1044361.html">消息来源：苹果正在讨论推出一项新的订阅服务，该服务将向人们收取收听播客的费用 </a></div><span class="my_story_list_date">2021-1-16 2:9</span></div><div class="col-sm"><div><a target="_blank" href="/story/1044329.html"><img src="http://img2.diglog.com/img/2021/1/thumb_636a3dd92096e1b71aa50d8702e64ca7.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1044329.html">信号关闭 </a></div><span class="my_story_list_date">2021-1-16 0:27</span></div><div class="col-sm"><div><a target="_blank" href="/story/1044228.html"><img src="http://img2.diglog.com/img/2021/1/thumb_578540beeed558b1b386938bb799ef93.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1044228.html">AT＆T取消了以前称为DirecTV的失败电视服务 </a></div><span class="my_story_list_date">2021-1-15 20:45</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>