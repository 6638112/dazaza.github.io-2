<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>字节码联盟：一年更新</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">字节码联盟：一年更新</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-10-27 06:27:04</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/10/249ac6f171e941d1bbde876cfebe8da1.png"><img src="http://img2.diglog.com/img/2020/10/249ac6f171e941d1bbde876cfebe8da1.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>We announced the Bytecode Alliance nearly a year ago, and since then it has been… quite a year 😬</p><p>我们在将近一年前宣布了字节码联盟，从那时起它就是…。相当一年的😬。</p><p> While the 2020-ness of this year has slowed us down on some fronts, we’ve also made a lot of progress on others.</p><p>虽然今年的2020年让我们在某些方面放慢了脚步，但我们在其他方面也取得了很大进展。</p><p> Now that we’ve adjusted to the new normal, we’re gearing up to accelerate on  all fronts. But before we do that, we wanted to share some highlights of what we’ve achieved to date.</p><p>既然我们已经适应了新常态，我们就在各条战线上加速前进。但在此之前，我们想分享一些我们迄今取得的成就的亮点。</p><p>  Our goal is to evolve WebAssembly from a compilation target that you compile monolithic applications  to, to a modular ecosystem that you compose applications  from.</p><p>我们的目标是将WebAssembly从编译单片应用程序的编译目标发展到组成应用程序的模块化生态系统。</p><p> As we do this, we have a chance to fix many longstanding problems with the way software is developed. For example, we can make it much safer for your application to use dependencies that you didn’t code yourself.</p><p>在我们这样做的同时，我们有机会解决软件开发方式中的许多长期存在的问题。例如，我们可以让您的应用程序更安全地使用不是您自己编写的依赖项。</p><p> This is why the  nanoprocess model is so important. It’s the paradigm shift necessary to empower developers to defend themselves against these problems.</p><p>这就是纳米过程模型如此重要的原因。这是必要的范式转换，使开发人员能够保护自己不受这些问题的影响。</p><p>   You can think of WASI as the way that the host and a WebAssembly module talk to each other.</p><p>您可以将WASI视为主机和WebAssembly模块相互通信的方式。</p><p> You can think of module linking as the way that two WebAssembly modules talk to each other.</p><p>您可以将模块链接视为两个WebAssembly模块相互通信的方式。</p><p>  In both of these cases, the two sides are often written in different source languages. This means they might represent values and handles to resources in different ways. Basically, they speak foreign languages.</p><p>在这两种情况下，双方通常都是用不同的源语言编写的。这意味着它们可能以不同的方式表示资源的值和句柄。基本上，他们说外语。</p><p> Interface types are like a foreign-language dictionary that the engine uses to help them communicate.</p><p>接口类型就像引擎用来帮助它们通信的外语词典。</p><p>   Note: The Bytecode Alliance doesn’t host specifications. While BA members are driving specs mentioned below, they are doing that in collaboration with others in the W3C WebAssembly CG. Bytecode Alliance projects include implementations of these specs.</p><p>注意：字节码联盟不托管规范。当BA成员驾驶下面提到的规格时，他们是与W3CWebAssembly CG中的其他人合作做到这一点的。字节码联盟项目包括这些规范的实现。</p><p>  When we introduced WASI, we compared it to  POSIX and other system interfaces. That was a bit of an oversimplification, though.</p><p>当我们介绍WASI时，我们将其与POSIX和其他系统接口进行了比较。不过，这有点过于简单化了。</p><p>  While WASI does aim to provide a set of standardized modules that provide these low-level system interface operations, we also intend to standardize modules for specialized higher-level host APIs.</p><p>虽然WASI的目标确实是提供一组标准化模块来提供这些低级系统接口操作，但我们也打算为专门的高级主机API标准化模块。</p><p>   For the low-level system interface level, the work has been focused on quality of implementation.</p><p>对于底层系统接口层，工作重点一直放在实现质量上。</p><p> On the spec side, that has been identifying and addressing problems with cross-platform implementability of the spec. One example of this is the   wasi-socket API (which was  recently prototyped in Wasmtime). In this case, the conversation has centered on the right way to apply capabilities-based security to the handling of sockets.</p><p>在规范方面，这一直在识别和解决规范的跨平台可实现性问题。这方面的一个例子是WASI-Socket API(最近在Wasmtime中建立了原型)。在本例中，对话的中心是将基于功能的安全性应用于套接字处理的正确方式。</p><p>  On the implementation side, we’ve done a lot of work to improve the security and reliability of our implementation. Part of this has been developing robust fuzzing measures (which we describe more below).</p><p>在实现方面，我们做了大量工作来提高实现的安全性和可靠性。这其中的一部分是开发强大的模糊措施(我们将在下面进行更多描述)。</p><p> Another thing we’ve done is factored out the security-critical operations into a dedicated library,   cap-std. It’s a cross-platform library which provides much of the functionality of Rust’s standard library in a capabilities-oriented way. This allows us to fully focus on getting those security-critical foundations right on all platforms. As a next step, we’ll make use of  cap-std in our WASI implementation.</p><p>我们做的另一件事是将安全关键操作分解到一个专用库CAP-STD中。它是一个跨平台库，以面向功能的方式提供了Rust标准库的大部分功能。这使我们能够完全专注于在所有平台上正确处理这些安全关键型基础。下一步，我们将在WASI实现中使用CAP-STD。</p><p>  For the specialized higher-level host APIs, there has been exciting work on proposals for completely new API modules.</p><p>对于专门的更高级别的主机API，已经就全新API模块的提案进行了激动人心的工作。</p><p> One great example of this is   wasi-nn, which is a  standardized interface for neural networking. This is useful because trained machine learning models are typically deployed on a variety of different devices with different architectures and operating systems. Using  wasi-nn, the  .wasm file can do things like describe tensors and execute inference requests in a portable way, regardless of the underlying ISA and OS.</p><p>WASI-nn就是一个很好的例子，它是神经网络的标准化接口。这很有用，因为经过训练的机器学习模型通常部署在具有不同架构和操作系统的各种不同设备上。使用wasi-nn，.wasm文件可以以可移植的方式执行诸如描述张量和执行推理请求之类的工作，而与底层的ISA和OS无关。</p><p> We’re implementing all of these in Wasmtime as they develop. That way, people can try them out and real world usage can inform the specification.</p><p>随着它们的发展，我们将在Wasmtime中实现所有这些功能。这样，人们就可以试用它们，现实世界中的使用情况也可以告知规范。</p><p>  If we’re going to have an ecosystem of reusable code, we need a good way to link modules together.</p><p>如果我们要有一个可重用代码的生态系统，我们需要一种将模块链接在一起的好方法。</p><p> Right now, you can link modules together using host APIs. For example, on the web you can string together a bunch of  WebAssembly.instantiate calls to link a set of modules together. In Wasmtime, you use the  linker APIs.</p><p>现在，您可以使用主机API将模块链接在一起。例如，在Web上，您可以将一组WebAssembly.instantiate调用串在一起，以便将一组模块链接在一起。在Wasmtime中，您可以使用链接器API。</p><p> But there are a few downsides to this imperative style, including the fact that it’s fairly cumbersome, not that fast and requires the host to include some type of garbage or cycle collector.</p><p>但是这种命令式风格也有一些缺点，包括它相当笨拙，速度不是很快，并且需要宿主包含某种类型的垃圾或循环收集器。</p><p> With the module linking proposal, linking becomes declarative. This means that it’s much easier to use. It also means that even at compile time, the engine has all of the information about how modules are connected to each other. This opens up lots of potential optimizations and features and removes the possibility of cycles.</p><p>有了模块链接建议，链接就变成了声明性的。这意味着它更容易使用。这还意味着，即使在编译时，引擎也拥有有关模块如何相互连接的所有信息。这打开了许多潜在的优化和特性，并消除了循环的可能性。</p><p> For now, we’re focusing on load-time linking, which will enable modules to factor out common library code. And for that, the proposal is pretty much complete. Longer term, we’ll be able to add run-time dynamic linking as well.</p><p>目前，我们将重点放在加载时链接上，这将使模块能够提取公共库代码。就这一点而言，这项提案几乎是完整的。从长远来看，我们还可以添加运行时动态链接。</p><p> Our next step is to finish a prototype implementation, which should be complete within the next few months.</p><p>我们的下一步是完成原型实现，应该在接下来的几个月内完成。</p><p>   Interface Types can now talk about a rich set of values. The design is also more efficient now, removing the need for an intermediate copy of values in almost all cases.</p><p>接口类型现在可以谈论一组丰富的值。设计现在也更加高效，几乎在所有情况下都不需要值的中间副本。</p><p>  While Interface Types can talk about values, they can’t yet talk about  handles to resources and  buffers. Both are important to support WASI and other APIs, because things like files should use handles, and it should be possible to read a file and write directly into a buffer.</p><p>虽然接口类型可以谈论值，但它们还不能谈论资源和缓冲区的句柄。这两种方法对于支持WASI和其他API都很重要，因为像文件这样的东西应该使用句柄，并且应该可以直接读取文件并将其写入缓冲区。</p><p>  Once those features are in place, Interface Types will have everything it needs to support both WASI and Module Linking, making it possible for them to talk about values and resources in a source-language independent way. So we’ll continue working on the spec in the W3C.</p><p>一旦这些特性就位，接口类型将拥有支持WASI和模块链接所需的一切，从而使它们能够以独立于源语言的方式谈论值和资源。因此，我们将继续研究W3C中的规范。</p><p> On the implementation, we’ve set the stage to execute quickly. We’ve already implemented the new features in Wasm core which Interface Types depend on, such as  Reference Types,  multi-value, and  multi-memory support.</p><p>在实现上，我们已经为快速执行做好了准备。我们已经在Wasm核心中实现了接口类型所依赖的新特性，例如引用类型、多值和多内存支持。</p><p> We’re also working on tools for using Interface Types. Currently, people can use   wasm-bindgen to create bindings for JS code. In the coming year, we’ll add direct support for Interface Types to language toolchains,  starting with Rust.</p><p>我们还在开发使用接口类型的工具。目前，人们可以使用wasm-bindgen为JS代码创建绑定。在接下来的一年里，我们将直接向语言工具链添加对接口类型的支持，从Rust开始。</p><p>  In the meantime, for people wanting to get things done today but in a forward compatible way, you can define your interface using  WITX. You can learn more about how to do this from  this presentation by Pat Hickey, or  this blog post from Radu Matei.</p><p>同时，对于想要在今天完成工作但又向前兼容的人来说，您可以使用WITX定义您的界面。你可以从Pat Hickey的这篇演讲或Radu Matei的这篇博客文章中了解到更多关于如何做到这一点的信息。</p><p>  To bring the nanoprocess model to as many people as possible, we need to integrate with as many languages as possible.</p><p>为了将纳米过程模型带给尽可能多的人，我们需要与尽可能多的语言集成。</p><p>  If you want to produce code that uses the nanoprocess model, you need a compiler that:</p><p>如果您想要生成使用纳米进程模型的代码，您需要一个编译器：</p><p>  To help language communities speed up their adoption, we’ve started building out   wasm-tools. This is a standard set of tools that other compilers can use to target WebAssembly.</p><p>为了帮助语言社区加速采用它们，我们已经开始构建wasm工具。这是其他编译器可以用来瞄准WebAssembly的一组标准工具。</p><p> These are all tools that we use in Wasmtime, so as new WebAssembly features come online, they are supported here. For example, we’ve already started building support for module-linking into these tools.</p><p>这些都是我们在Wasmtime中使用的工具，所以当新的WebAssembly特性上线时，这里支持它们。例如，我们已经开始在这些工具中构建对模块链接的支持。</p><p>  wasmparser, which is a parser for WebAssembly files. It’s quite cheap because it doesn’t do any extra allocations, and can parse in a streaming fashion.</p><p>Wasmparser，它是WebAssembly文件的解析器。它相当便宜，因为它不做任何额外的分配，并且可以以流的方式进行解析。</p><p>  wasmprinter, which translates a .wasm binary format into the .wat text format, which is useful for debugging and testing.</p><p>Wasm打印机，它将.wasm二进制格式转换为.wat文本格式，这对调试和测试很有用。</p><p>  wat and   wast, which translate the .wat and .wast text formats into the binary format, which is useful for running tests (since it’s easier to maintain tests in the text format).</p><p>Wat和wast，它们将.wat和.wast文本格式转换为二进制格式，这对于运行测试很有用(因为以文本格式维护测试更容易)。</p><p>  wasm-smith, which is a  test case generator. It generates pseudo-random Wasm modules, guaranteed to be valid Wasm modules, which we use for fuzzing.</p><p>WASM-Smith，它是一个测试用例生成器。它生成伪随机的wasm模块，保证是有效的wasm模块，我们将其用于模糊化。</p><p> We will be adding more tools over the next year. For example, we will host the language-independent parts of the  Rust Interface Types toolkit in  wasm-tools, which will make it easier for languages that compile to WebAssembly to start supporting Interface Types. We also plan to collaborate with language communities on integrating these tools as they come online.</p><p>明年我们将增加更多工具。例如，我们将在wasm-tools中托管Rust Interface Types工具包的与语言无关的部分，这将使编译为WebAssembly的语言更容易开始支持Interface类型。我们还计划与语言社区合作，在这些工具上线时将其集成起来。</p><p>  If you have a whole WebAssembly application, you can run that directly in a runtime like Wasmtime. But sometimes, you just want to run a little bit of WebAssembly in your project.</p><p>如果您有一个完整的WebAssembly应用程序，则可以在Wasmtime等运行时中直接运行该应用程序。但有时，您只想在项目中运行一点WebAssembly。</p><p> For example, you might be writing some Python code, but want to do some intensive computations. Python may be too slow, and native extensions may be too frustrating to use portably, so you could use a WebAssembly module instead.</p><p>例如，您可能正在编写一些Python代码，但是想要进行一些密集的计算。Python可能太慢，本机扩展可能太令人沮丧，无法移植使用，所以您可以使用WebAssembly模块。</p><p>     As new nanoprocess features come online, they get added to Wasmtime. We don’t consider feature development complete until the feature is exposed in the language embeddings that we maintain. That means that these languages can run the most cutting-edge WebAssembly modules as soon as possible.</p><p>随着新的纳米处理功能上线，它们将被添加到Wasmtime中。直到特性在我们维护的语言嵌入中公开，我们才认为特性开发完成。这意味着这些语言可以尽快运行最尖端的WebAssembly模块。</p><p> It also means that these language communities don’t have to come up with their own ways of doing linking and binding. They can just depend on the WebAssembly standards, which makes everything more interoperable.</p><p>这也意味着这些语言社区不必想出自己的链接和绑定方式。它们可以仅仅依赖于WebAssembly标准，这使得一切都更具互操作性。</p><p> In the last year, we’ve transitioned the embeddings we maintain to use the standard  Wasm C API, and we’re keeping our Rust embedding API and the C API updated in lock-step.</p><p>在去年，我们已经将我们维护的嵌入转换为使用标准的Wasm C API，并且我们保持Rust Embedding API和C API的同步更新。</p><p>  We’ve said it before, but building out these foundations is too big a task to tackle alone. That’s why effective multi-stakeholder collaboration is so important.</p><p>我们以前说过，但建设这些基础是一项太大的任务，无法单独解决。这就是为什么有效的多方利益相关者协作如此重要的原因。</p><p> Here are some of the changes we’ve made over the past year to make that collaboration even better.</p><p>以下是我们在过去一年中所做的一些更改，以使协作变得更好。</p><p>  Cranelift is the code generator used in many runtimes, including Wasmtime, Lucet, and SpiderMonkey, and other projects like an  alternative backend for the Rust compiler. It turns Wasm into machine code. With the new backend, we’ve made it much easier to add support for new ISAs, and to collaborate on improving existing ones.</p><p>Cranelift是许多运行时中使用的代码生成器，包括Wasmtime、Lucet和SpiderMonkey，以及其他项目中使用的代码生成器，例如Rust编译器的替代后端。它把wasm变成了机器代码。有了新的后端，我们可以更轻松地添加对新ISA的支持，并协作改进现有的ISA。</p><p> Cranelift’s previous backend used one intermediate representation (IR) for everything. It also had some obscure abstractions that were hard to work with.</p><p>Cranelift之前的后端使用一个中间表示(IR)来表示所有内容。它还有一些晦涩难懂的抽象概念，很难使用。</p><p> The new system splits the process into two phases, adding a second IR that is machine specific. This way, each IR can be specialized to its task at-hand. The new system also removes the obscure abstractions (you can learn more about this in the  Kill Recipes With Fire 🔥 bug).</p><p>新系统将流程分成两个阶段，增加了第二个特定于机器的IR。这样，每个IR都可以专门用于手头的任务。新系统还删除了模糊的抽象(您可以在用火杀死🔥错误中了解更多这方面的信息)。</p><p> We also added a new tool called  Peepmatic. With this tool, we can apply peephole optimizations when the code is still portable, before we get to the second IR. And we’re in the process of making Peepmatic even more flexible so that we can apply peephole optimizations in the second phase, too, when the IR is machine specific.</p><p>我们还添加了一个名为Peepmal的新工具。有了这个工具，我们可以在代码仍然可移植的情况下(在我们到达第二个IR之前)应用窥视优化。我们正在使PEEPMIC变得更加灵活，这样我们也可以在第二阶段应用窥视孔优化，当IR是特定于机器的时候。</p><p> The goal is that anything that is not a control-flow transformation can go through Peepmatic. With this, we’ll have a lot less one-off, hand-written code in Cranelift, which improves maintainability.</p><p>我们的目标是，任何不是控制流转换的东西都可以通过Peepma。有了这一点，我们在Cranelift中的一次性手写代码就会少得多，从而提高了可维护性。</p><p> It also helps with correctness: the DSL Peepmatic uses makes some correctness issues impossible, and is easier to reason about than hand-written code. We also have plans to add verification of our peephole optimizations. This way, we can detect when an optimization isn’t correct for all inputs.</p><p>它还有助于正确性：DSL Peepical的使用使得一些正确性问题变得不可能，而且比手写代码更容易推理。我们还计划增加对我们窥视孔优化的验证。这样，我们就可以检测到何时优化对所有输入都不正确。</p><p> To realize the full potential of Peepmatic and the WebAssembly sandbox in general, we’re working with academic researchers. For example, we’re working with  John Regehr and his student  Jubi Teneja on adding superoptimizations through integration with  Souper. And we now have promising approach for mitigating side channel attacks in Cranelift thanks to researchers at UCSD and the Helmholz Center for Information Security.</p><p>为了实现Peepmal和WebAssembly沙箱的全部潜力，我们正在与学术研究人员合作。例如，我们正在与John Regehr和他的学生Jubi Teneja合作，通过与Souper集成来添加超级优化。多亏了加州大学圣地亚哥分校(UCSD)和赫尔姆霍兹信息安全中心(Helmholz Center For Information Security)的研究人员，我们现在有了一种很有希望的方法来减轻Cranelift的侧通道攻击。</p><p>  If you have lots of people from lots of organizations adding new features, you need guardrails in place to make sure they aren’t breaking each other’s functionality in the process.</p><p>如果您有来自许多组织的许多人添加新功能，您需要设置护栏，以确保他们在添加新功能的过程中不会破坏彼此的功能。</p><p> One really great way to catch edge case-y bugs is fuzzing. We’ve put substantial effort into building top-notch fuzzing infrastructure. We even  became the first project written primarily in Rust to be accepted to Google’s  OSS-Fuzz continuous fuzzing service. Since then, OSS-Fuzz has found 80-90 bugs which might not have been found otherwise.</p><p>捕捉Edge case-y错误的一个非常好的方法是模糊。我们在建设一流的模糊基础设施上投入了大量的精力。我们甚至成为第一个接受Google的OSS-Fuzz连续模糊服务的主要用Rust编写的项目。从那时起，OSS-Fuzz已经发现了80-90个错误，否则可能不会发现这些错误。</p><p>  We fuzz WebAssembly execution. As mentioned above, we have the   wasm-smith test case generator, which is really good at creating interesting test cases as different inputs for fuzzing. We also do differential fuzzing, comparing results we get  with optimizations and those we get  without optimizations to make sure that we get the same results. And we do Peepmatic-specific fuzzing, plus  various other configurations.</p><p>我们模糊了WebAssembly的执行。如上所述，我们有wasm-Smith测试用例生成器，它非常擅长创建有趣的测试用例作为模糊的不同输入。我们还进行差分模糊处理，将优化后的结果与未优化时的结果进行比较，以确保得到相同的结果。我们做的是Peepma专用的毛发，外加各种其他的配置。</p><p> To make sure the calls into the library work, we also fuzz the API. And we  fuzz wasm-tools to make sure they can roundtrip everything. If the bytes the fuzzer gives us successfully parse as Wasm with  wasmparser, then we will print them with  wasmprinter to make sure that they successfully print to the text format, and then we’ll make sure that the text parsers can parse the result.</p><p>为了确保库中的调用正常工作，我们还对API进行了模糊处理。我们用模糊的工具来确保他们可以往返一切。如果fuzzer提供给我们的字节使用wasmparser成功地解析为wasm，那么我们将使用wasmprint打印它们，以确保它们成功打印为文本格式，然后我们将确保文本解析器可以解析结果。</p><p> In Cranelift, we don’t just fuzz at the entry IR level. We also have a second entry point near the end of the pipeline that we can also fuzz at. This makes it a lot easier to hit all of the corner cases of the register allocator algorithm.</p><p>在Cranelift中，我们不只是在入门IR级别进行模糊处理。我们还有第二个入口点，靠近管道的尽头，我们也可以在那里模糊不清。这使得命中寄存器分配器算法的所有转角情况变得容易得多。</p><p> And to make sure we continue to have top-notch fuzzing, we’ve instituted a new rule: a feature isn’t considered done until you’ve added fuzzing for it.</p><p>为了确保我们继续拥有一流的毛发功能，我们制定了一条新规则：在您为其添加毛发功能之前，不会认为该功能已完成。</p><p>  Of course, it’s hard to collaborate on something if you don’t know how it works. To this end, we’ve improved our  documentation and examples.</p><p>当然，如果你不知道某件事是如何运作的，就很难进行协作。为此，我们改进了文档和示例。</p><p>    Merging Lucet and Wasmtime has been the plan since we announced the BA. And it’s about to get a lot easier to execute on that plan, since the Wasmtime team is moving to Fastly! 🎉</p><p>自从我们宣布英航以来，合并Lucet和Wasmtime就一直是我们的计划。该计划的执行将变得容易得多，因为Wasmtime团队正在快速行动！🎉。</p><p>   Mozilla will continue to have a team working on WebAssembly in Firefox, focused exclusively on the needs of web developers. As part of this, they will continue working on the Cranelift code generator, used by many projects including Firefox, Lucet, and Wasmtime.</p><p>Mozilla将继续有一个团队在Firefox中开发WebAssembly，专门专注于Web开发人员的需求。作为这项工作的一部分，他们将继续开发Cranelift代码生成器，许多项目都在使用该生成器，包括Firefox、Lucet和Wasmtime。</p><p> Fastly will take on sponsorship for the work on the outside-the-browser projects that were hatched at Mozilla, including Wasmtime and WASI, and we look forward to expanding the scope of that work further.</p><p>Fastly将赞助在Mozilla孵化的浏览器外项目的工作，包括Wasmtime和Wasi，我们期待着进一步扩大这项工作的范围。</p><p> This is a testament to the collaborative, multi-stakeholder setup of the Bytecode Alliance. It doesn’t matter where we work—we’re still working together.</p><p>这证明了字节码联盟的协作、多利益相关者的设置。我们在哪里工作并不重要，我们还在一起工作。</p><p>  This process is all great. But it doesn’t mean anything if we don’t get it into the hands of users.</p><p>这个过程非常棒。但如果我们不把它送到用户手中，那就没有任何意义了。</p><p>   Firefox’s WebAssembly support on x86/x64 has always been best-in-class. However, because of architectural constraints, its performance on Arm wasn’t keeping up. Cranelift was started specifically to get a backend with an architecture that works as well for Arm and other platforms as it does for x86/x64.</p><p>Firefox对x86/x64的WebAssembly支持一直是同类中最好的。然而，由于体系结构的限制，它在ARM上的性能跟不上。Cranelift的启动是专门为了获得一个后端，它的架构可以在ARM和其他平台上工作，就像它在x86/x64上一样。</p><p> This is now bearing fruit. Cranelift is now used by default for WebAssembly content in Firefox Nightly on Arm64 platforms, and work is ongoing to use it on x86/x64, too.</p><p>这现在正在结出硕果。在Arm64平台上的Firefox Nighly中，Cranelift现在默认用于WebAssembly内容，在x86/x64上使用它的工作也在进行中。</p><p> This is another way that the Bytecode Alliance helps accelerate the whole ecosystem. By having our WebAssembly experts team up with the CPU architecture experts at Arm and Intel, we’ve been able to reach better designs that help us move faster and get better results.</p><p>这是字节码联盟帮助加速整个生态系统的另一种方式。通过让我们的WebAssembly专家与ARM和英特尔的CPU架构专家合作，我们已经能够实现更好的设计，帮助我们更快地行动并获得更好的结果。</p><p>  Fastly’s goal has always been to enable developers to move data and applications to the edge. And recently, they’ve made some huge advances towards that goal using WebAssembly.</p><p>Fastly的目标一直是使开发人员能够将数据和应用程序移动到边缘。最近，他们使用WebAssembly朝着这个目标取得了一些巨大的进步。</p><p> They were one of the  first companies to see WebAssembly’s potential on the server-side. They’ve since developed that into a serverless compute environment with startup times 100x faster than other alternatives, called  Compute@Edge.</p><p>他们是最早看到WebAssembly在服务器端潜力的公司之一。自那以后，他们已经将其开发成无服务器计算环境，启动时间比其他替代方案快100倍，称为Compute@Edge。</p><p>  Shopify powers over one million different merchants globally. And these customers all have different needs.</p><p>Shopify为全球100多万家不同的商家提供动力。而这些客户都有不同的需求。</p><p> To keep the codebase and user experience simple, Shopify has a product principle: Build what most merchants need, most of the time. If merchants need features beyond that core set, Shopify provides an App Store with third party apps to solve for that long tail of requirements.</p><p>为了保持代码库和用户体验的简单性，Shopify有一个产品原则：大部分时间构建大多数商家需要的东西。如果商家需要该核心集之外的功能，Shopify会提供一个带有第三方应用程序的应用程序商店来解决这一长尾需求。</p><p> Many of those apps are hosted on their own infrastructure, and during flash sale events are sometimes taken down by the surge in load. To help app developers build more stable apps, Shopify wants to allow app code to run internally right within Shopify.</p><p>其中许多应用程序都托管在自己的基础设施上，在闪电销售期间，活动有时会因为负载激增而被撤下。为了帮助应用程序开发者构建更稳定的应用程序，Shopify希望允许应用程序代码直接在Shopify内部运行。</p><p> But how can you run this third-party code in a fast and safe way?  By using WebAssembly.</p><p>但是，您如何才能快速安全地运行此第三方代码呢？通过使用WebAssembly。</p><p> With their new platform, built on top of Lucet, they’ve been able to run a flash sale with 120,000 WebAssembly modules spinning up and executing in a 60 second flash sale window, while maintaining a runtime performance of under 10 ms per module.</p><p>有了建立在Lucet之上的新平台，他们已经能够在60秒的闪售窗口中运行12万个WebAssembly模块的闪售，同时将每个模块的运行时性能保持在10毫秒以下。</p><p>  While Wasmtime is a great general purpose WebAssembly runtime, sometimes you want something that is tailored to your use case. A number of developers are building more complex purpose-built runtimes on top of it.</p><p>虽然Wasmtime是一个很好的通用WebAssembly运行时，但有时您需要为您的用例量身定做一些东西。许多开发人员正在其上构建更复杂的、专门构建的运行时。</p><p>  Enarx is a Trusted Execution Environment. It keeps your data completely confidential, even from the hardware it’s running on.</p><p>Enarx是一个受信任的执行环境。它使您的数据完全保密，即使是对其运行的硬件也是如此。</p><p>    WaSCC implements an actor framework for connecting to cloud-native services, such as message brokers and databases.</p><p>WaSCC实现了一个参与者框架，用于连接消息代理和数据库等云本地服务。</p><p>    One big focus is formalizing the governance model so we can bring on new members. There are some fantastic prospective members doing critical work in the ecosystem who we’d love to bring on. To do so, we need to define processes for things like how elections are held and important technical decisions are made. And we need to put all that into bylaws, so our partners know what they’re signing up for.</p><p>一大重点是将治理模型正式化，这样我们就可以引入新成员。有一些很棒的潜在成员在生态系统中做着关键的工作，我们很愿意把他们带出来。要做到这一点，我们需要为如何举行选举和做出重要的技术决策等问题定义流程。我们需要把所有这些都写进规章制度，这样我们的合作伙伴才能知道他们签约的目的是什么。</p><p> This year’s crises have distracted from that work, but after adjusting to the new normal, we’ve made good progress. At this point, we’re just working on the finishing touches. Once these are in place, we’ll be able to accept new members and work on scaling the organization.</p><p>今年的危机分散了我们对这项工作的注意力，但在适应新常态之后，我们取得了很好的进展。在这一点上，我们只是在做最后的润色。一旦这些都就位了，我们将能够接受新成员，并致力于扩大组织规模。</p><p>  As we mentioned above, both the Module Linking proposal and Interface Types proposals are coming along nicely. We’ll be focused on getting those proposals to an MVP, and implementing support in runtimes and toolchains. We expect to have much of this work done in the first half of 2021.</p><p>正如我们上面提到的，模块链接提案和接口类型提案都进展顺利。我们将专注于将这些建议提交给MVP，并在运行时和工具链中实现支持。我们预计这方面的大部分工作将在2021年上半年完成。</p><p>  Once the MVP for Interface Types is in place, we’ll be able to start working with language communities to map their language’s types to Interface Types. This way, we’ll be able to have maximum interoperability between modules written in different languages, and easily run these modules in WebAssembly hosts with WASI support.</p><p>一旦接口类型的MVP就位，我们将能够开始与语言社区合作，将他们的语言类型映射到接口类型。这样，我们将能够最大限度地提高用不同语言编写的模块之间的互操作性，并在具有WASI支持的WebAssembly主机中轻松运行这些模块。</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://bytecodealliance.org/articles/1-year-update">https://bytecodealliance.org/articles/1-year-update</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/字节/">#字节</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/alliance/">#alliance</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>