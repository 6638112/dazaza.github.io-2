<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在Go中为Clickhouse编写Postgres外部数据包装器Writing a Postgres Foreign Data Wrapper for Clickhouse in Go</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Writing a Postgres Foreign Data Wrapper for Clickhouse in Go<br/>在Go中为Clickhouse编写Postgres外部数据包装器</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-21 18:30:47</div><div class="page_narrow text-break page_content"><p>Postgres(hereinafter mentioned as PG) is a pretty cool database with lots of nice features, one of them little known ones is the ability of having Foreign data wrappers  (hereinafter mentioned as FDWs).</p><p>Postgres（以下称为PG）是一个非常酷的数据库，具有许多不错的功能，其中一个鲜为人知的功能就是具有外部数据包装器（以下称为FDW）的功能。</p><p> Clickhouse(hereinafter mentioned as CH) is another amazing database with an altogether different set of features targeted for OLAP use cases.</p><p>Clickhouse（以下简称CH）是另一个出色的数据库，具有针对OLAP用例的完全不同的功能集。</p><p>  Well unlike so many names in tech, we can actually infer some idea from the name itself in this case.So FDWs in essence, allows to access  foreign  data sources inside Postgres(PG) via a set of  wrapper APIs.</p><p>与技术中的众多名称不同，在这种情况下，我们实际上可以从名称本身推断出一些想法。因此FDW本质上允许通过一组包装器API访问Postgres（PG）内部的外部数据源。</p><p> That is, you can access data sitting in a Mysql/SQlite/Clickhouse( any other data source) table inside PG as you would do for a normal PG table. Isn’t that amazing!</p><p>也就是说，您可以像访问普通PG表那样访问PG内部Mysql / SQlite / Clickhouse（任何其他数据源）表中的数据。那不是太神奇了！</p><p>  One caveat is that the extent of features you can expect from a FDW is dependent on the particular implementation.We can expect normal read support but other niceties like push-down filters, aggregations or joins, or write support can be missing.</p><p>需要注意的是，您可以从FDW中获得的功能范围取决于特定的实现，我们可以期望获得正常的读取支持，但可能缺少诸如下推式过滤器，聚合或联接或写入支持之类的其他功能。</p><p>  Given the existence of so many possibilities of accessing other datastores, wouldn’t it be fun if we could access Clickhouse from inside Postgres.</p><p>鉴于存在访问其他数据存储的众多可能性，如果我们可以从Postgres内部访问Clickhouse，那会很有趣。</p><p>   But more realistically, one of the ambitious use cases at  MessageBird(my employer) was the ability to connect Clickhouse to  Looker as no direct integration existed at that time.It was a bit of a moonshot but we decided to give it a try to see if it would work :)</p><p>但更现实的是，MessageBird（我的老板）的雄心勃勃的用例之一是能够将Clickhouse连接到Looker，因为当时不存在直接集成。这虽然有些无聊，但我们决定尝试一下如果可以的话:)</p><p> MessageBird has generously made the full source for our experiment open source! The repository is available  here.So you can reference the ideas mentioned in the blog post directly in the code as well :)</p><p>MessageBird慷慨地为我们的实验开源了完整的源代码！该库位于此处，因此您也可以直接在代码中引用博客文章中提到的想法:)</p><p>  There are already  documentations on how we should approach this and some simple examples are also available on Github. Most of the full fledged FDWs have their code in open so we can consult them as well.Note that most of them are written in C becauses the FDW API of PG is in C, which makes sense.I should highlight one particular  FDW that is made for SQLite and has a solid feature set, which helped me a lot while writing the one for Clickhouse.</p><p>已经有关于如何处理此问题的文档，Github上也提供了一些简单的示例。完整的FDW大部分都公开了代码，因此我们也可以查阅它们。请注意，由于PG的FDW API使用C语言编写，因此大多数都是用C编写的，这是有道理的。专为SQLite编写，并具有可靠的功能集，这在为Clickhouse编写功能方面给了我很多帮助。</p><p> But what if we want to be adventurous and write one in Go? Well, it should be possible given the existence of  CGo.</p><p>但是，如果我们想冒险并用Go语言写一个该怎么办？好吧，考虑到CGo的存在，应该有可能。</p><p> We can expect that it will not be at all trivial. ;)There are already attempts on making Postgres Extensions in  Go, which gives a very valuable insight.</p><p>我们可以预料，这将是微不足道的。 ;）已经有尝试在Go中制作Postgres Extensions，这提供了非常有价值的见解。</p><p>  First we should familiarize ourselves with the  PG Extension Build Infrastructure/PGXS and how to write  C code for PG.These are crucial as we would want to integrate the C code with Go, and knowing how the build process works should help us in understanding where our code will fit.</p><p>首先，我们应该熟悉PG扩展构建基础架构/ PGXS以及如何为PG编写C代码，这些至关重要，因为我们希望将C代码与Go集成在一起，并且了解构建过程的工作原理将有助于我们了解哪里我们的代码将适合。</p><p> For writing a FDW we have to provide an entry point in form of a  struct containing function pointers to the implemented callback functions.Since we want to write those callback in Go, we can consult documentation for  accessing Go functions in C, which says there are specific annotations that should allow us to export go functions outside to the C code.All the important work is done in these callbacks only. Now it should be possible to add functions that PG FDW API expects via Go.</p><p>为了编写FDW，我们必须以结构的形式提供一个入口点，其中包含指向已实现的回调函数的函数指针。由于我们要在Go中编写这些回调，因此可以查阅文档以在C中访问Go函数。允许我们将go函数导出到C代码之外的特定注释。所有重要的工作仅在这些回调中完成。现在应该可以通过Go添加PG FDW API期望的功能。</p><p> But, how will the C code find the callback functions written in Go land ?  Go build modes is the answer.Directly referencing from the documentation, the  -buildmode=c-archive allows us to:</p><p>但是，C代码如何找到用Go land编写的回调函数？正确的构建模式就是答案。-buildmode = c-archive直接参考文档，使我们能够：</p><p> Build the listed main package, plus all packages it imports,into a C archive file. The only callable symbols will be thosefunctions exported using a cgo //export comment. Requiresexactly one main package to be listed.</p><p>将列出的主软件包及其导入的所有软件包构建到C存档文件中。唯一可调用的符号将是使用cgo // export注释导出的那些函数。只需列出一个主程序包。</p><p> Perfect! Now, the exported Go functions are available in the  archive file.The only remaining thing is to link the archive with C code during build.Thankfully,  PGXS provides a  Make variable  SHLIB_LINK that can be used to set the shared library used. So we’ll use that flag to provide the archive build from Go source files.</p><p>完善！现在，导出的Go函数在存档文件中可用了，剩下的唯一事情就是在构建过程中将存档与C代码链接起来。幸运的是，PGXS提供了一个Make变量SHLIB_LINK，可用于设置所使用的共享库。因此，我们将使用该标志来提供Go源文件的归档版本。</p><p>   To actually write a working FDW, we need to familiarize with the different stages a query goes through in PG and how the API functions play them out.Postgres has an excellent documentation and moreover since all the  source code is open, we can just navigate through the code as well!</p><p>要真正编写一个有效的FDW，我们需要熟悉查询在PG中所经历的不同阶段以及API函数如何发挥作用.Postgres具有出色的文档，而且由于所有源代码都是开放的，因此我们可以浏览代码也一样！</p><p> It would take more space than a blog post to explain the full internals of Query planner in Postgres and I probably can’t describe it well enough.So, I suggest to go through  the official documentation which is quite excellent and there are many other excellent references on the web.</p><p>要解释Postgres中的Query planner的完整内部知识，它所需要的空间比博客文章还多，因此我可能无法很好地描述它。因此，我建议您浏览一下非常出色的官方文档，还有许多其他出色的文档。网络上的参考。</p><p> I’ll try to briefly explain the flow of the API functions for the context of this post.A very basic plan looks like this:</p><p>我将在本文中简要说明API函数的流程。一个非常基本的计划如下所示：</p><p> +-------------------------+| || || GetForeignRelSize || || |+------------+------------+ | | |+------------v------------+| || || GetForeignPaths || || |+------------+------------+ | | |+------------v------------+| || || GetForeignPlan || || |+------------+------------+ | | |+------------v------------+| || || BeginForeignScan || || |+------------+------------+ | | |+------------v------------+| || || IterateForeignScan || || |+-------------------------+ | | |+------------v------------+| || || EndForeignScan || || |+-------------------------+</p><p>+ ------------------------- + | || || GetForeignRelSize || || | + ------------ + ------------ + | | | + ------------ v ------------ + | || || GetForeignPaths || || | + ------------ + ------------ + | | | + ------------ v ------------ + | || || GetForeignPlan || || | + ------------ + ------------ + | | | + ------------ v ------------ + | || || BeginForeignScan || || | + ------------ + ------------ + | | | + ------------ v ------------ + | || || IterateForeignScan || || | + ------------------------- + | | | + ------------ v ------------ + | || || EndForeignScan || || | + ------------------------- +</p><p> There are other functions in the FDW API that I’ve omitted here (like  ReScanForeignScan,  AnalyzeForeignTable,  GetForeignUpperPaths) but a basic FDW can be done with these.Also note that this path is only concerned with the read queries. To enable writing on the foreign database, there are separate functions that need to be implemented.You can see how the read path is implemented for our clickhouse FDW  here.</p><p>我在这里省略了FDW API中的其他功能（例如ReScanForeignScan，AnalyzeForeignTable，GetForeignUpperPaths），但是可以使用这些功能完成基本的FDW。还请注意，此路径仅与读取查询有关。为了能够在外部数据库上进行写入，需要实现单独的功能。您可以在此处查看如何为我们的Clickhouse FDW实现读取路径。</p><p> Important ones to take note of to properly implement the read path of a query are:</p><p>要正确实现查询的读取路径需要注意的重要因素有：</p><p> GetForeignRelSize: It should be used to determine the estimated number of rows to be scanned on the foreign server. However, it is also used to extract the restriction clauses present in the query presented by PG and to pass them to the foreign server if it can support them.See this  example.</p><p>GetForeignRelSize：它应用于确定外部服务器上要扫描的估计行数。但是，它也用于提取PG提出的查询中存在的限制子句，并将其传递给外部服务器（如果它可以支持它们的话）。请参见本示例。</p><p> GetForeignPlan: It should return the planner node(a data structure that contains the query plan). However, it is also used to extract the target columns that can be fetched from remote/foreign servers and pass that info along with restriction clauses, table names to the next stage.See this  example.</p><p>GetForeignPlan：它应该返回计划器节点（包含查询计划的数据结构）。但是，它也用于提取可从远程/外部服务器获取的目标列，并将该信息以及限制子句，表名传递给下一阶段。</p><p> BeginForeignScan: It should perform the initalization that is needed to perform the scan on the foreign server, for example: initialize the foreign DB connection, formalize the query running on foreign server and init the state with row iterator to be used in the next stage.See this  example.</p><p>BeginForeignScan：它应该执行在外部服务器上执行扫描所需的初始化，例如：初始化外部数据库连接，形式化在外部服务器上运行的查询，并使用行迭代器初始化状态，以在下一阶段中使用。请参阅此示例。</p><p> IterateForeignScan: It should return a row from the foreign server converted to the PG specific structure. This function should convert the foreign server specific data types to PG column data types.See this  example.</p><p>IterateForeignScan：它应从转换为PG特定结构的外部服务器返回一行。此函数应将外部服务器特定的数据类型转换为PG列数据类型。请参见此示例。</p><p> EndForeignScan: It should clean the state being stored for the query, like row iterators, db connections should be closed.See this  example.</p><p>EndForeignScan：它应该清除为查询存储的状态，例如行迭代器，应该关闭数据库连接。</p><p> This is a very dense overview of the functionality of a  basic FDW. It usually helps to look around the other FDWs that are open source to look for ideas of a sample implementation. But it can differ since the foreign server can be of various types.Usually, if we take databases that support some dialect of SQL then the hardest things are usually figuring out if the restriction clauses are remote safe, which can involve parsing the full expression clauses and then converting them to remote variants.Converting the foreign server datatypes to PG types is comparatively easy but is very toiling.</p><p>这是基本FDW功能的非常详尽的概述。它通常有助于查看其他开源的FDW，以查找示例实现的想法。但这可能会有所不同，因为外部服务器可以是多种类型的服务器。通常，如果我们采用支持某些SQL方言的数据库，则最困难的事情通常是确定限制子句是否是远程安全的，这可能涉及解析完整的表达式子句然后将外部服务器数据类型转换为PG类型相对容易，但非常麻烦。</p><p> You can look into how  clickhouse FDW does this to get an idea, but beware that it could be bug prone, since it hasn’t been tested thoroughly.</p><p>您可以研究Clickhouse FDW如何做到这一点，但请注意，由于尚未经过全面测试，因此可能容易出错。</p><p> I’ll also suggest getting an idea of commonly used PG datatypes and conventions like  OID,  Tuple,  RelOptInfo or just going over   relation.h reference from PG source code.</p><p>我还将建议您了解常用的PG数据类型和约定（例如OID，Tuple，RelOptInfo），或者仅从PG源代码翻阅related.h参考。</p><p>  These are some ideas that I’ve seen are fairly used while developing a FDW. Some can help in easy interop between Go and C, whether it is a good idea or not, is up for debate ;)</p><p>在开发FDW时，我已经看到一些合理的想法。有些人可以帮助Go和C之间轻松互操作，不管这是一个好主意，还是有待商;的；</p><p>  There are a lot of internal macros in PG source which makes it easier to access system cache, lists, heap tuples etc. which aren’t directly callable from Go’s userland. This is because CGo doesn’t quite allow directly calling C  #define macros. You can try to simulate the same behaviour using underlying constructs but that can get hairy and cumbersome. Instead one  easy idea is to define simple C wrapper functions like</p><p>PG源代码中有许多内部宏，可以更轻松地访问系统缓存，列表，堆元组等，而Go的用户域无法直接调用这些宏。这是因为CGo不允许直接调用C #define宏。您可以尝试使用基础构造来模拟相同的行为，但是可能会变得冗长而繁琐。相反，一个简单的想法是定义简单的C包装函数，例如</p><p>  This can now be used directly on Go side. But make sure you cast the results to proper types.</p><p>现在可以直接在Go端使用。但是请确保将结果转换为正确的类型。</p><p>  There can be a point where writing C code directly in Go source files is not feasible anymore, because increasing the number of commented lines can get incomprehensive after a point.</p><p>可能存在这样的情况，即直接在Go源文件中编写C代码不再可行，因为增加注释行的数量可能在一个点之后变得不全面。</p><p> Moving out C code into separate files and then accessing them in Go can be done as well. You need to link the Go code with the C symbol definitions that are outside the Go code during build times and it should work.It can be done by for example, separating the C code into header and source file and including the header file in the Go source code. Now CGo will automatically take care of building the object files.See it in action  here. For better understanding of different object files, see  here.</p><p>也可以将C代码移到单独的文件中，然后在Go中对其进行访问。您需要在构建期间将Go代码与Go代码之外的C符号定义链接起来，并且应该可以工作。例如，可以将C代码分为头文件和源文件，并将头文件包括在转到源代码。现在CGo会自动处理目标文件的生成，请参见这里的操作。为了更好地理解不同的目标文件，请参见此处。</p><p>  Go doesn’t allow passing pointers to Go objects (like maps, slices) to C (which makes sense, with Go being a garbage collected language). See  this reference for more details.</p><p>Go不允许将指向Go对象（如地图，切片）的指针传递给C（这很有意义，因为Go是一种垃圾收集语言）。有关更多详细信息，请参见此参考。</p><p> But we want to maintain states in Go for objects that are being accessed by C code.</p><p>但是我们想在Go中维护由C代码访问的对象的状态。</p><p> One example is database connections and cursor(row iterator). As we would want to access connection as a Go variable or in a PG execution stage we would want to use the same cursor which is being initialized in upper stages (i.e planning). One trick to make this happen is to keep a map of integers =&gt; Go objects and pass that integer around as we move downstream in the query stages.This integer is always incremented in the FDW’s lifetime (in each stage) and is never reused again in calls to FDW.For example see it  here.</p><p> One example is database connections and cursor(row iterator). As we would want to access connection as a Go variable or in a PG execution stage we would want to use the same cursor which is being initialized in upper stages (i.e planning). One trick to make this happen is to keep a map of integers =&gt; Go objects and pass that integer around as we move downstream in the query stages.This integer is always incremented in the FDW’s lifetime (in each stage) and is never reused again in calls to FDW.For example see it  here.</p><p>  PG FDW API also allows to embed internally private information as an opaque  void * that will be passed around in the query stages. This is quite neat IMHO and saves a lot of time for developers to allow bookkeeping :) You can pass state around stages by simply providing a  void * fdw_state where we can put anything (quite  literally). Clickhouse FDW uses this to pass around query state information like extracted remote safe restriction clauses, table names, column names etc. See this  reference.</p><p>PG FDW API还允许将内部私有信息作为不透明的void *嵌入，将在查询阶段进行传递。这是非常整洁的恕我直言，并为开发人员节省大量时间来允许记账:)您可以通过简单地提供一个void * fdw_state来在阶段间传递状态，我们可以在其中放置任何内容（从字面上看）。 Clickhouse FDW使用它来传递查询状态信息，例如提取的远程安全限制子句，表名，列名等。请参阅此参考。</p><p>  Since we are fetching the results from the Go driver of a DB and then pushing it down to the C API of PG, we need a conversion step between. Normally, it should be easy for fixed size integers and strings but PG has a large catalogue of datatypes like datetime, time zones, arrays and such. Further the foreign database can also have its own list of datatypes that might not be properly represented as a PG type. In that case, we have to do the best we can and might have to leave those fancy datatypes out. For user defined datatypes like variable length strings or arrays, PG has a nice system of input and output  function for conversions. We can rely on these functions for converting the value from Go to C.See this in action  here.</p><p>由于我们要从数据库的Go驱动程序中获取结果，然后将其下推到PG的C API，因此我们需要在两者之间进行转换。通常，固定大小的整数和字符串应该很容易，但是PG具有大量的数据类型目录，例如日期时间，时区，数组等。此外，外部数据库还可以具有其自己的数据类型列表，这些数据类型可能无法正确表示为PG类型。在这种情况下，我们必须尽力而为，并且可能不得不将那些花哨的数据类型排除在外。对于用户定义的数据类型（例如可变长度字符串或数组），PG具有用于转换的输入和输出功能的良好系统。我们可以依靠这些函数将值从Go转换为C，请参见此处的操作。</p><p>  This is one the nicest features to provide since it will leverage the underlying foreign DB’s capability and heavily reduce the amount of bytes travelled over the wire. Also, this makes the query being done on PG much closer to how it will be done on the foregin DB because otherwise the query will use PG’s query planner.</p><p>这是提供的最好的功能之一，因为它将利用底层外部数据库的功能并大大减少通过网络传输的字节数。而且，这使得在PG上进行查询的方式与在foregin DB上进行查询的方式更加接近，因为否则查询将使用PG的查询计划器。</p><p> To support push downed filters, we first have to deparse the expression from query clauses and then evaluate if they can be implemented in terms of foreign databases. I mostly leveraged the existing code that  sqlite_fdw has written for the same but tweaked it further to convert the expressions in terms of Clickhouse expressions.See it in example  here.</p><p>为了支持下推式过滤器，我们首先必须从查询子句中解析表达式，然后评估它们是否可以根据外部数据库来实现。我主要利用sqlite_fdw为之编写的现有代码，但进一步对其进行了调整以根据Clickhouse表达式转换表达式。</p><p> The functionality can be splitted into two parts, first can be the expression  deparsing and second can be the  evaluation.</p><p>功能可以分为两部分，第一部分可以是表达式解析，第二部分可以是评估。</p><p> For pushing down aggregations like  GROUP BY, the deparse and evaluation are mandatory step but we also have to implement FDW functions like   GetForeignUpperPaths.</p><p>对于下推GROUP BY之类的聚合，必须执行deparse和评估，但我们还必须实现FDW函数，例如GetForeignUpperPaths。</p><p>  In order to properly understand the FDW’s working and further extension, it is required to understand Postgres internals and it’s FDW API. Further a brief understanding of database design theory is also needed. If the teams doesn’t have such expertise beforehand, this can be a major bottleneck in providing a production grade interface between Foreign DB(like Clickhouse) and PG. It shouldn’t be the case that developers fear the code because it is too magical and they don’t understand the inner workings.</p><p>为了正确理解FDW的工作原理和进一步扩展，需要了解Postgres内部和FDW API。还需要对数据库设计理论有一个简短的了解。如果团队事先没有这样的专业知识，那么这可能是在Foreign DB（例如Clickhouse）和PG之间提供生产级接口的主要瓶颈。开发人员不应该担心代码，因为它太神奇了并且他们不了解内部工作原理。</p><p> Next, if one is assumed to have an understanding, there are the challenges of keeping the C to Go interface calls manageable. See  CGo performance penalties for example. So it is desirable to keep the codebase sane by keeping the amount of C code minimum. We somehow need to provide a balance between the two.</p><p>接下来，如果假设您已了解这一点，那么要保持C to Go接口调用的可管理性就存在挑战。例如，请参阅CGo性能惩罚。因此，希望通过使C代码量保持最小来保持代码库的健全。我们需要以某种方式在两者之间取得平衡。</p><p>  We can try to keep much of the code in Go (involving C interface functions) but we also need to be careful while passing memory chunks from Go to C. Any  Go.CString(...)s aren’t claimed back via Go runtime, although in case of C structs PG runtime promises to claim back the memory allocated by palloc as soon as the transaction ends. There are some constructs where we might need to touch PG’s HeapTuple memory allocators and manually make sure we free them after use.</p><p>我们可以尝试将很多代码保留在Go中（涉及C接口函数），但是在将内存块从Go传递到C时，我们也需要小心。任何Go.CString（...）都不会通过Go声明。运行时，尽管在C结构的情况下，PG运行时承诺在事务结束后立即收回由palloc分配的内存。在某些构造中，我们可能需要联系PG的HeapTuple内存分配器，并手动确保在使用后释放它们。</p><p> New collaborators will need to learn tricks around the converting C structs/datatypes to Go ones(and vice versa) and marshalling/unmarshalling results/arguments of PG C functions.</p><p>新的协作者将需要学习有关将C结构/数据类型转换为Go结构（反之亦然）以及将PG C函数编组/解组结果/参数的技巧。</p><p> A very extreme way is, To try to keep most of FDW stages in C with only “deparsing and type conversions from Go types to C types” and “Clickhouse query formation” in Go, but if the teams lack expertise in C, this may not be a favourable option.</p><p>一种非常极端的方法是，尝试通过仅在Go中将“从Go类型到C类型的解析和类型转换”和在Go中使用“ Clickhouse查询形成”来保留C中的大多数FDW阶段，但是如果团队缺乏C方面的专业知识，则可能不是一个好的选择。</p><p> The end result of this experimental project is available  here. I hope that other teams will find the code useful.</p><p>此实验项目的最终结果可在此处获得。我希望其他团队会发现该代码有用。</p><p> If these kinds of challenges excites you,  MessageBird is  hiring for lots of attractive roles!</p><p>如果这些挑战使您兴奋，则MessageBird会招聘许多具有吸引力的职位！</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://arunsori.me/posts/postgres-clickhouse-fdw-in-go/">https://arunsori.me/posts/postgres-clickhouse-fdw-in-go/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编写/">#编写</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/postgres/">#postgres</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/pg/">#pg</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>