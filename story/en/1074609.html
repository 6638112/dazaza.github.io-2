<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>小型计算机字节码解释器（2007）Bytecode interpreters for tiny computers (2007)</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Bytecode interpreters for tiny computers (2007)<br/>小型计算机字节码解释器（2007）</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-22 09:09:08</div><div class="page_narrow text-break page_content"><p>I&#39;ve previously come to the conclusion that there&#39;s little reason forusing bytecode in the modern world, except in order to get morecompact code, for which it can be very effective. So, what kind of abytecode engine will give you more compact code?</p><p>我&#39；我以前得出的结论是&#39；在现代社会，除了为了获得更紧凑的代码外，没有什么理由使用字节码，因为字节码非常有效。那么，什么样的abytecode引擎将为您提供更紧凑的代码？</p><p> Suppose I want a bytecode interpreter for a very small programmingenvironment, specifically to minimize the memory needed for a program;say, on a 32-bit microcontroller with 40KiB of program flash, wherethe program flash size is very often the limiting factor on what themachine can do.</p><p>假设我想要一个字节码解释器，用于一个非常小的编程环境，特别是最小化程序所需的内存；比如，在一个32位微控制器上，有40KiB的程序闪存，程序闪存的大小通常是限制机器功能的因素。</p><p>  fib: n n &lt; 2 ifTrue: [^1] ifFalse: [^(self fib: n - 1) + (self fib: n - 2)]</p><p>fib:n&lt；2如果正确：[^1]如果错误：[^（自我谎言：n-1）+（自我谎言：n-2）]</p><p>  9 &lt;10&gt; pushTemp: 010 &lt;77&gt; pushConstant: 211 &lt;B2&gt; send: &lt;12 &lt;99&gt; jumpFalse: 1513 &lt;76&gt; pushConstant: 114 &lt;7C&gt; returnTop15 &lt;70&gt; self16 &lt;10&gt; pushTemp: 017 &lt;76&gt; pushConstant: 118 &lt;B1&gt; send: -19 &lt;E0&gt; send: fib:20 &lt;70&gt; self21 &lt;10&gt; pushTemp: 022 &lt;77&gt; pushConstant: 223 &lt;B1&gt; send: -24 &lt;E0&gt; send: fib:25 &lt;B0&gt; send: +26 &lt;7C&gt; returnTop</p><p>9&lt；10&gt；pushTemp:010&lt；77&gt；推力常数：211&lt；B2&gt；发送：&lt；12&lt；99&gt；jumpFalse:1513&lt；76&gt；推力常数：114&lt；7C&gt；returnTop15&lt；70&gt；self16&lt；10&gt；pushTemp:017&lt；76&gt；推力常数：118&lt；B1&gt；发送：-19&lt；E0&gt；发送：fib:20&lt；70&gt；self21&lt；10&gt；pushTemp:022&lt；77&gt；推力常数：223&lt；B1&gt；发送：-24&lt；E0&gt；发送：fib:25&lt；B0&gt；发送：+26&lt；7C&gt；returnTop</p><p> Or, as I translated to pseudo-FORTH, &#34;n 2 &lt; if 1 return then self n 1- recurse self n 2 - recurse + return&#34;.</p><p>或者，正如我翻译成“伪福思”的那样，&#34；n2&lt；如果1返回，那么self n1-递归self n2-递归+返回&#34；。</p><p> The metric of goodness for a CPU instruction set is a little differentfrom that for a bytecode interpreter. Bytecode interpreters don&#39;thave to worry about clock rate (and therefore combinational logic pathlength) or, so far, parallelism; they can use arbitrary amounts ofstorage on their own behalf; they&#39;re easier to modify; theirfundamental operations can take advantage of more indirection.</p><p>CPU指令集的优度指标与字节码解释器的优度指标略有不同。字节码解释器不&#39；他们不得不担心时钟速率（因此组合逻辑路径长度）或目前为止的并行性；他们可以代表自己使用任意数量的存储；他们&#39；你更容易修改；他们的基本操作可以利用更多的间接性。</p><p> Here are some examples of things a bytecode interpreter can do that ahardware CPU might have more trouble with:</p><p>下面是字节码解释器可以做的一些事情的例子，硬件CPU可能会遇到更多问题：</p><p> you can have a very large register set (which is more or less what Squeak&#39;s VM does, treating local variables as registers) without incurring slow procedure call and return; MMIX suggests how this could be done in hardware as well.</p><p>您可以拥有非常大的寄存器集（这或多或少是Squeak和#39；s VM的功能，将局部变量视为寄存器），而不会导致缓慢的过程调用和返回；MMIX还建议如何在硬件中实现这一点。</p><p> you could imagine that every procedure could have its own register set (as, perhaps, on the SPARC), and a few of the instructions could access the contents of these registers; again, Squeak&#39;s VM does this</p><p>您可以想象，每个过程都可以有自己的寄存器集（可能是在SPARC上），一些指令可以访问这些寄存器的内容；再一次，吱吱&#39；虚拟机就是这么做的</p><p> you could have an instruction to create a new preemptively-scheduled thread, perhaps switching between threads every instruction, as in Core Wars or the Tera MTA;</p><p>您可以有一条指令来创建一个新的抢占式调度线程，可能会在每条指令之间切换线程，就像在Core Wars或Tera MTA中一样；</p><p> if the language is object-oriented, you could have a few instructions for calling certain distinguished methods of self, or the first argument, as in the Squeak VM;</p><p>如果语言是面向对象的，那么您可以使用一些指令来调用某些独特的self方法或第一个参数，如Squeak VM；</p><p> or, as a more general form of the same thing, entering some context might reprogram certain instructions to do some arbitrary thing;</p><p>或者，作为同一事物的更一般形式，输入某些上下文可能会重新编程某些指令以执行某些任意操作；</p><p> you can do all kinds of tag tests and dynamic dispatch on fundamental CPU operations, as in the Squeak VM, the LispMs, or Python&#39;s bytecode;</p><p>您可以对基本的CPU操作进行各种标记测试和动态调度，比如Squeak VM、LispMs或Python&#39；字节码；</p><p> you can support associative array lookups, appending to unbounded-size arrays, and the like, as fundamental machine operations.</p><p>作为基本的机器操作，您可以支持关联数组查找、附加到无限大小数组等。</p><p>  I don&#39;t have a FORTH handy, but I think the definition looks somethinglike this in FORTH:</p><p>我不&#39；我手边没有FORTH，但我认为FORTH的定义是这样的：</p><p> : FIB DUP 2 &lt; IF DROP 1 ELSE DUP 1- RECURSE SWAP 2 - RECURSE + THEN ;</p><p>：FIB DUP 2&lt；如果DROP 1 ELSE DUP 1-递归交换2-递归+然后；</p><p> which I think, in an indirect-threaded FORTH, compiles to a dictionaryentry containing something like this:</p><p>我认为，以一种间接的方式，它会编译成一个字典入口，包含如下内容：</p><p> DUP (2) &lt; (IF) #3 DROP (1) (ELSE) #8 DUP 1- FIB SWAP (2) - FIB + ;</p><p>DUP（2）&lt；（如果）#3下降（1）（否则）#8重复1-FIB交换（2）-FIB+；</p><p> That&#39;s 18 threading slots, so 36 bytes, plus the overhead of thedictionary structure, which I think is typically 2 bytes for adictionary that has forgotten the word names. Better than PowerPCassembly (at 96 bytes) but not great, noticeably worse than Squeak.</p><p>那&#39；18个线程槽，36个字节，加上字典结构的开销，我认为对于忘记单词名的字典来说，通常是2个字节。比PowerPCassembly（96字节）好，但不是很好，明显比Squeak差。</p><p>  What if we interpret fib with a simple Lisp interpreter that walkstree structures? We could define it as follows:</p><p>如果我们用一个简单的Lisp解释器来解释fib，walkstree结构会怎么样？我们可以将其定义如下：</p><p> (labels fib (n) (if (&lt; 2 n) 1 (+ (fib (- n 1)) (fib (- n 2)))))</p><p>（标签fib（n）（if（&lt；2n）1（+（fib（-n1））（fib（-n2щщ）））</p><p> That&#39;s 17 non-parenthesis tokens and 9 right parentheses, for a totalof 28 leaf-nodes on the cons tree. That means the tree contains 27conses, for 54 memory-address-containing cells in interior nodes,probably a minimum of 108 bytes. I conclude that while thisprogram-representation approach is very simple, it takes up a lot ofspace. I don&#39;t think cdr-coding would help enough, since none of thelists are very long; if you had 9 lists containing 25 pointers and 9one-byte lengths or one-byte terminators, you still have 59 bytes.</p><p>那&#39；s 17个非括号标记和9个右括号，用于cons树上总共28个叶节点。这意味着该树包含27个conses，即内部节点中包含单元的54个内存地址，可能至少为108字节。我的结论是，虽然这种程序表示方法非常简单，但它占用了很多空间。我不&#39；我不认为cdr编码会有足够的帮助，因为这些列表都不是很长；如果有9个列表包含25个指针和9个单字节长度或单字节终止符，那么仍然有59个字节。</p><p>  According to &#34;The Implementation of Lua 5.0&#34;, Lua&#39;s virtual machinehas been register-based since 2003. They claim that their four-byteregister instructions aren&#39;t really much more voluminous thanstack-based instructions, perhaps in part because they&#39;re comparing tostack-based instructions for a single-stack machine that has localvariable storage in addition to its stack.</p><p>根据&#34；Lua5.0和#34；的实现；，卢亚和#39；s的虚拟机自2003年以来一直以注册为基础。他们声称他们的四条byteregister指令不是&#39；它并没有比基于堆栈的指令多得多，部分原因可能是它们&#39；重新比较基于tostack的指令，该指令适用于除堆栈外还具有localvariable存储的单堆栈计算机。</p><p> Lua&#39;s register-based virtual machine is fairly small: &#34;[O]n Linux itsstand-alone interpreter, complete with all standard libraries, takesless than 150 Kbytes; the core is less than 100 Kbytes.&#34; They&#39;vepreviously said that the compiler is about 30% of the size of thecore, which suggests that the rest of the core, including the bytecodeinterpreter, is about 70KB.</p><p>卢亚和#39；s基于寄存器的虚拟机相当小：&#34；[O] n Linux及其独立解释器，配备所有标准库，不超过150 KB；核心小于100千字节&#34; 他们&#39；Ve之前说过，编译器的大小约为内核大小的30%，这表明内核的其余部分，包括字节码解释器，大约为70KB。</p><p> They mention that it has 35 instructions, which would almost fit in 5bits of opcode: MOVE, LOADK, LOADBOOL (converts to boolean andconditionally skips an instruction), LOADNIL (clears a bunch ofregisters), GETUPVAL, GETGLOBAL, GETTABLE, GETGLOBAL, SETUPVAL,SETTABLE, NEWTABLE, SELF, ADD, SUB, MUL, DIV, POW, UNM (unary minus),NOT, CONCAT (string concatenation of a bunch of registers), JMP, EQ,LT, LE, TEST, CALL, TAILCALL, RETURN, FORLOOP, TFORLOOP, TFORPREP,SETLIST, SETLISTO, CLOSE, and CLOSURE.</p><p>他们提到它有35条指令，几乎可以放入5位操作码中：MOVE、LOADK、LOADBOOL（转换为布尔值并有条件地跳过一条指令）、LOADNIL（清除一堆寄存器）、GETUPVAL、GETGLOBAL、GETTABLE、GETGLOBAL、SETUPVAL、SETTABLE、NEWTABLE、SELF、ADD、SUB、MUL、DIV、POW、UNM（一元减）、NOT、，CONCAT（一组寄存器的字符串串联）、JMP、EQ、LT、LE、TEST、CALL、TAILCALL、RETURN、FORLOOP、TFORLOOP、TFORPREP、SETLIST、SETLISTO、CLOSE和CLOSE。</p><p> CALL passes a range of registers to a function and stores its resultin a range of registers; this implies that the virtual machine handlessaving and restoring of the stack frame. The paper uses the term&#34;register window&#34; to compare it to what the SPARC does.</p><p>调用将一系列寄存器传递给函数，并将其结果存储在一系列寄存器中；这意味着虚拟机不需要保存和恢复堆栈帧。本文使用了#34；注册窗口&#34；将其与SPARC的功能进行比较。</p><p>   local a, t, i LOADNIL 0 2 0a = a + i ADD 0 0 2a = a + 1 ADD 0 0 250a = t[i] GETTABLE 0 1 2</p><p>本地a，t，i加载nil 0 2 0a=a+i添加0 0 2a=a+1添加0 0 250a=t[i]可获取0 1 2</p><p>   It seems that you should be able to compile this on a two-stackmachine as NIL NIL DUP &gt;R + 1+ R&gt; NIL GETTABLE, which is 9instructions instead of 11, and also clearly stupid, since nil isneither a table nor a number. If you could really fit that into 6bytes, it might be an improvement over the 12 bytes of their currentscheme or the 11 bytes of their previous one. It might be better totry more realistic code fragments.</p><p>看起来，您应该能够在两台stackmachine上将其编译为NIL NIL DUP&gt；R+1+R&gt；NIL GETTABLE是9指令而不是11指令，而且显然很愚蠢，因为NIL既不是表也不是数字。如果你真的能将其放入6字节，那么它可能比他们当前方案的12字节或之前方案的11字节有所改进。最好是编写更真实的代码片段。</p><p> The paper also discusses an interesting implementation of closures, inwhich captured variables migrate into heap-allocated structures uponfunction return.</p><p>本文还讨论了一个有趣的闭包实现，其中捕获的变量迁移到堆分配的结构uponfunction return中。</p><p>  The MuP21 was implemented in 6000 transistors, including an NTSCsignal generator and a controller for external DRAM, so it ought to bepossible to emulate its behavior with a fairly small amount ofsoftware. Here&#39;s the instruction set:</p><p>MuP21是在6000个晶体管中实现的，包括一个NTSC信号发生器和一个外部DRAM控制器，所以应该可以用相当少的软件来模拟其行为。这里&#39；这是指令集：</p><p> Transfer Instructions: JUMP, CALL, RET, JZ, JCZ Memory Instructions: LOAD, STORE, LOADP, STOREP, LIT ALU Instructions: COM, XOR, AND, ADD, SHL, SHR, ADDNZ Register Instructions: LOADA, STOREA, DUP, DROP, OVER, NOP</p><p>传输指令：跳转、调用、RET、JZ、JCZ内存指令：加载、存储、LOADP、STOREP、LIT-ALU指令：COM、XOR、AND、ADD、SHL、SHR、ADDNZ寄存器指令：LOADA、STOREA、DUP、DROP、OVER、NOP</p><p> COM is complement. The CPU has an A register, accessed with LOADA andSTOREA, that supplies the address for LOAD and STORE; I think LOADPand STOREP increment it as well. I think JCZ jumps if the carry bitis zero. (Each register on the stack has its own carry bit; the &#34;21&#34;refers to the 20-bit memory word size, plus the extra bit.)</p><p>COM是补码。CPU有一个寄存器，通过LOADA和STOREA访问，为LOAD和STORE提供地址；我认为Load和STOREP也增加了它。我认为如果进位为零，JCZ会跳。（堆栈上的每个寄存器都有自己的进位；&#34；21&#34；表示20位内存字大小，加上额外的位。）</p><p> The F21 had 27 instructions to the MuP21&#39;s 24. (Only 23 are listedabove, hmm.) They were renamed:</p><p>F21对MuP21和#39有27条指令；24岁。（只有23个是ListedBove，嗯。）它们被重命名为：</p><p> Code Name Description Forth (with a variable named A) 00 else unconditional jump ELSE 01 T0 jump if T0-19 is false w/ no drop DUP IF 02 call push PC+1 to R, jump : 03 C0 jump if T20 is false CARRY? IF 06 RET pop PC from R (subroutine return) ; 08 @R+ fetch from address in R, increment R R@ @ R&gt; 1+ &gt;R 09 @A+ fetch from address in A, increment A A @ @ 1 A +! 0A # fetch from PC+1, increment PC LIT 0B @A fetch from address in A A @ @ 0C !R+ store to address in R, increment R R@ ! R&gt; 1+ &gt;R 0D !A+ store to address in A, increment A A @ ! 1 A +! 0F !A store to address in A A @ ! 10 com complement T -1 XOR 11 2* left shift T, 0 to T0 2* 12 2/ right shift T, T20 to T19 2/ 13 +* add S to T if T0 is true DUP 1 AND IF OVER + THEN 14 -or exclusive-or S to T XOR 15 and and S to T AND 17 + add S to T + 18 pop pop R, push to T R&gt; 19 A push A to T A @ 1A dup push T to T DUP 1B over push S to T OVER 1C push pop T, push to R &gt;R 1D A! pop T to A A ! 1E nop delay 2ns NOP 1F drop pop T DROP</p><p>代码名称说明Forth（带有一个名为a的变量）00 else无条件跳转else 01 T0跳转如果T0-19为假，则不执行drop DUP如果02调用push PC+1到R，跳转：03 C0跳转如果T20为假进位？如果06从R返回pop PC（子程序返回）；08@R+从R中的地址提取，递增R@@R&gt；1+&gt；R 09@A+从A中的地址获取，增量A@1 A+！0A#从PC+1获取，增量PC LIT 0B@A从地址获取@@0C！R+存储到R中的地址，递增R@！R&gt；1+&gt；R 0D！A+存储地址为A，增量为A@！1A+！0F！要在A@中地址的商店！10 com补码T-1 XOR 11 2*左移T，0到T0 2*12 2/右移T，T20到T19 2/13+*如果T0为真，则将S添加到T，如果超过+1，则将14-或异或S添加到T XOR 15，将S添加到T+18 pop pop R，按下T R&gt；19 A推A到T A@1A推T到T推1B推S到T推1C推pop T，推R&gt；R 1D A！跳到A！1E nop延迟2ns nop 1F下降pop T下降</p><p> T is top-of-stack; R is top-of-return-stack; S is the element rightunder the top of stack. I think @R+ and !R+ are two of the three newinstructions; push and pop are probably the other one, since theydon&#39;t seem to be listed in the MuP21 list.</p><p>T是栈顶；R是返回堆栈的顶部；S是堆栈顶部正下方的元素。我认为@R+和！R+是三条新指令中的两条；push和pop可能是另一种，因为它们是on#39；似乎不在MuP21列表中。</p><p>  I&#39;m not sure where the else, T0, and C0 instructions jump to; maybethe next address on the operand stack.</p><p>我&#39；我不确定else、T0和C0指令跳转到哪里；可能是操作数堆栈上的下一个地址。</p><p> Interestingly, there doesn&#39;t seem to be a straightforward way to get a&#34;1&#34; onto the stack without using the # instruction, which is annoyingbecause that takes 25 bits of instructions. dup dup -or A! @A+ drop Ais another approach at 30 bits, but it clobbers the A register andissues a useless memory reference. dup dup -or com 2* com is another25-bit approach.</p><p>有趣的是，没有&#39；这似乎不是一个获得&#34；1&#34; 在不使用#指令的情况下将其加载到堆栈上，这很烦人，因为这需要25位指令。嘟嘟嘟嘟——或者一个@A+drop是另一种30位的方法，但它会破坏A寄存器并发出无用的内存引用。dup dup或com 2*com是另一种25位方法。</p><p> So here&#39;s my dumb fib benchmark expressed in F21 code, according to mylimited understanding, and without trying to be very clever:</p><p>所以这里&#39；根据我有限的理解，这是我用F21代码表达的愚蠢的fib基准测试，但我并不想太聪明：</p><p> fib: dup #-2 + #returnone swap c0 dup #-1 + #fib call swap #-2 + #fib call + ;returnone: drop drop #1 ;</p><p>fib:dup#-2+#returnone swap c0 dup#-1+#fib call swap#-2+#fib call+；returnone:drop-drop#1；</p><p> That loses pretty badly on literals; if we assume that # pushes itsvalue immediately and doesn&#39;t require any NOPs (e.g. to avoid havingmultiple # instructions per word) then we have 22 instructions and 7literals --- 6 words of instructions and 7 of literals, for a total of32.5 bytes. Not the code density direction I was hoping this wouldtake me!</p><p>在文字方面损失惨重；如果我们假设#立即推动其价值，而不#39；如果不需要任何NOP（例如，为了避免每个单词有多个#指令），那么我们有22条指令和7个文字——6条指令和7个文字，总共32条。5字节。不是我希望的代码密度方向！</p><p>  fib: dup #-2 dup push + #returnone swap c0 dup #-1 + #fib dup push call swap pop swap pop + swap call + ;returnone: pop drop drop drop #1 ;</p><p>fib:dup#-2 dup push+#returnone swap c0 dup#-1+#fib dup push call swap pop swap pop+swap call+；returnone:pop drop#1；</p><p>  fib: dup #-2 dup push + #returnone swap c0 dup #-1 + #fib dup push call swap pop swap pop + swap call + ;returnone: drop drop pop com ;</p><p>fib:dup#-2 dup push+#returnone swap c0 dup#-1+#fib dup push call swap pop swap pop+swap call+；returnone：drop-pop-com；</p><p> That makes it 29 instructions but only 4 literals --- 8 words ofinstructions, 4 of literals, for a total of 12 20-bit words, or 30bytes. Still worse than the Squeak version on size --- and quite hardto read! And some of the literals are still probably too closetogether to work on a real machine.</p><p>这使得它有29条指令，但只有4个文字——8个指令字，4个文字，总共12个20位字，或30字节。在尺寸上仍然比吱吱作响的版本更糟糕——而且很难读懂！有些文字可能仍然靠得太近，无法在真正的机器上工作。</p><p> If we were instead using three-instruction 16-bit words with a highbit used to tag literals, we could maybe win a little more.</p><p>如果我们改为使用三个指令16位单词，并使用高位来标记文字，我们可能会赢得更多。</p><p> fib: #-2 dup push over + nop nop #returnone swap c0 dup #-1 + nop nop #fib dup push call swap pop swap pop + swap call + ;returnone: drop drop pop com ;</p><p>fib:#-2次重复推送+nop-nop#返回一次交换c0次重复#-1次重复-nop-nop#fib-dup推送呼叫交换pop-swap-pop+swap-call+；returnone：drop-pop-com；</p><p> That&#39;s 33 instructions, but the four literals don&#39;t count, so 29instructions or 10 16-bit instruction words, plus four 16-bit literalwords. That&#39;s 28 bytes, almost the same as the Squeak version, butstill worse! And that&#39;s with me trying to get clever with theinstruction reordering, too.</p><p>那&#39；s 33指令，但四个文字不&#39；t计数，因此29条指令或10个16位指令字加上4个16位文字。那&#39；s 28字节，几乎与Squeak版本相同，但更糟！那&#39；我也在努力巧妙地重新安排指令。</p><p> Now I begin to understand why Chuck Moore was getting to the pointwhere he would repeat FOO twenty times by doing : FOO5 FOO FOO FOO FOOFOO ; FOO5 FOO5 FOO5 FOO5 instead of using a DO loop. Numbers are areal pain on the F21! (But perhaps that&#39;s as it should be;programming isn&#39;t about numbers, anyway.)</p><p>现在我开始明白了为什么查克·摩尔会通过这样做重复FOO二十次：FOO5 FOO FOO FOO FOO；FOO5 FOO5 FOO5 FOO5而不是使用DO循环。数字是F21上真正的痛苦！（但也许这是应该的；编程与数字无关。）</p><p>  Having two stacks removes the need for local argument vectors; you canalways shift the variables left and right between the call and returnstack, possibly swapping as you go, to get to the values you want.(This could be shortened if there was a &#34;repeat next instruction fourtimes&#34; instruction: &gt;R, &gt;R &gt;R, 4x &gt;R R&gt;, 4x &gt;R, 4x &gt;R &gt;R, 4x &gt;R 4x &gt;RR&gt; R&gt;, 4x &gt;R 4x &gt;R R&gt;, 4x &gt;R 4x &gt;R, and so on; and similar in theother direction.) It wasn&#39;t apparent to me which approach would useless code, or whether it would depend on the number of arguments andlocal variables.</p><p>有两个堆栈就不需要局部参数向量；您可以在调用和返回堆栈之间左右移动变量，可能在执行过程中进行交换，以获得所需的值。（如果有一个&#34；重复下一个指令四次&#34；指令：&gt；R、&gt；R&gt；R、4x&gt；R&gt；、4x&gt；R、4x&gt；R&gt；R、4x&gt；R&gt；、4x&gt；R&gt；、4x&gt；R&gt；，等等，并且在其他方向上类似。）它不是&#39；对于我来说，哪种方法会产生无用的代码，或者它是否取决于参数和局部变量的数量，这一点并不明显。</p><p> I thought I&#39;d see what the distribution is like in a body of realcode, so I ran the following code in Squeak 3.8-6665. (No doubt anySmalltalk programmer could improve it.)</p><p>我想我&#39；我在realcode中看到了发行版的样子，所以我在Squeak 3.8-6665中运行了以下代码。（毫无疑问，任何Smalltalk程序员都可以改进它。）</p><p> gatherMethodStats &#34;How common are methods with lots of temps?&#34; | totaldict tempdict argsdict update | tempdict := Dictionary new. &#34;Maybe not the best container.&#34; argsdict := Dictionary new. totaldict := Dictionary new. update := [:dict :key | dict at: key put: (1 + (dict at: key ifAbsent: [0]))]. Smalltalk allClassesDo: [:class | (Array with: class with: class class) do: [:cl | cl selectorsAndMethodsDo: [:sel :meth | update value: tempdict value: meth numTemps. update value: argsdict value: meth numArgs. update value: totaldict value: meth numTemps + meth numArgs. ] ] ]. ^ {&#39;temps&#39; -&gt; tempdict. &#39;args&#39; -&gt; argsdict. &#39;total&#39; -&gt; totaldict.}</p><p>收集统计数据和#34；有很多临时工的方法有多普遍&#34; | totaldict tempdict argsdict更新| tempdict:=字典新建&#34;也许不是最好的容器&#34; argsdict:=新字典。totaldict:=新字典。更新：=[：dict:key | dict at:key put:（1+（dict at:key ifAbsent:[0]）]）。Smalltalk allClassesDo:[：类|（数组中带有：类和：类类类）do:[：cl | cl选择器和方法do:[：sel:meth |更新值：tempdict值：meth numTemps.更新值：argsdict值：meth nummargs.更新值：totaldict值：meth numTemps+meth nummargs.].]{&#39；temps&#39；&gt；tempdict.&gt；args&#39；&gt；argsdict.&gt；total&#39；&gt；totaldict.}</p><p>  #(&#39;temps&#39; -&gt; a Dictionary( 0-&gt;18952 1-&gt;13665 2-&gt;6366 3-&gt;3697 4-&gt;2301 5-&gt;1492 6-&gt;939 7-&gt;676 8-&gt;426 9-&gt;346 10-&gt;196 11-&gt;193 12-&gt;139 13-&gt;99 14-&gt;60 15-&gt;47 16-&gt;46 17-&gt;30 18-&gt;15 19-&gt;20 20-&gt;12 21-&gt;11 22-&gt;15 23-&gt;6 24-&gt;3 25-&gt;5 26-&gt;4 27-&gt;3 28-&gt;5 32-&gt;1 33-&gt;2 37-&gt;1 39-&gt;1 50-&gt;1)&#39;args&#39; -&gt; a Dictionary( 0-&gt;26114 1-&gt;15903 2-&gt;4717 3-&gt;1712 4-&gt;756 5-&gt;309 6-&gt;138 7-&gt;64 8-&gt;37 9-&gt;13 10-&gt;8 11-&gt;2 12-&gt;1 13-&gt;1 )&#39;total&#39; -&gt; a Dictionary( 0-&gt;18952 1-&gt;3240 2-&gt;11976 3-&gt;3128 4-&gt;4290 5-&gt;1760 6-&gt;1947 7-&gt;999 8-&gt;983 9-&gt;558 10-&gt;521 11-&gt;293 12-&gt;276 13-&gt;155 14-&gt;196 15-&gt;115 16-&gt;81 17-&gt;57 18-&gt;52 19-&gt;31 20-&gt;43 21-&gt;24 22-&gt;20 23-&gt;11 24-&gt;17 25-&gt;9 26-&gt;6 27-&gt;9 28-&gt;7 29-&gt;5 30-&gt;6 33-&gt;1 35-&gt;1 36-&gt;1 38-&gt;1 42-&gt;1 44-&gt;1 46-&gt;1 62-&gt;1 ))</p><p>#（&#39；temps&#39；-&gt；字典）此外，现时有14 926 6 6 6-gt；939 9 9 9 7 7 7 7 7-gt；939 9 9 9 7 7-湾湾中中中中中中中中湾湾湾湾湾中中中中中中中湾湾湾中中中中中中中中中中湾湾中中中中中中湾中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中gt；133-&gt；237-&gt；139-&gt；150-&gt；1）和#39；args&#39-&gt；词典（0-&gt；26141-&gt；15903 2-&gt；4717 3-&gt；1712 4-&gt；756 5-&gt；3096-&gt；1387-&gt；648-&gt；379-&gt；1310-&gt；811-&gt；212-&gt；113-&gt；1）和；总数#39-&gt；字典此外，现时四九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九九&gt；530-&gt；633-&gt；135-&gt；136-&gt；138-&gt；142-&gt；144-&gt；146-&gt；162-&gt；1 ))</p><p> That&#39;s out of 49775 methods; so roughly 95% of these methods have 8 orfewer arguments and temporaries, 90% have 6 or fewer, 75% have 3 orfewer, and 69% have 2 or fewer. That suggests that in a codebase likeSmalltalk, it would probably be a marginal cost to use two stacks inthe bytecode instead of a local-argument vector.</p><p>那&#39；49775种方法中的s；因此，大约95%的方法有8个或更少的参数和临时变量，90%有6个或更少，75%有3个或更少，69%有2个或更少。这表明，在像MallTalk这样的代码库中，在字节码中使用两个堆栈而不是一个局部参数向量可能是一个边际成本。</p><p> But probably the methods that have a lot of local variables andarguments are longer, so inefficiency in implementing those methodsmight cause inefficiency out of proportion to their number. How muchdoes that skew the results? The CompiledMethod class has initialPCand endPC methods which return the bounds of its bytecode, so Ichanged the code to count bytecodes rather than methods:</p><p>但是，可能有很多局部变量和参数的方法更长，所以在实现这些方法时效率低下可能会导致效率低下与它们的数量不成比例。这在多大程度上扭曲了结果？CompiledMethod类有initialPc和endPC方法，它们返回字节码的边界，因此我将代码更改为计算字节码而不是方法：</p><p> gatherMethodStats &#34;How common are methods with lots of temps?&#34; | totaldict tempdict argsdict update | tempdict := Dictionary new. argsdict := Dictionary new. totaldict := Dictionary new. &#34;Maybe not the best container.&#34; update := [:dict :key :incr | dict at: key put: (incr + (dict at: key ifAbsent: [0]))]. Smalltalk allClassesDo: [:class | (Array with: class with: class class) do: [:cl | cl selectorsAndMethodsDo: [:sel :meth || methbytes | methbytes := meth endPC - meth initialPC + 1. update value: tempdict value: meth numTemps value: methbytes. update value: argsdict value: meth numArgs value: methbytes. update value: totaldict value: meth numTemps + meth numArgs value: methbytes. ] ] ]. ^ {&#39;temps&#39; -&gt; tempdict. &#39;args&#39; -&gt; argsdict. &#39;total&#39; -&gt; totaldict.}</p><p>收集统计数据和#34；有很多临时工的方法有多普遍&#34; | totaldict tempdict argsdict更新| tempdict:=字典新建。argsdict:=新字典。totaldict:=新字典&#34;也许不是最好的容器&#34; 更新：=[：dict:key:incr | dict at:key put:（incr+（dict at:key-ifAbsent:[0]））]。Smalltalk allClassesDo:[：class |（数组with:class with:class class class）do:[：cl | cl选择器和方法do:[：sel:meth | | methbytes | methbytes:=meth endPC-meth initialPC+1.更新值：tempdict值：meth numTemps值：methbytes.更新值：argsdict值：meth nummargs值：methbytes.更新值：totaldict值：meth numTemps+meth nummargs值：methbytes.]{&#39；temps&#39；&gt；tempdict.&gt；args&#39；&gt；argsdict.&gt；total&#39；&gt；totaldict.}</p><p>  &#39;total&#39; -&gt; a Dictionary( 0-&gt;171811 1-&gt;95663 2-&gt;182923 3-&gt;117718 4-&gt;125591 5-&gt;92320 6-&gt;92671 7-&gt;72908 8-&gt;61526 9-&gt;49807 10-&gt;46568 11-&gt;36943 12-&gt;27096 13-&gt;21759 14-&gt;27821 15-&gt;17379 16-&gt;13309 17-&gt;10390 18-&gt;9528 19-&gt;7659 20-&gt;10162 21-&gt;5969 22-&gt;5238 23-&gt;3087 24-&gt;5804 25-&gt;5229 26-&gt;2915 27-&gt;3747 28-&gt;2551 29-&gt;2217 30-&gt;3014 33-&gt;12 35-&gt;405 36-&gt;505 38-&gt;341 42-&gt;357 44-&gt;235 46-&gt;336 62-&gt;1028 )</p><p>&#39;总数#39-&gt；字典10.0-gt；2525591 5-gt；125591 5 5-gt；92925 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7-gt；92677 7 7 7 7 7 7-gt；92677 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7-gt；748181811 1 1 1 1-gt；1718181811 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 7-gt；湾湾湾中中中中中中中中中中gt；41414141414141414141414141417 7 7 7 7 7 7 7 7 7-gt；湾湾中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中中gt；湾湾湾湾湾湾湾湾湾湾湾湾湾湾湾湾湾湾湾湾湾湾湾湾湾湾湾湾湾湾&gt；5229 26-&gt；2915 27-&gt；3747 28-&gt；255129-&gt；2217 30-&gt；301433-&gt；12 35-&gt；405 36-&gt；505 38-&gt；341 42-&gt；357 44-&gt；235 46-&gt；336 62-&gt；1028 )</p><p> 50% of them are defined in a context with 4 or fewer locals and args;60% with 6 or fewer; 70% with 7 or fewer; 80% with 10 or fewer; 90%with 14 or fewer; 95% with 27 or fewer. That&#39;s not quite asencouraging as the raw method counts, but it still suggests that theapproach is viable and probably does not need the &#34;4x&#34; instruction Isuggested earlier. (Even in a method with 14 local variables, all ofwhich are simultaneously live, with really random access, I think theaverage distance from the variable you&#39;re currently at to the variableyou want is only a third of 14, or 4.7.)</p><p>其中50%是在包含4个或更少本地人和arg的上下文中定义的；60%为6岁或以下；70%为7岁或以下；80%的人10岁或以下；90%为14岁或以下；95%为27岁或更少。那&#39；虽然原始方法并不令人鼓舞，但它仍然表明该方法是可行的，可能不需要&#34；4x和34；说明是早些时候提出的。（即使是在一个包含14个局部变量的方法中，所有这些变量都是同时活动的，具有真正的随机访问，我认为从您当前所在的变量到您想要的变量的平均距离仅为14的三分之一，即4.7。）</p><p>  Maybe I could follow the MuP21&#39;s lead and use five-bit zero-operandinstructions for a two-stack abstract machine. Probably I should packthem five to a 32-bit word, or three to a 16-bit word; the left-overbits can be used for tagging immediate data in the instruction stream,as in Leong, Tsang, and Lee&#39;s MSL16 FPGA-based FORTH CPU.</p><p>也许我可以跟着MuP21&#39；s引导并使用五位零操作数指令，用于两堆栈抽象机器。也许我应该把它们打包成5到32位的单词，或者3到16位的单词；左超位可用于标记指令流中的即时数据，如Leong、Tsang和Lee&#39；基于CPU的MSL16 FPGA。</p><p> The appeal of the 5-bit instructions is that, say, my sample fibprogram could perhaps be expressed in less than 26 bytes, or 13 16-bitwords: 39 instructions or 16-bit literals. Can we do that? Clearlyit depends on the instruction set. An ideal FORTHish instruction setfor the sample dumb fibonacci program would make it simply</p><p>5位指令的吸引力在于，比方说，我的示例程序可能用不到26个字节或13个16位字来表示：39条指令或16位文字。我们能做到吗？很明显，这取决于指令集。对于示例哑斐波那契程序来说，理想的这种指令集将使其变得简单</p><p>  which is 11 instructions in length, 8 bytes, with 9 distinctinstructions. Some of these instructions --- dup, swap, +, and ; ---would clearly be included in any FORTH-like CPU; others --- 1-,return-1-if-less-than, 2, 2-, and recurse --- are less likely. Here&#39;sa version with a more likely instruction set:</p><p>它有11条指令，8字节，9条指令。其中一些指令--dup、swap、+和---显然会被包括在任何类似CPU的文件中；其他的——1-，return-1-if-less-than，2，2-和recurse——则不太可能。这里&#39；sa版本，具有更可能的指令集：</p><p> dup 1 swap 2 - negative? conditional-return popdup 1- literal(fib) call swap 1- 1- literal(fib) call + ;</p><p>dup 1交换2-负？条件返回popdup 1-literal（fib）调用交换1-1-literal（fib）调用+；</p><p> call, literal, and pop are also almost certain to exist; this versionuses additionally only 1, 2, -, negative?, conditional-return, and 1-.It contains 17 non-literal instructions and two literals, so it wouldbe 16 bytes if literals were two bytes.</p><p>call、literal和pop也几乎肯定会存在；这个版本只额外使用1,2，-，负数？，条件返回和1-。它包含17条非文字指令和两个文字，所以如果文字是两个字节，它将是16个字节。</p><p> For this function, we don&#39;t really need 2 or - as instructions; &#34;2 -&#34;can be rewritten just as easily as &#34;1- 1-&#34;. That brings the requiredinstruction repertoire down to 9 regular instructions, plus literal.</p><p>对于这个函数，我们没有&#39；我真的不需要两个或更多的指示&#34;2 -&#34;可以像&#34；1- 1-&#34;. 这使得所需的指令集减少到9条常规指令，再加上文字指令。</p><p> The only dubious instruction in the remaining repertoire is negative?,and it&#39;s only dubious because the MuP21 doesn&#39;t know about negativity.I think it amounts to testing the carry bit, which is actuallyprobably a pretty reasonable thing to either have an operation to testor to have conditional-return test.</p><p>剩下的曲目中唯一可疑的指令是否定的？，它&#39；这只是因为MuP21没有&#39；我不知道消极性。我认为这相当于测试进位，这实际上很可能是一件非常合理的事情，要么有一个操作要测试，要么有条件返回测试。</p><p> Following the MuP21/F21 model, maybe we could improve on Squeak&#39;sbytecode by avoiding the use of a special space and specialinstructions for local variables, by avoiding the need for messageargument counts (and by supporting multiple return values), andprobably by putting references to message selectors inline in thebytecode rather than in a separate literal table. My instance ofSqueak currently only has 30474 different message selectors, so 16bits for the selector identifier would probably accommodate many moreyears of evolution.</p><p>遵循MuP21/F21模型，也许我们可以改进Squeak#39；通过避免使用特殊空间和局部变量的specialinstructions，避免使用messageargument计数（并支持多个返回值），以及可能通过将对消息选择器的引用内联到字节码中，而不是在单独的文本表中，来编写SByte代码。我的squak实例目前只有30474个不同的消息选择器，因此选择器标识符的16位可能会适应更多年的发展。</p><p> These erasures would not be at the cost of safety --- in Smalltalk,the argument signature of a method is implicit in the selector, and aslong as the bytecode compiler was bug-free, whatever bogus method gotcalled would pop the right number of arguments and push a singlereturn value.</p><p>这些擦除不会以安全为代价——在Smalltalk中，方法的参数签名隐含在选择器中，只要字节码编译器没有错误，调用的任何伪方法都会弹出正确数量的参数并推送一个单一返回值。</p><p> Probably the stack manipulation instructions (# dup over push pop nopdrop) and the control-flow instructions (call else T0 C0 ret) wouldstay the same, with the addition of a &#34;send&#34; instruction; it wouldprobably also be good to keep the A register around in some form, asthe destination for messages, which implies keeping the A and A!instructions as well, for a total of 14 fixed instructions. The&#34;send&#34; instruction could simply leave the object reference in A duringthe call, and expect it to be preserved --- an &#34;A push&#34; sequencebefore clobbering it and a &#34;pop A!&#34; sequence before returning isprobably not too much to ask.</p><p>可能堆栈操作指令（#dup over push pop nopdrop）和控制流指令（call else T0 C0 ret）会保持不变，只是增加了一个&#34；发送&#34；指示以某种形式保留A寄存器，作为消息的目的地，这可能也很好，这意味着保留A和A！指令，共有14条固定指令。34岁；发送&#34；指令只需在调用过程中将对象引用保留在A中，并期望它被保留——A&#34；一推&#34；在击打它和a&#34之前进行排序；砰的一声&#34; 返回前的顺序可能没有太多要求。</p><p> Smalltalk&#39;s blocks might have a little difficulty in this environment--- to access method-local variables, to answer from their containingmethod, and to call methods on self; none of these are difficulties inthe cases where the compiler inlines the control structure, of course.It is, of course, possible to make them into full-fledged objects, asthe abstract</p><p>Smalltalk&#39；s块在这种环境中可能有点困难——访问方法局部变量，从其包含的方法中进行应答，以及在self上调用方法；当然，在编译器内联控制结构的情况下，这些都不是困难。当然，把它们抽象成完整的对象是可能的</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/字节/">#字节</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/指令/">#指令</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>