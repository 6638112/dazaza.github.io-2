<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>响应式集成开发环境的三种体系结构</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">响应式集成开发环境的三种体系结构</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-07-21 11:39:19</div><div class="page_narrow text-break page_content"><p>防锈分析器是一个新的IDE后端，用于防锈编程语言。支持Open Collective上的防锈分析器。</p><p>在这篇文章中，我们将通过三种不同的方式学习如何制作一个快速的集成开发环境：-)它的灵感来自于这篇关于使用数据日志进行语义分析的优秀文章：https://petevilter.me/post/datalog-typechecking/The发布只描述了最高级别的架构。</p><p>具体地说，我们将查看IDE的主干基础结构，它服务于两个目标：</p><p>第一种架构让人想起Map-Reduce范例，其思想是将分析分成相对简单的索引阶段和单独的完整分析阶段。</p><p>索引的核心约束是基于每个文件运行。索引器获取单个文件的文本，对其进行解析，然后输出有关该文件的一些数据。索引器不能接触其他文件。</p><p>完全分析可以读取其他文件，并且它利用索引中的信息来保存工作。</p><p>这听起来太抽象了，所以让我们来看一个具体的示例 - Java。在Java语言中，每个文件都以包声明开始。索引器将包的名称与类名连接起来，以获得完全限定名(FQN)。它还收集类中声明的方法集、超类和接口的列表等。</p><p>将每个文件的数据合并到将FQN映射到类的索引中。请注意，构建此映射是一项令人尴尬的并行任务，因为所有文件都是独立解析的。此外，此映射的更新成本很低。当文件更改到达时，此文件的贡献将从索引中移除，文件文本也会更改，索引器将在新文本上运行并添加新贡献。要做的工作量与更改的文件数量成正比，并且与文件总数无关。</p><p>//File./mypackage/Foo.java包mypackage；import java.util.*；public class foo{public static Bar f(){return new Bar()；}}//File./mypackage/Bar.java包mypackage；public class Bar{public void g(){}}//File./Main.java import mypackage.Foo；public class main{public static void main(string[]args){foo.。F()。}}。</p><p>用户刚刚输入了Foo.f().，我们需要计算出接收器表达式的类型是Bar，并建议使用g作为完成符。</p><p>首先，当文件Main.java被修改时，我们在这个文件上运行索引器，没有任何改变(该文件仍然包含带有静态Main方法的Main类)，所以我们不需要更新FQN索引。</p><p>接下来，我们需要解析名称Foo。我们解析文件，注意导入并在FQN索引中查找mypackage.foo。在索引中，我们还发现foo有一个静态方法f，因此我们也解析了调用。索引还存储了f的返回类型，但是，这一点很重要，它将其存储为字符串，而不是直接引用类Bar。</p><p>原因是在Foo.java中导入java.util.*。Bar可以引用java.util.Bar或mypackage.Bar.索引器不知道是哪一个，因为它只能查看Foo.java的文本。换句话说，虽然索引确实存储了方法的返回类型，但它以未解析的形式存储它们。</p><p>下一步是解析Foo.java.Context中的IDENTIFIER Bar。这将使用FQN索引，并位于类mypackage.Bar中。在那里可以找到所需的方法g。</p><p>总共只有三个文件在完成期间被触及。FQN索引允许我们完全忽略项目中的所有其他文件。</p><p>到目前为止所描述的方法的一个问题是，从索引解析类型需要大量的工作。例如，如果多次调用foo.f，这项工作可能会重复。修复方法是添加一个缓存。名称解析结果会被记录下来，因此只需支付一次成本。使用索引的任何更改 - 都会完全清除缓存，重新构建缓存的成本并不是很高。</p><p>每个文件都独立且并行地进行索引，生成存根( - )一组可见的顶级声明，其中包含未解析的类型。</p><p>名称解析是惰性的(我们只在需要的时候解析存根中的类型)，并且是有记忆的(每个类型只解析一次)。</p><p>如果编辑没有更改文件的存根，则不需要更改索引。</p><p>注意&#34；哑索引和&#34；智能缓存之间有趣的相互作用，前者可以递增更新，后者则从头开始重新计算。</p><p>这种方法结合了简单性和卓越的性能。大部分工作是索引阶段，您可以将其并行，甚至将其分布在多台机器上。此体系结构的两个示例是IntelliJ和Sorbet。</p><p>这种方法的主要缺点是，它只有在工作时才起作用， - 并不是每种语言都有定义良好的FQN概念。我认为总的来说，设计名称解析和模块系统(语言中的大多数令人厌烦的部分)以便它们能够很好地使用Map-Reduce范例是个好主意。</p><p>禁止添加新的顶级声明的元编程工具，或者限制它们的方式使它们可以被索引器使用。例如，一次访问单个文件的类似预处理器的编译器插件可能会很好。</p><p>确保每个源元素对应于单个语义元素。例如，如果语言支持条件编译，请确保它在名称解析期间(如Kotlin的Expect/Actual)工作，而不是在解析期间(如大多数其他语言中的条件编译)。否则，您必须用不同的条件编译设置来索引同一文件，这会很混乱。</p><p>最后一点值得详细说明。让我们看看下面的铁锈示例：</p><p>//File：./foo.rs特征T{fn f(&amp；self){}}//File：./bar.rs struct S；//File：./Where/ell.rs Impl T for S{}//File：./main.s use foo：：t；use bar：：s fn main(){let s=S；s.f()；}。</p><p>在这里，我们可以很容易地找到S结构和T特征(因为它们是直接导入的)。但是，为了确保S.f确实引用T中的f，我们还需要找到相应的impl，它可以大致在任何地方！</p><p>该方法的思想很简单， - 只需使用传统编译器，并在导入每个编译单元后立即对其状态进行快照。例如：</p><p>在这里，编译器完全处理iostream(以及任何更多的头)，对其状态进行快照，并自行解析程序。当用户键入更多字符时，编译器会从紧接在包含之后的位置重新启动。由于每个编译单元本身的大小通常是合理的，因此分析速度很快。</p><p>如果用户在头文件中键入内容，则需要使缓存无效。但是，对头文件的更改相对较少，大多数代码都位于.cpp文件中。</p><p>在某种意义上，标头对应于第一种方法的存根，有两个显著的区别：</p><p>是用户负责生成存根，而不是工具。</p><p>与存根不同，标头不能相互递归。存根存储未解析的类型，但可以在完成分析后创建Include快照。</p><p>这种方法的巨大好处是它允许重用现有的批处理编译器。本文描述的另外两种方法通常会导致编译器重写。缺点是几乎没有人喜欢头文件和转发声明。</p><p>请注意，这两种方法都不是以任何有趣的方式递增的。如果有什么变化，让我们完全清除缓存。在第一种方法中，索引更新中有一点点递增，但是 - 删除旧键，添加新键几乎是微不足道的。</p><p>这是因为让和集成开发变得快速的不是增量，而是懒惰(lastness - )，即完全跳过大量代码的能力。</p><p>使用map-duce，索引准确地告诉我们使用了当前文件中的哪一小部分文件，并且值得查看。Headers使我们免受大部分实现代码的影响。</p><p>#[MACRO_USE]外部箱架位标志；位标志！{struct标志：u32{const A=0b00000001；const B=0b00000010；const C=0b00000100；const ABC=self：：a.bits|self：：b.bits|self：：c.bits；}}。</p><p>位标志是来自另一个板条箱并定义顶级声明的宏。我们不能将宏展开的结果放入索引中，因为它依赖于另一个文件中的宏定义。我们可以将宏调用自身放入索引中，但这大多是无用的，因为由宏声明的项将丢失索引。</p><p>模块foo和bar引用相同的文件foo.rs，这实际上意味着foo.rs中的项是重复的。如果foo.rs包含声明struct S；，那么foo：：s和bar：：s是不同类型的。您也不能将其放入索引中，因为那些mod声明位于不同的文件中。</p><p>第二种方法也不起作用。在C++中，编译单元是单个文件。在Rust中，编译单元是一个完整的机箱，它由许多文件组成，通常要大得多。而且Rust有过程性宏，这意味着即使是代码的表面分析也可能需要无限的时间。而且没有头文件，所以IDE必须处理整个机箱。此外，机箱内的名称解析要复杂得多(使用前声明和定点迭代与宏交织在一起)。此外，在Rust中，编译单元是一个单独的文件。此外，Rust中的编译单元是一个完整的机箱，它由许多文件组成，通常要大得多。此外，RUST有过程性宏，这意味着即使是代码的表面分析也会花费无限的时间，而且没有头文件，所以IDE必须处理整个机箱。</p><p>似乎纯粹基于懒惰的模型不适用于Rust，懒惰的最小可行单位，一个板条箱，仍然太大了。</p><p>为此，在锈蚀分析器中，我们采用了一种智能的解决方案，我们用增量来弥补懒惰的不足，具体地说，我们使用了一个通用的框架来增量计算 - SALSA。</p><p>SALSA背后的思想相当简单， - 编译器内的所有函数调用都会被检测，以记录在执行过程中调用了哪些其他函数。记录的跟踪用于实现细粒度增量。如果修改后所有依赖项的结果都相同，则重用旧结果。</p><p>如果函数由于依赖关系的改变而重新执行，还会有一个额外的、关键的扭曲 - ，新结果将与旧结果进行比较，如果尽管输入不同，但它们是相同的，则无效的传播将停止。</p><p>使用这个引擎，我们能够实现一种相当奇特的更新策略。与Map Reduce方法不同，我们的索引可以存储解析的类型，这些类型只有在顶级更改发生时才会失效。即使在顶级更改之后，我们也能够重用大多数宏展开的结果。在顶级宏中键入也不会使缓存失效，除非宏的展开引入了一组不同的项。</p><p>这种方法的主要好处是通用性和正确性。如果您可以使用增量计算引擎，那么尝试构建计算的方式就会变得相对容易。代码看起来大多像一个乏味的命令式编译器，并且您不会出现缓存无效错误(我们有一个，因为过程性宏是不确定的)。</p><p>主要缺点是额外的复杂性、较慢的性能(细粒度跟踪依赖项需要时间和内存)，并且给人的感觉是这在某种程度上还是一个未知的领域：-)</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html">https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/开发/">#开发</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文件/">#文件</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1013192.html"><img src="http://img.diglog.com/img/2020/7/thumb_6d96ad8c6f775bb4e3ba2957ba55b860.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1013192.html">Stripe：构建开发人员崇拜</a></div><span class="my_story_list_date">2020-7-21 11:2</span></div><div class="col-sm"><div><a target="_blank" href="/story/1013142.html"><img src="http://img.diglog.com/img/2020/7/thumb_f9e7b37329e50215b0819550d14358b9.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1013142.html">
在多次遭到拒绝后，Strike为Co-Star人群开发的约会应用程序在App Store上线</a></div><span class="my_story_list_date">2020-7-21 6:48</span></div><div class="col-sm"><div><a target="_blank" href="/story/1013127.html"><img src="http://img.diglog.com/img/2020/7/thumb_5924018374cd89dba3bc79ab5f125898.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1013127.html">前Solus开发人员正在创建一个真正现代的Linux发行版</a></div><span class="my_story_list_date">2020-7-21 5:46</span></div><div class="col-sm"><div><a target="_blank" href="/story/1013106.html"><img src="http://img.diglog.com/img/2020/7/thumb_fda8a224f45cf238ad85f708a68b8836.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1013106.html">Adobe表示，它已经聘请了为谷歌Pixel系列开发计算摄影的顶级研究员马克·莱沃伊(Marc Levoy)，以帮助其开发一款通用的相机应用</a></div><span class="my_story_list_date">2020-7-21 3:53</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>