<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>用最美味的例子学习MakefilesLearn Makefiles with the Tastiest Examples</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Learn Makefiles with the Tastiest Examples<br/>用最美味的例子学习Makefiles</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2022-02-22 00:00:59</div><div class="page_narrow text-break page_content"><p>I built this guide because I could never quite wrap my head around Makefiles. They seemed awash with hidden rules and esoteric symbols, and asking simple questions didn’t yield simple answers. To solve this, I sat down for several weekends and read everything I could about Makefiles. I&#39;ve condensed the most critical knowledge into this guide. Each topic has a brief description and a self contained example that you can run yourself.</p><p>我之所以创建这个指南，是因为我从来都不太了解Makefiles。他们似乎充斥着隐藏的规则和深奥的符号，问简单的问题并不能得到简单的答案。为了解决这个问题，我花了几个周末坐下来，读了所有关于Makefiles的书。我&#39；我把最重要的知识浓缩到这本指南中。每个主题都有一个简短的描述和一个独立的示例，您可以自己运行。</p><p> If you mostly understand Make, consider checking out the Makefile Cookbook, which has a template for medium sized projects with ample comments about what each part of the Makefile is doing.</p><p>如果您主要理解Apple，请考虑查看MaxFoeCooBook，它有一个中等大小的项目的模板，对MaX文件的每个部分做了充分的注释。</p><p> Good luck, and I hope you are able to slay the confusing world of Makefiles!</p><p>祝你好运，我希望你能够杀掉这个令人困惑的Makefiles世界！</p><p>   Makefiles are used to help decide which parts of a large program need to be recompiled. In the vast majority of cases, C or C++ files are compiled. Other languages typically have their own tools that serve a similar purpose as Make. It can be used beyond programs too, when you need a series of instructions to run depending on what files have changed. This tutorial will focus on the C/C++ compilation use case.</p><p>Makefiles用于帮助决定需要重新编译大型程序的哪些部分。在绝大多数情况下，C或C++文件被编译。其他语言通常有自己的工具，其用途与Make类似。它也可以在程序之外使用，当你需要一系列的指令来运行时，这取决于文件发生了什么变化。本教程将重点介绍C/C++编译用例。</p><p> Here&#39;s an example dependency graph that you might build with Make. If any file&#39;s dependencies changes, then the file will get recompiled:</p><p>这里&#39；这是一个可以用Make构建的依赖关系图示例。如果有任何文件&#39；s依赖项更改，则文件将重新编译：</p><p>   Popular C/C++ alternative build systems are  SCons,  CMake,  Bazel, and  Ninja. Some code editors like  Microsoft Visual Studio have their own built in build tools. For Java, there&#39;s  Ant,  Maven, and  Gradle. Other languages like Go and Rust have their own build tools.</p><p>流行的C/C++替代构建系统有SCons、CMake、Bazel和Ninja。一些代码编辑器，如Microsoft Visual Studio，有自己的内置生成工具。对于Java，有&#39；s Ant，Maven和Gradle。Go和Rust等其他语言都有自己的构建工具。</p><p> Interpreted languages like Python, Ruby, and Javascript don&#39;t require an analogue to Makefiles. The goal of Makefiles is to compile whatever files need to be compiled, based on what files have changed. But when files in interpreted languages change, nothing needs to get recompiled. When the program runs, the most recent version of the file is used.</p><p>Python、Ruby和Javascript等解释语言；不需要模拟来生成文件。Makefiles的目标是根据更改的文件来编译任何需要编译的文件。但是，当解释语言中的文件发生更改时，不需要重新编译任何内容。程序运行时，将使用文件的最新版本。</p><p>  There are a variety of implementations of Make, but most of this guide will work on whatever version you&#39;re using. However, it&#39;s specifically written for GNU Make, which is the standard implementation on Linux and MacOS. All the examples work for Make versions 3 and 4, which are nearly equivalent other than some esoteric differences.</p><p>Make有多种实现方式，但本指南的大部分内容都适用于任何版本&#39；重复使用。然而，它&#39；它是专门为GNU Make编写的，GNU Make是Linux和MacOS上的标准实现。所有的例子都适用于Make版本3和版本4，除了一些深奥的差异之外，它们几乎是等价的。</p><p>  To run these examples, you&#39;ll need a terminal and &#34;make&#34; installed. For each example, put the contents in a file called  Makefile, and in that directory run the command  make. Let&#39;s start with the simplest of Makefiles:</p><p>要运行这些示例，您&#39；我需要一个终端和&#34；制作&#34；安装。对于每个示例，将内容放在一个名为Makefile的文件中，并在该目录中运行make命令。让&#39；让我们从最简单的makefile开始：</p><p>    That&#39;s it! If you&#39;re a bit confused, here&#39;s a video that goes through these steps, along with describing the basic structure of Makefiles.</p><p>那&#39；就这样！如果你&#39；你有点困惑，在这里&#39；这是一个视频，介绍了这些步骤，以及Makefiles的基本结构。</p><p>     The  targets are file names, separated by spaces. Typically, there is only one per rule.</p><p>目标是文件名，用空格分隔。通常，每条规则只有一条。</p><p> The  commands are a series of steps typically used to make the target(s). These  need to start with a tab character, not spaces.</p><p>这些命令是一系列通常用于生成目标的步骤。它们需要以制表符开始，而不是空格。</p><p> The  prerequisites are also file names, separated by spaces. These files need to exist before the commands for the target are run. These are also called  dependencies</p><p>先决条件也是文件名，用空格分隔。在运行目标命令之前，这些文件必须存在。这些也被称为依赖项</p><p>  The following Makefile has three separate  rules. When you run  make blah in the terminal, it will build a program called  blah in a series of steps:</p><p>下面的Makefile有三个单独的规则。在终端中运行make blah时，它将通过一系列步骤构建一个名为blah的程序：</p><p> The  cc -c command is then run, because all of the  blah.o dependencies are finished</p><p>然后运行cc-c命令，因为所有这些都是废话。o依赖项已完成</p><p> blah: blah.o	cc blah.o -o blah  # Runs third blah.o: blah.c	cc -c blah.c -o blah.o  # Runs second blah.c:	echo  &#34;int main() { return 0; }&#34; &gt; blah.c  # Runs first</p><p>等等。抄送废话。o-o废话#跑第三废话。o:废话。等等。等等。o#是第二个废话。c:echo&#34；int main（）{return 0；}&#34; &gt；废话。c#先跑</p><p> This makefile has a single target, called  some_file. The default target is the first target, so in this case  some_file will run.</p><p>这个makefile只有一个目标，叫做some_file。默认目标是第一个目标，因此在本例中，将运行一些_文件。</p><p>  This file will make  some_file the first time, and the second time notice it&#39;s already made, resulting in  make: &#39;some_file&#39; is up to date.</p><p>这个文件第一次会生成一些_文件，第二次会注意到它&#39；s已经制造，导致制造：&#39；一些文件&#39；是最新的。</p><p>  Here, the target  some_file &#34;depends&#34; on  other_file. When we run  make, the default target ( some_file, since it&#39;s first) will get called. It will first look at its list of  dependencies, and if any of them are older, it will first run the targets for those dependencies, and then run itself. The second time this is run, neither target will run because both targets exist.</p><p>在这里，目标是一些#文件#34；取决于&#34；在另一个文件上。当我们运行make时，将调用默认目标（一些#u文件，因为它是第一个文件）。它将首先查看其依赖项列表，如果其中任何依赖项比较旧，它将首先运行这些依赖项的目标，然后自行运行。第二次运行时，两个目标都不会运行，因为两个目标都存在。</p><p> some_file: other_file	echo  &#34;This will run second, because it depends on other_file&#34;	touch some_file other_file:	echo  &#34;This will run first&#34;	touch other_file</p><p>一些_文件：其他_文件回声#34；这将以秒为单位运行，因为它取决于其他#文件#34；触摸其他文件：echo&#34；这将首先运行&#34；触摸其他文件</p><p> This will always run both targets, because  some_file depends on other_file, which is never created.</p><p>这将始终运行两个目标，因为某些_文件依赖于另一个_文件，而另一个永远不会创建。</p><p>  clean is often used as a target that removes the output of other targets, but it is not a special word in  make.</p><p>clean通常用作删除其他目标的输出的目标，但它在make中不是一个特殊的词。</p><p>   Variables can only be strings. You&#39;ll typically want to use  :=, but  = also works. See  Variables Pt 2.</p><p>变量只能是字符串。你&#39；我通常希望使用：=，但=也可以。参见变量第2部分。</p><p>  files := file1 file2 some_file:  $(files)	echo  &#34;Look at this variable: &#34;  $(files)	touch some_file file1:	touch file1 file2:	touch file2 clean:	rm -f file1 file2 some_file</p><p>文件：=file1 file2一些文件：$（文件）echo&#34；看看这个变量：&#34$（文件）触摸一些文件文件1：触摸文件1文件2：触摸文件2清洁：rm-f文件1文件2一些文件</p><p>     Making multiple targets and you want all of them to run? Make an  all target.</p><p>制定多个目标，你想让所有目标都运行吗？制定一个全面的目标。</p><p> all: one two three one:	touch one two:	touch two three:	touch three clean:	rm -f one two three</p><p>全部：一二三一：触摸一二：触摸二三：触摸三清洁：rm-f一二三</p><p>  When there are multiple targets for a rule, the commands will be run for each target  $@ is an  automatic variable that contains the target name.</p><p>当规则有多个目标时，将为每个目标运行命令。$@是一个包含目标名称的自动变量。</p><p>    Both  * and  % are called wildcards in Make, but they mean entirely different things.  * searches your filesystem for matching filenames. I suggest that you always wrap it in the  wildcard function, because otherwise you may fall into a common pitfall described below.</p><p>*和%在Make中都被称为通配符，但它们的含义完全不同。*在文件系统中搜索匹配的文件名。我建议您总是将其包装在通配符函数中，否则您可能会陷入下面描述的常见陷阱。</p><p>    Danger: When  * matches no files, it is left as it is (unless run in the  wildcard function)</p><p>危险：当*不匹配任何文件时，它保持原样（除非在通配符函数中运行）</p><p> thing_wrong := *.o  # Don&#39;t do this! &#39;*&#39; will not get expandedthing_right :=  $( wildcard *.o) all: one two three four # Fails, because $(thing_wrong) is the string &#34;*.o&#34; one:  $(thing_wrong) # Stays as *.o if there are no files that match this pattern :( two: *.o  # Works as you would expect! In this case, it does nothing. three:  $(thing_right) # Same as rule three four: $(wildcard *.o)</p><p>有问题：=*。o#Don和#39；别这样&#39;*&#39; 无法展开正确的内容：=$（通配符*.o）全部：一二三四失败，因为$（出错）是字符串&#34；*。o&#34；第一：$（有错）#保持为*。o如果没有与此模式匹配的文件：（两个：:.o#按照您的预期工作！在本例中，它什么也不做。三：$（正确的东西）#与规则三四相同：$（通配符*.o）</p><p>  % is really useful, but is somewhat confusing because of the variety of situations it can be used in.</p><p>%是非常有用的，但由于它可以用于多种情况，因此有点令人困惑。</p><p> When used in &#34;matching&#34; mode, it matches one or more characters in a string. This match is called the stem.</p><p>在&#34中使用时；匹配&#34；模式，它匹配字符串中的一个或多个字符。这场比赛被称为干。</p><p> When used in &#34;replacing&#34; mode, it takes the stem that was matched and replaces that in a string.</p><p>在&#34中使用时；更换&#34；模式下，它将匹配的词干替换为字符串中的词干。</p><p>     hey: one two	 # Outputs &#34;hey&#34;, since this is the first target	echo  $@	 # Outputs all prerequisites newer than the target	echo  $?	 # Outputs all prerequisites	echo  $^	touch hey one:	touch one two:	touch two clean:	rm -f hey one two</p><p>嘿：一两个输出&#34；嘿&#34；，因为这是第一个目标echo$@#输出比目标echo$更新的所有先决条件？#输出所有先决条件$^touch hey one:touch one two:touch two clean:rm-f hey one two</p><p>   Make loves c compilation. And every time it expresses its love, things get confusing. Perhaps the most confusing part of Make is the magic/automatic rules that are made. Make calls these &#34;implicit&#34; rules. I don&#39;t personally agree with this design decision, and I don&#39;t recommend using them, but they&#39;re often used and are thus useful to know. Here&#39;s a list of implicit rules:</p><p>用c语言编译。每一次它表达爱的时候，事情都会变得扑朔迷离。也许Make中最令人困惑的部分是所制定的魔法/自动规则。打这些电话&#34；隐式&#34；规则。我不&#39；我个人不同意这个设计决定，我也不&#39；我不建议使用它们，但它们&#39；我们经常使用，因此了解它们很有用。这里&#39；这是一个隐式规则列表：</p><p> Compiling a C program:  n.o is made automatically from  n.c with a command of the form  $(CC) -c $(CPPFLAGS) $(CFLAGS)</p><p>编译C程序：n.o由n.C自动生成，命令格式为$（CC）-C$（CPPFLAGS）$（CFLAGS）</p><p> Compiling a C++ program:  n.o is made automatically from  n.cc or  n.cpp with a command of the form  $(CXX) -c $(CPPFLAGS) $(CXXFLAGS)</p><p>编译C++程序：N.O由N.CC或N.CPP自动生成，并带有表单$（CXX）-C$（CPPPFLAGS）$（CXFLAGS）的命令。</p><p> Linking a single object file:  n is made automatically from  n.o by running the command  $(CC) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS)</p><p>链接单个对象文件：n通过运行命令$（CC）$（LDFLAGS）n.o$（LOADLIBES）$（LDLIBS）从n.o自动生成</p><p>  LDFLAGS: Extra flags to give to compilers when they are supposed to invoke the linker</p><p>LDFLAGS：当编译器应该调用链接器时，给它们的额外标志</p><p> Let&#39;s see how we can now build a C program without ever explicitly telling Make how to do the compililation:</p><p>让&#39；让我们看看现在如何构建一个C程序，而不必明确告诉Make如何编译：</p><p> CC = gcc  # Flag for implicit rulesCFLAGS = -g  # Flag for implicit rules. Turn on debug info # Implicit rule #1: blah is built via the C linker implicit rule # Implicit rule #2: blah.o is built via the C compilation implicit rule, because blah.c exists blah: blah.o blah.c:	echo  &#34;int main() { return 0; }&#34; &gt; blah.c clean:	rm -f blah*</p><p>CC=gcc#隐式规则的标志scflags=-g#隐式规则的标志。打开调试信息#隐式规则#1:blah是通过C链接器隐式规则#隐式规则#2:blah构建的。o是通过C编译隐式规则构建的，因为诸如此类。存在等等。哦，废话。c:echo&#34；int main（）{return 0；}&#34; &gt；废话。c清洁：rm-f等等*</p><p>  Static pattern rules are another way to write less in a Makefile, but I&#39;d say are more useful and a bit less &#34;magic&#34;. Here&#39;s their syntax:</p><p>静态模式规则是在Makefile中写得更少的另一种方式，但我&#39；d说它们更有用，但有点少#34；魔法&#34；。这里&#39；这是他们的语法：</p><p>  The essence is that the given  target is matched by the  target-pattern (via a  % wildcard). Whatever was matched is called the  stem. The stem is then substituted into the  prereq-pattern, to generate the target&#39;s prereqs.</p><p>本质上，给定的目标与目标模式匹配（通过%通配符）。匹配的东西叫做茎。然后将stem替换为prereq模式，以生成目标&#39；这是先决条件。</p><p> A typical use case is to compile  .c files into  .o files. Here&#39;s the  manual way:</p><p>典型的用例是编译。c文件进入。o文件。这里&#39；这是手动方式：</p><p> objects = foo.o bar.o all.o all:  $(objects) # These files compile via implicit rules foo.o: foo.c bar.o: bar.c all.o: all.c all.c:	echo  &#34;int main() { return 0; }&#34; &gt; all.c %.c:	touch  $@ clean:	rm -f *.c *.o all</p><p>objects=foo。哦，酒吧。哦，好的。o所有：$（对象）#这些文件通过隐式规则foo编译。o:福。c酒吧。o:酒吧。c全部。o:好的。c全部。c:echo&#34；int main（）{return 0；}&#34; &gt；全部的c%。c:touch$@clean:rm-f*。c*。哦，所有</p><p>  objects = foo.o bar.o all.o all:  $(objects) # These files compile via implicit rules # Syntax - targets ...: target-pattern: prereq-patterns ... # In the case of the first target, foo.o, the target-pattern matches foo.o and sets the &#34;stem&#34; to be &#34;foo&#34;. # It then replaces the &#39;%&#39; in prereq-patterns with that stem $(objects): %.o: %.c all.c:	echo  &#34;int main() { return 0; }&#34; &gt; all.c %.c:	touch  $@ clean:	rm -f *.c *.o all</p><p>objects=foo。哦，酒吧。哦，好的。o所有：$（对象）#这些文件通过隐式规则编译#语法-目标…：目标模式：预请求模式…#对于第一个目标，foo。o、 目标模式与foo匹配。o并设置&#34；茎和#34；34岁；foo&#34；#然后它将替换&#39；%&#39; 在带有干$（对象）的prereq模式中：%。o:%。c全部。c:echo&#34；int main（）{return 0；}&#34; &gt；全部的c%。c:touch$@clean:rm-f*。c*。哦，所有</p><p>  While I introduce functions later on, I&#39;ll foreshadow what you can do with them. The  filter function can be used in Static pattern rules to match the correct files. In this example, I made up the  .raw and  .result extensions.</p><p>在我稍后介绍函数时，我&#39；I’我将为你能用它们做些什么做铺垫。可以在静态模式规则中使用filter函数来匹配正确的文件。在这个例子中，我编写了。生的和生的。结果扩展。</p><p> obj_files = foo.result bar.o lose.osrc_files = foo.raw bar.c lose.c  all:  $(obj_files) $( filter %.o, $(obj_files)): %.o: %.c	echo  &#34;target:  $@ prereq:  $&lt;&#34; $( filter %.result, $(obj_files)): %.result: %.raw	echo  &#34;target:  $@ prereq:  $&lt;&#34; %.c %.raw:	touch  $@ clean:	rm -f  $(src_files)</p><p>obj_files=foo。结果栏。哦，输了。osrc_files=foo。生酒吧。c输了。c全部：$（obj_文件）$（过滤器%.o，$（obj_文件））：%。o:%。c echo和#34；目标：$@prereq:$&lt&#34; $（筛选器%.result，$（obj_文件））：%。结果：%。原始回声&#34；目标：$@prereq:$&lt&#34; %.c%。原始：touch$@clean:rm-f$（src_文件）</p><p>  Pattern rules are often used but quite confusing. You can look at them as two ways:</p><p>模式规则经常被使用，但相当混乱。你可以从两个方面来看待它们：</p><p>   # Define a pattern rule that compiles every .c file into a .o file%.o : %.c		 $(CC) -c  $(CFLAGS)  $(CPPFLAGS)  $&lt; -o  $@</p><p>#定义一个模式规则，该规则编译每个。c文件转换成一个。o文件%。o:%。c$（CC）-c$（CFLAGS）$（CPPFLAGS）$&lt-o$@</p><p> Pattern rules contain a &#39;%&#39; in the target. This &#39;%&#39; matches any nonempty string, and the other characters match themselves. ‘%’ in a prerequisite of a pattern rule stands for the same stem that was matched by the ‘%’ in the target.</p><p>模式规则包含一个&#39；%&#39; 在目标中。这个&#39；%&#39; 匹配任何非空字符串，其他字符匹配它们自己。“%”在模式的先决条件中，规则代表与目标中“%”匹配的同一个干。</p><p>  # Define a pattern rule that has no pattern in the prerequisites. # This just creates empty .c files when needed. %.c: touch  $@</p><p>#定义一个先决条件中没有模式的模式规则。#这只会产生空的。需要时使用c文件。%。c:触摸$@</p><p>  Double-Colon Rules are rarely used, but allow multiple rules to be defined for the same target. If these were single colons, a warning would be printed and only the second set of commands would run.</p><p>很少使用双冒号规则，但允许为同一目标定义多个规则。如果这些是单冒号，则会打印一条警告，并且只会运行第二组命令。</p><p>    Add an  @ before a command to stop it from being printed You can also run make with  -s to add an  @ before each line</p><p>在命令前添加一个@以阻止打印。您还可以使用-s运行make以在每行之前添加一个@</p><p>   Each command is run in a new shell (or at least the effect is as such)</p><p>每个命令都在一个新的shell中运行（或者至少效果是这样的）</p><p> all: 	cd ..	 # The cd above does not affect this line, because each command is effectively run in a new shell	echo `pwd`	 # This cd command affects the next because they are on the same line	cd ..;echo `pwd`	 # Same as above	cd ..; \	echo `pwd`</p><p>全部：cd。。#上面的cd不影响此行，因为每个命令都在一个新的shell echo`pwd`中有效地运行#此cd命令影响下一个命令，因为它们在同一行cd上。。；echo`pwd`#与上述cd相同\echo`pwd`</p><p>     Add  -k when running make to continue running even in the face of errors. Helpful if you want to see all the errors of Make at once. Add a  - before a command to suppress the error Add  -i to make to have this happen for every command.</p><p>运行make时添加-k，即使遇到错误也可以继续运行。如果您想同时查看Make的所有错误，这将非常有用。在命令之前添加一个-Add-i以抑制错误，并为每个命令添加-i以使其发生这种情况。</p><p> one:	 # This error will be printed but ignored, and make will continue to run	-false	touch one</p><p>第一：#此错误将被打印但忽略，make将继续运行-错误触摸一</p><p>  Note only: If you  ctrl+c make, it will delete the newer targets it just made.</p><p>只需注意：如果按住ctrl+c组合键，它将删除刚刚创建的较新目标。</p><p>  To recursively call a makefile, use the special  $(MAKE) instead of  make because it will pass the make flags for you and won&#39;t itself be affected by them.</p><p>要递归调用makefile，请使用特殊的$（MAKE）而不是MAKE，因为它将为您传递MAKE标志，并赢得&#39；它本身不会受到它们的影响。</p><p> new_contents =  &#34;hello:\n\ttouch inside_file&#34; all:	mkdir -p subdir	printf  $(new_contents) | sed -e &#39;s/^ //&#39; &gt; subdir/makefile	cd subdir &amp;&amp;  $(MAKE) clean:	rm -rf subdir</p><p>新内容=&#34；您好：\n\t点击内部文件&#34；全部：mkdir-p subdir printf$（新内容）|sed-e&#39；s/^/&#39&gt；subdir/makefile cd subdir&amp&amp$（使）清洁：rm-rf细分</p><p>  The export directive takes a variable and makes it accessible to sub-make commands. In this example,  cooly is exported such that the makefile in subdir can use it.</p><p>export指令接受一个变量，并使子make命令可以访问该变量。在本例中，将导出cooly，以便subdir中的makefile可以使用它。</p><p> Note: export has the same syntax as sh, but they aren&#39;t related (although similar in function)</p><p>注意：export的语法与sh相同，但它们不是&#39；t相关（尽管功能相似）</p><p> new_contents =  &#34;hello:\n\\techo \$ $(cooly)&#34; all:	mkdir -p subdir	echo  $(new_contents) | sed -e &#39;s/^ //&#39; &gt; subdir/makefile	@echo  &#34;---MAKEFILE CONTENTS---&#34;	@cd subdir &amp;&amp; cat makefile	@echo  &#34;---END MAKEFILE CONTENTS---&#34;	cd subdir &amp;&amp;  $(MAKE) # Note that variables and exports. They are set/affected globally.cooly =  &#34;The subdirectory can see me!&#34; export cooly # This would nullify the line above: unexport cooly clean:	rm -rf subdir</p><p>新内容=&#34；你好：\n\\techo\$$（酷）和#34；全部：mkdir-p subdir echo$（新内容）|sed-e&#39；s/^/&#39&gt；subdir/makefile@echo&#34---MAKEFILE内容--&#34；@cd-R&amp&amp；cat makefile@echo&#34---结束MAKEFILE内容--&#34；cd&amp&amp$（MAKE）#注意变量和导出。它们在全球范围内受到影响。cooly=&#34；子目录可以看到我&#34; export cooly#这将使上面的行无效：unexport cooly clean:rm-rf subdir</p><p>  one=this will only work locally export two=we can run subcommands with this all: 	@echo  $(one)	@echo $$one	@echo  $(two)	@echo $$two</p><p>one=这只在本地工作export two=我们可以使用以下所有命令运行子命令：@echo$（一）@echo$$one@echo$（二）@echo$$two</p><p>  .EXPORT_ALL_VARIABLES:new_contents =  &#34;hello:\n\techo \$ $(cooly)&#34;cooly =  &#34;The subdirectory can see me!&#34; # This would nullify the line above: unexport cooly all:	mkdir -p subdir	echo  $(new_contents) | sed -e &#39;s/^ //&#39; &gt; subdir/makefile	@echo  &#34;---MAKEFILE CONTENTS---&#34;	@cd subdir &amp;&amp; cat makefile	@echo  &#34;---END MAKEFILE CONTENTS---&#34;	cd subdir &amp;&amp;  $(MAKE) clean:	rm -rf subdir</p><p>.EXPORT_ALL_变量：new_contents=&#34；你好：\n\techo\$$（酷）和#34；cooly=&#34；子目录可以看到我&#34; # 这将使上面的行无效：unexport cooly all:mkdir-p subdir echo$（新内容）|sed-e&#39；s/^/&#39&gt；subdir/makefile@echo&#34---MAKEFILE内容--&#34；@cd-R&amp&amp；cat makefile@echo&#34---结束MAKEFILE内容--&#34；cd&amp&amp$（使）清洁：rm-rf细分</p><p>  There&#39;s a nice  list of options that can be run from make. Check out  --dry-run,  --touch,  --old-file.</p><p>那里&#39；这是一个很好的选项列表，可以从make运行。检查——试运行，——触摸，——旧文件。</p><p> You can have multiple targets to make, i.e.  make clean run test runs the  clean goal, then  run, and then  test.</p><p>你可以设定多个目标，例如，让清洁运行测试运行清洁目标，然后运行，然后测试。</p><p>    recursive (use  =) - only looks for the variables when the command is  used, not when it&#39;s  defined.</p><p>递归（use=）-仅在使用命令时查找变量，而不是在&#39；这是定义。</p><p> simply expanded (use  :=) - like normal imperative programming -- only those defined so far get expanded</p><p>简单扩展（使用：=）——就像普通的命令式编程一样——只有到目前为止定义的程序才能被扩展</p><p> # Recursive variable. This will print &#34;later&#34; belowone = one ${later_variable} # Simply expanded variable. This will not print &#34;later&#34; belowtwo := two ${later_variable}later_variable = later all: 	echo  $(one)	echo  $(two)</p><p>#递归变量。这将打印&#34；后来&#34；belowone=one${later_variable}#简单扩展变量。这不会打印&#34；后来&#34；belowtwo:=two${later_variable}later_variable=later all:echo$（一）echo$（二）</p><p> Simply expanded (using  :=) allows you to append to a variable. Recursive definitions will give an infinite loop error.</p><p>简单扩展（使用：=）允许您附加到变量。递归定义将产生无限循环错误。</p><p> one = hello # one gets defined as a simply expanded variable (:=) and thus can handle appendingone := ${one} there all: 	echo  $(one)</p><p>one=hello#one被定义为一个简单的扩展变量（：=），因此可以处理appendingone:=${one}那里all:echo$（one）</p><p>  one = helloone ?= will not be settwo ?= will be set all: 	echo  $(one)	echo  $(two)</p><p>一个=你好吗？=不会是第二集吗？=将全部设置为：echo$（一个）echo$（两个）</p><p> Spaces at the end of a line are not stripped, but those at the start are. To make a variable with a single space, use  $(nullstring)</p><p>线条末端的空间不会被剥离，但开头的空间会被剥离。要使用单个空格生成变量，请使用$（nullstring）</p><p> with_spaces = hello  # with_spaces has many spaces after &#34;hello&#34;after =  $(with_spaces)therenullstring =space =  $(nullstring)  # Make a variable with a single space. all: 	echo  &#34; $(after)&#34;	echo start &#34; $(space)&#34;end</p><p>with_spaces=hello#with_spaces在&#34之后有许多空格；你好&#34；after=$（带_空格）therenullstring=space=$（nullstring）#用一个空格生成一个变量。全部：echo&#34$（之后）和#34；回声启动&#34$（空间）和#34；终止</p><p>     String Substitution is also a really common and useful way to modify variables. Also check out  Text Functions and  Filename Functions.</p><p>字符串替换也是修改变量的一种非常常见和有用的方法。还可以查看文本函数和文件名函数。</p><p>  You can override variables that come from the command line by using  override.Here we ran make with  make option_one=hi</p><p>可以通过使用override覆盖来自命令行的变量。这里我们运行了make with make option_one=hi</p><p> # Overrides command line arguments override option_one = did_override # Does not override command line argumentsoption_two = not_override all: 	echo  $(option_one)	echo  $(option_two)</p><p>#Overrides命令行参数override option_one=did#override#not override命令行参数option_two=not_override all:echo$（option_one）echo$（option_two）</p><p>  &#34;define&#34; is actually just a list of commands. It has nothing to do with being a function.Note here that it&#39;s a bit different than having a semi-colon between commands, because each is runin a separate shell, as expected.</p><p>&#34;定义&#34；实际上只是一个命令列表。它与函数无关。注意这里是&#39；这与在命令之间使用分号有点不同，因为正如预期的那样，每个命令都在单独的shell中运行。</p><p> one =  export blah= &#34;I was set!&#34;; echo $$blah define two export blah=setecho $$blah endef # One and two are different. all: 	@echo  &#34;This prints &#39;I was set&#39;&#34;	@ $(one)	@echo  &#34;This does not print &#39;I was set&#39; because each command runs in a separate shell&#34;	@ $(two)</p><p>一个=出口废话=&#34；我被安排好了&#34;; echo$$blah define two export blah=setecho$$blah endef#一和二是不同的。全部：@echo&#34；这张照片&#39；我被设定为&#39&#34;@echo&#34；这不打印&#39；我被设定为&#39；因为每个命令都在一个单独的shell中运行#34；@$（两个）</p><p>           nullstring =foo =  $(nullstring)  # end of line; there is a space here all: ifeq ( $( strip  $(foo)),)	echo  &#34;foo is empty after being stripped&#34; endif ifeq ( $(nullstring),)	echo  &#34;nullstring doesn&#39;t even have spaces&#34; endif</p><p>nullstring=foo=$（nullstring）#行尾；这里有一个空间：ifeq（$（strip$（foo）），）echo&#34；脱光衣服后，foo是空的&#34；endif ifeq（$（空字符串），）echo&#34；空字符串不&#39；甚至没有空间&#34；恩迪夫</p><p>  ifdef does not expand variable references; it just sees if something is defined at all</p><p>ifdef不展开变量引用；它只是看看是否有什么定义</p><p> bar =foo =  $(bar) all: ifdef foo	echo  &#34;foo is defined&#34; endif ifdef bar	echo  &#34;but bar is not&#34; endif</p><p>bar=foo=$（bar）all:ifdef foo echo&#34；foo的定义是&#34；endif ifdef bar echo&#34；但酒吧不是&#34；恩迪夫</p><p>  This example shows you how to test make flags with  findstring and  MAKEFLAGS. Run this example with  make -i to see it print out the echo statement.</p><p>此示例演示如何使用findstring和MAKEFLAGS测试make标志。用make-i运行这个例子，看它打印出echo语句。</p><p> bar =foo =  $(bar) all: # Search for the &#34;-i&#34; flag. MAKEFLAGS is just a list of single characters, one per flag. So look for &#34;i&#34; in this case. ifneq (, $( findstring i,  $(MAKEFLAGS)))	echo  &#34;i was passed to MAKEFLAGS&#34; endif</p><p>bar=foo=$（bar）all:#搜索&#34-我&#34；旗帜MAKEFLAGS只是单个字符的列表，每个标记一个字符。因此，寻找&#34；我&#34；在这种情况下。ifneq（，$（findstring i，$（MAKEFLAGS）））echo和#34；我被传给MAKEFLAGS&#34；恩迪夫</p><p>   Functions are mainly just for text processing. Call functions with  $(fn, arguments) or  ${fn, arguments}. You can make your own using the  call builtin function. Make has a decent amount of  builtin functions.</p><p>函数主要用于文本处理。使用$（fn，参数）或${fn，参数}调用函数。您可以使用call builtin功能自行创建。Make有相当多的内置功能。</p><p>   comma := ,empty:=space :=  $(empty)  $(empty)foo := a b cbar :=  $( subst  $(space), $(comma), $(foo)) all: 	@echo  $(bar)</p><p>逗号：=，空：=空格：=$（空）$（空）foo:=abcbar:=$（subst$（空格），$（逗号），$（foo））全部：@echo$（条）</p><p> Do NOT include spaces in the arguments after the first. That will be seen as part of the string.</p><p>在第一个参数之后的参数中不要包含空格。这将被视为字符串的一部分。</p><p> comma := ,empty:=space :=  $(empty)  $(empty)foo := a b cbar :=  $( subst  $(space),  $(comma) ,  $(foo)) all: 	 # Output is &#34;, a , b , c&#34;. Notice the spaces introduced	@echo  $(bar)</p><p>逗号：=，空：=空格：=$（空）$（空）foo:=abcbar:=$（subst$（空格），$（逗号），$（foo））全部：#输出为&#34；，a，b，c&#34；。注意@echo$（条形）中引入的空格</p><p>   &#34;Finds whitespace-separated words in text that match pattern and replaces them with replacement. Here pattern may contain a ‘%’ which acts as a wildcard, matching any number of any characters within a word. If replacement also contains a ‘%’, the ‘%’ is replaced by the text that matched the ‘%’ in pattern. Only the first ‘%’ in the pattern and replacement is treated this way; any subsequent ‘%’ is unchanged.&#34; ( GNU docs)</p><p>&#34;在匹配模式的文本中查找空格分隔的单词，并将其替换为替换。在这里，模式可能包含一个“%”作为通配符，匹配一个单词中任意数量的字符。如果替换还包含“%”，则“%”将被模式中与“%”匹配的文本替换。只有模式和替换中的第一个“%”被这样处理；任何后续“%”都将保持不变&#34; （GNU文档）</p><p>  There&#39;s another shorthand that that replaces only suffixes:  $(text:suffix=replacement). No  % wildcard is used here.</p><p>那里&#39；这是另一个只替换后缀的缩写：$（text:suffix=replacement）。此处未使用%通配符。</p><p> Note: don&#39;t add extra spaces for this shorthand. It will be seen as a search or replacement term.</p><p>注：唐和#39；不要为这个速记增加额外的空格。它将被视为搜索或替换术语。</p><p> foo := a.o b.o l.a c.oone :=  $( patsubst %.o,%.c, $(foo)) # This is a shorthand for the abovetwo := $(foo:%.o=%.c) # This is the suffix-only shorthand, and is also equivalent to the above.three := $(foo:.o=.c) all:	echo  $(one)	echo  $(two)	echo  $(three)</p><p>foo:=a.o b.o l.a c.oone:=$（patsubst%.o，%.c，$（foo））#这是上述两种语言的简写形式：=$（foo:%.o=%.c）#这是唯一的后缀简写形式，也相当于上述两种语言。三：=$（foo:.o=.c）全部：echo$（一）echo$（二）echo$（三）</p><p>  The foreach function looks like this:  $(foreach var,list,text). It converts one list of words (separated by spaces) to another.  var is set to each word in list, and  text is expanded for each word. This appends an exclamation after each word:</p><p>foreach函数如下所示：$（foreach变量、列表、文本）。它将一个单词列表（用空格分隔）转换为另一个。var被设置为列表中的每个单词，文本被展开为每个单词。这会在每个单词后附加一个感叹号：</p><p> foo := who are you # For each &#34;word&#34; in foo, output that same word with an exclamation afterbar :=  $( foreach wrd, $(foo), $(wrd)!) all:	 # Output is &#34;who! are! you!&#34;	@echo  $(bar)</p><p>foo:=你是谁#每个#34；单词&#34；在foo中，在后面加一个感叹号：=$（foreach wrd，$（foo），$（wrd）！）全部：#输出为&#34；谁是你&#34;@echo$（巴）</p><p>  if checks if the first argument is nonempty. If so runs the second argument, otherwise runs the third.</p><p>if检查第一个参数是否为非空。如果是，则运行第二个参数，否则运行第三个参数。</p><p>   Make supports creating basic functions. You &#34;define&#34; the function just by creating a variable, but use the parameters  $(0),  $(1), etc. You then call the function with the special  call function. The syntax is  $(call variable,param,param).  $(0) is the variable, while  $(1),  $(2), etc. are the params.</p><p>Make支持创建基本函数。你&#34；定义&#34；该函数只需创建一个变量，但使用参数$（0），$（1）等。然后使用特殊调用函数调用该函数。语法是$（call variable，param，param）$（0）是变量，而$（1），$（2）等是参数。</p><p> sweet_new_fn = Variable Name: $(0) First: $(1) Second: $(2) Empty Variable: $(3) all:	 # Outputs &#34;Variable Name: sweet_new_fn First: go Second: tigers Empty Variable:&#34;	@echo  $( call sweet_new_fn, go, tigers)</p><p>sweet_new_fn=变量名：$（0）第一个：$（1）第二个：$（2）空变量：$（3）所有：#输出和#34；变量名：sweet_new_fn First:go Second:tigers空变量：&#34；@echo$（呼叫sweet_new_fn，加油，老虎队）</p><p>      The include directive tells make to read one or more other makefiles. It&#39;s a line in the makefile makefile that looks like this:</p><p>include指令告诉make读取一个或多个其他makefile。它&#39；makefile makefile中的一行如下所示：</p><p>  This is particularly useful when you use compiler flags like  -M that create Makefiles based on the source. For example, if some c files includes a header, that header will be added to a Makefile that&#39;s written by gcc. I talk about this more in the  Makefile Cookbook</p><p>当使用编译器标志（如-M）基于源代码创建makefile时，这一点尤其有用。例如，如果一些c文件包含一个头文件，该头文件将被添加到一个生成文件中，该文件为&#39；这是gcc写的。我在Makefile烹饪书中详细讨论了这一点</p><p>  Use vpath to specify where some set of prerequisites exist. The format is  vpath &lt;pattern&gt; &lt;directories, space/colon separated&gt;  &lt;pattern&gt; can have a  %, which matches any zero or more characters. You can also do this globallyish with the variable VPATH</p><p>使用vpath指定某些先决条件集存在的位置。格式为vpath&lt；模式&gt&书信电报；目录，空格/冒号分隔&gt&书信电报；模式&gt；可以有一个%匹配任何零个或多个字符。您还可以使用变量VPATH全局执行此操作</p><p> vpath %.h ../headers ../other-directory some_binary: ../headers blah.h	touch some_binary ../headers:	mkdir ../headers blah.h:	touch ../headers/blah.h clean:	rm -rf ../headers	rm -f some_binary</p><p>vpath%。h/标题/其他目录一些二进制文件：/标题之类的。触摸一些二进制文件/标题：mkdir/标题之类的。h:触摸/标题/诸如此类。h清洁：rm-rf/头文件rm-f一些二进制文件</p><p>  The backslash (&#34;\&#34;) character gives us the ability to use multiple lines when the commands are too long</p><p>反斜杠（&#34；\&#34；）字符使我们能够在命令过长时使用多行</p><p> some_file: 	echo This line is too long, so \		it is broken up into multiple lines</p><p>some_file:echo这行太长，所以被分成多行</p><p>  Adding  .PHONY to a target will prevent make from confusing the phony target with a file name. In this example, if the file  clean is c</p><p>添加。假冒目标将防止make将假冒目标与文件名混淆。在本例中，如果文件clean是c</p><p>......</p><p>......</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/例子/">#例子</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/makefiles/">#makefiles</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/文件/">#文件</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>