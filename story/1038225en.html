<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>这些现代编程语言会让您受苦 These Modern Programming Languages Will Make You Suffer</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">These Modern Programming Languages Will Make You Suffer<br/>这些现代编程语言会让您受苦 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-07 22:45:53</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/f2aaabad359a81a3e66259f9afcbf7df.jpeg"><img src="http://img2.diglog.com/img/2020/12/f2aaabad359a81a3e66259f9afcbf7df.jpeg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>What are the pros and cons of a particular programming language? Is X a good language for my task? Googling for “best programming language” will give you a standard list of “Python, Java, JavaScript, C#, C++, PHP” with a vague list of pros and cons. Seeing such articles makes me cringe in pain, their authors must have been outright lazy, inexperienced, while lacking any imagination. Let’s dive deep and find out what really sucks, and what doesn’t.</p><p>特定编程语言的优缺点是什么？ X是我的任务很好的语言吗？搜寻“最佳编程语言”将为您提供“ Python，Java，JavaScript，C＃，C ++，PHP”的标准列表，以及优缺点的模糊列表。看到这样的文章会让我感到痛苦，他们的作者一定是完全懒惰，缺乏经验，同时又缺乏想象力。让我们深入研究一下，找出真正的缺点，而不是什么。</p><p>  In this articl  e, I’ll attempt to give an objective and hopefully unbiased overview of popular (and not so popular) modern programming languages, ranked from the worst to the best.</p><p>  在本文中，我将尝试对流行的（而不是那么流行的）现代编程语言给出客观而公正的概述，从最坏到最好的排名。</p><p> Bear in mind that there’s no one programming language perfectly suited to all possible use cases. Some languages are best suited for Frontend Development, others work best for Backend/API Development, others are great for System Programming.</p><p> 请记住，没有一种编程语言可以完美地适合所有可能的用例。一些语言最适合于前端开发，其他语言最适合于后端/ API开发，其他语言则非常适合系统编程。</p><p> I’m going to cover two of the most common language families in the world —  languages descended from C, and  languages descended from ML.</p><p> 我将介绍世界上两个最常见的语言家族-语言是C衍生的，而语言是ML衍生的。</p><p> Programming languages are just tools in a developer’s toolbox. And it is important to choose the right tool for the job. I really hope that this guide will help you in choosing the most suitable programming language for your task. Making the right choice might save you months (or even years) of development effort.</p><p> 编程语言只是开发人员工具箱中的工具。选择正确的工具来完成这项工作很重要。我真的希望本指南将帮助您选择最适合您任务的编程语言。做出正确的选择可以节省您数月（甚至数年）的开发工作。</p><p>  Most other similar articles base their comparisons on factors like   popularity and   earning potential. Popularity is rarely a good measure, especially in the world of software (although a big community &amp; ecosystem helps). Instead I’ll be taking into account the  strengths and weaknesses of a particular language.</p><p>  大多数其他类似的文章都根据受欢迎程度和潜在收入等因素进行比较。流行性很少是一个好的衡量标准，尤其是在软件领域（尽管大型社区和生态系统会有所帮助）。相反，我将考虑特定语言的优点和缺点。</p><p> I’ll be using a thumbs-up 👍 (i.e. +1 ), a thumbs-down 👎, or an ok 👌 (neither good nor bad) emojis to signify the score of a particular language characteristic.</p><p> 我将使用大拇指👍（即+1），大拇指朝下👎或OK👌（无论好坏）表情符号来表示特定语言特征的得分。 </p><p> Now, how will we measure? In other words, what really matters, other than language popularity?</p><p>现在，我们将如何衡量？换句话说，除了语言流行之外，真正重要的是什么？</p><p>    Many people swear by type systems. That’s why languages like TypeScript have picked up in popularity in recent years. I tend to agree, type systems eliminate a large number of errors in programs, and make refactoring easier. However, “having” a type system is only one part of the story.</p><p>    许多人按类型系统发誓。因此，近年来诸如TypeScript之类的语言开始流行。我倾向于同意，类型系统消除了程序中的大量错误，并使重构更加容易。但是，“拥有”类型系统只是故事的一部分。</p><p> If a language has a type system, then it is also very useful to have   type inference. The best type systems are able to infer most of the types, without annotating function signatures explicitly. Unfortunately, most of the programming languages only provide rudimentary type inference.</p><p> 如果语言具有类型系统，那么进行类型推断也非常有用。最好的类型系统能够推断大多数类型，而无需显式注释功能签名。不幸的是，大多数编程语言仅提供基本的类型推断。</p><p> It is also nice for a type system to support Algebraic Data Types (more on this later).</p><p> 对于类型系统来说，支持代数数据类型也很好（稍后会详细介绍）。</p><p> The most powerful type systems support Higher-Kinded Types, which are one level of abstraction above generics, and allow us to program at an even higher level of abstraction.</p><p> 最强大的类型系统支持高级类型，这是泛型之上的抽象级别，并允许我们以更高的抽象级别进行编程。</p><p> We also have to keep in mind that people tend to put too much importance on type systems. There are things that matter far more than static typing, and presence/lack of a type system shouldn’t be the only factor when choosing a language.</p><p> 我们还必须记住，人们往往对类型系统过于重视。有些事情远比静态类型重要，选择类型时，类型系统的存在与否并不是唯一的因素。</p><p>    We might have the perfect programming language, but what use is it if onboarding new developers might take months or even years (upfront investment)? On the other side of the spectrum, some programming paradigms take years to become good at.</p><p>    我们可能拥有完美的编程语言，但是如果新入职的开发人员可能要花费数月甚至数年（前期投资），它将有什么用？另一方面，某些编程范例需要花费数年才能变得精通。 </p><p> A good language should be approachable by beginners, and shouldn’t take years to master.</p><p>一门好的语言应该适合初学者，并且不需要花几年的时间就能掌握。</p><p>    I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</p><p>    我称之为我的十亿美元错误。它是1965年创建的空引用。当时，我正在设计第一个全面的类型系统，用于面向对象的语言中的引用。我的目标是确保对引用的所有使用都绝对安全，并由编译器自动执行检查。但是我忍不住要插入空引用的诱惑，仅仅是因为它很容易实现。这导致了无数错误，漏洞和系统崩溃，在最近四十年中可能造成十亿美元的痛苦和破坏。</p><p> Why are null references bad? Null references break type systems. When null is the default value, we can no longer rely on the compiler to check the validity of the code. Any nullable value is a bomb waiting to explode. What if we attempt to use the value that we didn’t think might be null, but it in fact is null? We get a runtime exception.</p><p> 为什么空引用不好？空引用中断类型系统。当null为默认值时，我们将不再依赖编译器来检查代码的有效性。任何可为空的值都是等待爆炸的炸弹。如果我们尝试使用我们不认为可能为空但实际上为空的值怎么办？我们得到一个运行时异常。</p><p>  We have to rely on   manual runtime checks to make sure that the value we’re dealing with isn’t null. Even in a statically-typed language, null references take away many benefits of a type system.</p><p>  我们必须依靠手动运行时检查来确保所处理的值不为null。即使使用静态类型的语言，空引用也剥夺了类型系统的许多好处。</p><p>  Such runtime checks (sometimes called null guards) in reality are workarounds around bad language design. They litter our code with boilerplate. And worst of all, there are no guarantees that we won’t forget to check for null.</p><p>  实际上，这种运行时检查（有时称为空防护）是针对不良语言设计的解决方法。他们用样板乱码。最糟糕的是，我们无法保证不会忘记检查null。</p><p> In a good language, the lack or presence of a value should be type-checked at compile-time.</p><p> 用一种好的语言，应该在编译时检查值的缺失或存在。</p><p>     Catching exceptions is a bad way to handle errors. Throwing exceptions is fine, but only in   exceptional circumstances, when the program has no way to recover, and has to crash. Just like nulls, exceptions break the type system.</p><p>     捕获异常是处理错误的一种坏方法。抛出异常是可以的，但仅在例外情况下，程序无法恢复并且必须崩溃。就像空值一样，异常会破坏类型系统。 </p><p> When exceptions are used as a primary way of error handling, it is impossible to know whether a function will return an expected value or blow up. Functions throwing exceptions are also impossible to compose.</p><p>当使用异常作为错误处理的主要方式时，就不可能知道函数是返回期望值还是崩溃。引发异常的函数也是不可能组成的。</p><p>  Obviously, it is not ok for an entire application to crash simply because we couldn’t fetch some data. Yet this is what really happens more often than we’d like to admit.</p><p>  显然，仅仅由于我们无法获取某些数据而导致整个应用程序崩溃是不可能的。但这确实比我们想要的更经常发生。</p><p> One option is to manually check for raised exceptions, but this approach is fragile (we may forget to check for an exception), and adds a lot of noise:</p><p> 一种选择是手动检查引发的异常，但是这种方法很脆弱（我们可能会忘记检查异常），并且会增加很多噪音：</p><p>  Nowadays there are much better mechanisms of error handling, possible errors should be type-checked at compile-time. Languages that do not use exceptions by default will be ranked higher.</p><p>  如今，错误处理机制更加完善，可能的错误应在编译时进行类型检查。默认情况下不使用例外的语言将排名更高。</p><p>    We’ve reached the end of Moore’s law, the processors will not get any faster, period. We live in the era of multi-core CPUs, and literally, any modern application has to take advantage of multiple cores.</p><p>    我们已经到了摩尔定律的尽头，处理器将不会更快。我们生活在多核CPU时代，实际上，任何现代应用程序都必须利用多核。</p><p> Unfortunately, most of the programming languages in use today were designed in the era of single-core computing, and simply do not have the features to effectively run on multiple cores.</p><p> 不幸的是，当今使用的大多数编程语言都是在单核计算时代设计的，根本不具备可在多核上有效运行的功能。</p><p> Libraries that help with concurrency are an after-thought, they simply add band-aids to languages that weren’t initially designed for concurrency. This doesn’t really count as good developer experience. In a modern language, concurrency support has to be built-in (think Go/Erlang/Elixir).</p><p> 帮助并发的库是事后的想法，它们只是向最初不是为并发设计的语言添加了创可贴。这并不是真正的良好开发经验。在现代语言中，必须内置并发支持（请考虑使用Go / Erlang / Elixir）。 </p><p>    I think that large objected-oriented programs struggle with increasing complexity as you build this large object graph of mutable objects. You know, trying to understand and keep in your mind what will happen when you call a method and what will the side effects be.</p><p>我认为，当您构建可变对象的大对象图时，大型面向对象的程序会越来越复杂。您知道，尝试理解并牢记当您调用方法时会发生什么以及副作用是什么。</p><p> Programming with immutable values nowadays is becoming more and more popular. Even modern UI libraries like  React are intended to be used with immutable values. Languages with first-class support for immutable data values will be ranked higher. Simply because immutability eliminates a whole category of bugs from our code.</p><p> 如今，使用不变的值进行编程变得越来越流行。甚至像React这样的现代UI库也打算与不可变值一起使用。具有对不可变数据值的一流支持的语言将排名更高。仅仅因为不变性消除了我们代码中的一整类错误。</p><p> What is immutable state? Simply put, it is data that doesn’t change. Just like strings in most programming languages. For example, capitalizing a string will never change the original string — a new string will always be returned instead.</p><p> 什么是不可变状态？简而言之，它是不变的数据。就像大多数编程语言中的字符串一样。例如，大写字符串永远不会更改原始字符串-始终会返回一个新字符串。</p><p> Immutability takes this idea further, and makes sure that nothing is ever changed. A new array will always be returned instead of changing the original one. Updating user’s name? A new user object will be returned with its name updated, while leaving the original one intact.</p><p> 不变性进一步推动了这一想法，并确保一切都没有改变。总会返回一个新数组，而不是更改原始数组。更新用户名？将返回一个新的用户对象，并更新其名称，同时保留原始对象。</p><p> With immutable state, nothing is shared, therefore we no longer have to worry about the complexity of thread safety. Immutability makes our code easy to parallelize.</p><p> 处于不可变状态时，不会共享任何内容，因此我们不再需要担心线程安全性的复杂性。不变性使我们的代码易于并行化。</p><p> Functions that do not mutate(change) any state are called  pure, and are significantly easier to test, and to reason about. When working with pure functions, we never have to worry about anything outside of the function. Simply focus on just this one function that you’re working with, while forgetting about everything else. You can probably imagine how much easier development becomes (in comparison to OOP, where an entire graph of objects has to be kept in mind).</p><p> 不变异（改变）任何状态的函数称为纯函数，它们很容易测试和推理。使用纯函数时，我们不必担心函数之外的任何事情。只需专注于您正在使用的这一功能，而忽略其他所有功能。您可能可以想象，开发变得多么容易（与OOP相比，必须牢记整个对象图）。</p><p>    A language may not be very good, but it may have a large ecosystem which makes it appealing. Having access to good libraries may save one months (or even years) of development effort.</p><p>    语言可能不是很好，但是它可能具有庞大的生态系统，因此很有吸引力。访问优质的图书馆可以节省一个月（甚至几年）的开发工作。 </p><p>     How fast does the language   compile? How fast do the programs start? What is the runtime performance? All of these matter, and will be included in the ranking.</p><p>语言的编译速度如何？程序启动速度有多快？运行时性能如何？所有这些都很重要，并将列入排名。</p><p>    Although there are some exceptions, generally, newer languages will be better than older ones. Simply because newer languages learn from the mistakes of their predecessors.</p><p>    尽管有一些例外，但是一般而言，较新的语言会比较旧的语言更好。仅仅因为更新的语言可以从其前辈的错误中学习。</p><p>  Let’s begin our rating with the worst of the worst, probably one of the biggest mistakes of computer science, C++. Yes, C++ is not considered a shiny modern programming language. But it is still in wide use today and had to be included in the list.</p><p>  让我们从最坏的情况入手，这可能是计算机科学中最大的错误之一，C ++。是的，C ++不被认为是一种崭新的现代编程语言。但是今天它仍在广泛使用，必须将其包括在列表中。</p><p>     C++ is a horrible language… And limiting your project to C means that people don’t screw things up with any idiotic “object model” c&amp;@p.  — Linus Torvalds, the creator of Linux.</p><p>     C ++是一种可怕的语言…而且将您的项目限制为C意味着人们不会用任何愚蠢的“对象模型” c＆amp; @p弄乱事情。 — Linux的创建者Linus Torvalds。</p><p> C++ is bloated with features. It attempts to do everything, while not being good at any particular thing. C++ has  goto , pointers, references, OOP, operator overloading, and many other non-productive features.</p><p> C ++具有许多功能。它尝试做所有事情，同时又不擅长任何特定的事情。 C ++具有goto，指针，引用，OOP，运算符重载和许多其他非生产性功能。</p><p> Why is C++ so bad? In my opinion, the biggest reason is its age. C++ was designed long ago in 1979. At that time the designers lacked the experience, and had no idea what to focus on. The features added might have seemed like a good idea at that time. The language was very popular, which meant that many more features were added to support various use cases (creating an even bigger mess of features).</p><p> 为什么C ++如此糟糕？我认为，最大的原因是它的年龄。 C ++是在1979年设计的很早的时候。当时的设计师缺乏经验，也不知道该关注什么。当时添加的功能似乎是个好主意。该语言非常流行，这意味着添加了许多功能来支持各种用例（创建更大的功能混乱）。</p><p>  C++ is notorious for its slow compilation time. Significantly slower than Java, not as bad as Scala.</p><p>  C ++因其编译时间慢而臭名昭著。比Java慢得多，不如Scala差。 </p><p>      I had hoped that a garbage collector which could be optionally enabled would be part of C++0x, but there were enough technical problems…</p><p>我曾希望可以选择启用的垃圾收集器将成为C ++ 0x的一部分，但是存在足够的技术问题……</p><p> Garbage collection was never added into C++. Manual memory management is extremely error prone. The developers have to worry about manually releasing and allocating memory. I will never miss the days when I was using non-garbage-collected languages, the innumerous number of bugs that are nowadays easily prevented in garbage-collected languages.</p><p> 垃圾回收从未添加到C ++中。手动内存管理极易出错。开发人员必须担心手动释放和分配内存。我将永远不会错过使用非垃圾收集语言的日子，如今在垃圾收集语言中很容易避免许多错误。</p><p>  I invented the term Object-Oriented, and I can tell you I did not have C++ in mind.</p><p>  我发明了术语“面向对象”，我可以告诉你我没有C ++。</p><p> Having appeared in the late 60s, OOP was a cool new technology when the work on C++ has started. It’s very unfortunate that C++ made a few crucial mistakes in their implementation of OOP (unlike languages like Smalltalk), which has turned a really good idea into a nightmare.</p><p> OOP出现于60年代后期，是C ++工作开始时的一项很酷的新技术。不幸的是，C ++在实现OOP时犯了一些关键错误（与Smalltalk等语言不同），这使一个好主意变成了一场噩梦。</p><p> One good thing about C++, in comparison to Java is that OOP in C++ at least is optional.</p><p> 与Java相比，C ++的一件好事是C ++中的OOP至少是可选的。</p><p>   C++ is a complicated low-level language with no automated memory management. Due to its feature bloat, beginners have to spend a lot of time learning the language.</p><p>   C ++是一种复杂的低级语言，没有自动内存管理。由于其功能膨胀，初学者不得不花很多时间学习该语言。</p><p>  C++ was designed in the era of single-core computing, and has only rudimentary concurrency mechanisms that were added in the past decade.</p><p>  C ++是在单核计算时代设计的，仅在过去十年中添加了基本的并发机制。 </p><p>           The best use of C++ is probably system programming. However, given much better and modern alternatives in existence (Rust and Go), C++ shouldn’t even be used for that. I don’t think that C++ has any pros at all, feel free to prove me wrong.</p><p>C ++的最佳用途可能是系统编程。但是，鉴于存在更好，更现代的替代方案（Rust and Go），C ++甚至不应该用于此。我认为C ++毫无优势，请随时证明我是错的。</p><p>  Having first appeared in 1995, Java is 16 years younger than C++. Java is a much simpler language, which likely has contributed to its popularity.</p><p>  自1995年首次出现以来，Java比C ++年龄小16岁。 Java是一种简单得多的语言，这可能有助于其流行。</p><p>    One of the biggest benefits that Java provides over C++ is garbage collection, which by itself eliminates a large category of bugs.</p><p>    Java提供的优于C ++的最大好处之一是垃圾收集，垃圾收集本身消除了许多错误。</p><p>  Java has been around for a long time, and it has a huge ecosystem for backend development, which significantly reduces development effort.</p><p>  Java已经存在了很长时间，并且它具有一个庞大的用于后端开发的生态系统，从而大大减少了开发工作。</p><p>  I will not go too deep into the drawbacks of OOP here, for a more detailed analysis you may read my other article  Object-Oriented Programming — The Trillion Dollar Disaster.</p><p>  在这里，我不会深入探讨OOP的弊端，有关更详细的分析，您可以阅读我的其他文章《面向对象编程—万亿美元灾难》。</p><p> Instead I’ll simply quote some of the most prominent people in computer science, to get their opinion on OOP:</p><p> 相反，我只是引用一些计算机科学领域最杰出的人，以得到他们对OOP的看法：</p><p> I’m sorry that I long ago coined the term “objects” for this topic because it gets many people to focus on the lesser idea. The big idea is messaging. - Alan Kay, the inventor of OOP</p><p> 很抱歉，我很久以前就为该主题创造了“对象”一词，因为它使许多人专注于较小的想法。大想法是消息传递。 -OOP的发明者艾伦·凯（Alan Kay） </p><p> Alan Kay is right, the mainstream OOP languages focus on the wrong thing — classes, and objects, while ignoring messaging. Thankfully, there are modern languages that got this idea right (Erlang/Elixir).</p><p>艾伦·凯（Alan Kay）是对的，主流的OOP语言专注于错误的事物（类和对象），而忽略了消息传递。值得庆幸的是，现代语言正确地实现了这个想法（Erlang / Elixir）。</p><p> With OOP-inflected programming languages, computer software becomes more verbose, less readable, less descriptive, and harder to modify and maintain.</p><p> 使用受OOP影响的编程语言，计算机软件变得更冗长，可读性更差，描述性更强，更难修改和维护。</p><p> Anyone who’s used an OOP language (like Java or C#), and then had experience working in a non-OOP language, can probably relate.</p><p> 使用过OOP语言（例如Java或C＃）并具有使用非OOP语言的经验的任何人都可以联系。</p><p>  Java, obviously, runs on top of Java Virtual Machine, which is notorious for its slow startup times. I’ve seen programs running on top of JVM take 30 seconds and longer to start up, which is unacceptable for modern cloud-native programs.</p><p>  显然，Java在Java虚拟机之上运行，而Java虚拟机的启动时间很慢。我已经看到，在JVM上运行的程序需要30秒甚至更长的时间才能启动，这对于现代的云原生程序来说是不可接受的。</p><p> The compilation speed is slow on bigger projects, significantly impacting developer productivity (although nowhere as bad as Scala).</p><p> 在较大的项目上，编译速度很慢，这极大地影响了开发人员的生产力（尽管没有Scala那样糟糕）。</p><p>   While Java is a rather simple language, its focus on Object-Oriented Programming makes becoming good really hard. One can easily write a simple program. However, knowing how to write reliable and maintainable Object-Oriented code may take well over a decade.</p><p>   尽管Java是一种相当简单的语言，但它对面向对象编程的关注使真正变得很难。可以轻松编写一个简单的程序。但是，知道如何编写可靠且可维护的面向对象代码可能要花十年的时间。</p><p>  Java was designed in the era of single-core computing, and like C++ has only rudimentary concurrency support.</p><p>  Java是在单核计算时代设计的，并且像C ++一样，仅具有基本的并发支持。 </p><p>          Java was a decent language when it has appeared. Its too bad that Java (unlike Scala) has always focused exclusively on OOP. The language is very verbose, and suffers a lot from boilerplate code.</p><p>Java出现时是一种不错的语言。太糟糕了，Java（与Scala不同）一直只专注于OOP。该语言非常冗长，并且受样板代码的影响很大。</p><p>  Fundamentally, there’s very little difference between C# and Java (since the early versions of C# were actually a Microsoft implementation of Java).</p><p>  从根本上讲，C＃和Java之间几乎没有什么区别（因为C＃的早期版本实际上是Java的Microsoft实现）。</p><p> C# shares most of its cons with Java. Having first appeared in 2000, C# is 5 years younger than Java, and has learned a few things from Java’s mistakes.</p><p> C＃与Java共享大多数缺点。 C＃于2000年首次出现，但比Java年龄小5岁，并且已经从Java的错误中学到了一些东西。</p><p>    C# syntax has always been a little ahead of Java. C# suffers less from boilerplate code than Java. Although being an OOP language, C# is more on the verbose side. It’s good to see C# syntax being improved with every release, with the addition of features like expression-bodied function members, pattern matching, tuples, and others.</p><p>    C＃语法一直领先于Java。 C＃比样板代码遭受的痛苦更少。尽管C＃是一种OOP语言，但它在冗长的方面更为重要。很高兴看到C＃语法在每个版本中都得到了改进，并增加了诸如表达式强健的函数成员，模式匹配，元组等功能。</p><p>  Just like Java, C# focuses mostly on OOP. Once again, I’m not going to spend too much time here trying to convince you of the drawbacks of OOP, I’ll simply quote a few more prominent people in computer science.</p><p>  就像Java一样，C＃主要关注OOP。再一次，我不会在这里花太多时间试图说服OOP的缺点，我只想引用一些计算机科学领域的杰出人物。</p><p> I think the lack of reusability comes in object-oriented languages, not in functional languages. Because the problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.</p><p> 我认为缺乏可重用性的是面向对象的语言，而不是功能语言。因为面向对象语言的问题在于它们拥有了它们所伴随的所有隐式环境。您想要香蕉，但是得到的是一只大猩猩，拿着香蕉和整个丛林。</p><p> I have to agree with Joe Armstrong, reusing object-oriented code is very difficult, in comparison with functional (or even imperative) code.</p><p> 我必须同意Joe Armstrong的观点，与功能（甚至命令性）代码相比，重用面向对象的代码非常困难。 </p><p> Object oriented programs are offered as alternatives to correct ones…  — Edsger W. Dijkstra, pioneer of computer science</p><p>提供面向对象的程序作为正确程序的替代方案……—计算机科学先驱Edsger W. Dijkstra</p><p> Having worked with both OOP and non-OOP languages throughout my career, I have to agree that OOP code is much harder to get right, in comparison to non-OOP code.</p><p> 在我整个职业生涯中都使用过OOP和非OOP语言之后，我不得不同意与非OOP代码相比，OOP代码更难正确。</p><p>  C# claims to be a multi-paradigm language. In particular, C# claims to support functional programming. I must disagree, having support for first-class functions is simply not enough for a language to be called functional.</p><p>  C＃声称是一种多范式语言。特别是，C＃声称支持功能编程。我必须不同意，仅仅支持一流的功能还不足以使一种语言称为功能。</p><p> What functional features should a language have? At the very least, built-in support for immutable data structures, pattern matching, pipe operator for function composition, Algebraic Datatypes.</p><p> 语言应具有哪些功能？至少，对不可变数据结构，模式匹配，函数组合的管道运算符，代数数据类型的内置支持。</p><p>  C# was created in the era of single-core computing, and like Java has only rudimentary concurrency support.</p><p>  C＃是在单核计算时代创建的，就像Java一样，它仅具有基本的并发支持。</p><p>          I’ve spent a large chunk of my career working with C#, and was always mostly frustrated with the language. Just like with Java, I’d recommend looking for more modern alternatives. It is the same Java under the hood, with a little more modern syntax.</p><p>          我在C＃的职业生涯中花费了大量时间，并且总是对这种语言感到沮丧。与Java一样，我建议您寻找更现代的替代方案。它是相同的Java，但语法更现代。</p><p>  Having first appeared in 1991, Python is an old language. Along with JavaScript, Python is one of the most popular languages in the world.</p><p>  自1991年首次出现以来，Python是一门古老的语言。与JavaScript一起，Python是世界上最受欢迎的语言之一。 </p><p>    Python has a library almost for anything. Unlike JavaScript, Python can’t be used for Frontend Web Development, however Python easily makes up with a huge number of data science libraries.</p><p>Python几乎有任何库。与JavaScript不同，Python无法用于前端Web开发，但是Python可以轻松地构成大量的数据科学库。</p><p>  Python is a very simple language which can be picked up by beginners in a couple of weeks.</p><p>  Python是一种非常简单的语言，初学者可以在几周内掌握它们。</p><p>  Python is dynamically typed, there’s not much more to say about the type system.</p><p>  Python是动态类型的，关于类型系统没有太多要说的了。</p><p>  Python is an interpreted language and is notorious for being one of the slowest programming languages, in terms of runtime performance. Using Cython instead of plain Python may be a good solution where runtime performance is critical.</p><p>  Python是一种解释型语言，以运行时性能而言，它是最慢的编程语言之一而臭名昭著。在运行时性能至关重要的情况下，使用Cython代替普通的Python可能是一个很好的解决方案。</p><p>   Having used Python along with other modern languages, it’s hard not to be disappointed with Python’s dependency management. There’s pip, pipenv, virtualenv,  pip freeze and others. In comparison, NPM in JavaScript is the only tool you’ll ever need.</p><p>   在将Python和其他现代语言一起使用后，很难不对Python的依赖项管理感到失望。点子，pipenv，virtualenv，点子冻结等。相比之下，JavaScript中的NPM是您唯一需要的工具。</p><p>            It is really unfortunate that Python has no proper support for functional programming. Functional Programming is suited extremely well for problems that data science is trying to solve. Even for very pythonic tasks like web scraping, functional languages (like Elixir) are a much better fit.</p><p>            真的很不幸，Python没有对函数式编程的适当支持。函数式编程非常适合于数据科学试图解决的问题。即使对于诸如网络抓取之类的非常Python的任务，功能性语言（例如Elixir）也更合适。</p><p> I don’t recommend using Python for large projects, the language was not built with serious software engineering in mind.</p><p> 我不建议将Python用于大型项目，因为该语言在构建时并未考虑到严格的软件工程。 </p><p> Python shouldn’t be used for anything other than data science, when no other alternatives are available.  Julia seems to be a good modern alternative to Python in the field of data science, although its ecosystem is not nearly as mature as Python’s.</p><p>当没有其他替代方法可用时，Python不应用于数据科学以外的其他任何用途。在数据科学领域，Julia似乎是Python的一个很好的现代替代品，尽管它的生态系统还不如Python成熟。</p><p>  Rust was designed from the ground up to be fast. Compilation of Rust programs takes longer than compilation of Go programs. The runtime performance of Rust programs is a little faster than Go.</p><p>  Rust从一开始就被设计为快速。 Rust程序的编译比Go程序的编译花费更长的时间。 Rust程序的运行时性能比Go快一点。</p><p>  The first language on our list with a modern null alternative! Rust doesn’t have a null or nil value, and Rust developers use the Option Pattern instead.</p><p>  我们列表中的第一种语言，带有现代null替代选项！ Rust没有null或nil值，Rust开发人员改用Option Pattern。</p><p>   Rust takes a modern functional approach to error handling, and uses a dedicated  Result type to signify an operation that might fail. It is very similar to the  Option above, however the  None case now also has a value.</p><p>   Rust采用了​​一种现代的功能性方法来处理错误，并使用专用的Result类型来表示可能失败的操作。它与上面的选项非常相似，但是None情况现在也有一个值。</p><p>   Rust is the only modern language on our list with no garbage collection. This forces the developers to think about low-level memory management, and makes developer productivity suffer.</p><p>   Rust是我们列表中唯一没有垃圾回收的现代语言。这迫使开发人员考虑进行低级内存管理，并使开发人员的工作效率下降。</p><p>  Due to the lack of garbage collection, concurrency is rather hard in Rust. Developers have to worry about things like boxing and pinning, which typically are done automatically in a garbage-collected language.</p><p>  由于缺乏垃圾收集，因此在Rust中并发非常困难。开发人员必须担心诸如装箱和固定之类的事情，这些事情通常会以垃圾回收语言自动完成。</p><p>    Being a low-level language, developer productivity in Rust can’t be as high as in other higher-level languages. This also makes the learning effort significantly harder.</p><p>    作为一种低级语言，Rust中的开发人员生产力无法达到其他高级语言中的水平。这也使学习努力变得更加困难。 </p><p>    Rust is a good fit for system programming. Although more complex than Go, it provides a powerful type system. Rust provides a modern alternative to nulls, and a modern way for handling errors.</p><p>Rust非常适合系统编程。尽管它比Go更复杂，但它提供了强大的类型系统。 Rust为空值提供了一种现代的替代方法，并提供了一种处理错误的现代方法。</p><p> Why is Rust still ranked below TypeScript and JavaScript? It is a low-level language designed for system programming. Rust is not a very good fit for Backend/Web API development. It lacks garbage collection, and has no built-in support for immutability.</p><p> 为什么Rust仍然排名低于TypeScript和JavaScript？它是为系统编程设计的低级语言。 Rust并非非常适合后端/ Web API开发。它缺少垃圾收集，并且不内置对不变性的支持。</p><p>  TypeScript is a compile-to-js language. Its main goal is to make a “better JavaScript” by adding static typing to JavaScript. Just like JavaScript, TypeScript is being used for both frontend and backend development.</p><p>  TypeScript是一种js编译语言。它的主要目标是通过向JavaScript添加静态类型来制作“更好的JavaScript”。就像JavaScript一样，TypeScript被用于前端和后端开发。</p><p> TypeScript was designed by Anders Hejlsberg, the same person, who has designed C#. TypeScript code feels very C-sharpy, and fundamentally can be thought of as C# for the browser.</p><p> TypeScript是由设计C＃的同一人Anders Hejlsberg设计的。 TypeScript代码感觉非常C尖锐，从根本上讲，可以将其视为浏览器的C＃。</p><p>    Yes, being a superset of JavaScript has helped a lot with the adoption of TypeScript. After all, a lot of people already know JavaScript.</p><p>    是的，JavaScript的超集对TypeScript的采用起到了很大的帮助。毕竟，很多人已经知道JavaScript。</p><p> However, being a superset of JavaScript is more of a dr</p><p> 但是，成为JavaScript的超集更像是博士</p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://suzdalnitski.medium.com/modern-languages-suck-ad21cbc8a57c">https://suzdalnitski.medium.com/modern-languages-suck-ad21cbc8a57c</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/编程/">#编程</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编程语言/">#编程语言</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/语言/">#语言</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>