<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>实际的OSI模型 The Actual OSI Model</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">The Actual OSI Model<br/>实际的OSI模型 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-03-30 00:32:38</div><div class="page_narrow text-break page_content"><p>I have said before that I believe that teaching modern students the OSI modelas an approach to networking is a fundamental mistake that makes the conceptsless clear rather than more. The major reason for this is simple: the OSI modelwas prescriptive of a specific network stack designed alongside it, and thatnetwork stack is not the one we use today. In fact, the TCP/IP stack we usetoday was intentionally designed differently from the OSI model for practicalreasons.</p><p>在我之前已经说过，我相信教学现代学生OSI Modelas一种网络的方法是一个基本错误，使得概念明确而不是更多。这是一个重要的原因很简单：OSI ModelWas规定的特定网络堆栈与其一起设计，并且该网络堆栈不是我们今天使用的网络堆栈。事实上，我们使用的TCP / IP堆栈与OSI模型有意地设计，以便实际地设计。</p><p> Teaching students about TCP/IP using the OSI model is like teaching studentsabout small engine repair using a chart of the Wankel cycle. It&#39;s nonsensicalto the point of farce. The OSI model is not some &#34;ideal&#34; model of networking,it is not a &#34;gold standard&#34; or even a &#34;useful reference.&#34; It&#39;s the architectureof a specific network stack that failed to gain significant real-worldadoption.</p><p> 使用OSI模型教学学生关于TCP / IP的是使用Wankel周期的图表教授SeashingAbout小型发动机修复。它＆＃39;毫无疑问的闹剧点。 OSI模型不是一些＆＃34;理想＆＃34;网络模型，它不是A＆＃34;金标准＆＃34;甚至是A＆＃34;有用的参考。＆＃34;它＆＃39;＆＃39;它是一个故障的特定网络堆栈的架构，无法获得重要的真实世界adoption。</p><p> Well, &#34;failed to gain real-world adoption&#34; is one of my favorite things, sotoday we&#39;re going to talk about the OSI model and the OSI network stack.</p><p> 嗯，＆＃34;未能获得现实世界的采用＆＃34;是我最喜欢的东西之一，我们＆＃39;重新谈论OSI模型和OSI网络堆栈。</p><p> The story of the OSI model basically starts in the late &#39;70s with a projectbetween various standards committees (prominently ISO) to create a standardizednetwork stack which could be used to interconnect various systems. An OpenSystems Interconnection model, if you will.</p><p> OSI模型的故事基本上始于迟到的＆＃39; 70年代，其中一个标准委员会（突出的ISO），创建标准化的堆栈，可以用于互连各种系统。 OpenSystems互连模型，如果您愿意。</p><p> This time period was the infancy of computer networking, and most computernetworks operated on vendor-specific protocols that were basically overgrownversions of protocols designed to connect terminals to mainframes. The IBMSystems Network Architecture was perhaps the most prominent of these, butthere were more of them than you could easily list.</p><p> 此时间段是计算机网络的缺点，大多数计算机在特定于供应商的协议上运行，这些协议基本上超过了旨在将终端连接到大型机的协议。 IBMSystems网络架构可能是最突出的，但比您可以轻松列出的更多。</p><p> Standardized network protocols that could be implemented across differentcomputer architectures were relatively immature. X.25 was the most popular, andcontinues to be used as a teaching example today because it is simple and easyto understand. However, X.25 had significant limitations, and was married tothe telephone network in uncomfortable ways (both in that it relied on leasedlines and in that X.25 was in many ways designed as a direct analog to thetelephone network). X.25 was not good enough, and just as soon as it gainedmarket share people realized they needed something that was more powerful, butalso not tied to a vendor.</p><p> 可以在不同计算机体系结构上实现的标准化网络协议相对不成熟。 X.25是最受欢迎的，并且被用作今天的教学例子，因为它很简单而容易理解。然而，X.25具有显着的限制，并以不舒服的方式结婚，以不舒服的方式（其两者都依赖于Laketlines，并且在X.25中，X.25是以直接模拟的方式设计为直接模数网络）。 X.25不够好，就在上帝市场上的分享人们意识到他们需要更强大的东西，而不是与供应商联系在一起。</p><p> The OSI network stack was designed in a very theory-first way. That is, the OSIconceptual model of seven layers was mostly designed before the actualprotocols that implemented those layers. This puts the OSI model in an unusualposition of having always, from the very start, been divorced from actualworking computer networks. And while this is a matter of opinion, I believe theOSI model to have been severely over-engineered from that beginning.</p><p> OSI网络堆栈以非常理论的方式设计。也就是说，七层的OSICOnceptual模型主要设计在实现这些层的实际权力之前。这将OSI模型始终始终从一开始就脱离了实际的计算机网络。虽然这是一个意见问题，但我相信Theosi模型从那开始被严重过度设计。 </p><p> Unlike most practical computer networks which aim to provide a simple channelwith few bells and whistles, the OSI model attempted to encode just about everyaspect of what we now consider the &#34;application&#34; into the actual protocols.This results in the OSI model&#39;s top four layers, which today are allessentially &#34;Application&#34; spelled in various strange ways. Through a criticaleye, this could be viewed as a somewhat severe example of design over function.History had, even by this time, shown that what was needed from computernetworks was usually ease of implementation and ease of use, not power.</p><p>与大多数实用的计算机网络不同，该网络旨在提供很短的钟声和吹口哨，OSI模型试图编码我们现在考虑＆＃34;应用程序＆＃34的每次审议。进入实际的协议。这结果是OSI模型和＃39;今天的前四层，今天是＆＃34;应用程序＆＃34;以各种奇怪的方式拼写。通过一个关键的，这可以被视为函数的设计中的一个严格的例子。甚至在这段时间内，Computernetworks所需要的是通常易于实现和易用的东西，而不是电力。</p><p>  From the modern perspective, this might not be entirely obvious, but onlybecause most CS students have been trained to simply ignore a large portion ofthe model. Remember, the OSI model is:</p><p>  从现代的角度来看，这可能并不完全明显，但只有大多数CS学生都接受了训练，只是忽略了大部分模型。请记住，OSI模型是：</p><p>  Before we get too much into the details of these layers, let&#39;s remember what alayer is. The fundamental concept that the OSI model is often used to introduceis the concept that I call network abstraction: each layer interacts only withthe layer below it, and by doing so provides a service to the layer above it.</p><p>  在我们过多进入这些层的细节之前，让＆＃39;请记住Alayer是什么。 OSI模型的基本概念通常用于介绍我呼叫网络抽象的概念：每层只与它下面的图层相互作用，并且通过这样做提供给它上方的层的服务。</p><p> Each layer has a constrained area of concern, and the protocol definitionscreate a contract which defines the behavior of each layer. Through thissort of rigid, enforced abstraction, we gain flexibility: the layers become&#34;mix and match.&#34; As long as layers implement the correct interface for aboveand expect the correct interface from below, we can use any implementation of agiven layer that we want.</p><p> 每个层都有一个受约束的关注区域，协议定义了一个限定每层行为的合同。通过TheSssors的刚性，强制抽象，我们获得灵活性：层变成＆＃34;混合和匹配。＆＃34;只要图层为ABOVEAND实现了正确的接口，我们可以使用下面的正确接口，我们可以使用我们想要的任何agiven层的实现。</p><p> This matters in practice. Consider the situation of TCP and UDP: TCP and UDPcan both be dropped on top of IP because they both expect the same capabilitiesfrom the layer under them. Moreover, to a surprising extent TCP and UDP areinterchangeable. While they provide different guarantees, the interface for thetwo is largely the same, and so switching which of the two software uses istrivial (in the simple case where we do not require the guarantees which TCPprovides) [1].</p><p> 这一事项在实践中。考虑TCP和UDP的情况：TCP和UDPCAN都会在IP之上丢弃，因为它们都期望在它们下面的图层下方的功能。此外，在令人惊讶的程度上，TCP和UDP缺乏倾听。虽然它们提供不同的保证，但Thetwo的接口很大程度上是相同的，因此切换两个软件中的哪一个使用等值（在我们不需要保证TCPProvides）[1]的简单情况下使用。</p><p> So, having hopefully grasped this central concept of networking, let&#39;s apply itto the OSI model, with which it was likely originally taught to us. Thepresentation layer depends on the session layer, and provides services to theapplication layer. That&#39;s, uhh, cool. Wikipedia suggests that serializing datastructures is an example of something which might occur at this layer. But thissort of presupposes that the session layer does not require any high-level datastructures, since it functions without the use of the presentation layer. Italso seems to suggest that presentation is somehow dependent on session, whichmakes little sense in the context of serialization.</p><p> 所以，希望掌握这种网络的中央概念，让＆＃39; s应用于OSI模型，它可能最初教授给我们。 PruseEntation层取决于会话层，并为TheApplication层提供服务。那个＆＃39; s，uhh，很酷。维基百科表明，序列化数据结构是该层可能发生的东西的示例。但是，Session层不需要任何高级数据结构，因为它在不使用呈现层的情况下函数，所以TheSsorps。 Italso似乎表明，在序列化的背景下，呈现出会话，在序列化的背景下，在序列化的情况下略微意义。</p><p> In fact, it&#39;s hard to see how this &#34;fundamental concept&#34; of the presentationlayer applies to computing systems because it does not. Session andpresentation are both &#34;vestigial layers&#34; which were not implemented in the IPstack, and so they have no real modern equivalent. Most teaching of the sessionand presentation layers consists of instructors grasping for examples---I haveheard of things like CHAP as the session layer---which undermine the point theyare making by violating the actual fundamental concept of layered networking.</p><p> 事实上，它很难看出这个问题和＃34;基本概念＆＃34; PresentationLayer适用于计算系统，因为它没有。会话和图片都是＆＃34; vestigal层和＃34;哪个没有在ipstack中实施，因此它们没有真正的现代等效物。大多数会议教学的演示层包括掌握示例的教师---我哈哈德作为会话层的东西，因为它通过违反分层网络的实际基本概念而破坏了这一点。 </p><p> Now that we all agree that the OSI model is garbage which does not representthe real world, let&#39;s look at the world it does represent: the OSI protocols,which were in fact designed explicitly as an implementation of the OSI model.</p><p>现在我们都同意OSI模型是垃圾，它没有代表现实世界，让＆＃39;看看世界所代表的世界：OSI协议，实际上是明确设计为OSI模型的实现。</p><p>  No one really defines layer 1, the physical layer, because it is generally aconstraint on the design of the protocols rather than something that anyonegets to design intentionally. The physical layer, in the context of the OSIstack, could generally be assumed to be a simple serial channel like a leasedtelephone line, using some type of line coding and other details which are notreally of interest to the network programmer.</p><p>  没有人真正定义第1层，物理层，因为它通常是关于协议的设计而不是任何故意设计的东西的ACONSTRAIN。在OSISTack的上下文中，物理层通常可以假设是一种简单的串行通道，如leasttelephone线，使用某种类型的线路编码和其他细节，这些细节是对网络程序员感兴趣的。</p><p>  Layer 2, the data link layer, provides the most fundamental networkingfeatures. Today we often talk of layer 2 as being further subdivided into theMAC (media access control) and LLC (logical link control) sublayers, but to alarge extent this is simply a result of trying to retcon the OSI model ontomodern network stacks, and the differentiation between MAC and LLC is notsomething which was contemplated by the actual designers of the OSI model.</p><p>  第2层，数据链路层提供最基本的网络化特征。今天，我们经常将第2层讨论为进一步细分为主题（媒体访问控制）和LLC（逻辑链路控制）子层，但是以外的范围这只是尝试retcon retcon oSi模型的结果，以及差异化在Mac和LLC之间是由OSI模型的实际设计者所考虑的。</p><p> The data link layer is implemented primarily in the form of X.212. In a majorchange from what you might expect if you were taught the IP stack via the OSImodel, the OSI data link link layer and thus X.212 provides reliability featuresincluding checksumming and resending. Optionally, it provides guaranteed orderof delivery. X.212 further provides a quality of service capability.</p><p> 数据链路层主要以x.212的形式实现。在从您可能期望的大气中通过OSIMODEL教授IP堆栈，OSI数据链路链路层以及X.212提供了可靠性，其中包括Checksumming和重新发送的可靠性。可选地，它提供有保证的订单。 X.212进一步提供了服务质量。</p><p> Specifically related to order of delivery, X.212 provides a connection-orientedmode and a connectionless mode. This is very similar (but not quite the same)to the difference between TCP and UDP, but we are still only talking aboutlayer 2! Keep in mind here that layer 2 is essentially defined within thecontext of a specific network link, and so these features are in place tocontent with unreliable links or links that are themselves implemented onother high-level protocols (e.g. tunnels), and not to handle routed networks.</p><p> 与递送顺序特异性相关，X.212提供连接 -  RosentedMode和无连接模式。 TCP和UDP之间的区别非常相似（但不是完全相同），但我们仍然只是谈论默特拉德2！请记住，第2层基本上定义在特定网络链路的TheContext中，因此这些功能始于与其他高级协议（例如隧道）实现的不可靠的链路或链接，而不是处理路由网络。</p><p> X.212 addressing is basically unspecified, because the expectation is thataddresses used at layer 2 will be ephemeral and specific to the media in use.Because layer 2 traffic cannot directly span network segments, there is no needfor any sort of standardized addressing.</p><p> X.212寻址基本上是未指定的，因为期望在第2层中使用的那个程序将是短暂的，并且特定于使用中的媒体。第2层流量不能直接跨越网段，没有必要任何类型的标准化寻址。</p><p> As with most layers, there are alternative implementations available for thedata link layer, including implementations that transport it over otherprotocols.</p><p> 与大多数层一样，有用于Thedata链路层的替代实现，包括将其传输到其他问题的实现。 </p><p>  OSI layer 3, the network layer, provides a more sophisticated service which iscapable of moving bytes between hosts with basically the same semantics weexpect in the IP world. Layer 3 is available in connection oriented andconnectionless modes, much like layer 2, but now provides these services acrossa routed network.</p><p>OSI第3层，网络层提供了更复杂的服务，可在IP世界中基本相同的语义WEExpect之间存在于主机之间的移动字节。第3层可以面向导向的和连接模式，很像层2，但现在在跨路由网络提供这些服务。</p><p> The two typical layer 3 protocols are Connectionless Network Protocol andConnection Oriented Network Protocol, which are basically exactly what theysound like.</p><p> 两个典型的第3层协议是无连接网络协议和连接面向网络协议，基本上基本上完全是什么样的。</p><p> OSI addressing at these layers is based on Network Service Point Addresses orNSAPs. Or, well, it&#39;s better to say that NSAPs are the current standard foraddressing. In fact, the protocols are somewhat flexible and historically otherschemes were used but have been largely replaced by NSAP. NSAP addresses are 20bytes in length and have no particular structure, although there are variousnorms for allocation of NSAPs that include embedding of IP addresses. NSAPs donot include routing information as is the case with IP addresses, and so theprocess of routing traffic to a given NSAP includes the &#34;translation&#34; of NSAPsinto more detailed addressing types which may be dependent on the layer 2 inuse. All in all, OSI addressing is confusing and in modern use depends verymuch on the details of the specific application.</p><p> 这些图层的OSI寻址基于网络服务点地址ORNSAPS。或者，嗯，它更好地说，NSAP是当前的标准弃权。事实上，协议有些灵活性，历史上方被使用，但已经大大替换为NSAP。 NSAP地址的长度为20bytes，并且没有特定的结构，尽管存在包括嵌入IP地址的NSAP分配的各种型。 NSAPS Donot包括具有IP地址的情况的路由信息​​，因此对给定NSAP的路由流量的处理包括＆＃34;翻译＆＃34; nsapsinto更详细的寻址类型，其可以依赖于第2层注入。总而言之，OSI寻址令人困惑，在现代使用中取决于特定应用程序的细节。</p><p>  Layer 4, the transport layer, adds additional features over layer 3 includingmultiplexing of multiple streams, error recovery, flow control, and connectionmanagement (e.g. retries and reconnects). There are a variety of defined layer4 protocol classes called TP0 thru TP4, which vary in the features that theyoffer in ways that do not entirely make sense from the modern perspective.</p><p>  第4层，传输层在第3层增加附加特征，包括多个流，错误恢复，流量控制和连接管理员（例如重试和重新连接）。有各种称为TP0 TP4的定义的Layer4协议类，其特征在于以不完全从现代角度完全理解的方式变化。</p><p> Because layer 4 offers general messaging features, it is perhaps the closestequivalent to the TCP and UDP protocols in the IP stack, but of course this isa confusing claim since there are many elements of UDP and TCP found at lowerlevels as well.</p><p> 因为第4层提供常规消息传递功能，所以它可能是IP堆栈中的TCP和UDP协议的最偏执，但当然这是令人困惑的索赔，因为在LowerLevels中发现了许多UDP和TCP的元素。</p><p> The selection of one of the five transport layer &#34;levels&#34; depends basically onapplication requirements and can range from very high reliability (TP4) to lowlatency given unreliable network conditions, with relaxed guarantees (TP0 orTP1).</p><p> 选择五个传输层之一＆＃34;水平＆＃34;依赖于基本上是卓越的要求，并且可以从非常高的可靠性（TP4）到低矮的网络条件，带有轻松的保证（TP0 ORTP1）。</p><p>  The session layer adds management of associations between two hosts and thestatus of the connection between them. This is a bit confusing because the IPmodel does not have an equivalent, but it might help to know that, in the OSImodel, connections are &#34;closed&#34; at the session layer (which causes actionswhich cascade down to the lower layers). The OSI session layer, defined byX.215, this serves some of the roles we associate with link setup.</p><p>  会话图层添加了两个主机之间的关联管理和它们之间的连接之间的attatus。这有点令人困惑，因为IPModel没有等效，但它可能有助于知道，在Osimodel中，连接是＆＃34;关闭＆＃34;在会话层（导致级联到下层的动作）。 OSI会话层定义为Byx.215，这为我们与链路设置相关联的一些角色服务。 </p><p> More interestingly, though, the session layer is responsible for veryhigh-level handling of significant network errors by gracefully restarting anetwork dialog. This is not a capability that the IP stack offers unless it isexplicitly included in an application.</p><p>但是，更有趣的是，会话层是负责通过优雅地重新启动Anetwork对话框来处理重大网络错误的高级处理。这不是IP堆栈所提供的能力，除非它是未被应用程序中的应用程序。</p><p> The session layer manages conversations through a token mechanism, which issomewhat similar to that of token-ring networking or the general &#34;talkingstick&#34; concept. Multiple tokens may be in use, allowing for half-duplex orduplex interactions between hosts.</p><p> 会话层通过令牌机制管理对话，该机制是类似于令牌环网络或常规＆＃34的与之相同的方式;谈话＆＃34;概念。可以使用多个令牌，允许主机之间的半双工正常交互。</p><p> Like basically every layer below it, Layer 5 comes in connection-oriented andconnectionless flavors. The connectionless flavor is particularly importantsince it provides powerful features for session management without therequirement for an underlying prepared circuit---something which is likewiseoften implemented at the application layer over UDP.</p><p> 类似于它下面的每个层，第5层面向连接的和连接的口味。无连接的味道尤其是Emportants，它为会话管理提供了强大的功能，而不需要符合底层准备的电路---在UDP上应用层在应用层中实现的东西。</p><p>  Layer 6, the presentation layer, is another which does not exist in the IPstack. The session layer is a bit hard to understand from the view of the IPstack, but the presentation layer is even stranger.</p><p>  第6层，呈现层是IPstack中不存在的另一个。从IPStack的视图中，会话层有点难以理解，但演示层甚至是陌生人。</p><p> The basic concept is this: applications should interact using abstractrepresentations rather than actual wire-encoded values. These abstract valuescan then be translated to actual wire values based on the capabilities ofthe underlying network.</p><p> 基本概念是：应用程序应使用AbstractRepresentations而不是实际的线编码值进行交互。然后，这些抽象的valueScan基于底层网络的功能转换为实际的线值。</p><p> Why is this even something we want? Well, it&#39;s important to remember that thisnetwork stack was developed in a time period when text encoding was even morepoorly standardized than now, and when numeric representation was notespecially well standardized either (with various types of BCD in common use).</p><p> 为什么这甚至是我们想要的东西？嗯，它＆＃39是重要的要记住，这是在短时间内的时间段开发的，当文本编码甚至比现在都是标准化的时间段，而且数值表示不值得良好的标准化（具有各种类型的BCD）。</p><p> So, for two systems to be able to reliably communicate, they must establish anacceptable way to represent data values... and it is likely that a degree oftranslation will be required. The OSI presentation layer, defined by X.216,nominally adjusts for these issues by the use of an abstract representationtransformed to and from a network representation. There are actually a numberof modern technologies that are similar in concept, but they are seldom viewedas network layers [2].</p><p> 因此，对于两个系统能够可靠地进行通信，他们必须建立一个可接近的方式来表示数据值......很可能需要一定程度的特征。由x.216定义的OSI呈现层名义上通过使用向网络表示和从网络表示来使用抽象表示来标称调整这些问题。实际上有一个数字在概念中类似的现代技术，但它们很少查看网络图层[2]。 </p><p>  Finally, the application layer is actually where, you know, things are done.While the application layer is necessarily flexible and not strongly defined,the OSI stack nonetheless comes with a generous number of defined applicationlayer protocols. While it&#39;s not particularly interesting to dig into these all,it is useful to note a couple that remain important today.</p><p>最后，应用层实际上是在哪里，你知道的事情。当应用程序层必须灵活而不是强烈定义时，oSI堆栈仍然存在慷慨的定义应用程序协议。虽然它并不是特别有趣的挖掘，但要注意今天仍然很重要的夫妇是有用的。</p><p> X.500, the directory service application protocol, can be considered thegrandparent of LDAP. If you think, like all sane people, that LDAP isfrustratingly complicated, boy you will love X.500. It was basically toocomplex to live, but too important to die, and so it was pared down to the&#34;lightweight&#34; LDAP.</p><p> X.500，目录服务应用程序协议，可以被视为LDAP的“戈兰锥体”。如果你认为，就像所有理智的人一样，那个LDAP是折磨的，男孩你会喜欢X.500。它基本上是对食用的，但对死亡来说太重要了，所以它被削减到＆＃34;轻量级＆＃34; LDAP。</p><p> Although X.500 failed to gain widespread adoption, one component of X.500 liveson today, nearly intact: X.509, which describes the cryptographic certificatefeature of the X.500 ecosystem. The X.509 certificate format and concepts aredirectly used today by TLS and other cryptographic implementations, includingits string representations (length-prefixed) which were a decent choice at thetime but now quite strange considering the complete victory of null-terminatedrepresentations.</p><p> 虽然X.500未能获得广泛的采用，但今天X.500 Liveson的一个组成部分，几乎完好无损：X.509，描述了X.500生态系统的加密证书。今天由TLS和其他加密实现时使用的X.509证书格式和概念，包括字符串表示（长度为前缀），这是Thetime的体面选择，但现在考虑到零任务的完全胜利，这很奇怪。</p><p> X.400, the messaging service protocol, is basically the OSI version of email.As you would expect, it is significantly more powerful and complicated thanemail as we know it today. For a long time, Microsoft Exchange was betterdescribed as an X.400 implementation than an email implementation, which ispart of why it is a frightening monstrosity. The other part is everythingabout modern email.</p><p> X.400，Messaging Service Protocol，基本上是OSI版本的电子邮件。您预期的是，我们今天知道它是明显更强大和复杂的复杂。很长一段时间，Microsoft Exchange被录制为X.400的实施，而不是电子邮件实施，这是为什么这是一个可怕的怪物。另一部分是现代电子邮件中的一切。</p><p> And that is a tour of the OSI network protocols. I could go into quite a bitmore depth, but I have both a limited budget to buy ISO standards and a limitedattention span to read the ones I could get copies of. If you are interested,though, the OSI stack protocols are all well defined by ITU standards availablein the US from ISO or from our Estonian friends for much cheaper. For a funacademic project, implement them: you will be perhaps the only human alive who truly understands the OSI model ramble your data communications professorindulged in.</p><p> 这是一场OSI网络协议的巡回赛。我可以进入相当的深度，但我有一个有限的预算来购买ISO标准和有利的跨度来阅读我可以获得的副本。但是，如果您有兴趣，OSI堆栈协议都是由ITU标准符合美国ISO或来自我们爱沙尼亚的朋友的良好定义，以便更便宜。对于磁性化项目，实施它们：你可能是真正了解OSI模型的唯一人类活力，漫步你的数据通信教授。</p><p> [1] Contrast SCTP, which provides an interface which is significantly differentfrom the UDP and TCP bytestream, due to features such as multiple streams. Notunrelatedly, SCTP has never been successful on the internet.</p><p> [1]对比度SCTP，其提供了一种接口，该接口由于多个流等特征而显着地与UDP和TCP ByteStream不同。 Notuneratedly，SCTP从未在互联网上取得成功。</p><p> [2] I think that this is actually a clue to the significant limitations of theOSI model for teaching. The OSI model tends to create a perception that thereis one &#34;fixed&#34; set of layers with specified functions, when in actual modernpractice it is very common to have multiple effective layers of what we wouldcall application protocols.</p><p> [2]我认为这实际上是一个关于Theosi教学模型的重要局限性的线索。 OSI模型倾向于在其中创建一个＆＃34;固定＆＃34;具有指定函数的一组图层，在实际的现代化服务中，它非常常见的是我们将拥有应用程序协议的多个有效层。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://computer.rip/2021-03-27-the-actual-osi-model.html">https://computer.rip/2021-03-27-the-actual-osi-model.html</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/osi/">#osi</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>