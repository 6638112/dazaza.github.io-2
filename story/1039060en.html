<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>夜锈病的单子和GAT Monads and GATs in Nightly Rust</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Monads and GATs in Nightly Rust<br/>夜锈病的单子和GAT </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-12-11 16:15:18</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/12/fa1c37c85d903a06c4e4bfd950f8a48c.jpg"><img src="http://img2.diglog.com/img/2020/12/fa1c37c85d903a06c4e4bfd950f8a48c.jpg" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>This blog post was entirely inspired by reading the  GATs on Nightly! Reddit post by /u/C5H5N5O. I just decided to take things a little bit too far, and thought a blog post on it would be fun. I want to be clear from the start: I&#39;m introducing some advanced concepts in this post that rely on unstable features in Rust. I&#39;m not advocating their usage  at all. I&#39;m just exploring what may and may not be possible with GATs.</p><p>这篇博客文章的灵感完全来自于每晚阅读GAT！ / d / C5H5N5O的Reddit帖子。我只是决定把事情做得有点过头，并认为关于它的博客文章会很有趣。我想从一开始就很清楚：我在这篇文章中介绍了一些高级概念，这些概念依赖于Rust中的不稳定功能。我根本不主张使用它们。我只是在探索GAT可能和不可能的事情。</p><p> Rust shares many similarities with Haskell at the type system level. Both have types, generic types, associated types, and traits/type classes (which are basically equivalent). However, Haskell has one important additional feature that is lacking in Rust: Higher Kinded Types (HKTs). This isn&#39;t an accidental limitation in Rust, or some gap that should be filled in. It&#39;s an intentional design decision, at least as far as I know. But as a result, some things until now can&#39;t really be implemented in Rust.</p><p> Rust在类型系统级别上与Haskell有许多相似之处。两者都具有类型，泛型类型，关联类型和特征/类型类（基本上是等效的）。但是，Haskell具有Rust中缺少的一项重要附加功能：高级类型（HKT）。这并不是Rust的偶然限制，也不是应该填补的空白。至少据我所知，这是一个故意的设计决定。但是结果是，到目前为止，Rust仍无法真正实现某些功能。</p><p> Take, for instance, a  Functor in Haskell. For all of its scary sounding name, almost all developers today are familiar with the concept of a  Functor. A  Functor provides a general purpose interface for &#34;map a function over this structure.&#34; Many different structures in Rust can provide such mapping functionality, including  Option,  Result,  Iterator, and  Future.</p><p> 以Haskell中的Functor为例。尽管听起来很恐怖，但如今几乎所有开发人员都对Functor的概念很熟悉。 Functor提供了一个通用接口，用于在此结构上映射功能。 Rust中许多不同的结构都可以提供这种映射功能，包括Option，Result，Iterator和Future。</p><p> However, it hasn&#39;t been possible to write a general purpose  Functor trait that can be implemented by multiple types. Instead, individual types can implement them as methods on that type. For example, we can write our own custom  MyOption and  MyResult enums and provide  map methods:</p><p> 但是，不可能编写可以由多种类型实现的通用Functor特性。相反，单个类型可以将它们实现为该类型上的方法。例如，我们可以编写我们自己的自定义MyOption和MyResult枚举并提供映射方法：</p><p> #[ derive (Debug, PartialEq)] enum  MyOption &lt;A&gt; {  Some (A),  None ,} impl &lt;A&gt;  MyOption &lt;A&gt; {  fn  map &lt;F:  FnOnce (A) -&gt; B, B&gt;( self ,  f : F) -&gt; MyOption&lt;B&gt; {  match  self  { MyOption::Some(a)  =&gt;  MyOption::Some( f (a)), MyOption::None  =&gt;  MyOption::None, } }}#[ test ] fn  test_option_map () {  assert_eq! (MyOption::Some( 5 ). map (| x | x +  1 ), MyOption::Some( 6 ));  assert_eq! (MyOption::None. map (| x :  i32 | x +  1 ), MyOption::None);}#[ derive (Debug, PartialEq)] enum  MyResult &lt;A, E&gt; {  Ok (A),  Err (E),} impl &lt;A, E&gt;  MyResult &lt;A, E&gt; {  fn  map &lt;F:  FnOnce (A) -&gt; B, B&gt;( self ,  f : F) -&gt; MyResult&lt;B, E&gt; {  match  self  { MyResult::Ok(a)  =&gt;  MyResult::Ok( f (a)), MyResult::Err(e)  =&gt;  MyResult::Err(e), } }}#[ test ] fn  test_result_map () {  assert_eq! (MyResult::Ok( 5 ). map (| x | x +  1 ), MyResult::Ok::&lt; i32 , ()&gt;( 6 ));  assert_eq! (MyResult::Err( &#34; hello &#34; ). map (| x :  i32 | x +  1 ), MyResult::Err( &#34; hello &#34; ));}</p><p> ＃[派生（Debug，PartialEq）]枚举MyOption＆lt; A＆gt; {Some（A），None，}表示＆lt; A＆gt; MyOption＆lt; A＆gt; {fn map＆lt; F：FnOnce（A）-＆gt; B，B＞（self，f：F）-＞ B。 MyOption＆lt; B＆gt; {match self {MyOption :: Some（a）=＆gt; MyOption :: Some（f（a）），MyOption :: None =＆gt; MyOption :: None，}}}＃[test] fn test_option_map（）{assert_eq！ （MyOption :: Some（5）。map（| x | x + 1），MyOption :: Some（6））; assert_eq！ （MyOption :: None。map（| x：i32 | x + 1），MyOption :: None）;}＃[派生（Debug，PartialEq）]枚举MyResult＆lt; A，E＆gt; {Ok（A），Err（E），} impl＆lt; A，E＆gt; MyResult＆lt; A，E＆gt; {fn map＆lt; F：FnOnce（A）-＆gt; B，B＞（self，f：F）-＞ B。 MyResult＆lt; B，E＆gt; {match self {MyResult :: Ok（a）=＆gt; MyResult :: Ok（f（a）），MyResult :: Err（e）=> MyResult :: Err（e），}}}＃[test] fn test_result_map（）{assert_eq！ （MyResult :: Ok（5）。map（| x | x + 1），MyResult :: Ok ::＆lt; i32，（）＆gt;（6））; assert_eq！ （MyResult :: Err（＆＃34; hello＆＃34;）。map（| x：i32 | x + 1），MyResult :: Err（＆＃34; hello＆＃34;））;}</p><p> However, it hasn&#39;t been possible without GATs to define  map as a trait method. Let&#39;s see why. Here&#39;s a naive approach to a &#34;monomorphic functor&#34; trait, and an implementation for  Option:</p><p> 但是，没有GAT不可能将map定义为特征方法。让我们看看为什么。这是单态仿函数的幼稚方法。特质，以及Option的实现：</p><p> /// Monomorphic functor trait trait  MonoFunctor  {  type  Unwrapped ;  // value &#34;contained inside&#34;  fn  map &lt;F&gt;( self ,  f : F) -&gt;  Self  where  F: FnMut( Self:: Unwrapped) -&gt;  Self:: Unwrapped;}impl&lt;A&gt; MonoFunctor  for Option &lt;A&gt; {  type  Unwrapped  = A;  fn  map &lt;F:  FnMut (A) -&gt; A&gt;( self ,  mut  f : F) -&gt;  Option &lt;A&gt; {  match  self  {  Some (a)  =&gt; Some ( f (a)),  None =&gt; None , } }}</p><p> ///单态函子特征trait MonoFunctor {类型Unwrapped; //值＆＃34;包含在内部＆＃34; fn映射＆lt; F＆gt;（self，f：F）-＆gt;自己在哪里F：FnMut（自己::未包装）-＆gt;自我：：未包装；} imp＆lt; A＆gt;选项＆lt; A＆gt;的MonoFunctor {类型Unwrapped = A; fn映射＆lt; F：FnMut（A）-＆gt; A＆gt;（self，mut f：F）-＆gt;选项＆lt; A＆gt; {匹配自己{一些（a）=＆gt;一些（f（a）），无=>没有 ， } }} </p><p> In our trait definition, we define an associated type  Unwrapped, for the value that lives &#34;inside&#34; the  MonoFunctor. In the case of  Option&lt;A&gt;, that would be  A. And herein lies the problem. We&#39;re hard-coding the  Unwrapped to just one type,  A. Usually with a  map function, we want to change the type to  B. But we have no way in current, stable Rust to say &#34;I want a type that&#39;s associated with this  MonoFunctor, but also a little bit different in what lives inside of it.&#34;</p><p>在特征定义中，我们为存在于＆＃34; inside＆＃34;中的值定义了一个关联类型Unwrapped。 MonoFunctor。在选项＆lt; A＆gt;的情况下，将是A。这就是问题所在。我们将Unwrapped硬编码为一种类型，A。通常使用map函数，我们希望将类型更改为B。但是，在当前稳定的Rust中，我们无话可说与该MonoFunctor关联的类型，但其内部的内容也有些不同。＆＃34;</p><p>   In order to get a polymorphic functor, we need to be able to say &#34;here&#39;s how my type would look if I wrapped up a  different type inside of it.&#34; For example, with  Option, we&#39;d like to say &#34;hey, I&#39;ve got  Option&lt;A&gt;, and it contains an  A type, but if it contained a  B type instead, it would be  Option&lt;B&gt;.&#34; To do this, we&#39;re going to use the generic associated type  Wrapped&lt;B&gt;:</p><p>   为了获得多态函子，我们需要能够说出如果我在其中封装了其他类型，我的类型将如何显示。例如，对于Option，我们想说“嘿，我有Option＆lt; A＆gt ;，它包含一个A类型，但是如果它包含一个B类型，它将是选项＆lt; B＆gt;。为此，我们将使用通用的关联类型Wrapped＆lt; B＆gt ;：</p><p> trait  Functor  {  type  Unwrapped ;  type  Wrapped &lt;B&gt;: Functor;  fn  map &lt;F, B&gt;( self ,  f : F) -&gt;  Self:: Wrapped&lt;B&gt;  where  F: FnMut( Self:: Unwrapped) -&gt; B;}</p><p> 特征Functor {类型为未包装;包装的＆lt; B＆gt;类型：Functor; fn映射＆lt; F，B＆gt;（self，f：F）-＆gt;自身：：包装的B。其中F：FnMut（自我：：未包装）-＆gt; B;}</p><p>  When we know a functor, we can also figure out another, associated type  Wrapped&lt;B&gt; which is &#34;like  Self, but has a different wrapped up value underneath&#34;</p><p>  当我们知道一个函子时，我们也可以找出另一个关联类型WrappedB。就像“自我”，但其下面的包裹值不同</p><p>  The function parameter will map from the current underlying  Unwrapped value to some new type  B</p><p>  函数参数将从当前的基础Unwrapped值映射到一些新的B类型</p><p>  impl &lt;A&gt; Functor  for  Option &lt;A&gt; {  type  Unwrapped  = A;  type  Wrapped &lt;B&gt; =  Option &lt;B&gt;;  fn  map &lt;F:  FnMut (A) -&gt; B, B&gt;( self ,  mut  f : F) -&gt;  Option &lt;B&gt; {  match  self  {  Some (x)  =&gt; Some ( f (x)),  None =&gt; None , } }}#[ test ] fn  test_option_map () {  assert_eq! ( Some ( 5 ). map (| x | x +  1 ),  Some ( 6 ));  assert_eq! ( None . map (| x :  i32 | x +  1 ),  None );}</p><p>  impl＆lt; A＆gt;选项＆lt; A＆gt;的函子{类型Unwrapped = A;类型包装的＆lt; B＆gt; =选项＆lt; B＆gt ;； fn映射＆lt; F：FnMut（A）-＆gt; B，B＞（self，mut f：F）-＞ B。选项＆lt; B＆gt; {match self {Some（x）=＆gt;一些（f（x）），无=>无，}}}＃[测试] fn test_option_map（）{assert_eq！ （Some（5）。map（| x | x + 1），Some（6））; assert_eq！ （None。map（| x：i32 | x + 1），None）;}</p><p> And if you play with all of the type gymnastics, you&#39;ll see that this ends up being identical to the  map method we special-cased for  MyOption above (sans a difference between  FnOnce and  FnMut). Cool!</p><p> 而且，如果您使用所有类型的体操运动，您将发现它最终与我们上面针对MyOption特殊设置的map方法相同（没有FnOnce和FnMut之间的差异）。凉！ </p><p>  In Haskell, none of this generic associated type business is needed. In fact, Haskell  Functors don&#39;t use  any associated types. The typeclass for  Functor in Haskell far predates the presence of associated types in the language. For comparison, let&#39;s see what that looks like, renaming a bit to match up with Rust:</p><p>在Haskell中，不需要任何此类通用关联类型业务。实际上，Haskell函子不使用任何关联的类型。 Haskell中的Functor的类型类早于该语言中相关类型的存在。为了进行比较，让我们看一下外观，将其重命名为与Rust相匹配：</p><p> class Functor  f  where  map  ::  ( a  -&gt;  b )  -&gt;  f a  -&gt;  f b instance  Functor Option  where  map f option  = case  option  of  Some  x  -&gt;  Some  (f x)  None  -&gt;  None</p><p> 类Functor f其中map ::（a-> b）-＆gt; f a-＆gt; f b实例Functor Option，其中map f option = Some x-＆gt;的case选项。某些（f x）无->没有</p><p>  trait  HktFunctor  {  fn  map &lt;A, B, F:  FnMut (A) -&gt; B&gt;( self : Self&lt;A&gt;,  f : F) -&gt; Self&lt;B&gt;; impl  HktFunctor  for  Option  {  fn  map &lt;A, B, F:  FnMut (A) -&gt; B&gt;( self :  Option &lt;A&gt;,  f : F) -&gt;  Option &lt;B&gt; {  match  self  {  Some (a)  =&gt; Some ( f (a)),  None =&gt; None , } }}</p><p>  特性HktFunctor {fn map＆lt; A，B，F：FnMut（A）-＆gt; B＆gt;（self：Self＆lt; A＆gt; f：F）-＆gt;自我B；选项{fn map 的impl HktFunctor B＆gt;（self：Option＆lt; A＆gt ;, f：F）-＆gt;选项＆lt; B＆gt; {匹配自己{一些（a）=＆gt;一些（f（a）），无=>没有 ， } }}</p><p> But this isn&#39;t valid Rust! That&#39;s because we&#39;re trying to provide type parameters to  Self. But in Rust,  Option isn&#39;t a type.  Option must be applied to a single type parameter before it becomes a type.  Option&lt;i32&gt; is a type.  Option on its own is not.</p><p> 但这不是有效的Rust！那是因为我们正在尝试为Self提供类型参数。但是在Rust中，Option不是一种类型。选项必须先应用于单个类型参数，然后才能成为类型。选项＆lt; i32＆gt;是一种。期权本身不是。</p><p> By contrast, in Haskell,  Maybe Int is a type of  kind  Type.  Maybe is a  type constructor, of  kind  Type -&gt; Type. But you can treat  Maybe has a type of its own for purposes of creating type classes and instance.  Functor in Haskell works on the kind  Type -&gt; Type. This is what we mean by &#34;higher kinded types&#34;: we can have types whose  kind is higher than just  Type.</p><p> 相反，在Haskell中，也许Int是Type类型的一种。也许是类型构造器，类型->类型。但是您可以为了创建类型类和实例而将Maybe拥有自己的类型。 Haskell中的Functor使用Type-＆gt;类型。这就是“更高种类的类型”的意思：我们可以拥有类型比不仅仅是“类型”高的类型。</p><p> GATs in Rust are a workaround for this lack of HKTs for the examples below. But as we&#39;ll ultimately see, they are more brittle and more verbose. That&#39;s not to say that GATs are a Bad Thing, far from it. It  is to say that trying to write Haskell in Rust is probably not a good idea.</p><p> 在以下示例中，Rust中的GAT是针对缺少HKT的一种解决方法。但是，正如我们最终看到的那样，它们更加脆弱且更加冗长。这并不是说GAT是一件坏事，离它还很遥远。就是说，尝试用Rust编写Haskell可能不是一个好主意。</p><p> OK, now that we&#39;ve thoroughly established that what we&#39;re about to do isn&#39;t a great idea... let&#39;s do it!</p><p> 好的，既然我们已经彻底确定了我们将要做的不是一个好主意，那就去做吧！ </p><p>  There&#39;s a controversial typeclass in Haskell called  Pointed. It&#39;s controversial because it introduces a typeclass without any laws associated with it, which is often not very liked. But since I already told you this is all a bad idea, let&#39;s implement  Pointed.</p><p>在Haskell中，一个有争议的类型类称为Pointed。之所以引起争议，是因为它引入了一个没有任何相关法律的类型类，而这通常不是很喜欢。但是，由于我已经告诉过您，这都是一个坏主意，让我们实现Pointed。</p><p> The idea of  Pointed is simple: wrap up a value into a  Functor-like thing. So in the case of  Option, it would be like wrapping it with  Some. In a  Result, it&#39;s using  Ok. And for a  Vec, it would be a single-element vector. Unlike  Functor, this will be a static method, since we don&#39;t have an existing  Pointed value to change. Let&#39;s see it in action:</p><p> 指向对象的想法很简单：将值包装到类似Functor的事物中。因此，对于Option而言，这就像用Some包装它。结果是，使用Ok。对于Vec，它将是一个单元素向量。与Functor不同，这将是静态方法，因为我们没有要更改的现有Pointed值。让我们来看看它的作用：</p><p> trait  Pointed : Functor {  fn  wrap &lt;T&gt;( t : T) -&gt;  Self:: Wrapped&lt;T&gt;;} impl &lt;A&gt; Pointed  for  Option &lt;A&gt; {  fn  wrap &lt;T&gt;( t : T) -&gt;  Option &lt;T&gt; {  Some (t) }}</p><p> 指向的特征：函子{fn wrap＆lt; T＆gt;（t：T）-＆gt;自：：包裹T} impl＆lt; A＆gt;指向选项＆lt; A＆gt; {fn wrap＆lt; T＆gt;（t：T）-＆gt;选项＆lt; T＆gt; {一些（t）}}</p><p> What&#39;s particularly interesting about this is that we don&#39;t use the  A type parameter in the  Option implementation at all.</p><p> 对此特别有趣的是，我们根本没有在Option实现中使用A类型参数。</p><p> There&#39;s one more thing worth noting. The result of calling  wrap is a  Self::Wrapped&lt;T&gt; value. What exactly do we know about  Self::Wrapped&lt;T&gt;? Well, from the  Functor trait definition, we know exactly one thing: that  Wrapped&lt;T&gt; must be a  Functor. Interestingly, we have  lost the knowledge here that  Self::Wrapped&lt;T&gt; is also a  Pointed. That&#39;s going to be a recurring theme for the next few traits.</p><p> 还有另外一件事值得注意。调用wrap的结果是Self :: Wrapped＆lt; T＆gt;值。我们确切了解Self :: Wrapped＆lt; T＆gt;吗？好吧，从Functor特征定义中，我们确切地知道一件事：Wrapped＆lt; T＆gt;必须是函子。有趣的是，我们在这里已经失去了Self :: Wrapped＆lt; T＆gt;也是有针对性的。对于接下来的几个特征，这将是一个反复出现的主题。</p><p> But let me reiterate this a different way. When we&#39;re working with a general  Functor trait implementation, we don&#39;t know  anything at all about the  Wrapped associated type except that it implements  Functor itself. Logically, we know that for a  Option&lt;A&gt; implementation, we&#39;d like  Wrapped to be a  Option&lt;B&gt; kind of thing. But the GAT implementation does not enforce it. (By contrast, the HKT approach in Haskell  does enforce this.) Nothing prevents us from writing a horrifically non-sensible implementation such as:</p><p> 但是，让我重申一下这种不同的方式。当我们使用常规的Functor特征实现时，我们对Wrapped关联类型一无所知，只是它实现了Functor本身。从逻辑上讲，我们知道对于Option＆lt; A＆gt;实施中，我们希望Wrapped是OptionB。之类的事情。但是GAT实施不会强制实施。 （相比之下，Haskell中的HKT方法确实实现了这一点。）没有什么可以阻止我们编写令人毛骨悚然的不明智的实现，例如：</p><p> impl &lt;A&gt; Functor  for  MyOption &lt;A&gt; {  type  Unwrapped  = A;  type  Wrapped &lt;B&gt; =  Result &lt;B,  String &gt;;  // wut?  fn  map &lt;F:  FnMut (A) -&gt; B, B&gt;( self ,  mut  f : F) -&gt;  Result &lt;B,  String &gt; {  match  self  { MyOption::Some(a)  =&gt; Ok ( f (a)), MyOption::None  =&gt; Err ( &#34; Well this is weird, isn&#39;t it? &#34; . to_owned ()), } }}</p><p> impl＆lt; A＆gt; MyOption＆lt; A＆gt;的函子{类型Unwrapped = A;类型包装的＆lt; B＆gt; =结果＆lt; B，字符串＆gt ;; //会吗？ fn映射＆lt; F：FnMut（A）-＆gt; B，B＞（self，mut f：F）-＞ B。结果＆lt; B，字符串＆gt; {match self {MyOption :: Some（a）=＆gt;确定（f（a）），MyOption :: None =＆gt;错误（＆＃34;嗯，这很奇怪，不是吗？＆＃34;。to_owned（）），}}} </p><p> You may be thinking, &#34;So what, no one would write something like that. And it&#39;s their own fault if they do.&#34; That&#39;s not the point here. The point is that the compiler can&#39;t know that there&#39;s a connection between  Self and  Wrapped&lt;B&gt;. And since it can&#39;t know that, there are some things we can&#39;t get to type check. I&#39;ll show you one of those at the end.</p><p>您可能在想，那么，没人会这样写。如果他们这样做，那是他们自己的错。这不是这里的重点。关键是编译器无法知道Self和Wrapped B之间存在联系。而且由于它不知道，所以有些事情我们无法输入check。最后，我将向您展示其中之一。</p><p>  When I give Haskell training, and I get to the  Functor/ Applicative/ Monad section, most people are nervous about  Monads. In my experience, the really confusing part is really  Applicative. Once you understand that,  Monad is relatively speaking easy.</p><p>  当我接受Haskell培训后，进入Functor / Applicative / Monad部分，大多数人都对Monads感到不安。以我的经验，真正令人困惑的部分是实用性的。一旦您了解了这一点，Monad相对来说就很简单。</p><p> The  Applicative typeclass in Haskell has two methods.  pure is equivalent to the  wrap that I put into  Pointed, so we can ignore it. The other method is  &lt;*&gt;, known as &#34;apply,&#34; or &#34;splat&#34;, or &#34;the tie fighter.&#34; I originally implemented  Applicative with a method called  apply that matches that operator, but found that it was better to go a different route.</p><p> Haskell中的Applicative类型类有两种方法。 pure等同于我放入Pointed中的包装，因此我们可以忽略它。另一种方法是＆lt; *，称为＆＃34; apply，＆＃34;或＆＃34;或领带战斗机。＆＃34;我最初使用与该运算符匹配的名为apply的方法来实现Applicative，但发现最好走另一条路。</p><p> Instead, there&#39;s an alternate way to define an  Applicative typeclass, based on a different function called  liftA2 (or, in Rust,  lift_a2). Here&#39;s the idea. Suppose I have two functions:</p><p> 取而代之的是，还有一种替代方法，可以基于另一个称为liftA2的函数（或在Rust中为lift_a2）来定义Applicative类型类。这是想法。假设我有两个功能：</p><p>  I may not know the current year or the birth year, in which case I&#39;ll return  None. But if I get a  Some return for both of these function calls, then I can calculate the age. In normal Rust code, this may look like:</p><p>  我可能不知道当前年份或出生年份，在这种情况下，我将返回None。但是，如果我对这两个函数调用均获得“和”回报，则可以计算出年龄。在普通的Rust代码中，这可能类似于：</p><p> fn  age () -&gt;  Option &lt; i32 &gt; {  let  birth_year =  birth_year () ? ;  let  current_year =  current_year () ? ;  Some (current_year - birth_year)}</p><p> fn age（）-＆gt;选项＆lt; i32＆gt; {let birth_year = birth_year（）吗？ ;让current_year = current_year（）吗？ ;一些（当前年份-出生年份）}</p><p> But that&#39;s leveraging  ? and early return. A primary purpose of  Applicative is to address the same problem. So let&#39;s rewrite this without any early return, and instead use some pattern matching:</p><p> 但这是杠杆吗？和早日返回。应用程序的主要目的是解决相同的问题。因此，我们将其重写而没有任何提前返回，而是使用一些模式匹配： </p><p> fn  age () -&gt;  Option &lt; i32 &gt; {  match  ( birth_year (),  current_year ()) { ( Some (birth_year),  Some (current_year))  =&gt; Some (current_year - birth_year),  _ =&gt; None , }}</p><p>fn age（）-＆gt;选项＆lt; i32＆gt; {match（birth_year（），current_year（））{（Some（birth_year），Some（current_year））=＆gt;一些（当前年份-出生年份），_ =＆gt;没有 ， }}</p><p> This certainly works, but it&#39;s verbose. It also doesn&#39;t generalize to other cases, like a  Result. And what about a really sophisticated case, like &#34;I have a  Future that will return the birth year, a  Future that will return the current year, and I want to produce a  Future that finds the difference.&#34; With async/await syntax, it&#39;s easy enough to do. But we can also do it with  Applicative, using our  lift_a2 method.</p><p> 当然可以，但是很冗长。它也不会推广到其他情况，例如结果。还有一个非常复杂的案例，例如“我有一个可以返回出生年份的Future，一个可以返回当前年份的Future，并且我想生成一个可以发现差异的Future。”使用async / await语法，这很容易做到。但是，我们也可以使用我们的lift_a2方法在Applicative中完成此操作。</p><p> The point of  lift_a2 is: I&#39;ve got two values wrapped up, perhaps both in an  Option. I&#39;d like to use a function to combine them together. Let&#39;s see what that looks like in Rust:</p><p> lift_a2的要点是：我包装了两个值，也许都在一个期权中。我想使用一个函数将它们组合在一起。让我们看一下Rust中的外观：</p><p> trait  Applicative : Pointed {  fn  lift_a2 &lt;F, B, C&gt;( self ,  b :  Self:: Wrapped&lt;B&gt;,  f : F) -&gt;  Self:: Wrapped&lt;C&gt;  where  F: FnMut( Self:: Unwrapped, B) -&gt; C;}impl&lt;A&gt; Applicative  for Option &lt;A&gt; {  fn  lift_a2 &lt;F, B, C&gt;( self ,  b :  Self:: Wrapped&lt;B&gt;,  mut  f : F) -&gt;  Self:: Wrapped&lt;C&gt;  where  F: FnMut( Self:: Unwrapped, B) -&gt; C {  let  a =  self ? ;  let  b = b ? ;  Some ( f (a, b)) }}</p><p> 性状适用：指向{fn lift_a2＆lt; F，B，C＆gt;（self，b：Self :: Wrapped B，f：F）-自：：包裹的C。其中F：FnMut（自我：：未包装，B）-＆gt; C；} impl A ＝ C。适用于选项＆lt; A＆gt; {fn lift_a2＆lt; F，B，C＆gt;（self，b：Self ::包装的B＆gt; mut f：F）-＆gt;自：：包裹的C。其中F：FnMut（自我：：未包装，B）-＆gt; C {让a =自我？ ;令b = b？ ;一些（f（a，b））}}</p><p>   Whether this is an improvement or not probably depends heavily on how much Haskell you&#39;ve written in your life. Again, I&#39;m not advocating changing Rust here, but it&#39;s certainly interesting.</p><p>   这是否是一种改进，可能在很大程度上取决于您一生写了多少Haskell。同样，我不主张在这里更改Rust，但这确实很有趣。</p><p>  fn  birth_year () -&gt;  Result &lt; i32 ,  String &gt; {  Err ( &#34; No birth year &#34; . to_string ())} fn  current_year () -&gt;  Result &lt; i32 ,  String &gt; {  Err ( &#34; No current year &#34; . to_string ())} fn  age () -&gt;  Result &lt; i32 ,  String &gt; {  current_year (). lift_a2 ( birth_year (), | cy ,  by | cy - by)}</p><p>  fn birth_year（）->结果＆lt; i32，字符串＆gt; {Err（＆＃34;没有出生年份＆＃34;。to_string（））} fn current_year（）-＆gt;结果＆lt; i32，字符串＆gt; {Err（＆＃34;无当前年份＆＃34; to_string（））} fn age（）-＆gt;结果＆lt; i32，字符串＆gt; {  今年 （）。 lift_a2（birth_year（），| cy，by | cy-by）}</p><p> Which may beg the question: which of the two  Err values do we take? Well, that depends on our implementation of  Applicative, but typically we would prefer choosing the first:</p><p> 可能是哪个问题：我们采用两个Err值中的哪个？嗯，这取决于我们对Applicative的实现，但是通常我们更喜欢选择第一个： </p><p> impl &lt;A, E&gt; Applicative  for  Result &lt;A, E&gt; {  fn  lift_a2 &lt;F, B, C&gt;( self ,  b :  Self:: Wrapped&lt;B&gt;,  mut  f : F) -&gt;  Self:: Wrapped&lt;C&gt;  where  F: FnMut( Self:: Unwrapped, B) -&gt; C {  match  ( self , b) { ( Ok (a),  Ok (b))  =&gt; Ok ( f (a, b)), ( Err (e),  _ )  =&gt; Err (e), ( _ ,  Err (e))  =&gt; Err (e), } }}</p><p>impl＆lt; A，E＆gt;适用于结果＆lt; A，E＆gt; {fn lift_a2＆lt; F，B，C＆gt;（self，b：Self ::包装的B＆gt; mut f：F）-＆gt;自：：包裹的C。其中F：FnMut（自我：：未包装，B）-＆gt; C {match（self，b）{（Ok（a），Ok（b））=>好（f（a，b）），（Err（e），_）=> Err（e），（_，Err（e））=>错误（e），}}}</p><p> But what if we wanted both? Here&#39;s a case where  Applicative gives us power that  ? doesn&#39;t.</p><p> 但是，如果我们两个都想要怎么办？这是Applicative赋予我们权力的情况？不。</p><p>  The  Validation type from Haskell represents the idea &#34;I&#39;m going to try lots of things, some of them may fail, and I want to collect together all of the error results.&#34; A typically example of this would be web form parsing. If a user enters an invalid email address, invalid phone number,  and forgets to click the &#34;I agree&#34; box, you&#39;d want to generate all three error messages. You don&#39;t want to generate just one.</p><p>  Haskell的Validation类型代表了我要尝试很多事情的想法，其中有些可能会失败，我想将所有错误结果汇总在一起。＆＃34;一个典型的例子是Web表单解析。如果用户输入了无效的电子邮件地址，无效的电话号码，并且忘记了单击“我同意”。框，您想生成所有三个错误消息。您不想只生成一个。</p><p> To start off our  Validation implementation, we need to introduce one more Haskell-y typeclass, this time for representing the concept of &#34;combining together multiple values.&#34; We  could just hard-code  Vec in here, but where&#39;s the fun in that? Instead, let&#39;s introduce the strangely-named  Semigroup trait. This doesn&#39;t even require any special GAT code:</p><p> 要开始我们的Validation实现，我们需要引入一个Haskell-y类型类，这一次是表示＆＃34;将多个值组合在一起的概念。我们可以在这里对Vec进行硬编码，但是这样做的乐趣在哪里呢？取而代之的是，我们引入一个名字奇怪的半群特征。这甚至不需要任何特殊的GAT代码：</p><p> trait  Semigroup  {  fn  append ( self ,  rhs :  Self ) -&gt;  Self ;} impl  Semigroup  for  String  {  fn  append ( mut  self ,  rhs :  Self ) -&gt;  Self  {  self  +=  &amp; rhs;  self  }} impl &lt;T&gt; Semigroup  for  Vec &lt;T&gt; {  fn  append ( mut  self ,  mut  rhs :  Self ) -&gt;  Self  {  Vec ::append( &amp; mut  self ,  &amp; mut  rhs);  self  }} impl  Semigroup  for  () {  fn  append ( self , (): ()) -&gt; () {}}</p><p> 特质Semigroup {fn append（self，rhs：Self）-> Self;} impl字符串的半群{fn append（mut self，rhs：Self）->自我{自我+ =＆amp; rhs;自我}}隐含＆lt; T＆gt; Vec＆lt; T＆gt;的半群{fn append（mut self，mut rhs：Self）->自我{Vec :: append（＆amp; mut self，＆amp; mut rhs）; self}} impl Semigroup for（）{fn append（self，（）：（））-> （）{}}</p><p>   The  Functor and  Pointed implementations are boring, let&#39;s skip straight to the meat with the  Applicative implementation:</p><p>   Functor和Pointed实现很无聊，让我们通过Applicative实现直接跳到最前面：</p><p> impl &lt;A, E: Semigroup&gt; Applicative  for  Validation &lt;A, E&gt; {  fn  lift_a2 &lt;F, B, C&gt;( self ,  b :  Self:: Wrapped&lt;B&gt;,  mut  f : F) -&gt;  Self:: Wrapped&lt;C&gt;  where  F: FnMut( Self:: Unwrapped, B) -&gt; C {  match  ( self , b) { (Validation::Ok(a), Validation::Ok(b))  =&gt;  Validation::Ok( f (a, b)), (Validation::Err(e), Validation::Ok( _ ))  =&gt;  Validation::Err(e), (Validation::Ok( _ ), Validation::Err(e))  =&gt;  Validation::Err(e), (Validation::Err(e1), Validation::Err(e2))  =&gt;  Validation::Err(e1. append (e2)), } }}</p><p> impl＆lt; A，E：Semigroup＆gt;适用于验证＆lt; A，E＆gt; {fn lift_a2＆lt; F，B，C＆gt;（self，b：Self ::包装的B＆gt; mut f：F）-＆gt;自：：包裹的C。其中F：FnMut（自我：：未包装，B）-＆gt; C {match（self，b）{（Validation :: Ok（a），Validation :: Ok（b））=> Validation :: Ok（f（a，b）），（Validation :: Err（e），Validation :: Ok（_））=> Validation :: Err（e），（Validation :: Ok（_），Validation :: Err（e））=>验证：： Err（e），（验证：： Err（e1），验证：： Err（e2））=>验证:: Err（e1。append（e2）），}}} </p><p> Here, we&#39;re saying that the error type parameter must implement  Semigroup. If both values are  Ok, we apply the  f function to them and wrap up the result in  Ok. If only one of the values is  Err, we return that error. But if  both of them are error, we leverage the  append method of  Semigroup to combine them together. This is something you can&#39;t get with  ?-style error handling.</p><p>在这里，我们说的是错误类型参数必须实现Semigroup。如果两个值都为Ok，则将f函数应用于它们并将结果包装在Ok中。如果只有一个值是Err，我们将返回该错误。但是，如果两者都出错，则可以利用Semigroup的append方法将它们组合在一起。这是使用？样式错误处理无法获得的。</p><p>  At last, the dreaded monad rears its head! But in reality, at least for Rustaceans, monad isn&#39;t much of a surprise. You&#39;re already used to it: it&#39;s the  and_then method. Almost any chain of statements that end with  ? in Rust can be reimagined as monadic binds. In my opinion, the main reason monad has the allure of the unknowable was a series of particularly bad tutorials that cemented this idea in people&#39;s minds.</p><p>  最后，可怕的莫纳德抬起头来！但实际上，至少对于Rustaceans而言，单子并不令人惊讶。您已经习惯了它：and_then方法。几乎所有以结尾的语句链？可以将Rust中的Monadic绑定重新想象。在我看来，monad之所以具有这种不可知的吸引力，其主要原因是一系列特别糟糕的教程，这些教程在人们的脑海中凝聚了这个想法。</p><p> Anyway, since we&#39;re just trying to match the existing method signature of  and_then on  Option, I&#39;m not going to spend much time motivating &#34;why monad.&#34; Instead, let&#39;s just look at the definition of the trait:</p><p> 无论如何，由于我们只是试图匹配Option上and_then的现有方法签名，所以我不会花很多时间来激发“ monad”的作用。相反，我们只看一下特征的定义：</p><p> trait  Monad  : Applicative {  fn  bind &lt;B, F&gt;( self ,  f : F) -&gt;  Self:: Wrapped&lt;B&gt;  where  F: FnMut( Self:: Unwrapped) -&gt;  Self:: Wrapped&lt;B&gt;;}impl&lt;A&gt; Monad  for Option &lt;A&gt; {  fn  bind &lt;B, F&gt;( self ,  f : F) -&gt;  Option &lt;B&gt;  where  F: FnMut(A) -&gt;  Option &lt;B&gt;, {  self . and_then (f) }}</p><p> 性状Monad：适用{自身：：包装的B。其中F：FnMut（自我：：未包装）-＆gt;自：：包裹B；} impl A；选项＆lt; A＆gt;的Monad {fn bind＆lt; B，F＆gt;（self，f：F）-＆gt;选项＆lt; B＆gt;其中F：FnMut（A）→选项＆lt; B＆gt ;， {self。 and_then（f）}}</p><p> And just like that, we&#39;ve got monadic Rust. Time to ride off into the sunset.</p><p> 就这样，我们得到了Monadic Rust。是时候骑到日落了。</p><p>    I&#39;m overall not a huge fan of monad transformers. I think they are drastically overused in Haskell, and lead to huge amounts of complication. I instead advocate the  ReaderT design pattern. But again, this post is definitely not about best practices.</p><p>    我总体上不是monad变压器的忠实拥护者。我认为它们在Haskell中被过度使用，并导致大量的并发症。相反，我主张使用ReaderT设计模式。但是同样，这篇文章绝对不是关于最佳实践的。</p><p> Typically, each monad instance provides some kind of additional functionality.  Option means &#34;it might not produce a value.&#34;  Result means &#34;it might fail with an error.&#34; If we provided it,  Future means &#34;it won&#39;t produce a value immediately, but it will eventually.&#34; And as a final example, the  Reader monad means &#34;I have read-only access to some environmental data.&#34;</p><p> 通常，每个monad实例都提供某种附加功能。选项表示＆＃34;它可能不会产生值。＆＃34;结果表示＆＃34;它可能会因错误而失败。＆＃34;如果我们提供了它，则Future意味着它不会立即产生一个值，但最终会产生一个值。作为最后一个示例，Reader monad意味着＆＃34;我对某些环境数据具有只读访问权限。＆＃34; </p><p> But what if we want to have two pieces of functionality? There&#39;s no obvious way to combine a  Reader and a  Result. In Rust, we  do combine together  Result and  Future via  async functions and  ?, but that had to have carefully designed language support. Instead, the Haskell approach to this problem would be: just provide  do notation (syntactic sugar for monads), and then layer up your monad transformers to add together all of the functionality.</p><p>但是，如果我们想拥有两项功能，该怎么办？没有明显的方法将阅读器和结果结合起来。在Rust中，我们确实通过异步函数和？将Result和Future组合在一起，但是必须精心设计语言支持。相反，针对此问题的Haskell方法将是：仅提供do表示法（用于monad的语法糖），然后分层放置monad转换器以将所有功能加在一起。</p><p> I&#39;ve considered writing a blog post on this philosophical difference for a while. (If people are interested in such a post, please let me know.) But for now, let&#39;s simply explore what it looks like to provide a monad transformer in Rust. We&#39;ll implement it for the most boring of all monad transformers,  IdentityT. This is the transformer that doesn&#39;t do anything at all. (And if you&#39;re wondering &#34;why have it,&#34; consider why Rust has 1-tuples. Sometimes, you need something that fits a certain shape to make some generic code work nicely.)</p><p> 我考虑过一段时间写一篇关于这种哲学差异的博客文章。 （如果人们对这样的帖子感兴趣，请让我知道。）但是，现在，让我们简单地探索在Rust中提供monad转换器的外观。我们将在所有最讨厌的monad转换器（IdentityT）中实现它。这是根本不做任何事情的变压器。 （并且，如果您想知道为什么拥有它，请考虑为什么Rust具有1个元组。有时，您需要一些适合特定形状的东西才能使某些通用代码正常工作。）</p><p> Since  IdentityT doesn&#39;t do anything, it&#39;s comforting to see that its type reflects that perfectly:</p><p> 由于IdentityT不做任何事情，因此很高兴看到它的类型完美地反映了这一点：</p><p>  I&#39;m calling the type parameter  M, because it&#39;s going to itself be an implementation of  Monad. That&#39;s the idea here: every monad transformer sits on top of a &#34;base monad.&#34;</p><p>  我之所以调用类型参数M，是因为它本身就是Monad的实现。这就是这里的想法：每个monad变压器都位于基本monad的顶部。</p><p> Next, let&#39;s look at a  Functor implementation. The idea is to unwrap the  IdentityT layer, leverage the underlying  map method, and then rewrap  IdentityT.</p><p> 接下来，让我们看一下Functor的实现。想法是拆开IdentityT层，利用底层的映射方法，然后重新包装IdentityT。</p><p> impl &lt;M: Functor&gt; Functor  for  IdentityT &lt;M&gt; {  type  Unwrapped  = M::Unwrapped;  type  Wrapped &lt;A&gt; = IdentityT&lt; M:: Wrapped&lt;A&gt;&gt;;  fn  map &lt;F, B&gt;( self ,  f : F) -&gt;  Self:: Wrapped&lt;B&gt;  where  F: FnMut( M:: Unwrapped) -&gt; B { IdentityT( self . 0. map (f)) }}</p><p> impl＆lt; M：Functor＆gt; IdentityT的函子＆lt; M＆gt; {类型为未包装= M ::未包装；类型包装的＆lt; A＆gt; = IdentityT＆lt; M ：：包裹的A； fn映射＆lt; F，B＆gt;（self，f：F）-＆gt;自身：：包装的B。其中F：FnMut（M ::未包装）-＆gt; B {IdentityT（self。0. map（f））}}</p><p> For our associated types, we leverage the associated types of  M. Inside  map, we use  self.0 to get the underlying  M, and wrap the result of the  map metho</p><p> 对于关联的类型，我们利用M的关联类型。在地图内部，我们使用self.0来获取基础M，然后包装地图方法的结果 </p><p>......</p><p>...... </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://www.fpcomplete.com/blog/monads-gats-nightly-rust/">https://www.fpcomplete.com/blog/monads-gats-nightly-rust/</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/锈病/">#锈病</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/gats/">#gats</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/类型/">#类型</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1039035.html"><img src="http://img2.diglog.com/img/2020/12/thumb_524d0a6238b4fbafd11724b452d87b49.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1039035.html">Facebook反托拉斯案中的吸烟枪 </a></div><span class="my_story_list_date">2020-12-11 10:32</span></div><div class="col-sm"><div><a target="_blank" href="/story/1039006.html"><img src="http://img2.diglog.com/img/2020/12/thumb_5d144d75025200eaffb082dd0e2e30ed.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1039006.html">Facebook因将Oculus使用与Facebook帐户绑定而遭到反托拉斯调查 </a></div><span class="my_story_list_date">2020-12-11 8:13</span></div><div class="col-sm"><div><a target="_blank" href="/story/1038976.html"><img src="http://img2.diglog.com/img/2020/12/thumb_e4a17ecf8d0495c05b16c35094c7001a.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1038976.html">最初的应用商店Cydia以反托拉斯为由起诉苹果 </a></div><span class="my_story_list_date">2020-12-11 7:47</span></div><div class="col-sm"><div><a target="_blank" href="/story/1038870.html"><img src="http://img2.diglog.com/img/2020/12/thumb_5d144d75025200eaffb082dd0e2e30ed.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1038870.html">Facebook因将Oculus使用与Facebook帐户绑定而遭到反托拉斯调查 </a></div><span class="my_story_list_date">2020-12-10 21:37</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>