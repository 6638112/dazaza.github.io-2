<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>用shellcode的衬衫的故事 Story of a Tshirt with a Shellcode</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script>
<script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">Story of a Tshirt with a Shellcode<br/>用shellcode的衬衫的故事 </h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2021-05-11 04:03:31</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2021/5/af475c7cca5ae03114a797d947eb4196.png"><img src="http://img2.diglog.com/img/2021/5/af475c7cca5ae03114a797d947eb4196.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>The text printed on it looks very much like the output of  objdump -d shellcode.o command.</p><p>打印在它上的文本看起来非常类似于objdump -d shellcode.o命令的输出。</p><p>  If you had a chance to write your own shellcode, you will immediately recognize this  jmp,  call,  pop pattern.In pure form it looks like this (NASM syntax):</p><p>  如果您有机会编写自己的shellcode，您将立即识别此JMP，呼叫，流行模式。纯表单如下所示（NASM语法）：</p><p> jmp  short _end _run:   pop   esi  ; now esi register contains address of data label  ; actual shellcode instructions go here _end:   call  _run  data:   db   &#39;some data&#39;</p><p> JMP短_END _RUN：POP ESI;现在ESI寄存器包含数据标签的地址;实际的Shellcode指令在这里_end：呼叫_Run数据：DB＆＃39;一些数据＆＃39;</p><p> When we use shellcode on a real system, we have no idea at which memory address our shellcode will be loaded. Sometimes this information can be very useful e.g. when our shellcode contains not only code but also data.While  jmps and  calls can operate on relative addresses, thus allowing us to write position independent code (PIC), the data access instructions ( movs) need absolute addresses.</p><p> 当我们在真实系统上使用shellcode时，我们不知道我们的shellcode的内存地址将被加载。有时这些信息可以非常有用。当我们的shellcode不仅包含代码而且数据而且呼叫可以在相对地址上运行，因此允许我们写入位置独立代码（图片），数据访问指令（MOVS）需要绝对地址。</p><p> NOTE: The last sentence is no longer true on x86_64 architecture, as it introduced a new addressing mode called &#34;RIP relative addressing&#34;.</p><p> 注意：最后一句在x86_64架构上不再是真实的，因为它引入了一个名为＆＃34; RIP相对地址＆＃34的新寻址模式;</p><p> When we use  jmp and  call instructions in relative address mode, we are actually using offsets relative to the  next instruction following  jmp or  call opcode.So a relative jump  jmp short 0 (again NASM syntax), will just jump to the next instruction and  jmp short -2 will create an infinite loop (assuming that the entire  jmp instruction takes two bytes).</p><p> 当我们在相对地址模式中使用JMP和呼叫指令时，我们实际上使用偏移相对于JMP或Call opcode.so相对跳转JMP短0（再次NASM语法），只会跳转到下一个指令和JMP短-2将创建一个无限循环（假设整个JMP指令需要两个字节）。</p><p> call offset instruction is more interesting, as it will not only jump to the offset, but also will push the address of the following instruction on the stack (the so called return address).</p><p> 呼叫偏移指令更有趣，因为它不仅跳转到偏移量，而且还将推动堆栈上以下指令的地址（所谓的返回地址）。 </p><p> Now we can understand how  jmp,  call,  pop pattern works.First we need to position  call instruction just before the data, of which we want to get address. Then we do a relative jump to the  call. The  call will put the address of the next instruction (in this case our data) on the stack and will again do a relative jump to the specified offset. Now we have the address of our data on the stack, so we may just  pop it into a register of our choice  🎉</p><p>现在我们可以了解JMP，呼叫，流行模式Works.First我们需要在数据之前定位呼叫指令，我们想要获得地址。然后我们做一个相对跳转到呼叫。调用将在堆栈上放置下一个指令（在这种情况下我们的数据）的地址，并将再次执行相对跳转到指定的偏移量。现在我们有我们在堆栈上的数据的地址，因此我们可能只是将其流程为我们选择的注册</p><p> When we take a look at the t-shirt again, we may notice that the actual offsets printed there are wrong.  jmp 0x2b should be in fact  jmp 0x2a because the address of  call instruction is  0x2f = 0x05 + 0x2a. The  call instruction on the other hand should jump to the  pop esi instruction, so the offset should be  0x2f (call addr) + 0x05 (length of call instruction) + offset = 0x05, or  -0x2f (using 2&#39;s complement this value can be represented as  0xffffffd1).</p><p> 当我们再次看看T恤时，我们可能会注意到印刷的实际偏移有问题。 JMP 0x2B实际上应该是JMP 0x2A，因为呼叫指令的地址是0x2F = 0x05 + 0x2a。另一方面，呼叫指令应该跳转到POP ESI指令，因此偏移量应为0x2F（调用Addr）+ 0x05（呼叫指令的长度）+ Offset = 0x05，或-0x2f（使用2＆＃39;补充这个值可以表示为0xFFFFFFD1）。</p><p>  mov  dword ptr  [ esi + 0x8 ],   esi 	 mov  byte ptr  [ esi + 0x7 ],   0x0 	 mov  dword ptr  [ esi + 0xc ],   0x0</p><p>  MOV DWORD PTR [ESI + 0x8]，ESI MOV字节PTR [ESI + 0x7]，0x0 mov DWORD PTR [ESI + 0xC]，0x0</p><p> We know now that  esi points to the area after our last shellcode instruction.We may illustrate this memory area as:</p><p> 我们现在知道ESI在我们的最后一个shellcode指令之后指向该区域。我们可以将此内存区域说明为：</p><p>  After executing all these move instructions (in intel syntax that we have here, it is always  mov dest, src) our memory area will look like this:</p><p>  执行所有这些移动指令（在我们这里拥有的英特尔语法中，它始终是mov ist，src）我们的内存区域将如下所示：</p><p>  Now this is interesting. Looks like we have a seven character string terminated by zero, then a pointer to that string and a  NULL value.</p><p>  现在这很有意思。看起来我们有一个七个字符串终止为零，然后指向该字符串的指针和空值。</p><p> 🤔 Seven character string, seven character string... when it is about shellcodes it must be  /bin/sh :D So it looks like the shellcode on the t-shirt is truncated, the last two instruction should look like this:</p><p> 🤔七字符串，七字符串......当它是关于shellcodes它必须是/ bin / sh：d，所以它看起来像t恤上的shellcode被截断，最后两个指令应该如下所示： </p><p>    Now that we know what the missing bytes are, we may expect that our shellcode is calling one of the  execve functions.In C  execve is declared in  unistd.h as:</p><p>既然我们知道丢失的字节是什么，我们可能希望我们的shellcode正在调用其中一个执行函数。在unistd.h中声明了cexerme.h是：</p><p>  It takes three arguments that should be know to every C programmer out there.Both  argv and  envp arrays contain pointers to strings and must be terminatedby an entry containing  NULL. Here is how we may use  execve in C:</p><p>  它需要三个参数，应该知道每个C程序员。argv和envp阵列包含指向字符串的指针，必须终止包含null的条目。以下是我们如何在C中使用EXECVE：</p><p> int  main( int argc,  char** argv) {	 char* args[] = {   &#34;/bin/sh &#34;,  NULL };	 char* env[] = {  NULL };	 execve(args[ 0], args, env);}</p><p> int main（int argc，char ** argv）{char * args [] = {＆＃34; / bin / sh＆＃34;，null}; char * env [] = {null};执行（args [0]，args，Env）;}</p><p> Actually when  env is empty we may compress this code a bit (by reusing  NULL already present in  args array):</p><p> 实际上，当Env为空时，我们可能会一点压缩此代码（通过重用已在args数组中存在的NULL）：</p><p> int  main( int argc,  char** argv) {	 char* args[] = {   &#34;/bin/sh &#34;,  NULL };	 execve(args[ 0], &amp;args[ 0], &amp;args[ 1]);}</p><p> int main（int argc，char ** argv）{char * args [] = {＆＃34; / bin / sh＆＃34;，null};执行（args [0]，＆amp; args [0]，＆amp; args [1]）;}</p><p>   mov   eax ,   0xb  ; execve(filename, argv, envp) 	 mov   ebx ,   esi   	 lea   ecx ,   [ esi + 0x8 ]   	 lea   edx ,   [ esi + 0xc ] 	 int   0x80</p><p>   mov eax，0xb;执行（文件名，argv，envp）movebx，ESI Lea ECX，[ESI + 0x8] LEA EDX，[ESI + 0xC] INT 0x80</p><p> The  int 0x80 instruction is the standard way to call the Linux kernel from 32-bit code (64-bit code nowadays usually uses  syscall instruction).When we call a system function, we pass the function arguments in ebx,  ecx,  edx,  esi,  edi and  ebp registers in exactly that order. eax register is used to select the function itself. We may see the list of all available functions  here.</p><p> INT 0x80指令是调用从32位代码（64位代码时下通常使用系统调用指令）。当我们称一个系统函数，我们通过在EBX函数参数，ECX EDX，ESI Linux内核的标准方法，EDI和EBP以此顺序注册。 EAX寄存器用于选择功能本身。我们可能会在此处查看所有可用功能的列表。 </p><p> For example to call  exit(0), first we need to check the value that system assigned to  exit function ( 0x01) and put it in  eax register. exit(0) takes one argument. We must put that argument value in  ebx register(subsequent arguments would go in  ecx, then  edx and so on).Finally we may call the kernel using  int 0x80 software interrupt:</p><p>例如要呼叫退出（0），首先需要检查分配给退出功能（0x01）的值并将其放在EAX寄存器中的值。退出（0）采取一个争论。我们必须将该参数值放在EBX寄存器中（后续参数将进入ECX，然后在EDX中进入EDX等）。最后我们可以使用INT 0x80软件中断调用内核：</p><p>  execve function is assigned to number  0x0b. And when we look at the t-shirt again, there, after a block of  movs we can see that exactly this function iscalled:</p><p>  EXECVE函数分配给0x0B。当我们再次查看T恤时，在那里，在一块MOV之后，我们可以看到这函数恰好被视为：</p><p> mov   eax ,   0xb  ; execve(filename, argv, envp) 	 mov   ebx ,   esi   	 lea   ecx ,   [ esi + 0x8 ]   	 lea   edx ,   [ esi + 0xc ] 	 int   0x80</p><p> mov eax，0xb;执行（文件名，argv，envp）movebx，ESI Lea ECX，[ESI + 0x8] LEA EDX，[ESI + 0xC] INT 0x80</p><p> lea instruction is used to load the address of the operand to the specified register.But here since we use indirect memory addressing,  lea ecx, [esi+0x8]is equivalent to  ecx = esi + 0x08 in C.</p><p> Lea指令用于将操作数的地址加载到指定的寄存器。由于我们使用间接存储器寻址，因此lea ECX，[ESI + 0x8]相当于C中的ECX = ESI + 0x08。</p><p> After all these  movs and  leas we have the address of  /bin/sh string in  ebx, the address of  args array (pointer to  /bin/sh followed by  NULL)in  ecx and finally address of  NULL in  edx.In other words our code is equivalent to the C code that we saw earlier:</p><p> 在所有这些MOV和租赁之后，我们在EBX中拥有/ bin / sh字符串的地址，args数组的地址（指针到/ bin / sh，后跟null）在ecx中，最后在edx中的null的null的地址。在我们的代码中的其他单词中相当于我们之前看到的C代码：</p><p> int  main( int argc,  char** argv) {	 char* args[] = {   &#34;/bin/sh &#34;,  NULL };	 execve(args[ 0], &amp;args[ 0], &amp;args[ 1]);}</p><p> int main（int argc，char ** argv）{char * args [] = {＆＃34; / bin / sh＆＃34;，null};执行（args [0]，＆amp; args [0]，＆amp; args [1]）;}</p><p> What follows call to  execve, is a call to  exit(0). This is a standard technique used in shellcode to just exit the program without crashing it. This way we will leave no traces of our code (think no coredumps).</p><p> 跟随呼叫执行，是退出（0）的呼叫。这是Shellcode中使用的标准技术，只需退出程序而不崩溃。这样我们就不会留下我们的代码痕迹（毫无疑问）。 </p><p>  jmp  short _sh_last   _sh_start: 	 pop   esi 	 mov  dword  [ esi + 0x8 ],   esi 	 mov  byte  [ esi + 0x7 ],   0x0 	 mov  dword  [ esi + 0xc ],   0x0 	 mov   eax ,   0xb  ; execve(filename, argv, envp) 	 mov   ebx ,   esi   	 lea   ecx ,   [ esi + 0x8 ]   	 lea   edx ,   [ esi + 0xc ] 	 int   0x80 	 mov   eax ,   0x1  ; exit(0) 	 mov   ebx ,   0x0 	 int   0x80 _sh_last: 	 call  _sh_start 	 db   &#39;/bin/sh&#39;</p><p>JMP短_sh_last _sh_start：pop esi mov dword [esi + 0x8]，esi mov byte [esi + 0x7]，0x0 mov dword [esi + 0xc]，0x0 mov eax，0xb;执行（文件名，ARGV，ENVP）MOV EBX，ESI LEA ECX，[ESI + 0x8] lea EDX，[ESI + 0xC] INT 0x80 MOV EAX，0x1;退出（0）MOV EBX，0x0 int 0x80 _sh_last：呼叫_sh_start db＆＃39; / bin / sh＆＃39;</p><p> Now the moral of this story: always put a  working shellcode on t-shirts to avoid further embarrassment by posts like this one ;)</p><p> 现在这个故事的寓意：始终把一个工作的shellcode放在T恤上，以避免像这样的帖子进一步尴尬;）</p><p> Bonus: This repo contains a  Makefile that will build the shellcode and also prepare a C header file containing the shellcode bytes. There is also a wrapper program that will demonstrate that the shellcode indeed works. The only thing that you need is a 32-bit Linux.</p><p> 奖金：此repo包含一个Makefile，它将构建shellcode，并准备包含shellcode字节的C头文件。还有一个包装程序程序，将证明shellcode确实有效。您需要的唯一是32位Linux。</p><p>  uname -aLinux 4.15.0-133-generic #137~16.04.1-Ubuntu SMP Fri Jan 15 02:55:05 UTC 2021 i686 i686 i686 GNU/Linux</p><p>  uname -alinux 4.15.0-133-通用＃137〜16.04.1-Ubuntu SMP Fri 1月15日02:55:05 UTC 2021 I686 I686 I686 GNU / Linux</p><p>  To compile the assembly code you will need  nasm. You can install it using  apt-get.</p><p>  要编译汇编代码，您将需要nasm。您可以使用apt-get安装它。 </p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/marcin-chwedczuk/shellcode-tshirt">https://github.com/marcin-chwedczuk/shellcode-tshirt</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/衬衫/">#衬衫</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/tshirt/">#tshirt</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/shellcode/">#shellcode</a></button></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/恶搞/">#恶搞</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/qq/">#qq</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/工具/">#工具</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/分享/">#分享</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy;2012-2021 diglog.com </div></div></body></html>