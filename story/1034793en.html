<!doctype html><html lang="zh-hans"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>在锈迹斑斑的情况下编写过多的Brainfuck编译器来学习汇编语言</title><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous"><link rel="stylesheet" href="/img/css.css?random="><link data-rh="true" rel="icon" href="/img/favicon.ico"/><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?03c1a0f31299b4a2fbb83c34d6beaac9";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script data-ad-client="ca-pub-6067137220025946" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5effb96910009800120b8d4d&product=inline-share-buttons" async="async"></script></head><body><div id="my_header"><div class="container"><nav class="navbar navbar-expand-lg"><a class="navbar-brand" href="/"><img alt="diglog" src="/img/logo.v1.gif" class="rounded-sm"></a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div class="collapse navbar-collapse" id="navbarNavAltMarkup"><div class="navbar-nav"></div></div></nav></div></div><div class="container"><div id="my_content"><h1 class="page_narrow">在锈迹斑斑的情况下编写过多的Brainfuck编译器来学习汇编语言</h1><div class="row"><div class="col-lg-12 col-12"><div class="my_story_list_item shadow p-3 mb-5 bg-white rounded"><div class="story_page_pub_time page_narrow">2020-11-13 00:36:08</div><div class="story_img_container"><a href="http://img2.diglog.com/img/2020/11/88fd6ddb8253d4481c2e73bf9c8b9c36.png"><img src="http://img2.diglog.com/img/2020/11/88fd6ddb8253d4481c2e73bf9c8b9c36.png" class="img-fluid my_story_img" onerror="this.style.display='none'"></a></div><div class="page_narrow text-break page_content"><p>Hey you! Have you ever wanted to become a  CPU Whisperer? Me too! I&#39;m a frontend web developer by trade but low-level assembly code and compilers have always fascinated me. I&#39;ve procrastinated on learning either for a long time but after I recently picked up Rust and have been hanging out in a lot of online Rust communities it&#39;s given me the kick in the butt to dive in. Rustaceans use fancy words and acronyms like  auto-vectorization,  inlining,  alignment,  padding,  linking,  custom allocators,  endianness,  system calls,  LLVM,  SIMD,  ABI,  TLS and I feel bad for not being able to follow the discussions because I don&#39;t know what any of that stuff is. All I know is that it vaguely relates to low-level assembly code somehow so I decided I&#39;d learn assembly by writing entirely too many brainfuck compilers in Rust. How many is too many? Four! My compile targets are going to be x86, ARM, WebAssembly, and LLVM.</p><p>嘿，你！你有没有想过成为一名CPU语者？我也是!。我是一名前台网络开发人员，但低级汇编代码和编译器一直让我着迷。我在学习这两个方面都拖延了很长一段时间，但在我最近染上了铁锈，并在很多在线铁锈社区闲逛后，它给了我很大的动力，让我潜入其中。Rustaceans使用奇特的词汇和缩略语，比如自动向量化、内联、对齐、填充、链接、自定义分配器、字符顺序、系统调用、LLVM、SIMD、ABI、TLS和我不能跟上讨论的内容，因为我不知道这些东西是什么。我所知道的就是它在某种程度上与低级汇编代码有些模糊的联系，所以我决定通过在Rust中编写太多的Brainfuck编译器来学习汇编语言。多少才算太多？四!。我的编译目标是x86、ARM、WebAssembly和LLVM。</p><p> The goal of this article is to be easily-digestible for anyone who has a modest amount of programming experience under their belt, even if they&#39;ve never written a single line of assembly before.</p><p>本文的目标是让任何有一定编程经验的人都能轻松理解，即使他们以前从未写过一条汇编线。</p><p> So why x86? x86 is not just an ISA but it is  the ISA. Most servers, desktop PCs, laptops, and home gaming consoles use x86 CPUs.</p><p>那么为什么选择x86呢？X86不仅仅是ISA，它也是ISA。大多数服务器、台式PC、笔记本电脑和家用游戏机都使用x86 CPU。</p><p> Why ARM? ARM is not just an ISA but it is  the other ISA. Most mobile phones, tablets, mobile gaming consoles, and microcontrollers use ARM CPUs. Also Apple announced they will be switching all their laptops and desktops from x86 to ARM CPUs in 2021 which seems like a Pretty Big Deal.</p><p>为什么是ARM？ARM不仅仅是一个ISA，它也是另一个ISA。大多数手机、平板电脑、移动游戏机和微控制器都使用ARM CPU。此外，苹果还宣布，他们将在2021年将所有笔记本电脑和台式机从x86换成ARM处理器，这似乎是一件很大的事情。</p><p> Why WebAssembly? WebAssembly has the potential to be the future of the web and also the future of containerized applications in general! Solomon Hykes, the creator of Docker, has tweeted  &#34;If WASM + WASI existed in 2008, we wouldn&#39;t have needed to create Docker. That&#39;s how important it is. WebAssembly on the server is the future of computing. A standardized system interface was the missing link. Let&#39;s hope WASI is up to the task!&#34;</p><p>为什么是WebAssembly？WebAssembly有可能成为Web的未来，也是整个容器应用程序的未来！Docker的创始人所罗门·海克斯(Solomon Hykes)在推特上写道，如果WASM+WASI在2008年就存在了，我们就不需要创建Docker了。这就是它的重要性。服务器上的WebAssembly是计算的未来。标准化的系统界面是缺失的一环。让我们希望瓦西能胜任这项任务！</p><p> Why LLVM? LLVM because it can compile to x86, ARM, or WebAssembly. Also because many modern and successful programming languages like Rust and Swift compile to LLVM instead of to assembly directly.</p><p>为什么选择LLVM？LLVM，因为它可以编译为x86、ARM或WebAssembly。还因为许多现代的、成功的编程语言，如Rust和Swift，都编译成LLVM，而不是直接编译成汇编语言。</p><p> Since all of the above targets go by many names here&#39;s a quick list of their aliases:</p><p>由于以上所有目标都有很多名字，下面是其别名的快速列表：</p><p>  If you&#39;d like to play around with the code in this article yourself then you&#39;re in luck! The article comes with a  companion code repository which contains all the code and instructions on how to run it. Following along using the companion code repository is completely optional and the article can be easily read without it.</p><p>如果你想亲自尝试一下这篇文章中的代码，那么你就幸运了！本文附带了一个配套的代码库，其中包含有关如何运行它的所有代码和说明。接下来使用配套的代码库是完全可选的，不使用它也可以很容易地阅读文章。</p><p>  Brainfuck is, oxymoronically, the most well-known esoteric programming language. It&#39;s fame largely comes from the fact it has the word &#34;fuck&#34; in its name but hobbyist compiler developers like it because it&#39;s a tiny language which makes it easy to write compilers for. Fun fact: people have written more brainfuck compilers than actual brainfuck programs. Fun fact: I did zero research for that previous fun fact but it&#39;s probably true.</p><p>矛盾的是，Brainfuck是最广为人知的深奥编程语言。它的名声很大程度上是因为它的名字中有他妈的这个词，但业余的编译器开发者喜欢它，因为它是一种很小的语言，使得编写编译器变得很容易。有趣的事实：人们编写的愚蠢的编译器比实际的愚蠢的程序还多。有趣的事实：我没有为之前的有趣事实做过任何研究，但这可能是真的。</p><p>  Brainfuck programs have an implicit pointer, &#34;the pointer&#34;, which is free to move around an array of 30k unsigned bytes, all initially set to 0.</p><p>Brainfuck程序有一个隐式指针，即指针，可以自由移动30K无符号字节数组，所有这些字节最初都设置为0。</p><p>      Let&#39;s write a quick brainfuck interpreter first. We&#39;re going to parse brainfuck programs into an  Vec&lt;Inst&gt; where  Inst is defined as:</p><p>让我们先写一个头脑简单的翻译器。我们将把Brainfuck程序解析为VEC&lt；Inst&&gt;，其中Inst定义为：</p><p>  The first  usize of every  Inst is its run-length encoding. The second  usize of  LoopStart and  LoopEnd is the index of the instruction after the matching  LoopEnd or  LoopStart within the  Vec&lt;Inst&gt;. Keeping track of these little additional pieces of information will allow us to implement a much more efficient interpreter and also produce much more efficient assembly from our compilers.</p><p>每个Inst的第一个USIZE是它的游程编码。LoopStart和LoopEnd的第二个USIZE是Vec&lt；Inst&&gt;内匹配的LoopEnd或LoopStart之后的指令索引。跟踪这些小小的附加信息将使我们能够实现更高效的解释器，并从我们的编译器生成更高效的汇编。</p><p> We&#39;ll skip going over the remaining brainfuck interpreter code as it&#39;s very unexciting. Let&#39;s get to the fun part and try interpreting some brainfuck programs!</p><p>我们将跳过剩余的脑洞翻译器代码，因为它非常乏味。让我们进入有趣的部分，试着解读一些愚蠢的节目吧！</p><p> If you&#39;re following along using the  companion code repository the command we&#39;ll be using to interpret brainfuck programs is  just interpret {{name}} where  {{name}} is the name of the brainfuck source file in the  ./input directory.</p><p>如果您正在使用配套的代码库，我们将用来解释Brainfuck程序的命令是Just Interprete{{name}}，其中{{name}}是./input目录中Brainfuck源文件的名称。</p><p> # prints &#34;Hello world!&#34; &gt; just interpret hello_worldHello World !  # prints fibonacci numbers under 100 &gt; just interpret fibonacci1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89  # encrypts lines from stdin using rot13 cipher &gt; just interpret rot13unencrypted textharapelcgrq grkg</p><p>#prints&34；Hello world！&#34；&gt；只需解释Hello_world Hello World！#打印100&gt；以下斐波纳奇数；只需解释fibonacci1、1、2、3、5、8、13、21、34、55、89#使用rot13密码加密来自stdin的行&&gt;只需解释rot13未加密的textharapelcgrq grkg。</p><p>   A slightly better first question is what is an ISA? ISA stands for Instruction Set Architecture. An ISA is an interface which CPUs can implement. The most popular ISAs today are x86_64 and aarch64. If we write code using x86_64 instructions then any CPU which implements the x86_64 ISA will be able to run that code. So is &#34;assembly&#34; the same thing as an ISA? Well, not quite. The short answer is that &#34;assembly&#34; is any syntax understood by an assembler. An assembler is a utility program that allows people to write machine-code in a more human-friendly way, like with comments, whitespace, and symbolic names for machine instructions. &#34;Assembly&#34; therefore is a thin layer of abstraction over an ISA offered by an assembler. The assembler we will be using to assemble all of our x86_64 and aarch64 programs will be the GNU Assembler, often abbreviated to GAS. We&#39;ll be using Intel syntax instead of the default AT&amp;T syntax for x86_64 assembly because it&#39;s closer to ARM syntax for aarch64 assembly which makes it less jarring to switch between the two. If that last sentence made no sense to you don&#39;t worry you&#39;re in good company. Also, we&#39;ll be executing all the compiled binaries in a Linux environment so we&#39;ll be making direct Linux system calls in our assembly programs when necessary.</p><p>更好的第一个问题是什么是ISA？ISA代表指令集体系结构。ISA是CPU可以实现的接口。目前最流行的ISA是x86_64和aarch64。如果我们使用x86_64指令编写代码，那么任何实现x86_64 ISA的CPU都将能够运行该代码。那么，装配和ISA是一回事吗？嗯，不完全是。简而言之，汇编是汇编器理解的任何语法。汇编器是一种实用程序，它允许人们以更友好的方式编写机器代码，比如使用注释、空格和机器指令的符号名称。因此，汇编是汇编者提供的ISA之上的一层薄薄的抽象层。我们将用来汇编所有x86_64和aarch64程序的汇编程序将是GNU汇编程序，通常缩写为GAS。我们将使用英特尔语法，而不是x86_64汇编的默认AT&amp；T语法，因为它更接近于aarch64汇编的ARM语法，这使得在两者之间切换不那么不协调。如果最后一句话对你没有任何意义，不要担心你有很好的同伴。此外，我们将在Linux环境中执行所有编译后的二进制文件，因此必要时我们将在汇编程序中直接调用Linux系统。</p><p>  x86_64 is a register-based ISA. A register is a container where we can store data. We can store data in RAM too but RAM is very far from the CPU whereas registers are directly  in the CPU and are where the CPU does all of its actual work. All of the instructions in x86_64 operate on registers directly or indirectly in some way. There are many different kinds of registers: some store integers, some store floats, some store vectors of integers, some are general purpose and some have a special purpose, and some we can modify directly and others we can only modify indirectly (as a byproduct of certain instructions). For the purposes of this article the only registers we&#39;ll be using are  rax,  rdi,  rsi,  rdx, and  r12 which all store 64-bit integers.</p><p>X86_64是基于寄存器的ISA。寄存器是一个容器，我们可以在其中存储数据。我们也可以在RAM中存储数据，但是RAM离CPU非常远，而寄存器直接在CPU中，是CPU完成所有实际工作的地方。X86_64中的所有指令都以某种方式直接或间接地在寄存器上操作。有许多不同类型的寄存器：一些存储整数，一些存储浮点数，一些存储整数向量，一些是通用的，有些是专用的，有些我们可以直接修改，而另一些我们只能间接修改(作为某些指令的副产品)。就本文而言，我们将使用的唯一寄存器是RAX、RDI、RSI、RDX和R12，它们都存储64位整数。</p><p>   mov moves something from  &lt;src&gt; to  &lt;dest&gt; where  &lt;src&gt; can be a literal value, register, or memory address and  &lt;dest&gt; can be a register or memory address.</p><p>MOV将某些内容从&lt；src&&gt;；移动到&lt；目标&&gt;，其中&lt；src&&gt;可以是文字值、寄存器或内存地址，而&lt；目标&&gt;可以是寄存器或内存地址。</p><p> mov rax,  5 # store  5 in rax mov rsi, rdi # copy value in rdi to rsi mov [r12],  15 # store  15 at the memory address in r12</p><p>Mov rax，5#在rax mov rsi中存储5，rdi#将RDI中的值复制到rsi mov[r12]，15#在r12中的内存地址存储15。</p><p> The last instruction is actually illegal because it&#39;s ambiguous. In the first 2 examples it&#39;s clear we&#39;re working with 64-bit integers since we&#39;re using 64-bit registers as operands, however in the last example we&#39;re trying to store the value 15 in the memory address in  r12 but how &#34;big&#34; is the value &#34;15&#34;? Does it take up 1, 2, 4, or 8 bytes? We need to know how many bytes to write to memory, after all. We can clear up ambiguities by suffixing the ambiguous instruction with  b (byte),  w (word, 2 bytes),  l (longword, 4 bytes), or  q (quadword, 8 bytes). So we can fix the last instruction in any number of these ways:</p><p>最后一条指令实际上是非法的，因为它是模棱两可的。在前两个例子中，很明显我们使用的是64位整数，因为我们使用64位寄存器作为操作数，然而在最后一个例子中，我们试图将值15存储在R12的内存地址中，但是值有多大呢？它占用1、2、4或8个字节吗？毕竟，我们需要知道要向内存写入多少字节。我们可以通过在歧义指令后面加上b(字节)、w(字，2字节)、l(长字，4字节)或q(四字，8字节)来清除歧义。因此，我们可以通过以下任意几种方式修复最后一条指令：</p><p> movb [r12],  15 # write  15 as  1 byte to memory address in r12 movw [r12],  15 # write  15 as  2 bytes to memory address in r12 movl [r12],  15 # write  15 as  4 bytes to memory address in r12 movq [r12],  15 # write  15 as  8 bytes to memory address in r12</p><p>Movb[r12]，15#将15作为1个字节写入r12 movw[r12]中的存储器地址，15#将15作为2个字节写入r12 mov1[r12]中的存储器地址，15#将15作为4个字节写入r12 movq[r12]中的存储器地址，15#将15作为8个字节写入R12中的存储器地址。</p><p> Also, although it may have already been made obvious, if we want to dereference a memory address stored in a register or label we wrap it with square brackets  [].</p><p>此外，尽管这一点可能已经很明显了，但如果我们想要取消引用存储在寄存器或标签中的内存地址，我们可以用方括号[]将其括起来。</p><p> mov rax, r12 # copy value from r12 to rax mov rax, [r12] # copy value from memory address stored in r12 to rax</p><p>Mov rax，r12#将值从r12复制到rax mov rax，[r12]#将值从存储在r12中的内存地址复制到rax。</p><p>  add &lt;dest&gt;, &lt;src&gt; # dest &lt;- dest + src sub &lt;dest&gt;, &lt;src&gt; # dest &lt;- dest - src</p><p>添加&lt；DEST&&gt;，&lt；src&&gt;；#DEST&lt；-DEST+src子&lt；DEST&&gt;，&lt；src&&gt;#DEST&lt；-DEST-src</p><p>    jmp &lt;label&gt; # unconditional jump to &lt;label&gt;# all instructions below are conditional jumps which check the flags in the rflags register je &lt;label&gt; # jump to &lt;label&gt; if equal  jne &lt;label&gt; # jump to &lt;label&gt; if  not equal jg &lt;label&gt; # jump to &lt;label&gt; if greater than jge &lt;label&gt; # jump to &lt;label&gt; if greater than  or equal to jl &lt;label&gt; # jump to &lt;label&gt; if less than jle &lt;label&gt; # jump to &lt;label&gt; if less than  or equal to</p><p>JMP&lt；Label&&gt;；#无条件跳转到&lt；Label&&gt;#下面的所有指令都是有条件的跳转，如果等于，则跳转到&lt；Label；#如果大于Jg；，则跳到&lt；Label&&gt;；#如果不等于，则跳转到&lt；Label&&gt;；#如果大于Jg；，则跳转到&lt；Label&&gt;；#如果不等于Jg；，则跳转到&lt；Label；#如果大于Jg；，则跳转到&lt；Label&&gt;；#如果不等于，则跳转到&lt；Label&&gt;；#如果大于Jg；，则跳到&lt；Label&&gt;。LABEL&&gt;；#如果小于，则跳至&lt；LABEL&&gt;；#如果小于或等于，则跳至&lt；LABEL&&gt;；</p><p>  mov rax,  5 # store  5 in rax mov r12,  10 # store  10 in r12 add rax, r12 # rax &lt;- rax + r12 =  15 cmp rax, r12 #  set flags in rflags jge RAX_IS_LARGER # read flags in rflags, jump to RAX_IS_LARGER R12_IS_LARGER:# some instructions jmp  END RAX_IS_LARGER:# some other instructions END:# more instructions</p><p>Mov rax，5#在rax中存储5 mov r12，10#在r12中存储10添加rax，r12#rax&lt；-rax+r12=15 cmp rax，r12#在r标志中设置标志jge rax_is_sierger#读标志，跳转到rax_is_ger r12_is_ger：#一些指令JMP end rax_is_igger：#一些其他指令结束：#更多指令。</p><p> The rules for how to use registers before, during, and after a function call for both the caller and callee is called a  Calling Convention. The problem with calling conventions is that it seems everyone and their grandma has one. ISAs, Operating Systems, and programming languages which compile to assembly can each define their own different calling conventions. Luckily for us it&#39;s not possible to define functions in brainfuck so we don&#39;t have to get into the nitty gritty details of any calling conventions in this article.</p><p>关于如何在函数调用之前、期间和之后为调用方和被调用方使用寄存器的规则称为调用约定。所谓惯例的问题在于，似乎每个人和他们的祖母都有一个。编译成汇编语言的ISA、操作系统和编程语言可以各自定义自己不同的调用约定。幸运的是，我们不可能用Brainfuck定义函数，所以在本文中我们不必深入任何调用约定的细节。</p><p> To make a system call we use the  syscall instruction after setting the system call number in  rax and the system call arguments in the  rdi,  rsi, and  rdx registers.</p><p>要进行系统调用，我们在设置了RX中的系统调用号以及RDI、RSI和RDX寄存器中的系统调用参数之后，使用syscall指令。</p><p> # direct Linux system calls mov rax,  60 # syscall number  for  exit(code) mov rdi,  0 # exit code,  0  for  success syscall # make system call mov rax,  0 # syscall number  for  read(fd, buf_adr, buf_len) mov rdi,  0 # file descriptor  for  stdin mov rsi,  1234 # memory address to some buffer mov rdx,  1 # buffer&#39;s length in bytes syscall # make system call# syscall returns number of bytes read in rax mov rax,  1 # syscall number  for  write(fd, buf_adr, buf_len) mov rdi,  1 # file descriptor  for  stdout mov rsi,  1234 # memory address to some buffer mov rdx,  1 # buffer&#39;s length in bytes syscall # make system call# syscall returns number of bytes written in rax</p><p>#直接Linux系统调用mov rax，60#系统调用退出(Code)mov RDI，0#退出代码，0成功syscall#进行系统调用mov rax，0#系统调用读取(fd，buf_adr，buf_len)mov RDI，0#stdin mov RSI文件描述符，1234#指向某个缓冲区mov RDX的内存地址，1#Buffer&#39；S长度(字节)syscall#make system call#syscall返回rax mov rax中读取的字节数，1#用于写入的syscall number(fd，buf_adr，buf_len)mov RDI，1#stdout mov RSI的文件描述符，1234#某个缓冲区mov RDX的内存地址，1#Buffer的字节长度syscall#make system call#syscall返回写入rav RDX的字节数。</p><p> We now know a handful of x86_64 instructions, enough to write a brainfuck compiler actually, and yet we still haven&#39;t put together a single complete program yet. This is where the assembler comes in. As mentioned above we&#39;ll be using GNU Assembler for all our x86_64 code. Let&#39;s take a look at a simple x86_64 program that just exits.</p><p>我们现在知道一些x86_64指令，实际上足以编写一个脑洞大开的编译器，但我们还没有把一个完整的程序组合在一起。这就是汇编器的用武之地。如上所述，我们将对所有x86_64代码使用GNU汇编器。让我们来看看一个刚刚退出的简单x86_64程序。</p><p> # ./examples/x86_64/exit.s# GNU Assembler, Intel syntax, x86_64 Linux .data .equ SYS_EXIT,  60 .equ EXIT_CODE,  0 .text .global _start _start: # exit(code) mov rax, SYS_EXIT mov rdi, EXIT_CODE syscall</p><p>#./Examples/x86_64/exit.s#GNU汇编程序，英特尔语法，x86_64 Linux.Data.equsys_exit，60.equexit_code，0.text.global_start：#exit(Code)mov rax，sys_exit mov RDI，exit_code syscall。</p><p>  Words prefixed with a dot  . are called  assembler directives and they direct the assembler on how to assemble our assembly.</p><p>以点为前缀的单词。称为汇编器指令，它们指导汇编器如何汇编我们的程序集。</p><p>    Words suffixed by a colon  : are labels and they can point to data or instructions. The  _start label points to the first instruction of our program.</p><p>以冒号：为后缀的单词是标签，它们可以指向数据或指令。_start标签指向我们程序的第一条指令。</p><p> .global &lt;label&gt; means  &#34;Make  &lt;label&gt; visible to the linker.&#34; The linker is a program which converts the assembled output of our assembler into an actual executable program, and it needs to know where our program begins, hence the  _start label.</p><p>.global&lt；Label&gt；意味着使链接器可见。链接器是一个将汇编器的汇编输出转换为实际可执行程序的程序，它需要知道我们的程序从哪里开始，因此有_start标签。</p><p> To make our program a little more exciting let&#39;s read a character from stdin, and if it&#39;s lowercase we&#39;ll make it uppercase, and if it&#39;s uppercase we&#39;ll make it lowercase, and then we&#39;ll write the switched case character to stdout.</p><p>为了让我们的程序更令人兴奋，让我们从标准输入中读取一个字符，如果它是小写的，我们会将其设置为大写，如果它是大写的，我们会将其设置为小写，然后我们会将切换后的大小写字符写入标准输出。</p><p> # ./examples/x86_64/switch_case.s# GNU Assembler, Intel syntax, x86_64 Linux .data# exit(code) .equ SYS_EXIT,  60 .equ EXIT_CODE,  0# write(fd, buf_adr, buf_len) .equ SYS_WRITE,  1 .equ STDOUT,  1# read(fd, buf_adr, buf_len) .equ SYS_READ,  0 .equ STDIN,  0# ASCII code  for  lowercase  &#39;a&#39; .equ ASCII_A,  97# Quick ASCII refresher:#  65 -  91 =  &#39;A&#39; -  &#39;Z&#39;#  97 -  123 =  &#39;a&#39; -  &#39;z&#39;# e.g.#  &#39;A&#39; +  32 =  &#39;a&#39;#  &#39;a&#39; -  32 =  &#39;A&#39;  .equ CASE_DIFF,  32# single byte in memory CHAR: .byte  0 .text .global _start _start: # read(STDIN, CHAR,  1) mov rax, SYS_READ mov rdi, STDIN mov rsi, offset CHAR mov rdx,  1 syscall cmpb [CHAR], ASCII_A # if byte at CHAR is lowercase jge MAKE_UPPERCASE # make it uppercase MAKE_LOWERCASE: # else make it lowercase addb [CHAR], CASE_DIFF # lowercase byte at CHAR  jmp   WRITE # then write it to stdout MAKE_UPPERCASE: subb [CHAR], CASE_DIFF # uppercase byte at CHAR WRITE: # write byte to stdout # write(STDOUT, CHAR,  1) mov rax, SYS_WRITE mov rdi, STDOUT mov rsi, offset CHAR mov rdx,  1 syscall # exit(EXIT_CODE) mov rax, SYS_EXIT mov rdi, EXIT_CODE syscall</p><p>#./Examples/x86_64/Switch_Case.s#GNU汇编程序，英特尔语法，x86_64 Linux.Data#exit(Code).equsys_exit，60.equexit_code，0#WRITE(FD，buf_adr，buf_len).equsys_WRITE，1.equSTDOUT，1#read(fd，buf_adr，buf_len).equsys_read，0.equSTDIN，.eQu ASCII_A，97#快速ASCII刷新器：#65-91=&#39；A&#39；-&#39；Z&#39；#97-123=&#39；A&#39；-&#39；Z&#39；#例如#&#39；A&#39；+32=&#39；A&#39；A&#39；-32=&#39；A&#39；.eque case_diff，32#内存中的单字节字符：.byte 0.text.global_start_start：#read(STDIN，CHAR，1)mov rax，SYS_read mov RDI，STDIN mov RSI，Offset Char mov RDX，1 syscall CMPB[char]，ASCII_A#如果char处的字节为小写JGE make_upercase#，则将其设置为大写Make_Low ercase。Case_diff#字符写入时的大写字节：#WRITE BYTE to stdout#WRITE(STDOUT，CHAR，1)mov rax，SYS_WRITE mov RDI，STDOUT mov RSI，Offset Char mov RDX，1 syscall#exit(Exit_Code)mov rax，syscall_exit mov RDI，exit_code syscall。</p><p>  .byte allows us to define an array of bytes by writing a comma-separated list of integer literals. In the above program we only needed 1 byte.</p><p>.byte允许我们通过编写逗号分隔的整数文字列表来定义字节数组。在上面的程序中，我们只需要1个字节。</p><p> By default, GAS dereferences labels, so  mov rsi, CHAR would copy the value  0 into  rsi. However, we don&#39;t want to copy the value at  CHAR but we want to copy the literal value of  CHAR itself, i.e. its memory address. We can do this using the  offset keyword, which we do in  mov rsi, offset CHAR.</p><p>默认情况下，gas取消引用标签，因此mov rsi，char会将值0复制到rsi中。然而，我们不想复制CHAR的值，但是我们想复制CHAR本身的文字值，即它的内存地址。我们可以使用OFFSET关键字来实现这一点，这是我们在mov RSI，Offset Char中所做的。</p><p> If you&#39;re following along using the  companion code repository the command we&#39;ll be using to compile and run x86_64 example programs is  just carx {{name}} where  {{name}} is the name of the x86_64 source file in the  ./examples/x86_64 directory.</p><p>如果您正在使用配套的代码库，我们将用来编译和运行x86_64示例程序的命令只有carx{{name}}，其中{{name}}是./Examples/x86_64目录中的x86_64源文件的名称。</p><p> # reads char from stdin, switches its case, prints to stdout &gt; just carx switch_caseaAExit code: 0 &gt; just carx switch_caseAaExit code: 0</p><p>#从stdin读取字符，切换大小写，打印到stdout&&gt;只有carx switch_CaseaAExit代码：0&gt；只有carx switch_CaseAaExit代码：0</p><p>  Alright, first thing&#39;s first, we need a zero-initialized array of 30k bytes. Given what we learned in the previous section we could generate the following code with our compiler:</p><p>好的，首先，我们需要一个30K字节的零初始化数组。根据我们在上一节中学到的内容，我们可以使用我们的编译器生成以下代码：</p><p>  However, even for a compiler generated solution, it looks pretty dumb. Luckily for us there&#39;s an easier way to define large amounts of zero-initialized data:</p><p>然而，即使对于一个由编译器生成的解决方案，它看起来也相当愚蠢。幸运的是，对于我们来说，有一种更简单的方式来定义大量零初始化数据：</p><p>  .bss is similar to  .data in the sense that we define data items below it, but the main difference is we don&#39;t initialize the data items, we just declare their size, and they are automatically zero initialized for us.  .lcomm ARRAY, 30000 means,  &#34;Make symbol  ARRAY point to a zero-initialized array of 30k bytes.&#34;</p><p>.bss类似于.data，因为我们在它下面定义数据项，但主要的区别是我们不初始化数据项，我们只声明它们的大小，并且它们会自动为我们零初始化。(=。.lcomm数组，30000表示，&#34；使符号数组指向30K字节的零初始化数组。&#34；</p><p> One last tiny decision we have to make is which register we&#39;ll be using to store our array pointer. There&#39;s a lot to choose from, but let&#39;s go with  r12 because it&#39;s a general-purpose callee-saved register which means if we make any function or system calls we&#39;re guaranteed those calls won&#39;t overwrite  r12.</p><p>我们必须做出的最后一个小决定是，我们将使用哪个寄存器来存储数组指针。有很多可供选择的，但让我们使用R12，因为它是一个通用的被调用者保存的寄存器，这意味着如果我们进行任何函数或系统调用，我们保证这些调用不会覆盖R12。</p><p> Now that we have that out of the way we can generate the header and footer boilerplate for any compiled brainfuck program:</p><p>现在，我们可以为任何编译的Brainfuck程序生成页眉和页脚模板：</p><p> ### header boilerplate #### GNU Assembler, Intel syntax, x86_64 Linux .data .equ SYS_EXIT,  60 .equ SUCCESS,  9 .equ SYS_WRITE,  1 .equ STDOUT,  1 .equ SYS_READ,  0 .equ STDIN,  0  .bss .lcomm ARRAY,  30000 .text .global _start _start: mov r12, offset ARRAY################################################ actual compiled brainfuck program goes here ################################################### footer boilerplate ### mov rax, SYS_EXIT mov rdi, SUCCESS syscall</p><p>#标题样板#GNU汇编程序，英特尔语法，x86_64 Linux.Data.equsys_exit，60.equSuccess，9.equSYS_WRITE，1.equSTDOUT，1.equsys_read，0.equSTDIN，0.bss.lcomm数组，30000.text.global_start_start：MOV r12，Offset ARRAY###实际编译的Brainfuck程序位于此处###页脚样板#mov rax，sys_exit mov rdi，成功系统调用。</p><p> Let&#39;s now map brainfuck commands to x86_64 instructions. We should also consider how we can coalesce multiple repeating commands into single instructions.</p><p>现在，让将Brainfuck命令映射到x86_64指令。我们还应该考虑如何将多个重复命令合并为单条指令。</p><p> # increment array pointer# &gt; add r12,  1# &gt;&gt; add r12,  2# decrement array pointer# &lt; sub r12,  1# &lt;&lt; sub r12,  2# increment byte at pointer# + addb [r12],  1# ++ addb [r12],  2# decrement byte at pointer# - subb [r12],  1# -- subb [r12],  2# read byte from stdin &amp; store at pointer# , mov rax, SYS_READ mov rdi, STDIN mov rsi, r12 mov rdx,  1 syscall# ,, mov rax, SYS_READ mov rdi, STDIN mov rsi, r12 mov rdx,  1 syscall mov rax, SYS_READ mov rdi, STDIN mov rsi, r12 mov rdx,  1 syscall# write byte at pointer to stdout# . mov rax, SYS_WRITE mov rdi, STDOUT mov rsi, r12 mov rdx,  1 syscall# .. mov rax, SYS_WRITE mov rdi, STDOUT mov rsi, r12 mov rdx,  1 syscall mov rax, SYS_WRITE mov rdi, STDOUT mov rsi, r12 mov rdx,  1 syscall</p><p>#递增数组指针#&gt；add r12，1#&gt；&gt；add r12，2#递减数组指针#&lt；subR12，1#；&lt；subR12，2#递增指针#+addb[r12]，1#++addb[r12]，2#递减字节#-subb[r12]，1#-subb[r12]，2#从stdin&读取字节。存储在指针#、mov rax、sys_read mov RDI、STDIN mov RSI、r12 mov RDX、1 syscall#、、mov rax、sys_read mov RDI、stdin mov RSI、r12 mov RDX、1 syscall mov rax、sys_read mov RDI、STDIN mov RSI、r12 mov RDX、1 syscall#在指向标准输出的指针处写入字节。MOV RAX、SYS_WRITE MOV RDI、STDOUT MOV RSI、R12 MOV RDX、1系统调用#.。MOV RAX、SYS_WRITE MOV RDI、STDOUT mov RSI、R12 mov RDX、1 syscall mov rax、SYS_WRITE mov RDI、STDOUT mov RSI、R12 mov RDX、1 syscall</p><p> Unfortunately there&#39;s no simple way to coalesce multiple  , or  . commands into less instructions than it takes to execute a single  , or  . because the registers we set up for the system calls can be overwritten by the system call procedures so we have to reset the registers again before every call.</p><p>不幸的是，没有简单的方法来合并多个，或者。命令生成的指令比执行单个或更少的指令要少。因为我们为系统调用设置的寄存器可能会被系统调用过程覆盖，所以我们必须在每次调用之前重新设置寄存器。</p><p>  Generating matching labels for matching loops is a problem we already solved in our parser. To examine the simplest case, our parser will parse the following brainfuck program  [-] like so:</p><p>为匹配循环生成匹配标签是我们在解析器中已经解决的问题。为了检查最简单的情况，我们的解析器将像这样解析下面的Brainfuck程序[-]：</p><p> [  LoopStart( 1,  3),  // index 0, goto 3  DecByte( 1)  // index 1  LoopEnd( 1,  1),  // index 2, goto 1]</p><p>[LoopStart(1，3)，//index 0，Goto 3 DecByte(1)//index 1 LoopEnd(1，1)，//index 2，Goto 1]。</p><p> Using  LoopStart(n, goto) and its  index within our  Vec&lt;Inst&gt; we can generate the following labels:</p><p>在我们的VEC&lt；Inst&gt；中使用LoopStart(n，goto)及其索引，我们可以生成以下标签：</p><p>  And using  LoopEnd(n, goto) and its  index within our  Vec&lt;Inst&gt; we can generate the following labels:</p><p>在我们的Vec&lt；Inst&gt；中使用LoopEnd(n，goto)及其索引，我们可以生成以下标签：</p><p>    Multiple stacked loops is interesting because it&#39;s not any different than a single loop. If the current byte is zero it doesn&#39;t matter how many  [ we have in a row because it will jump past all of them to the outermost matching  ]. Also, if the current byte is nonzero then it doesn&#39;t matter how many  ] we have in a row because it&#39;ll jump back to the innermost matching  [. Our parser handles the hard work of figuring out which jumps to make so our label generation scheme stays the same regardless of how many stacked loops we have in the source code.</p><p>多个堆叠循环很有趣，因为它与单个循环没有什么不同。如果当前字节为零，则不管我们有多少个字节[我们连续有多少个字节，因为它会跳过所有字节到达最外层的匹配项]。此外，如果当前字节不是零，那么它与我们连续有多少个字节无关，因为它会跳回到最里面的匹配。我们的解析器处理确定要进行哪些跳转的繁重工作，因此无论源代码中有多少堆叠循环，我们的标签生成方案都保持不变。</p><p>  If you&#39;re following along using the  companion code repository the command we&#39;ll be using to compile brainfuck programs to x86_64 and run them is  just carbx {{name}} where  {{name}} is the name of the brainfuck source file in the  ./input directory.</p><p>如果您正在使用配套的代码库，我们将用来将Brainfuck程序编译成x86_64并运行它们的命令只有carx{{name}}，其中{{name}}是./input目录中Brainfuck源文件的名称。</p><p> # prints &#34;Hello world!&#34; &gt; just carbx hello_worldHello World !  # prints fibonacci numbers under 100 &gt; just carbx fibonacci1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89  # encrypts lines from stdin using rot13 cipher &gt; just carbx rot13unencrypted textharapelcgrq grkg</p><p>#print&34；Hello world！&#34；&gt；Just Carx Hello_WorldHello World！#打印小于100的斐波纳奇数1，1，2，3，5，8，13，21，34，55，89#使用rot13密码加密stdin中的行；只打印Carxrot13未加密的textharapelcgrq grkg</p><p> Everything works as expected. I&#39;m curious how much faster the compiled programs are compared to the interpreter so I&#39;ll run a very unscientific and informal benchmark by timing how long it takes to interpret the most CPU-intensive brainfuck program  ./input/mandelbrot.b vs how long the x86_64 compiled version takes to execute.</p><p>一切都按预期进行。我很好奇编译后的程序比解释器快多少，所以我会运行一个非常不科学和非正式的基准测试，方法是计算解释最耗费CPU的Brainfuck程序需要多长时间。/input/mandelbrot.b对比x86_64编译版本执行需要多长时间。</p><p> &gt; just benchmark mandelbrot  # program outputs omitted  # interpreted mandelbrot.b4.95s user 0.01s system 99% cpu 4.960 total  # x86_64 compiled mandelbrot.breal 0m1.214suser 0m1.149ssys 0m0.041s</p><p>&gt；Just Benchmark mandelbrot#程序输出被省略#解释的mandelbrot.b4.95s用户0.01s系统99%cpu 4.960总计#x86_64编译的mandelbrot.breal 0m1.214s用户0m1.149ssys 0m0.041s。</p><p> Wow, not bad! Our compiled version runs over 4x as fast as the interpreted version. In my opinion this is an impressive improvement given how simplistic brainfuck programs are, we&#39;re just moving a single pointer around in a single array and adding or subtracting some bytes.</p><p>哇，还不错！我们的编译版本运行速度是解释版本的4倍以上。在我看来，这是一个令人印象深刻的改进，考虑到脑筋急转弯的程序是多么简单，我们只是在单个数组中移动一个指针，并增加或减少一些字节。</p><p>  Like x86_64, aarch64 is a register-based ISA. We&#39;ll be using the following 64-bit registers for our examples and for our compiler  x0,  x1,  x2,  x8,  x19, and  x20.</p><p>与x86_64一样，aarch64也是基于寄存器的ISA。对于我们的示例和我们的编译器x0、x1、x2、x8、x19和x20，我们将使用以下64位寄存器。</p><p>   mov moves something from  &lt;src&gt; to  &lt;dest&gt; where  &lt;src&gt; can be a literal value or register and  &lt;dest&gt; is a register. As you may have noticed, unlike the x86_64 version of  mov, the aarch64 version of  mov cannot operate directly on memory. This is not just true for the  mov instruction but is generally true for all aarch64 instructions. The only aarch64 instructions that can operate on memory are  ldr and  str where  ldr loads data from memory into registers and  str stores data from registers into memory. So for example, this single x86_64 instruction:</p><p>MOV将某些内容从&lt；src&&gt;；移动到&lt；est&&gt;；，其中&lt；src&&gt;可以是文字值或寄存器，&lt；目标&&gt;可以是寄存器。您可能已经注意到，与x86_64版本的mov不同，aarch64版本的mov不能直接在内存上操作。这不仅适用于mov指令，而且通常适用于所有aarch64指令。唯一可以在内存上操作的aarch64指令是ldr和str，其中ldr将数据从内存加载到寄存器，而str将数据从寄存器存储到内存。例如，下面这条x86_64指令：</p><p> addq [r12],  100 //  add  100 to the  8-byte integer stored at the memory address in r12</p><p>Addq[r12]，100//将存储在r12中内存地址的8字节整数加100。</p><p>  ldr x20, [x19] // load  8-byte integer stored at</p><p>LDR x20，[x19]//加载存储在。</p><p>......</p><p>.</p></div><div id="story_share_this"><div class="sharethis-inline-share-buttons"></div></div><div class="text-break sotry_link page_narrow"><a target="_blank" href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/too-many-brainfuck-compilers.md">https://github.com/pretzelhammer/rust-blog/blob/master/posts/too-many-brainfuck-compilers.md</a></div><div class="story_tags page_narrow"><button type="button" class="btn btn-light my_tag"><a href="/tag/rust/">#rust</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/编译/">#编译</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/汇编/">#汇编</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/brainfuck/">#brainfuck</a></button><button type="button" class="btn btn-light my_tag"><a href="/tag/assembly/">#assembly</a></button></div></div><div class="shadow p-3 mb-5 bg-white rounded clearfix"><div class="container"><div class="row"><div class="col-sm"><div><a target="_blank" href="/story/1034785.html"><img src="http://img2.diglog.com/img/2020/11/thumb_ee8fa1e28b89f8f9ef8af0a5d8b5704a.jpeg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034785.html">一群谷歌批评者呼吁欧盟采取反垄断行动</a></div><span class="my_story_list_date">2020-11-12 23:47</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034608.html"><img src="http://img2.diglog.com/img/2020/11/thumb_10c030b2429f801a5aed8756bdece9d2.jpg" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034608.html">铁锈编译程序的PGO探索</a></div><span class="my_story_list_date">2020-11-12 2:30</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034437.html"><img src="http://img2.diglog.com/img/2020/11/thumb_d8a50e934080e1cb6b2fa8ece56296f9.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034437.html">使用Rust为1100万并发用户扩展Elixir</a></div><span class="my_story_list_date">2020-11-11 8:32</span></div><div class="col-sm"><div><a target="_blank" href="/story/1034383.html"><img src="http://img2.diglog.com/img/2020/11/thumb_13adc774d7220747f1b03cc994ede446.png" class="img-fluid" onerror="this.style.display='none'"></a></div><div class="item_title"><a target="_blank" href="/story/1034383.html">InfluxDB将赌注押在Rust和Apache Arrow的下一代数据存储上</a></div><span class="my_story_list_date">2020-11-11 4:9</span></div></div></div></div><div class="my_movie_list_item shadow p-3 mb-5 bg-white rounded"><button type="button" class="btn btn-link my_tag"><a href="/tag/web2.0/">#web2.0</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/google/">#google</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/设计/">#设计</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/游戏/">#游戏</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/创意/">#创意</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/apple/">#apple</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/苹果/">#苹果</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/摄影/">#摄影</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/软件/">#软件</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/美国/">#美国</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/iphone/">#iphone</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/图片/">#图片</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/手机/">#手机</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/视频/">#视频</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/广告/">#广告</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/免费/">#免费</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/谷歌/">#谷歌</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/网站/">#网站</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/windows/">#windows</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/微软/">#微软</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/下载/">#下载</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/firefox/">#firefox</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/音乐/">#音乐</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/linux/">#linux</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/blog/">#blog</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/博客/">#博客</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/程序/">#程序</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/艺术/">#艺术</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/web/">#web</a></button><button type="button" class="btn btn-link my_tag"><a href="/tag/wordpress/">#wordpress</a></button></div></div></div><div id="my_footer"><div class=""><a href="/tags/">tags</a> <a href="/users/">users</a></div>&copy; 2020 diglog.com </div></div></body></html>